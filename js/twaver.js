/*! demo 2016-04-19 */
/*! demo 2016-04-18 */
function inherit(a) {
    function b() {}
    if (null == a) throw TypeError();
    if (Object.create) return Object.create(a);
    var c = typeof a;
    if ("object" !== c && "function" !== c) throw TypeError();
    return b.prototype = a,
    new b
} !
function(d, e) {
    function f(a, b, c, d, e, f) {
        var g = e.realSize ? e.realSize: e;
        b = b || "",
        b = String(b),
        a.font = c,
        a.fillStyle = d,
        a.strokeStyle = "gray",
        a.textBaseline = "middle",
        a.textAlign = "center";
        for (var h = b.split("\n"), i = h.length, j = g.height / i, k = (e.height - g.height) / 2, l = 0; i > l; l++) {
            var m = fc.getTextSize(c, h[l]).width,
            n = (e.height, m / 2);
            "right" == f ? (n = e.width - m / 2, a.textAlign = "center") : "left" == f ? (n = m / 2, a.textAlign = "center", a.textBaseline = "middle") : "center" == f && (n = e.width / 2),
            a.strokeText(h[l], n, j / 2 + l * j + k),
            a.fillText(h[l], n, j / 2 + l * j + k)
        }
    }
    function g(a, b) {
        var c = 0;
        if (a.shadowMatrix) for (var d = 0,
        e = b.size(); e > d; d++) {
            var f = b.get(d);
            f.refreshShadowUniforms(a, c) && c++
        }
    }
    function h(a, b) {
        var c = 0;
        if (a.pShadowMap) for (var d = 0,
        e = b.size(); e > d; d++) {
            var f = b.get(d);
            f.refreshUniformsPointShadow(a, c) && c++
        }
    }
    function k(a, b, c) {
        b._modelViewMatrix || (b._modelViewMatrix = new ac),
        c.uniformMatrix4fv(a.modelViewMatrix, !1, b._modelViewMatrix.elements),
        a.normalMatrix && c.uniformMatrix3fv(a.normalMatrix, !1, b._normalMatrix.elements)
    }
    function l(a, b, c) {
        var d;
        return "fragment" === a ? d = c.createShader(c.FRAGMENT_SHADER) : "vertex" === a && (d = c.createShader(c.VERTEX_SHADER)),
        c.shaderSource(d, b),
        c.compileShader(d),
        c.getShaderParameter(d, c.COMPILE_STATUS) ? d: (console.log(c.getShaderInfoLog(d)), console.error(b), null)
    }
    function m(a, b) {
        a.ambientLightColor.value = b.ambient,
        a.directionalLightColor.value = b.directional.colors,
        a.directionalLightDirection.value = b.directional.positions,
        a.pointLightColor.value = b.point.colors,
        a.pointLightPosition.value = b.point.positions,
        a.pointLightDistance.value = b.point.distances,
        a.spotLightColor.value = b.spot.colors,
        a.spotLightPosition.value = b.spot.positions,
        a.spotLightDistance.value = b.spot.distances,
        a.spotLightDirection.value = b.spot.directions,
        a.spotLightAngleCos.value = b.spot.anglesCos,
        a.spotLightExponent.value = b.spot.exponents,
        a.hemisphereLightSkyColor.value = b.hemi.skyColors,
        a.hemisphereLightGroundColor.value = b.hemi.groundColors,
        a.hemisphereLightDirection.value = b.hemi.positions
    }
    function n(a, b, c, d) {
        a[b] = c.r * d,
        a[b + 1] = c.g * d,
        a[b + 2] = c.b * d
    }
    function o(a, b, c, d) {
        a[b] = c.r * c.r * d,
        a[b + 1] = c.g * c.g * d,
        a[b + 2] = c.b * c.b * d
    }
    function p(a) {
        var b = a;
        tc.isNaN(b._renderInterval) && (b._renderInterval = 10),
        b.__timeOutFunc || (b.__timeOutFunc = function() {
            requestAnimationFrame(b.__timeOutFunc),
            b.render()
        }),
        setTimeout(b.__timeOutFunc, b._renderInterval)
    }
    function q(a, b, c) {
        null != a && ("number" == typeof a ? this.fromNumber(a, b, c) : null == b && "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b))
    }
    function r() {
        return new q(null)
    }
    function s(a, b, c, d, e, f) {
        for (; --f >= 0;) {
            var g = b * this[a++] + c[d] + e;
            e = Math.floor(g / 67108864),
            c[d++] = 67108863 & g
        }
        return e
    }
    function t(a, b, c, d, e, f) {
        for (var g = 32767 & b,
        h = b >> 15; --f >= 0;) {
            var i = 32767 & this[a],
            j = this[a++] >> 15,
            k = h * i + j * g;
            i = g * i + ((32767 & k) << 15) + c[d] + (1073741823 & e),
            e = (i >>> 30) + (k >>> 15) + h * j + (e >>> 30),
            c[d++] = 1073741823 & i
        }
        return e
    }
    function v(a, b, c, d, e, f) {
        for (var g = 16383 & b,
        h = b >> 14; --f >= 0;) {
            var i = 16383 & this[a],
            j = this[a++] >> 14,
            k = h * i + j * g;
            i = g * i + ((16383 & k) << 14) + c[d] + e,
            e = (i >> 28) + (k >> 14) + h * j,
            c[d++] = 268435455 & i
        }
        return e
    }
    function w(a) {
        return Hc.charAt(a)
    }
    function x(a, b) {
        var c = Ic[a.charCodeAt(b)];
        return null == c ? -1 : c
    }
    function y(a) {
        for (var b = this.t - 1; b >= 0; --b) a[b] = this[b];
        a.t = this.t,
        a.s = this.s
    }
    function z(a) {
        this.t = 1,
        this.s = 0 > a ? -1 : 0,
        a > 0 ? this[0] = a: -1 > a ? this[0] = a + DV: this.t = 0
    }
    function A(a) {
        var b = r();
        return b.fromInt(a),
        b
    }
    function B(a, b) {
        var c;
        if (16 == b) c = 4;
        else if (8 == b) c = 3;
        else if (256 == b) c = 8;
        else if (2 == b) c = 1;
        else if (32 == b) c = 5;
        else {
            if (4 != b) return void this.fromRadix(a, b);
            c = 2
        }
        this.t = 0,
        this.s = 0;
        for (var d = a.length,
        e = !1,
        f = 0; --d >= 0;) {
            var g = 8 == c ? 255 & a[d] : x(a, d);
            0 > g ? "-" == a.charAt(d) && (e = !0) : (e = !1, 0 == f ? this[this.t++] = g: f + c > this.DB ? (this[this.t - 1] |= (g & (1 << this.DB - f) - 1) << f, this[this.t++] = g >> this.DB - f) : this[this.t - 1] |= g << f, f += c, f >= this.DB && (f -= this.DB))
        }
        8 == c && 0 != (128 & a[0]) && (this.s = -1, f > 0 && (this[this.t - 1] |= (1 << this.DB - f) - 1 << f)),
        this.clamp(),
        e && q.ZERO.subTo(this, this)
    }
    function C() {
        for (var a = this.s & this.DM; this.t > 0 && this[this.t - 1] == a;)--this.t
    }
    function D(a) {
        if (this.s < 0) return "-" + this.negate().toString(a);
        var b;
        if (16 == a) b = 4;
        else if (8 == a) b = 3;
        else if (2 == a) b = 1;
        else if (32 == a) b = 5;
        else {
            if (4 != a) return this.toRadix(a);
            b = 2
        }
        var c, d = (1 << b) - 1,
        e = !1,
        f = "",
        g = this.t,
        h = this.DB - g * this.DB % b;
        if (g-->0) for (h < this.DB && (c = this[g] >> h) > 0 && (e = !0, f = w(c)); g >= 0;) b > h ? (c = (this[g] & (1 << h) - 1) << b - h, c |= this[--g] >> (h += this.DB - b)) : (c = this[g] >> (h -= b) & d, 0 >= h && (h += this.DB, --g)),
        c > 0 && (e = !0),
        e && (f += w(c));
        return e ? f: "0"
    }
    function E() {
        var a = r();
        return q.ZERO.subTo(this, a),
        a
    }
    function F() {
        return this.s < 0 ? this.negate() : this
    }
    function G(a) {
        var b = this.s - a.s;
        if (0 != b) return b;
        var c = this.t;
        if (b = c - a.t, 0 != b) return b;
        for (; --c >= 0;) if (0 != (b = this[c] - a[c])) return b;
        return 0
    }
    function H(a) {
        var b, c = 1;
        return 0 != (b = a >>> 16) && (a = b, c += 16),
        0 != (b = a >> 8) && (a = b, c += 8),
        0 != (b = a >> 4) && (a = b, c += 4),
        0 != (b = a >> 2) && (a = b, c += 2),
        0 != (b = a >> 1) && (a = b, c += 1),
        c
    }
    function I() {
        return this.t <= 0 ? 0 : this.DB * (this.t - 1) + H(this[this.t - 1] ^ this.s & this.DM)
    }
    function J(a, b) {
        var c;
        for (c = this.t - 1; c >= 0; --c) b[c + a] = this[c];
        for (c = a - 1; c >= 0; --c) b[c] = 0;
        b.t = this.t + a,
        b.s = this.s
    }
    function K(a, b) {
        for (var c = a; c < this.t; ++c) b[c - a] = this[c];
        b.t = Math.max(this.t - a, 0),
        b.s = this.s
    }
    function L(a, b) {
        var c, d = a % this.DB,
        e = this.DB - d,
        f = (1 << e) - 1,
        g = Math.floor(a / this.DB),
        h = this.s << d & this.DM;
        for (c = this.t - 1; c >= 0; --c) b[c + g + 1] = this[c] >> e | h,
        h = (this[c] & f) << d;
        for (c = g - 1; c >= 0; --c) b[c] = 0;
        b[g] = h,
        b.t = this.t + g + 1,
        b.s = this.s,
        b.clamp()
    }
    function M(a, b) {
        b.s = this.s;
        var c = Math.floor(a / this.DB);
        if (c >= this.t) return void(b.t = 0);
        var d = a % this.DB,
        e = this.DB - d,
        f = (1 << d) - 1;
        b[0] = this[c] >> d;
        for (var g = c + 1; g < this.t; ++g) b[g - c - 1] |= (this[g] & f) << e,
        b[g - c] = this[g] >> d;
        d > 0 && (b[this.t - c - 1] |= (this.s & f) << e),
        b.t = this.t - c,
        b.clamp()
    }
    function N(a, b) {
        for (var c = 0,
        d = 0,
        e = Math.min(a.t, this.t); e > c;) d += this[c] - a[c],
        b[c++] = d & this.DM,
        d >>= this.DB;
        if (a.t < this.t) {
            for (d -= a.s; c < this.t;) d += this[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d += this.s
        } else {
            for (d += this.s; c < a.t;) d -= a[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d -= a.s
        }
        b.s = 0 > d ? -1 : 0,
        -1 > d ? b[c++] = this.DV + d: d > 0 && (b[c++] = d),
        b.t = c,
        b.clamp()
    }
    function O(a, b) {
        var c = this.abs(),
        d = a.abs(),
        e = c.t;
        for (b.t = e + d.t; --e >= 0;) b[e] = 0;
        for (e = 0; e < d.t; ++e) b[e + c.t] = c.am(0, d[e], b, e, 0, c.t);
        b.s = 0,
        b.clamp(),
        this.s != a.s && q.ZERO.subTo(b, b)
    }
    function P(a) {
        for (var b = this.abs(), c = a.t = 2 * b.t; --c >= 0;) a[c] = 0;
        for (c = 0; c < b.t - 1; ++c) {
            var d = b.am(c, b[c], a, 2 * c, 0, 1); (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1)
        }
        a.t > 0 && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1)),
        a.s = 0,
        a.clamp()
    }
    function Q(a, b, c) {
        var d = a.abs();
        if (! (d.t <= 0)) {
            var e = this.abs();
            if (e.t < d.t) return null != b && b.fromInt(0),
            void(null != c && this.copyTo(c));
            null == c && (c = r());
            var f = r(),
            g = this.s,
            h = a.s,
            i = this.DB - H(d[d.t - 1]);
            i > 0 ? (d.lShiftTo(i, f), e.lShiftTo(i, c)) : (d.copyTo(f), e.copyTo(c));
            var j = f.t,
            k = f[j - 1];
            if (0 != k) {
                var l = k * (1 << this.F1) + (j > 1 ? f[j - 2] >> this.F2: 0),
                m = this.FV / l,
                n = (1 << this.F1) / l,
                o = 1 << this.F2,
                p = c.t,
                s = p - j,
                t = null == b ? r() : b;
                for (f.dlShiftTo(s, t), c.compareTo(t) >= 0 && (c[c.t++] = 1, c.subTo(t, c)), q.ONE.dlShiftTo(j, t), t.subTo(f, f); f.t < j;) f[f.t++] = 0;
                for (; --s >= 0;) {
                    var u = c[--p] == k ? this.DM: Math.floor(c[p] * m + (c[p - 1] + o) * n);
                    if ((c[p] += f.am(0, u, c, s, 0, j)) < u) for (f.dlShiftTo(s, t), c.subTo(t, c); c[p] < --u;) c.subTo(t, c)
                }
                null != b && (c.drShiftTo(j, b), g != h && q.ZERO.subTo(b, b)),
                c.t = j,
                c.clamp(),
                i > 0 && c.rShiftTo(i, c),
                0 > g && q.ZERO.subTo(c, c)
            }
        }
    }
    function R(a) {
        var b = r();
        return this.abs().divRemTo(a, null, b),
        this.s < 0 && b.compareTo(q.ZERO) > 0 && a.subTo(b, b),
        b
    }
    function S(a) {
        this.m = a
    }
    function T(a) {
        return a.s < 0 || a.compareTo(this.m) >= 0 ? a.mod(this.m) : a
    }
    function U(a) {
        return a
    }
    function V(a) {
        a.divRemTo(this.m, null, a)
    }
    function W(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function X(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function Y() {
        if (this.t < 1) return 0;
        var a = this[0];
        if (0 == (1 & a)) return 0;
        var b = 3 & a;
        return b = b * (2 - (15 & a) * b) & 15,
        b = b * (2 - (255 & a) * b) & 255,
        b = b * (2 - ((65535 & a) * b & 65535)) & 65535,
        b = b * (2 - a * b % this.DV) % this.DV,
        b > 0 ? this.DV - b: -b
    }
    function Z(a) {
        this.m = a,
        this.mp = a.invDigit(),
        this.mpl = 32767 & this.mp,
        this.mph = this.mp >> 15,
        this.um = (1 << a.DB - 15) - 1,
        this.mt2 = 2 * a.t
    }
    function $(a) {
        var b = r();
        return a.abs().dlShiftTo(this.m.t, b),
        b.divRemTo(this.m, null, b),
        a.s < 0 && b.compareTo(q.ZERO) > 0 && this.m.subTo(b, b),
        b
    }
    function _(a) {
        var b = r();
        return a.copyTo(b),
        this.reduce(b),
        b
    }
    function aa(a) {
        for (; a.t <= this.mt2;) a[a.t++] = 0;
        for (var b = 0; b < this.m.t; ++b) {
            var c = 32767 & a[b],
            d = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM;
            for (c = b + this.m.t, a[c] += this.m.am(0, d, a, b, 0, this.m.t); a[c] >= a.DV;) a[c] -= a.DV,
            a[++c]++
        }
        a.clamp(),
        a.drShiftTo(this.m.t, a),
        a.compareTo(this.m) >= 0 && a.subTo(this.m, a)
    }
    function ba(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function ca(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function da() {
        return 0 == (this.t > 0 ? 1 & this[0] : this.s)
    }
    function ea(a, b) {
        if (a > 4294967295 || 1 > a) return q.ONE;
        var c = r(),
        d = r(),
        e = b.convert(this),
        f = H(a) - 1;
        for (e.copyTo(c); --f >= 0;) if (b.sqrTo(c, d), (a & 1 << f) > 0) b.mulTo(d, e, c);
        else {
            var g = c;
            c = d,
            d = g
        }
        return b.revert(c)
    }
    function fa(a, b) {
        var c;
        return c = 256 > a || b.isEven() ? new S(b) : new Z(b),
        this.exp(a, c)
    }
    function ga() {
        var a = r();
        return this.copyTo(a),
        a
    }
    function ha() {
        if (this.s < 0) {
            if (1 == this.t) return this[0] - this.DV;
            if (0 == this.t) return - 1
        } else {
            if (1 == this.t) return this[0];
            if (0 == this.t) return 0
        }
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
    }
    function ia() {
        return 0 == this.t ? this.s: this[0] << 24 >> 24
    }
    function ja() {
        return 0 == this.t ? this.s: this[0] << 16 >> 16
    }
    function ka(a) {
        return Math.floor(Math.LN2 * this.DB / Math.log(a))
    }
    function la() {
        return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
    }
    function ma(a) {
        if (null == a && (a = 10), 0 == this.signum() || 2 > a || a > 36) return "0";
        var b = this.chunkSize(a),
        c = Math.pow(a, b),
        d = A(c),
        e = r(),
        f = r(),
        g = "";
        for (this.divRemTo(d, e, f); e.signum() > 0;) g = (c + f.intValue()).toString(a).substr(1) + g,
        e.divRemTo(d, e, f);
        return f.intValue().toString(a) + g
    }
    function na(a, b) {
        this.fromInt(0),
        null == b && (b = 10);
        for (var c = this.chunkSize(b), d = Math.pow(b, c), e = !1, f = 0, g = 0, h = 0; h < a.length; ++h) {
            var i = x(a, h);
            0 > i ? "-" == a.charAt(h) && 0 == this.signum() && (e = !0) : (g = b * g + i, ++f >= c && (this.dMultiply(d), this.dAddOffset(g, 0), f = 0, g = 0))
        }
        f > 0 && (this.dMultiply(Math.pow(b, f)), this.dAddOffset(g, 0)),
        e && q.ZERO.subTo(this, this)
    }
    function oa(a, b, c) {
        if ("number" == typeof b) if (2 > a) this.fromInt(1);
        else for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(q.ONE.shiftLeft(a - 1), wa, this), this.isEven() && this.dAddOffset(1, 0); ! this.isProbablePrime(b);) this.dAddOffset(2, 0),
        this.bitLength() > a && this.subTo(q.ONE.shiftLeft(a - 1), this);
        else {
            var d = new Array,
            e = 7 & a;
            d.length = (a >> 3) + 1,
            b.nextBytes(d),
            e > 0 ? d[0] &= (1 << e) - 1 : d[0] = 0,
            this.fromString(d, 256)
        }
    }
    function pa() {
        var a = this.t,
        b = new Array;
        b[0] = this.s;
        var c, d = this.DB - a * this.DB % 8,
        e = 0;
        if (a-->0) for (d < this.DB && (c = this[a] >> d) != (this.s & this.DM) >> d && (b[e++] = c | this.s << this.DB - d); a >= 0;) 8 > d ? (c = (this[a] & (1 << d) - 1) << 8 - d, c |= this[--a] >> (d += this.DB - 8)) : (c = this[a] >> (d -= 8) & 255, 0 >= d && (d += this.DB, --a)),
        0 != (128 & c) && (c |= -256),
        0 == e && (128 & this.s) != (128 & c) && ++e,
        (e > 0 || c != this.s) && (b[e++] = c);
        return b
    }
    function qa(a) {
        return 0 == this.compareTo(a)
    }
    function ra(a) {
        return this.compareTo(a) < 0 ? this: a
    }
    function sa(a) {
        return this.compareTo(a) > 0 ? this: a
    }
    function ta(a, b, c) {
        var d, e, f = Math.min(a.t, this.t);
        for (d = 0; f > d; ++d) c[d] = b(this[d], a[d]);
        if (a.t < this.t) {
            for (e = a.s & this.DM, d = f; d < this.t; ++d) c[d] = b(this[d], e);
            c.t = this.t
        } else {
            for (e = this.s & this.DM, d = f; d < a.t; ++d) c[d] = b(e, a[d]);
            c.t = a.t
        }
        c.s = b(this.s, a.s),
        c.clamp()
    }
    function ua(a, b) {
        return a & b
    }
    function va(a) {
        var b = r();
        return this.bitwiseTo(a, ua, b),
        b
    }
    function wa(a, b) {
        return a | b
    }
    function xa(a) {
        var b = r();
        return this.bitwiseTo(a, wa, b),
        b
    }
    function ya(a, b) {
        return a ^ b
    }
    function za(a) {
        var b = r();
        return this.bitwiseTo(a, ya, b),
        b
    }
    function Aa(a, b) {
        return a & ~b
    }
    function Ba(a) {
        var b = r();
        return this.bitwiseTo(a, Aa, b),
        b
    }
    function Ca() {
        for (var a = r(), b = 0; b < this.t; ++b) a[b] = this.DM & ~this[b];
        return a.t = this.t,
        a.s = ~this.s,
        a
    }
    function Da(a) {
        var b = r();
        return 0 > a ? this.rShiftTo( - a, b) : this.lShiftTo(a, b),
        b
    }
    function Ea(a) {
        var b = r();
        return 0 > a ? this.lShiftTo( - a, b) : this.rShiftTo(a, b),
        b
    }
    function Fa(a) {
        if (0 == a) return - 1;
        var b = 0;
        return 0 == (65535 & a) && (a >>= 16, b += 16),
        0 == (255 & a) && (a >>= 8, b += 8),
        0 == (15 & a) && (a >>= 4, b += 4),
        0 == (3 & a) && (a >>= 2, b += 2),
        0 == (1 & a) && ++b,
        b
    }
    function Ga() {
        for (var a = 0; a < this.t; ++a) if (0 != this[a]) return a * this.DB + Fa(this[a]);
        return this.s < 0 ? this.t * this.DB: -1
    }
    function Ha(a) {
        for (var b = 0; 0 != a;) a &= a - 1,
        ++b;
        return b
    }
    function Ia() {
        for (var a = 0,
        b = this.s & this.DM,
        c = 0; c < this.t; ++c) a += Ha(this[c] ^ b);
        return a
    }
    function Ja(a) {
        var b = Math.floor(a / this.DB);
        return b >= this.t ? 0 != this.s: 0 != (this[b] & 1 << a % this.DB)
    }
    function Ka(a, b) {
        var c = q.ONE.shiftLeft(a);
        return this.bitwiseTo(c, b, c),
        c
    }
    function La(a) {
        return this.changeBit(a, wa)
    }
    function Ma(a) {
        return this.changeBit(a, Aa)
    }
    function Na(a) {
        return this.changeBit(a, ya)
    }
    function Oa(a, b) {
        for (var c = 0,
        d = 0,
        e = Math.min(a.t, this.t); e > c;) d += this[c] + a[c],
        b[c++] = d & this.DM,
        d >>= this.DB;
        if (a.t < this.t) {
            for (d += a.s; c < this.t;) d += this[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d += this.s
        } else {
            for (d += this.s; c < a.t;) d += a[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d += a.s
        }
        b.s = 0 > d ? -1 : 0,
        d > 0 ? b[c++] = d: -1 > d && (b[c++] = this.DV + d),
        b.t = c,
        b.clamp()
    }
    function Pa(a) {
        var b = r();
        return this.addTo(a, b),
        b
    }
    function Qa(a) {
        var b = r();
        return this.subTo(a, b),
        b
    }
    function Ra(a) {
        var b = r();
        return this.multiplyTo(a, b),
        b
    }
    function Sa() {
        var a = r();
        return this.squareTo(a),
        a
    }
    function Ta(a) {
        var b = r();
        return this.divRemTo(a, b, null),
        b
    }
    function Ua(a) {
        var b = r();
        return this.divRemTo(a, null, b),
        b
    }
    function Va(a) {
        var b = r(),
        c = r();
        return this.divRemTo(a, b, c),
        new Array(b, c)
    }
    function Wa(a) {
        this[this.t] = this.am(0, a - 1, this, 0, 0, this.t),
        ++this.t,
        this.clamp()
    }
    function Xa(a, b) {
        if (0 != a) {
            for (; this.t <= b;) this[this.t++] = 0;
            for (this[b] += a; this[b] >= this.DV;) this[b] -= this.DV,
            ++b >= this.t && (this[this.t++] = 0),
            ++this[b]
        }
    }
    function Ya() {}
    function Za(a) {
        return a
    }
    function $a(a, b, c) {
        a.multiplyTo(b, c)
    }
    function _a(a, b) {
        a.squareTo(b)
    }
    function ab(a) {
        return this.exp(a, new Ya)
    }
    function bb(a, b, c) {
        var d = Math.min(this.t + a.t, b);
        for (c.s = 0, c.t = d; d > 0;) c[--d] = 0;
        var e;
        for (e = c.t - this.t; e > d; ++d) c[d + this.t] = this.am(0, a[d], c, d, 0, this.t);
        for (e = Math.min(a.t, b); e > d; ++d) this.am(0, a[d], c, d, 0, b - d);
        c.clamp()
    }
    function cb(a, b, c) {--b;
        var d = c.t = this.t + a.t - b;
        for (c.s = 0; --d >= 0;) c[d] = 0;
        for (d = Math.max(b - this.t, 0); d < a.t; ++d) c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b);
        c.clamp(),
        c.drShiftTo(1, c)
    }
    function db(a) {
        this.r2 = r(),
        this.q3 = r(),
        q.ONE.dlShiftTo(2 * a.t, this.r2),
        this.mu = this.r2.divide(a),
        this.m = a
    }
    function eb(a) {
        if (a.s < 0 || a.t > 2 * this.m.t) return a.mod(this.m);
        if (a.compareTo(this.m) < 0) return a;
        var b = r();
        return a.copyTo(b),
        this.reduce(b),
        b
    }
    function fb(a) {
        return a
    }
    function gb(a) {
        for (a.drShiftTo(this.m.t - 1, this.r2), a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); a.compareTo(this.r2) < 0;) a.dAddOffset(1, this.m.t + 1);
        for (a.subTo(this.r2, a); a.compareTo(this.m) >= 0;) a.subTo(this.m, a)
    }
    function hb(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function ib(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function jb(a, b) {
        var c, d, e = a.bitLength(),
        f = A(1);
        if (0 >= e) return f;
        c = 18 > e ? 1 : 48 > e ? 3 : 144 > e ? 4 : 768 > e ? 5 : 6,
        d = 8 > e ? new S(b) : b.isEven() ? new db(b) : new Z(b);
        var g = new Array,
        h = 3,
        i = c - 1,
        j = (1 << c) - 1;
        if (g[1] = d.convert(this), c > 1) {
            var k = r();
            for (d.sqrTo(g[1], k); j >= h;) g[h] = r(),
            d.mulTo(k, g[h - 2], g[h]),
            h += 2
        }
        var l, m, n = a.t - 1,
        o = !0,
        p = r();
        for (e = H(a[n]) - 1; n >= 0;) {
            for (e >= i ? l = a[n] >> e - i & j: (l = (a[n] & (1 << e + 1) - 1) << i - e, n > 0 && (l |= a[n - 1] >> this.DB + e - i)), h = c; 0 == (1 & l);) l >>= 1,
            --h;
            if ((e -= h) < 0 && (e += this.DB, --n), o) g[l].copyTo(f),
            o = !1;
            else {
                for (; h > 1;) d.sqrTo(f, p),
                d.sqrTo(p, f),
                h -= 2;
                h > 0 ? d.sqrTo(f, p) : (m = f, f = p, p = m),
                d.mulTo(p, g[l], f)
            }
            for (; n >= 0 && 0 == (a[n] & 1 << e);) d.sqrTo(f, p),
            m = f,
            f = p,
            p = m,
            --e < 0 && (e = this.DB - 1, --n)
        }
        return d.revert(f)
    }
    function kb(a) {
        var b = this.s < 0 ? this.negate() : this.clone(),
        c = a.s < 0 ? a.negate() : a.clone();
        if (b.compareTo(c) < 0) {
            var d = b;
            b = c,
            c = d
        }
        var e = b.getLowestSetBit(),
        f = c.getLowestSetBit();
        if (0 > f) return b;
        for (f > e && (f = e), f > 0 && (b.rShiftTo(f, b), c.rShiftTo(f, c)); b.signum() > 0;)(e = b.getLowestSetBit()) > 0 && b.rShiftTo(e, b),
        (e = c.getLowestSetBit()) > 0 && c.rShiftTo(e, c),
        b.compareTo(c) >= 0 ? (b.subTo(c, b), b.rShiftTo(1, b)) : (c.subTo(b, c), c.rShiftTo(1, c));
        return f > 0 && c.lShiftTo(f, c),
        c
    }
    function lb(a) {
        if (0 >= a) return 0;
        var b = this.DV % a,
        c = this.s < 0 ? a - 1 : 0;
        if (this.t > 0) if (0 == b) c = this[0] % a;
        else for (var d = this.t - 1; d >= 0; --d) c = (b * c + this[d]) % a;
        return c
    }
    function mb(a) {
        var b = a.isEven();
        if (this.isEven() && b || 0 == a.signum()) return q.ZERO;
        for (var c = a.clone(), d = this.clone(), e = A(1), f = A(0), g = A(0), h = A(1); 0 != c.signum();) {
            for (; c.isEven();) c.rShiftTo(1, c),
            b ? (e.isEven() && f.isEven() || (e.addTo(this, e), f.subTo(a, f)), e.rShiftTo(1, e)) : f.isEven() || f.subTo(a, f),
            f.rShiftTo(1, f);
            for (; d.isEven();) d.rShiftTo(1, d),
            b ? (g.isEven() && h.isEven() || (g.addTo(this, g), h.subTo(a, h)), g.rShiftTo(1, g)) : h.isEven() || h.subTo(a, h),
            h.rShiftTo(1, h);
            c.compareTo(d) >= 0 ? (c.subTo(d, c), b && e.subTo(g, e), f.subTo(h, f)) : (d.subTo(c, d), b && g.subTo(e, g), h.subTo(f, h))
        }
        return 0 != d.compareTo(q.ONE) ? q.ZERO: h.compareTo(a) >= 0 ? h.subtract(a) : h.signum() < 0 ? (h.addTo(a, h), h.signum() < 0 ? h.add(a) : h) : h
    }
    function nb(a) {
        var b, c = this.abs();
        if (1 == c.t && c[0] <= Jc[Jc.length - 1]) {
            for (b = 0; b < Jc.length; ++b) if (c[0] == Jc[b]) return ! 0;
            return ! 1
        }
        if (c.isEven()) return ! 1;
        for (b = 1; b < Jc.length;) {
            for (var d = Jc[b], e = b + 1; e < Jc.length && Kc > d;) d *= Jc[e++];
            for (d = c.modInt(d); e > b;) if (d % Jc[b++] == 0) return ! 1
        }
        return c.millerRabin(a)
    }
    function ob(a) {
        var b = this.subtract(q.ONE),
        c = b.getLowestSetBit();
        if (0 >= c) return ! 1;
        var d = b.shiftRight(c);
        a = a + 1 >> 1,
        a > Jc.length && (a = Jc.length);
        for (var e = r(), f = 0; a > f; ++f) {
            e.fromInt(Jc[Math.floor(Math.random() * Jc.length)]);
            var g = e.modPow(d, this);
            if (0 != g.compareTo(q.ONE) && 0 != g.compareTo(b)) {
                for (var h = 1; h++<c && 0 != g.compareTo(b);) if (g = g.modPowInt(2, this), 0 == g.compareTo(q.ONE)) return ! 1;
                if (0 != g.compareTo(b)) return ! 1
            }
        }
        return ! 0
    }
    function pb() {
        this.i = 0,
        this.j = 0,
        this.S = new Array
    }
    function qb(a) {
        var b, c, d;
        for (b = 0; 256 > b; ++b) this.S[b] = b;
        for (c = 0, b = 0; 256 > b; ++b) c = c + this.S[b] + a[b % a.length] & 255,
        d = this.S[b],
        this.S[b] = this.S[c],
        this.S[c] = d;
        this.i = 0,
        this.j = 0
    }
    function rb() {
        var a;
        return this.i = this.i + 1 & 255,
        this.j = this.j + this.S[this.i] & 255,
        a = this.S[this.i],
        this.S[this.i] = this.S[this.j],
        this.S[this.j] = a,
        this.S[a + this.S[this.i] & 255]
    }
    function sb() {
        return new pb
    }
    function tb(a) {
        Mc[Nc++] ^= 255 & a,
        Mc[Nc++] ^= a >> 8 & 255,
        Mc[Nc++] ^= a >> 16 & 255,
        Mc[Nc++] ^= a >> 24 & 255,
        Nc >= Oc && (Nc -= Oc)
    }
    function ub() {
        tb((new Date).getTime())
    }
    function vb() {
        if (null == Lc) {
            for (ub(), Lc = sb(), Lc.init(Mc), Nc = 0; Nc < Mc.length; ++Nc) Mc[Nc] = 0;
            Nc = 0
        }
        return Lc.next()
    }
    function wb(a) {
        var b;
        for (b = 0; b < a.length; ++b) a[b] = vb()
    }
    function xb() {}
    function yb(a, b) {
        return new q(a, b)
    }
    function zb(a, b) {
        if (b < a.length + 11) return null;
        for (var c = new Array,
        d = a.length - 1; d >= 0 && b > 0;) {
            var e = a.charCodeAt(d--);
            128 > e ? c[--b] = e: e > 127 && 2048 > e ? (c[--b] = 63 & e | 128, c[--b] = e >> 6 | 192) : (c[--b] = 63 & e | 128, c[--b] = e >> 6 & 63 | 128, c[--b] = e >> 12 | 224)
        }
        c[--b] = 0;
        for (var f = new xb,
        g = new Array; b > 2;) {
            for (g[0] = 0; 0 == g[0];) f.nextBytes(g);
            c[--b] = g[0]
        }
        return c[--b] = 2,
        c[--b] = 0,
        new q(c)
    }
    function Ab() {
        this.n = null,
        this.e = 0,
        this.d = null,
        this.p = null,
        this.q = null,
        this.dmp1 = null,
        this.dmq1 = null,
        this.coeff = null
    }
    function Bb(a, b) {
        this.n = yb(a, 16),
        this.e = parseInt(b, 16)
    }
    function Cb(a) {
        return a.modPowInt(this.e, this.n)
    }
    function Db(a) {
        var b = zb(a, this.n.bitLength() + 7 >> 3);
        if (null == b) return null;
        var c = this.doPrivate(b);
        if (null == c) return null;
        var d = c.toString(16);
        return 0 == (1 & d.length) ? d: "0" + d
    }
    function Eb(a, b) {
        for (var c = a.toByteArray(), d = 0; d < c.length && 0 == c[d];)++d;
        if (c.length - d != b - 1 || 2 != c[d]) return null;
        for (++d; 0 != c[d];) if (++d >= c.length) return null;
        for (var e = ""; ++d < c.length;) {
            var f = 255 & c[d];
            128 > f ? e += String.fromCharCode(f) : f > 191 && 224 > f ? (e += String.fromCharCode((31 & f) << 6 | 63 & c[d + 1]), ++d) : (e += String.fromCharCode((15 & f) << 12 | (63 & c[d + 1]) << 6 | 63 & c[d + 2]), d += 2)
        }
        return e
    }
    function Fb(a, b, c) {
        this.n = yb(a, 16),
        this.e = parseInt(b, 16),
        this.d = yb(c, 16)
    }
    function Gb(a, b, c, d, e, f, g, h) {
        this.n = yb(a, 16),
        this.e = parseInt(b, 16),
        this.d = yb(c, 16),
        this.p = yb(d, 16),
        this.q = yb(e, 16),
        this.dmp1 = yb(f, 16),
        this.dmq1 = yb(g, 16),
        this.coeff = yb(h, 16)
    }
    function Hb(a) {
        if (null == this.p || null == this.q) return a.modPow(this.d, this.n);
        for (var b = a.mod(this.p).modPow(this.dmp1, this.p), c = a.mod(this.q).modPow(this.dmq1, this.q); b.compareTo(c) < 0;) b = b.add(this.p);
        return b.subtract(c).multiply(this.coeff).mod(this.p).multiply(this.q).add(c)
    }
    function Ib(a) {
        var b = yb(a, 16),
        c = this.doPublic(b);
        return null == c ? null: Eb(c, this.n.bitLength() + 7 >> 3)
    }
    function Jb(a, b) {
        a.diffuse.value = b.color,
        a.opacity.value = b.opacity
    }
    function Kb(a, b) {
        a.dashSize.value = b.dashSize,
        a.totalSize.value = b.dashSize + b.gapSize,
        a.scale.value = b.scale
    }
    function Lb(a, b) {
        a.psColor.value = b.color,
        a.opacity.value = b.opacity,
        a.size.value = b.size,
        a.map.value = b.map
    }
    function Mb(a, b) {
        return a.distance - b.distance
    }
    function Nb(a, b, c, d, e) { (a instanceof Yb.Node || a instanceof Yb.Billboard) && Pb(a, b, c, d, e)
    }
    function Ob(a, b, c, d, f) {
        if (a !== e) for (var g = a.getDescendants(), h = 0, i = g.length; i > h; h++) Nb(g[h], b, c, d, f)
    }
    function Pb(a, b, c, d, f) {
        if (d || 0 != f.isVisible(a)) {
            if (a instanceof Yb.Billboard) {
                var g = b.matrixPosition;
                g.setFromMatrixPosition(a.worldMatrix);
                var h = b.ray.distanceToPoint(g),
                i = a.material.alignment,
                j = new Yb.Plane(1, 1); (i.x || i.y) && (j.setPosition(i.x, i.y, 0), j = Yb.Utils.transformElement(j, !0)),
                j.setPosition(g);
                var k = (new $b).getScaleFromMatrix(a.worldMatrix);
                j.setScale(k.x, k.y, 1);
                var l = b.direction.clone(),
                m = j.getPosition().clone(),
                n = a.material;
                n && n.vertical && (l.y = 0),
                m.sub(l),
                j.lookAt(m),
                j.updateWorldMatrix(!0);
                var o = [];
                return Pb(j, b, o, !0, f),
                0 === o.length ? c: (c.push({
                    distance: o[0].distance,
                    point: a._position,
                    face: null,
                    object: a,
                    element: a
                }), c)
            }
            if (a instanceof Yb.Line) {
                var p = 1;
                p -= 1;
                var q = Math.sqrt(b.linePrecision + p),
                r = q * q,
                s = a;
                if (null == s.boundingSphere && s.computeBoundingSphere(), fd.copy(s.boundingSphere), fd.applyMatrix4(a.worldMatrix), b.ray.isIntersectionSphere(fd) === !1) return c;
                cd.getInverse(a.worldMatrix),
                bd.copy(b.ray).transform(cd);
                for (var t = s.vertices,
                u = t.length,
                v = new $b,
                w = new $b,
                x = a.type === Yb.LineStrip ? 1 : 2, y = 0; u - 1 > y; y += x) {
                    var z = bd.distanceSqToSegment(t[y], t[y + 1], w, v);
                    if (! (z > r)) {
                        var h = bd.origin.distanceTo(w);
                        h < b.near || h > b.far || c.push({
                            distance: h,
                            point: v.clone().applyMatrix4(a.worldMatrix),
                            face: null,
                            faceIndex: null,
                            element: a,
                            object: a
                        })
                    }
                }
                return c
            }
            if (null === a.boundingSphere && a.computeBoundingSphere(), fd.set(a.worldMatrix.getPosition(), a.boundingSphere.radius * a.worldMatrix.getMaxScaleOnAxis()), !b.ray.isIntersectionSphere(fd)) return c;
            var A, B, C, D, s = a,
            t = s.vertices,
            E = a.material instanceof Yb.ArrayMaterial,
            F = E === !0 ? a.material.materials: null,
            G = a.material.side,
            q = b.precision;
            a.rotationWorldMatrix.extractRotation(a.worldMatrix),
            cd.getInverse(a.worldMatrix),
            bd.copy(b.ray).transform(cd);
            for (var H = 0,
            I = s.faces.length; I > H; H++) {
                var J = s.faces[H],
                K = E === !0 ? F[J.materialIndex] : a.material,
                L = f.getOverLoadMaterial(a, K);
                if (L && (K = L), K !== e && K.visible !== !1 && (s.visible !== !1 || d) && (!K.transparent || 0 != K.opacity)) {
                    dd.setFromNormalAndCoplanarPoint(J.normal, t[J.a]);
                    var M = bd.distanceToPlane(dd);
                    if (! (Math.abs(M) < q || 0 > M)) {
                        G = K.side;
                        var N = bd.direction.dot(dd.normal);
                        if ((G === Yb.DoubleSide || (G === Yb.FrontSide ? 0 > N: N > 0)) && !(M < b.near || M > b.far)) {
                            ed = bd.at(M, ed);
                            var O, P = new $b,
                            Q = (J.materialIndex, !1);
                            if (f && f._selectTransparencyThreshold > 0 && (Q = 1 == K.transparent || K.alphaTest > 0), J instanceof Yb.Face3) {
                                if (A = t[J.a], B = t[J.b], C = t[J.c], !Yb.Triangle.containsPoint(ed, A, B, C)) continue;
                                P = Yb.Triangle.barycoordFromPoint(ed, A, B, C)
                            } else {
                                if (! (J instanceof Yb.Face4)) throw Error("face type not supported");
                                A = t[J.a],
                                B = t[J.b],
                                C = t[J.c],
                                D = t[J.d];
                                var R = Yb.Triangle.containsPoint(ed, A, B, D),
                                S = Yb.Triangle.containsPoint(ed, B, C, D);
                                if (!R && !S) continue;
                                R ? P = Yb.Triangle.barycoordFromPoint(ed, A, B, D) : (P = Yb.Triangle.barycoordFromPoint(ed, B, C, D), O = !0)
                            }
                            var T = new Zb,
                            U = P.z,
                            V = P.x,
                            W = P.y;
                            if (s.uvs && s.uvs[H]) {
                                var X = s.uvs[H];
                                J instanceof Yb.Face3 ? (T.x = X[0].x * V + X[1].x * W + X[2].x * U, T.y = X[0].y * V + X[1].y * W + X[2].y * U) : O ? (T.x = X[1].x * V + X[2].x * W + X[3].x * U, T.y = X[1].y * V + X[2].y * W + X[3].y * U) : (T.x = X[0].x * V + X[1].x * W + X[3].x * U, T.y = X[0].y * V + X[1].y * W + X[3].y * U)
                            }
                            var Y, Z = 1;
                            if (T = f.debugUV || T, Q) {
                                if (K.opacity < f._selectTransparencyThreshold) continue;
                                if (null == K.map) Z = K.opacity;
                                else {
                                    Y = K.map._image;
                                    var $ = tc.getPixelFromImage(Y, T.x, T.y);
                                    Z = $[3] / 255 * (null == K.opacity ? 1 : K.opacity)
                                }
                                Z < K.alphaTest ? Z = 0 : 0 == K.transparent && (Z = 1)
                            }
                            Z < f._selectTransparencyThreshold || c.push({
                                distance: M,
                                point: b.ray.at(M),
                                face: J,
                                uv: T,
                                faceIndex: H,
                                element: a,
                                object: a,
                                side: N > 0 ? 1 : -1
                            })
                        }
                    }
                }
            }
        }
    }
    function Qb(a) {
        if (!qd[a.id]) {
            if (sd = !0, qd[a.id] = a, a.finish = null == a.finish ? a.delay + a.dur + a.interval: a.finish, null == a.from && a.attr && a.source) {
                var b; (b = a.attr.match(/^S[:@](.*)/i)) ? a.from = a.source.getStyle(b[1]) : (b = a.attr.match(/^C[:@](.*)/i)) ? a.from = a.source.getClient(b[1]) : a.from = twaver.Util.getValue(a.source, a.attr)
            }
            Rb(a),
            Sb(a)
        }
        return a
    }
    function Rb(a) {
        var b = a.type,
        c = a.from,
        d = a.to;
        "number" === b ? (a.from = c || 0, a.to = d || 0) : "point" === b ? (c ? c.length && (a.from = {
            x: c[0],
            y: c[1]
        }) : a.from = "scale" === a.attr ? {
            x: 1,
            y: 1
        }: {
            x: 0,
            y: 0
        },
        d ? d.length && (a.to = {
            x: d[0],
            y: d[1]
        }) : a.to = "scale" === a.attr ? {
            x: 1,
            y: 1
        }: {
            x: 0,
            y: 0
        }) : "rect" === b ? (c ? c.length && (a.from = {
            x: c[0],
            y: c[1],
            w: c[2],
            h: c[3]
        }) : a.from = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        },
        d ? d.length && (a.to = {
            x: d[0],
            y: d[1],
            w: d[2],
            h: d[3]
        }) : a.to = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        }) : "color" === b ? (a.from = getColorValue(c), a.to = getColorValue(d)) : "set" !== b && "group_set" === b,
        a.current = a.from
    }
    function Sb(a) {
        var b = a.type,
        c = a.from,
        d = a.to;
        "number" === b ? a.delta = d - c: "point" === b ? a.delta = {
            x: d.x - c.x,
            y: d.y - c.y
        }: "rect" === b ? a.delta = {
            x: d.x - c.x,
            y: d.y - c.y,
            w: d.w - c.w,
            h: d.h - c.h
        }: "color" === b ? a.delta = {
            r: d.r - c.r,
            g: d.g - c.g,
            b: d.b - c.b,
            a: d.a - c.a
        }: "set" !== b && "group_set" === b
    }
    function Tb(a, b) {
        return qd[a.id] && (null == b && (b = !0), b && Xb(a, a.to), a.onStop && a.onStop(), a.time = 0, a.total = 0, a.start = null, a.count = 0, a.started = !1, a.stopped = !1, delete qd[a.id]),
        a
    }
    function Ub(a) {
        null == a && (a = !0),
        Object.keys(qd).forEach(function(b) {
            var c = qd[b];
            a && Xb(c, c.to),
            c.onStop && c.onStop()
        }),
        qd = {}
    }
    function Vb(a) {
        Object.keys(qd).forEach(function(b) {
            var c = qd[b];
            if (c) {
                if (null == c.start && (c.start = a), c.total = a - c.start, c.total > c.delay) {
                    c.time = c.total - c.delay;
                    var d = !1;
                    if (c.time >= c.dur && (c.time = c.dur, d = !0), !c.stopped && Xb(c, Wb(c)), c.stopped = d, c.total >= c.finish) if (c.count++, c.count >= c.repeat) Tb(c, !1),
                    c.onDone && c.onDone();
                    else if (c.time = 0, c.total = 0, c.start = null, c.stopped = !1, c.reverse) {
                        var e = c.from;
                        c.from = c.to,
                        c.to = e,
                        Sb(c)
                    }
                } ! sd && (sd = !0)
            }
        })
    }
    function Wb(a, b) {
        var c = a.type,
        d = a.delta,
        e = a.from,
        f = a.time,
        g = a.dur,
        h = jc[a.easing || "easeNone"];
        return h || (h = jc.easeNone),
        "number" === c ? b = h(f, e, d, g) : "point" === c ? b = {
            x: h(f, e.x, d.x, g),
            y: h(f, e.y, d.y, g)
        }: "rect" === c ? b = {
            x: h(f, e.x, d.x, g),
            y: h(f, e.y, d.y, g),
            w: h(f, e.w, d.w, g),
            h: h(f, e.h, d.h, g)
        }: "color" === c ? b = "rgba(" + Math.floor(h(f, e.r, d.r, g)) + "," + Math.floor(h(f, e.g, d.g, g)) + "," + Math.floor(h(f, e.b, d.b, g)) + "," + Math.floor(h(f, e.a, d.a, g)) + ")": "set" === c ? a.time && (b = a.to) : "group_set" === c && (b = a.to[a.groupIndex]),
        a.current = b,
        b
    }
    function Xb(a, b) {
        if (a.started || (a.started = !0, a.onPlay && a.onPlay()), a.filter && (b = a.filter(b)), a.attr && a.source) {
            var c; (c = a.attr.match(/^S[:@](.*)/i)) ? a.source.setStyle(c[1], b) : (c = a.attr.match(/^C[:@](.*)/i)) ? a.source.setClient(c[1], b) : twaver.Util.setValue(a.source, a.attr, b)
        }
        a.onUpdate && a.onUpdate(b)
    }
    self.Int32Array = self.Int32Array || Array,
    self.Float32Array = self.Float32Array || Array,
    Object.create = Object.create ||
    function(a) {
        var b = function() {};
        return b.prototype = a,
        new b
    };
    var Yb = {
        version: "2.0.6",
        _id: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"],
        id: function(a) {
            a = null == a ? "": a;
            for (var b = [], c = 0; 32 > c; c++) b[c] = this._id[Math.floor(16 * Math.random())];
            return b[12] = "4",
            b[16] = this._id[3 & b[16] | 8],
            a + b.join("")
        },
        ip: function(a, b, c, d) {
            var e = c + b;
            a[Yb.getter(b, d)] = function() {
                return this[e]
            },
            a[Yb.setter(b)] = function(a) {
                var c = this[e];
                c !== a && (this.setPropertyValue ? this.setPropertyValue(e, a) && (this.onPropertyChange(b, c, a), this.firePropertyChange(b, c, a)) : (this[e] = a, this.onPropertyChange(b, c, a), this.firePropertyChange(b, c, a)))
            }
        },
        getter: function(a, b) {
            var c = a.charAt(0).toUpperCase() + a.slice(1),
            d = /ble$/.test(a) || /ed$/.test(a) ? "is": "get";
            return b && -1 != b.indexOf(a) && (d = "is"),
            d + c
        },
        setter: function(a) {
            var b = a.charAt(0).toUpperCase() + a.slice(1);
            return "set" + b
        },
        getValue: function(a, b, c) {
            var d = b.charAt(0).toUpperCase() + b.slice(1),
            e = "get" + d,
            f = "is" + d;
            return c ? "boolean" === c ? a[f]() : (null == a[e] && console.log("get Function " + e + " not exist"), a[e]()) : a[e] ? a[e]() : a[f] ? a[f]() : a[b]
        },
        setValue: function(a, b, c) {
            a["set" + b.charAt(0).toUpperCase() + b.slice(1)](c)
        },
        clone: function(a) {
            if (!a) return null;
            var b = {};
            for (var c in a) b[c] = a[c];
            return b
        },
        addMethod: function(a, b) {
            var c = a.prototype;
            for (var d in b) c[d] = b[d]
        },
        classCache: {},
        getClass: function(a) {
            var b = Yb.classCache[a];
            if (!b) {
                var c = a.split("."),
                e = c.length;
                b = d;
                for (var f = 0; e > f; f++) b = b[c[f]];
                Yb.classCache[a] = b
            }
            return b
        },
        newInstance: function(a) {
            "string" == typeof a && (a = Yb.getClass(a), a = a.prototype);
            var b = a.constructor;
            if (!b) return null;
            var c = arguments.length,
            d = arguments;
            if (1 === c) return new b;
            if (2 === c) return new b(d[1]);
            if (3 === c) return new b(d[1], d[2]);
            if (4 === c) return new b(d[1], d[2], d[3]);
            if (5 === c) return new b(d[1], d[2], d[3], d[4]);
            if (6 === c) return new b(d[1], d[2], d[3], d[4], d[5]);
            if (7 === c) return new b(d[1], d[2], d[3], d[4], d[5], d[6]);
            if (8 === c) return new b(d[1], d[2], d[3], d[4], d[5], d[6], d[7]);
            throw "don't support args more than 7"
        },
        xml: function(a) {
            if (d.DOMParser) return (new DOMParser).parseFromString(a, "text/xml");
            var b = new ActiveXObject("Microsoft.XmlDOM");
            return b.async = !1,
            b.loadXml(a),
            b
        }
    };
    d.TGL = Yb,
    d.mono = Yb,
    Yb.extend = function(a, b, c) {
        if (b) {
            var d = function() {};
            d.prototype = b.prototype,
            a.prototype = new d,
            a.prototype.constructor = a,
            a.superClass = b.prototype,
            b.prototype.constructor == Object.prototype.constructor && (b.prototype.constructor = b)
        }
        var e = a.prototype;
        if (c) {
            e.getClassName = function() {
                return c.className
            };
            for (var f in c) {
                if ("__accessor" === f) for (var g = c.__accessor,
                h = c.__bool,
                i = 0; i < g.length; i++) {
                    var j = g[i];
                    Yb.ip(e, j, "", h)
                } else if ("___accessor" === f) for (var g = c.___accessor,
                i = 0; i < g.length; i++) {
                    var j = g[i];
                    Yb.ip(e, j, "_", h)
                }
                e[f] = c[f]
            }
            c.constructor && (e.newInstance = function() {
                return Yb.newInstance(this)
            })
        }
    },
    Yb.defaultEulerOrder = "XYZ",
    String.prototype.startsWith = String.prototype.startsWith ||
    function(a) {
        return this.slice(0, a.length) === a
    },
    String.prototype.endsWith = String.prototype.endsWith ||
    function(a) {
        var b = String(a),
        c = this.lastIndexOf(b);
        return (c > -1 && c) === this.length - b.length
    },
    String.prototype.trim = String.prototype.trim ||
    function() {
        return this.replace(/^\s+|\s+$/g, "")
    },
    function() {
        for (var a = 0,
        b = ["ms", "moz", "webkit", "o"], c = 0; c < b.length && !d.requestAnimationFrame; ++c) d.requestAnimationFrame = d[b[c] + "RequestAnimationFrame"],
        d.cancelAnimationFrame = d[b[c] + "CancelAnimationFrame"] || d[b[c] + "CancelRequestAnimationFrame"];
        d.requestAnimationFrame === e && (d.requestAnimationFrame = function(b, c) {
            var e = Date.now(),
            f = Math.max(0, 16 - (e - a)),
            g = d.setTimeout(function() {
                b(e + f)
            },
            f);
            return a = e + f,
            g
        }),
        d.cancelAnimationFrame = d.cancelAnimationFrame ||
        function(a) {
            d.clearTimeout(a)
        }
    } (),
    Yb.CullFaceNone = 0,
    Yb.CullFaceBack = 1,
    Yb.CullFaceFront = 2,
    Yb.CullFaceFrontBack = 3,
    Yb.FrontFaceDirectionCW = 0,
    Yb.FrontFaceDirectionCCW = 1,
    Yb.BasicShadowMap = 0,
    Yb.PCFShadowMap = 1,
    Yb.PCFSoftShadowMap = 2,
    Yb.FrontSide = "front",
    Yb.BackSide = "back",
    Yb.DoubleSide = "both",
    Yb.BothSide = "both",
    Yb.NoShading = 0,
    Yb.FlatShading = 1,
    Yb.SmoothShading = 2,
    Yb.NormalTypeFlat = "flat",
    Yb.NormalTypeSmooth = "smooth",
    Yb.NoColors = 0,
    Yb.FaceColors = 1,
    Yb.VertexColors = 2,
    Yb.NoBlending = 0,
    Yb.NormalBlending = 1,
    Yb.AdditiveBlending = 2,
    Yb.SubtractiveBlending = 3,
    Yb.MultiplyBlending = 4,
    Yb.CustomBlending = 5,
    Yb.AddEquation = 100,
    Yb.SubtractEquation = 101,
    Yb.ReverseSubtractEquation = 102,
    Yb.ZeroFactor = 200,
    Yb.OneFactor = 201,
    Yb.SrcColorFactor = 202,
    Yb.OneMinusSrcColorFactor = 203,
    Yb.SrcAlphaFactor = 204,
    Yb.OneMinusSrcAlphaFactor = 205,
    Yb.DstAlphaFactor = 206,
    Yb.OneMinusDstAlphaFactor = 207,
    Yb.DstColorFactor = 208,
    Yb.OneMinusDstColorFactor = 209,
    Yb.SrcAlphaSaturateFactor = 210,
    Yb.MultiplyOperation = 0,
    Yb.MixOperation = 1,
    Yb.AddOperation = 2,
    Yb.UVMapping = function() {},
    Yb.CubeReflectionMapping = function() {},
    Yb.CubeRefractionMapping = function() {},
    Yb.SphericalReflectionMapping = function() {},
    Yb.SphericalRefractionMapping = function() {},
    Yb.RepeatWrapping = "repeat",
    Yb.ClampToEdgeWrapping = "clamp",
    Yb.MirroredRepeatWrapping = "mirrored",
    Yb.NearestFilter = 1003,
    Yb.NearestMipMapNearestFilter = 1004,
    Yb.NearestMipMapLinearFilter = 1005,
    Yb.LinearFilter = 1006,
    Yb.LinearMipMapNearestFilter = 1007,
    Yb.LinearMipMapLinearFilter = 1008,
    Yb.UnsignedByteType = 1009,
    Yb.ByteType = 1010,
    Yb.ShortType = 1011,
    Yb.UnsignedShortType = 1012,
    Yb.IntType = 1013,
    Yb.UnsignedIntType = 1014,
    Yb.FloatType = 1015,
    Yb.UnsignedShort4444Type = 1016,
    Yb.UnsignedShort5551Type = 1017,
    Yb.UnsignedShort565Type = 1018,
    Yb.AlphaFormat = 1019,
    Yb.RGBFormat = 1020,
    Yb.RGBAFormat = 1021,
    Yb.LuminanceFormat = 1022,
    Yb.LuminanceAlphaFormat = 1023,
    Yb.RGB_S3TC_DXT1_Format = 2001,
    Yb.RGBA_S3TC_DXT1_Format = 2002,
    Yb.RGBA_S3TC_DXT3_Format = 2003,
    Yb.RGBA_S3TC_DXT5_Format = 2004,
    Yb.Gradient_Linear_U = 1,
    Yb.Gradient_Linear_V = 2,
    Yb.Gradient_Linear_UV = 3,
    Yb.Gradient_Linear_NUV = 4,
    Yb.Gradient_Linear_Radial = 5,
    Yb.Gradient_Linear_Sweep = 6,
    Yb.Math = {
        clamp: function(a, b, c) {
            return b > a ? b: a > c ? c: a
        },
        isConcave: function(a, b, c) {
            var d = c ? 1 : -1;
            return (a.x * b.y - b.x * a.y) * d < 0 ? !0 : !1
        },
        area: function(a, b, c, d) {
            var f = d ? 1 : -1;
            if (!a || !b || !c) return e;
            var g = -a.x * b.y - b.x * c.y - c.x * a.y + c.x * b.y + b.x * a.y + a.x * c.y;
            return g * f
        },
        isClockwise: function(a, b, c) {
            b = b || "x",
            c = c || "y";
            for (var d = 0,
            e = a.length,
            f = 0; e > f; f++) {
                var g = a[f],
                h = a[f + 1 === e ? 0 : f + 1];
                d += (h[b] - g[b]) * (h[c] + g[c])
            }
            return 0 > d
        },
        isClockwise3: function(a, b, c) { (new mono.Vec3).crossVectors(a, b),
            (new mono.Vec3).subVectors(b, a),
            (new mono.Vec3).subVectors(b, a)
        },
        clampBottom: function(a, b) {
            return b > a ? b: a
        },
        mapLinear: function(a, b, c, d, e) {
            return d + (a - b) * (e - d) / (c - b)
        },
        random16: function() {
            return (65280 * Math.random() + 255 * Math.random()) / 65535
        },
        randInt: function(a, b) {
            return a + Math.floor(Math.random() * (b - a + 1))
        },
        randFloat: function(a, b) {
            return a + Math.random() * (b - a)
        },
        randFloatSpread: function(a) {
            return a * (.5 - Math.random())
        },
        sign: function(a) {
            return 0 > a ? -1 : a > 0 ? 1 : 0
        },
        degToRad: function(a) {
            return a * Yb.Math.__d2r
        },
        radToDeg: function(a) {
            return a * Yb.Math.__r2d
        },
        smoothstep: function(a, b, c) {
            return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a))
        },
        smootherstep: function(a, b, c) {
            return b >= a ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10))
        },
        PI2: 2 * Math.PI,
        generateUUID: function() {
            var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
            c = new Array(36),
            d = 0;
            return function() {
                for (var e = 0; 36 > e; e++) 8 == e || 13 == e || 18 == e || 23 == e ? c[e] = "-": 14 == e ? c[e] = "4": (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), a = 15 & d, d >>= 4, c[e] = b[19 == e ? 3 & a | 8 : a]);
                return c.join("")
            }
        } ()
    },
    Yb.Math.__d2r = Math.PI / 180,
    Yb.Math.__r2d = 180 / Math.PI,
    Yb.Quat = function(a, b, c, d) {
        this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0,
        this.w = d !== e ? d: 1
    },
    Yb.Quat.prototype = {
        constructor: Yb.Quat,
        set: function(a, b, c, d) {
            return this.x = a,
            this.y = b,
            this.z = c,
            this.w = d,
            this
        },
        copy: function(a) {
            return this.x = a.x,
            this.y = a.y,
            this.z = a.z,
            this.w = a.w,
            this
        },
        setFromEuler: function(a, b) {
            var c = Math.cos(a.x / 2),
            d = Math.cos(a.y / 2),
            f = Math.cos(a.z / 2),
            g = Math.sin(a.x / 2),
            h = Math.sin(a.y / 2),
            i = Math.sin(a.z / 2);
            return b === e || "XYZ" === b ? (this.x = g * d * f + c * h * i, this.y = c * h * f - g * d * i, this.z = c * d * i + g * h * f, this.w = c * d * f - g * h * i) : "YXZ" === b ? (this.x = g * d * f + c * h * i, this.y = c * h * f - g * d * i, this.z = c * d * i - g * h * f, this.w = c * d * f + g * h * i) : "ZXY" === b ? (this.x = g * d * f - c * h * i, this.y = c * h * f + g * d * i, this.z = c * d * i + g * h * f, this.w = c * d * f - g * h * i) : "ZYX" === b ? (this.x = g * d * f - c * h * i, this.y = c * h * f + g * d * i, this.z = c * d * i - g * h * f, this.w = c * d * f + g * h * i) : "YZX" === b ? (this.x = g * d * f + c * h * i, this.y = c * h * f + g * d * i, this.z = c * d * i - g * h * f, this.w = c * d * f - g * h * i) : "XZY" === b && (this.x = g * d * f - c * h * i, this.y = c * h * f - g * d * i, this.z = c * d * i + g * h * f, this.w = c * d * f + g * h * i),
            this
        },
        setFromAxisAngle: function(a, b) {
            var c = b / 2,
            d = Math.sin(c);
            return this.x = a.x * d,
            this.y = a.y * d,
            this.z = a.z * d,
            this.w = Math.cos(c),
            this
        },
        setFromRotationMatrix: function(a) {
            var b, c = a.elements,
            d = c[0],
            e = c[4],
            f = c[8],
            g = c[1],
            h = c[5],
            i = c[9],
            j = c[2],
            k = c[6],
            l = c[10],
            m = d + h + l;
            return m > 0 ? (b = .5 / Math.sqrt(m + 1), this.w = .25 / b, this.x = (k - i) * b, this.y = (f - j) * b, this.z = (g - e) * b) : d > h && d > l ? (b = 2 * Math.sqrt(1 + d - h - l), this.w = (k - i) / b, this.x = .25 * b, this.y = (e + g) / b, this.z = (f + j) / b) : h > l ? (b = 2 * Math.sqrt(1 + h - d - l), this.w = (f - j) / b, this.x = (e + g) / b, this.y = .25 * b, this.z = (i + k) / b) : (b = 2 * Math.sqrt(1 + l - d - h), this.w = (g - e) / b, this.x = (f + j) / b, this.y = (i + k) / b, this.z = .25 * b),
            this
        },
        inverse: function() {
            return this.conjugate().normalize(),
            this
        },
        conjugate: function() {
            return this.x *= -1,
            this.y *= -1,
            this.z *= -1,
            this
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        normalize: function() {
            var a = this.length();
            return 0 === a ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (a = 1 / a, this.x = this.x * a, this.y = this.y * a, this.z = this.z * a, this.w = this.w * a),
            this
        },
        multiply: function(a, b) {
            return b !== e ? (console.warn("DEPRECATED: Quat's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
        },
        multiplyQuaternions: function(a, b) {
            var c = a.x,
            d = a.y,
            e = a.z,
            f = a.w,
            g = b.x,
            h = b.y,
            i = b.z,
            j = b.w;
            return this.x = c * j + f * g + d * i - e * h,
            this.y = d * j + f * h + e * g - c * i,
            this.z = e * j + f * i + c * h - d * g,
            this.w = f * j - c * g - d * h - e * i,
            this
        },
        multiplyVector3: function(a) {
            return console.warn("DEPRECATED: Quat's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( Quat ) instead."),
            a.applyQuaternion(this)
        },
        slerp: function(a, b) {
            var c = this.x,
            d = this.y,
            e = this.z,
            f = this.w,
            g = f * a.w + c * a.x + d * a.y + e * a.z;
            if (0 > g ? (this.w = -a.w, this.x = -a.x, this.y = -a.y, this.z = -a.z, g = -g) : this.copy(a), g >= 1) return this.w = f,
            this.x = c,
            this.y = d,
            this.z = e,
            this;
            var h = Math.acos(g),
            i = Math.sqrt(1 - g * g);
            if (Math.abs(i) < .001) return this.w = .5 * (f + this.w),
            this.x = .5 * (c + this.x),
            this.y = .5 * (d + this.y),
            this.z = .5 * (e + this.z),
            this;
            var j = Math.sin((1 - b) * h) / i,
            k = Math.sin(b * h) / i;
            return this.w = f * j + this.w * k,
            this.x = c * j + this.x * k,
            this.y = d * j + this.y * k,
            this.z = e * j + this.z * k,
            this
        },
        toEuler: function() {
            var a = this.w * this.w,
            b = this.x * this.x,
            c = this.y * this.y,
            d = this.z * this.z,
            e = 180 / Math.PI * Math.atan2(2 * (this.y * this.z + this.x * this.w), -b - c + d + a),
            f = 180 / Math.PI * Math.asin( - 2 * (this.x * this.z - this.y * this.w)),
            g = 180 / Math.PI * Math.atan2(2 * (this.x * this.y + this.z * this.w), b - c - d + a);
            return [e, f, g]
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        },
        clone: function() {
            return new Yb.Quat(this.x, this.y, this.z, this.w)
        }
    },
    Yb.Quat.slerp = function(a, b, c, d) {
        return c.copy(a).slerp(b, d)
    };
    var Zb = function(a, b) {
        this.x = a || 0,
        this.y = b || 0
    };
    Zb.prototype = {
        constructor: Zb,
        set: function(a, b) {
            return this.x = a,
            this.y = b,
            this
        },
        setX: function(a) {
            return this.x = a,
            this
        },
        setY: function(a) {
            return this.y = a,
            this
        },
        setComponent: function(a, b) {
            switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            default:
                throw new Error("index is out of range: " + a)
            }
        },
        getComponent: function(a) {
            switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + a)
            }
        },
        copy: function(a) {
            return this.x = a.x,
            this.y = a.y,
            this
        },
        add: function(a, b) {
            return b !== e ? (console.warn("DEPRECATED: Vec2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this)
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this
        },
        addScalar: function(a) {
            return this.x += a,
            this.y += a,
            this
        },
        sub: function(a, b) {
            return b !== e ? (console.warn("DEPRECATED: Vec2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this)
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this
        },
        multiplyScalar: function(a) {
            return this.x *= a,
            this.y *= a,
            this
        },
        multiply: function(a) {
            return this.x *= a.x,
            this.y *= a.y,
            this
        },
        divideScalar: function(a) {
            return 0 !== a ? (this.x /= a, this.y /= a) : this.set(0, 0),
            this
        },
        min: function(a) {
            return this.x > a.x && (this.x = a.x),
            this.y > a.y && (this.y = a.y),
            this
        },
        max: function(a) {
            return this.x < a.x && (this.x = a.x),
            this.y < a.y && (this.y = a.y),
            this
        },
        clamp: function(a, b) {
            return this.x < a.x ? this.x = a.x: this.x > b.x && (this.x = b.x),
            this.y < a.y ? this.y = a.y: this.y > b.y && (this.y = b.y),
            this
        },
        negate: function() {
            return this.multiplyScalar( - 1)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x,
            c = this.y - a.y;
            return b * b + c * c
        },
        setLength: function(a) {
            var b = this.length();
            return 0 !== b && a !== b && this.multiplyScalar(a / b),
            this
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b,
            this.y += (a.y - this.y) * b,
            this
        },
        equals: function(a) {
            return null == a ? !1 : a.x === this.x && a.y === this.y
        },
        clone: function() {
            return new Zb(this.x, this.y)
        }
    },
    Yb.Vec2 = Zb;
    var $b = function(a, b, c) {
        this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0
    };
    Yb.Vec3 = $b,
    $b.prototype = {
        set: function(a, b, c) {
            return this.x = a,
            this.y = b,
            this.z = c,
            this
        },
        setX: function(a) {
            return this.x = a,
            this
        },
        setY: function(a) {
            return this.y = a,
            this
        },
        setZ: function(a) {
            return this.z = a,
            this
        },
        setComponent: function(a, b) {
            switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            default:
                throw new Error("index is out of range: " + a)
            }
        },
        getComponent: function(a) {
            switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + a)
            }
        },
        center: function(a, b) {
            return this.x = (a.x + b.x) / 2,
            this.y = (a.y + b.y) / 2,
            this.z = (a.z + b.z) / 2,
            this
        },
        copy: function(a) {
            return (null == this || null == a) && console.log("TGL.Vec3.copy this : " + this + " v : " + a),
            this.x = a.x,
            this.y = a.y,
            this.z = a.z,
            this
        },
        add: function(a) {
            return (!this || !a) && console.log("TGL.Vec3.add this : " + this + " v : " + a),
            this.x += a.x,
            this.y += a.y,
            this.z += a.z,
            this
        },
        addScalar: function(a) {
            return this.x += a,
            this.y += a,
            this.z += a,
            this
        },
        addVectors: function(a, b) {
            return (!a || !b) && console.log("TGL.Vec3.addVectors a : " + a + " b : " + b),
            this.x = a.x + b.x,
            this.y = a.y + b.y,
            this.z = a.z + b.z,
            this
        },
        sub: function(a) {
            return this.x -= a.x,
            this.y -= a.y,
            this.z -= a.z,
            this
        },
        subVectors: function(a, b) {
            return (null == a || null == b) && console.log("null"),
            this.x = a.x - b.x,
            this.y = a.y - b.y,
            this.z = a.z - b.z,
            this
        },
        multiply: function(a) {
            return this.x *= a.x,
            this.y *= a.y,
            this.z *= a.z,
            this
        },
        multiplyScalar: function(a) {
            return this.x *= a,
            this.y *= a,
            this.z *= a,
            this
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x,
            this.y = a.y * b.y,
            this.z = a.z * b.z,
            this
        },
        applyMatrix3: function(a) {
            var b = this.x,
            c = this.y,
            d = this.z,
            e = a.elements;
            return this.x = e[0] * b + e[3] * c + e[6] * d,
            this.y = e[1] * b + e[4] * c + e[7] * d,
            this.z = e[2] * b + e[5] * c + e[8] * d,
            this
        },
        applyMatrix4: function(a) {
            var b = this.x,
            c = this.y,
            d = this.z,
            e = a.elements;
            return this.x = e[0] * b + e[4] * c + e[8] * d + e[12],
            this.y = e[1] * b + e[5] * c + e[9] * d + e[13],
            this.z = e[2] * b + e[6] * c + e[10] * d + e[14],
            this
        },
        applyProjection: function(a) {
            var b = this.x,
            c = this.y,
            d = this.z,
            e = a.elements,
            f = 1 / (e[3] * b + e[7] * c + e[11] * d + e[15]);
            return this.x = (e[0] * b + e[4] * c + e[8] * d + e[12]) * f,
            this.y = (e[1] * b + e[5] * c + e[9] * d + e[13]) * f,
            this.z = (e[2] * b + e[6] * c + e[10] * d + e[14]) * f,
            this
        },
        applyQuaternion: function(a) {
            var b = this.x,
            c = this.y,
            d = this.z,
            e = a.x,
            f = a.y,
            g = a.z,
            h = a.w,
            i = h * b + f * d - g * c,
            j = h * c + g * b - e * d,
            k = h * d + e * c - f * b,
            l = -e * b - f * c - g * d;
            return this.x = i * h + l * -e + j * -g - k * -f,
            this.y = j * h + l * -f + k * -e - i * -g,
            this.z = k * h + l * -g + i * -f - j * -e,
            this
        },
        applyEuler: function(a, b) {
            var c = $b.__q1.setFromEuler(a, b);
            return this.applyQuaternion(c),
            this
        },
        applyAxisAngle: function(a, b) {
            var c = $b.__q1.setFromAxisAngle(a, b);
            return this.applyQuaternion(c),
            this
        },
        divide: function(a) {
            return this.x /= a.x,
            this.y /= a.y,
            this.z /= a.z,
            this
        },
        divideScalar: function(a) {
            return 0 !== a ? (this.x /= a, this.y /= a, this.z /= a) : (this.x = 0, this.y = 0, this.z = 0),
            this
        },
        min: function(a) {
            return this.x > a.x && (this.x = a.x),
            this.y > a.y && (this.y = a.y),
            this.z > a.z && (this.z = a.z),
            this
        },
        max: function(a) {
            return this.x < a.x && (this.x = a.x),
            this.y < a.y && (this.y = a.y),
            this.z < a.z && (this.z = a.z),
            this
        },
        clamp: function(a, b) {
            return this.x < a.x ? this.x = a.x: this.x > b.x && (this.x = b.x),
            this.y < a.y ? this.y = a.y: this.y > b.y && (this.y = b.y),
            this.z < a.z ? this.z = a.z: this.z > b.z && (this.z = b.z),
            this
        },
        negate: function() {
            return this.multiplyScalar( - 1)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(a) {
            var b = this.length();
            return 0 !== b && a !== b && this.multiplyScalar(a / b),
            this
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b,
            this.y += (a.y - this.y) * b,
            this.z += (a.z - this.z) * b,
            this
        },
        lerpVectors: function(a, b, c) {
            return this.x = a.x + (b.x - a.x) * c,
            this.y = a.y + (b.y - a.y) * c,
            this.z = a.z + (b.z - a.z) * c,
            this
        },
        cross: function(a) {
            var b = this.x,
            c = this.y,
            d = this.z;
            return this.x = c * a.z - d * a.y,
            this.y = d * a.x - b * a.z,
            this.z = b * a.y - c * a.x,
            this
        },
        crossVectors: function(a, b) {
            return this.x = a.y * b.z - a.z * b.y,
            this.y = a.z * b.x - a.x * b.z,
            this.z = a.x * b.y - a.y * b.x,
            this
        },
        angleTo: function(a) {
            return Math.acos(this.dot(a) / this.length() / a.length())
        },
        distanceTo: function(a) {
            return Math.sqrt(this.distanceToSquared(a))
        },
        distanceToSquared: function(a) {
            var b = this.x - a.x,
            c = this.y - a.y,
            d = this.z - a.z;
            return b * b + c * c + d * d
        },
        getPositionFromMatrix: function(a) {
            return this.x = a.elements[12],
            this.y = a.elements[13],
            this.z = a.elements[14],
            this
        },
        setEulerFromRotationMatrix: function(a, b) {
            function c(a) {
                return Math.min(Math.max(a, -1), 1)
            }
            var d = a.elements,
            f = d[0],
            g = d[4],
            h = d[8],
            i = d[1],
            j = d[5],
            k = d[9],
            l = d[2],
            m = d[6],
            n = d[10];
            return b === e || "XYZ" === b ? (this.y = Math.asin(c(h)), Math.abs(h) < .99999 ? (this.x = Math.atan2( - k, n), this.z = Math.atan2( - g, f)) : (this.x = Math.atan2(m, j), this.z = 0)) : "YXZ" === b ? (this.x = Math.asin( - c(k)), Math.abs(k) < .99999 ? (this.y = Math.atan2(h, n), this.z = Math.atan2(i, j)) : (this.y = Math.atan2( - l, f), this.z = 0)) : "ZXY" === b ? (this.x = Math.asin(c(m)), Math.abs(m) < .99999 ? (this.y = Math.atan2( - l, n), this.z = Math.atan2( - g, j)) : (this.y = 0, this.z = Math.atan2(i, f))) : "ZYX" === b ? (this.y = Math.asin( - c(l)), Math.abs(l) < .99999 ? (this.x = Math.atan2(m, n), this.z = Math.atan2(i, f)) : (this.x = 0, this.z = Math.atan2( - g, j))) : "YZX" === b ? (this.z = Math.asin(c(i)), Math.abs(i) < .99999 ? (this.x = Math.atan2( - k, j), this.y = Math.atan2( - l, f)) : (this.x = 0, this.y = Math.atan2(h, n))) : "XZY" === b && (this.z = Math.asin( - c(g)), Math.abs(g) < .99999 ? (this.x = Math.atan2(m, j), this.y = Math.atan2(h, f)) : (this.x = Math.atan2( - k, n), this.y = 0)),
            this
        },
        setEulerFromQuaternion: function(a, b) {
            function c(a) {
                return Math.min(Math.max(a, -1), 1)
            }
            var d = a.x * a.x,
            f = a.y * a.y,
            g = a.z * a.z,
            h = a.w * a.w;
            return b === e || "XYZ" === b ? (this.x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - d - f + g), this.y = Math.asin(c(2 * (a.x * a.z + a.y * a.w))), this.z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + d - f - g)) : "YXZ" === b ? (this.x = Math.asin(c(2 * (a.x * a.w - a.y * a.z))), this.y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - d - f + g), this.z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - d + f - g)) : "ZXY" === b ? (this.x = Math.asin(c(2 * (a.x * a.w + a.y * a.z))), this.y = Math.atan2(2 * (a.y * a.w - a.z * a.x), h - d - f + g), this.z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - d + f - g)) : "ZYX" === b ? (this.x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - d - f + g), this.y = Math.asin(c(2 * (a.y * a.w - a.x * a.z))), this.z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + d - f - g)) : "YZX" === b ? (this.x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - d + f - g), this.y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + d - f - g), this.z = Math.asin(c(2 * (a.x * a.y + a.z * a.w)))) : "XZY" === b && (this.x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - d + f - g), this.y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + d - f - g), this.z = Math.asin(c(2 * (a.z * a.w - a.x * a.y)))),
            this
        },
        getScaleFromMatrix: function(a) {
            var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),
            c = this.set(a.elements[4], a.elements[5], a.elements[6]).length(),
            d = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
            return this.x = b,
            this.y = c,
            this.z = d,
            this
        },
        toString: function() {
            return this.x + "_" + this.y + "_" + this.z
        },
        equals: function(a) {
            return null == a ? !1 : a.x === this.x && a.y === this.y && a.z === this.z
        },
        clone: function() {
            return new $b(this.x, this.y, this.z)
        },
        setFromMatrixPosition: function(a) {
            return this.x = a.elements[12],
            this.y = a.elements[13],
            this.z = a.elements[14],
            this
        },
        rotateFromAxisAndCenter: function(a, b, c) {
            var d = (new Yb.Mat4).makeRotationAxisAndCenter(a, b, c);
            return this.applyMatrix4(d),
            this
        },
        rotationTowards: function(a, b) {
            var c = (new Yb.Mat4).rotationTowards(a, b);
            return this.setEulerFromRotationMatrix(c),
            this
        },
        constructor: Yb.Vec3
    },
    $b.__q1 = new Yb.Quat,
    Yb.Vec4 = function(a, b, c, d) {
        this.x = a || 0,
        this.y = b || 0,
        this.z = c || 0,
        this.w = d !== e ? d: 1
    },
    Yb.Vec4.prototype = {
        constructor: Yb.Vec4,
        set: function(a, b, c, d) {
            return this.x = a,
            this.y = b,
            this.z = c,
            this.w = d,
            this
        },
        setX: function(a) {
            return this.x = a,
            this
        },
        setY: function(a) {
            return this.y = a,
            this
        },
        setZ: function(a) {
            return this.z = a,
            this
        },
        setW: function(a) {
            return this.w = a,
            this
        },
        setComponent: function(a, b) {
            switch (a) {
            case 0:
                this.x = b;
                break;
            case 1:
                this.y = b;
                break;
            case 2:
                this.z = b;
                break;
            case 3:
                this.w = b;
                break;
            default:
                throw new Error("index is out of range: " + a)
            }
        },
        getComponent: function(a) {
            switch (a) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + a)
            }
        },
        copy: function(a) {
            return this.x = a.x,
            this.y = a.y,
            this.z = a.z,
            this.w = a.w !== e ? a.w: 1,
            this
        },
        add: function(a, b) {
            return b !== e ? (console.warn("DEPRECATED: Vec4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this)
        },
        addScalar: function(a) {
            return this.x += a,
            this.y += a,
            this.z += a,
            this.w += a,
            this
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this.z = a.z + b.z,
            this.w = a.w + b.w,
            this
        },
        sub: function(a, b) {
            return b !== e ? (console.warn("DEPRECATED: Vec4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this)
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this.z = a.z - b.z,
            this.w = a.w - b.w,
            this
        },
        multiplyScalar: function(a) {
            return this.x *= a,
            this.y *= a,
            this.z *= a,
            this.w *= a,
            this
        },
        applyMatrix4: function(a) {
            var b = this.x,
            c = this.y,
            d = this.z,
            e = this.w,
            f = a.elements;
            return this.x = f[0] * b + f[4] * c + f[8] * d + f[12] * e,
            this.y = f[1] * b + f[5] * c + f[9] * d + f[13] * e,
            this.z = f[2] * b + f[6] * c + f[10] * d + f[14] * e,
            this.w = f[3] * b + f[7] * c + f[11] * d + f[15] * e,
            this
        },
        divideScalar: function(a) {
            return 0 !== a ? (this.x /= a, this.y /= a, this.z /= a, this.w /= a) : (this.x = 0, this.y = 0, this.z = 0, this.w = 1),
            this
        },
        min: function(a) {
            return this.x > a.x && (this.x = a.x),
            this.y > a.y && (this.y = a.y),
            this.z > a.z && (this.z = a.z),
            this.w > a.w && (this.w = a.w),
            this
        },
        max: function(a) {
            return this.x < a.x && (this.x = a.x),
            this.y < a.y && (this.y = a.y),
            this.z < a.z && (this.z = a.z),
            this.w < a.w && (this.w = a.w),
            this
        },
        clamp: function(a, b) {
            return this.x < a.x ? this.x = a.x: this.x > b.x && (this.x = b.x),
            this.y < a.y ? this.y = a.y: this.y > b.y && (this.y = b.y),
            this.z < a.z ? this.z = a.z: this.z > b.z && (this.z = b.z),
            this.w < a.w ? this.w = a.w: this.w > b.w && (this.w = b.w),
            this
        },
        negate: function() {
            return this.multiplyScalar( - 1)
        },
        dot: function(a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length())
        },
        setLength: function(a) {
            var b = this.length();
            return 0 !== b && a !== b && this.multiplyScalar(a / b),
            this
        },
        lerp: function(a, b) {
            return this.x += (a.x - this.x) * b,
            this.y += (a.y - this.y) * b,
            this.z += (a.z - this.z) * b,
            this.w += (a.w - this.w) * b,
            this
        },
        equals: function(a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        },
        clone: function() {
            return new Yb.Vec4(this.x, this.y, this.z, this.w)
        },
        setAxisAngleFromQuaternion: function(a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            return 1e-4 > b ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b),
            this
        },
        setAxisAngleFromRotationMatrix: function(a) {
            var b, c, d, e, f = .01,
            g = .1,
            h = a.elements,
            i = h[0],
            j = h[4],
            k = h[8],
            l = h[1],
            m = h[5],
            n = h[9],
            o = h[2],
            p = h[6],
            q = h[10];
            if (Math.abs(j - l) < f && Math.abs(k - o) < f && Math.abs(n - p) < f) {
                if (Math.abs(j + l) < g && Math.abs(k + o) < g && Math.abs(n + p) < g && Math.abs(i + m + q - 3) < g) return this.set(1, 0, 0, 0),
                this;
                b = Math.PI;
                var r = (i + 1) / 2,
                s = (m + 1) / 2,
                t = (q + 1) / 2,
                u = (j + l) / 4,
                v = (k + o) / 4,
                w = (n + p) / 4;
                return r > s && r > t ? f > r ? (c = 0, d = .707106781, e = .707106781) : (c = Math.sqrt(r), d = u / c, e = v / c) : s > t ? f > s ? (c = .707106781, d = 0, e = .707106781) : (d = Math.sqrt(s), c = u / d, e = w / d) : f > t ? (c = .707106781, d = .707106781, e = 0) : (e = Math.sqrt(t), c = v / e, d = w / e),
                this.set(c, d, e, b),
                this
            }
            var x = Math.sqrt((p - n) * (p - n) + (k - o) * (k - o) + (l - j) * (l - j));
            return Math.abs(x) < .001 && (x = 1),
            this.x = (p - n) / x,
            this.y = (k - o) / x,
            this.z = (l - j) / x,
            this.w = Math.acos((i + m + q - 1) / 2),
            this
        }
    };
    var _b = function(a, b, c, d, f, g, h, i, j) {
        this.elements = new Float32Array(9),
        this.set(a !== e ? a: 1, b || 0, c || 0, d || 0, f !== e ? f: 1, g || 0, h || 0, i || 0, j !== e ? j: 1)
    };
    _b.prototype = {
        constructor: _b,
        set: function(a, b, c, d, e, f, g, h, i) {
            var j = this.elements;
            return j[0] = a,
            j[3] = b,
            j[6] = c,
            j[1] = d,
            j[4] = e,
            j[7] = f,
            j[2] = g,
            j[5] = h,
            j[8] = i,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        copy: function(a) {
            var b = a.elements;
            return this.set(b[0], b[3], b[6], b[1], b[4], b[7], b[2], b[5], b[8]),
            this
        },
        multiplyVector3: function(a) {
            return console.warn("DEPRECATED: Mat3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            a.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            var a = new $b;
            return function(b) {
                for (var c = 0,
                d = b.length; d > c; c += 3) a.x = b[c],
                a.y = b[c + 1],
                a.z = b[c + 2],
                a.applyMatrix3(this),
                b[c] = a.x,
                b[c + 1] = a.y,
                b[c + 2] = a.z;
                return b
            }
        } (),
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a,
            b[3] *= a,
            b[6] *= a,
            b[1] *= a,
            b[4] *= a,
            b[7] *= a,
            b[2] *= a,
            b[5] *= a,
            b[8] *= a,
            this
        },
        determinant: function() {
            var a = this.elements,
            b = a[0],
            c = a[1],
            d = a[2],
            e = a[3],
            f = a[4],
            g = a[5],
            h = a[6],
            i = a[7],
            j = a[8];
            return b * f * j - b * g * i - c * e * j + c * g * h + d * e * i - d * f * h
        },
        getInverse: function(a, b) {
            var c = a.elements,
            d = this.elements;
            d[0] = c[10] * c[5] - c[6] * c[9],
            d[1] = -c[10] * c[1] + c[2] * c[9],
            d[2] = c[6] * c[1] - c[2] * c[5],
            d[3] = -c[10] * c[4] + c[6] * c[8],
            d[4] = c[10] * c[0] - c[2] * c[8],
            d[5] = -c[6] * c[0] + c[2] * c[4],
            d[6] = c[9] * c[4] - c[5] * c[8],
            d[7] = -c[9] * c[0] + c[1] * c[8],
            d[8] = c[5] * c[0] - c[1] * c[4];
            var e = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
            if (0 === e) {
                var f = "Mat3.getInverse(): can't invert matrix, determinant is 0";
                if (b) throw new Error(f);
                return console.warn(f),
                this.identity(),
                this
            }
            return this.multiplyScalar(1 / e),
            this
        },
        transpose: function() {
            var a, b = this.elements;
            return a = b[1],
            b[1] = b[3],
            b[3] = a,
            a = b[2],
            b[2] = b[6],
            b[6] = a,
            a = b[5],
            b[5] = b[7],
            b[7] = a,
            this
        },
        getNormalMatrix: function(a) {
            return this.getInverse(a).transpose(),
            this
        },
        transposeIntoArray: function(a) {
            var b = this.elements;
            return a[0] = b[0],
            a[1] = b[3],
            a[2] = b[6],
            a[3] = b[1],
            a[4] = b[4],
            a[5] = b[7],
            a[6] = b[2],
            a[7] = b[5],
            a[8] = b[8],
            this
        },
        clone: function() {
            var a = this.elements;
            return new _b(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8])
        }
    },
    Yb.Mat3 = _b;
    var ac = function(a, b, c, d, f, g, h, i, j, k, l, m, n, o, p, q) {
        this.elements = new Float32Array(16),
        this.set(a !== e ? a: 1, b || 0, c || 0, d || 0, f || 0, g !== e ? g: 1, h || 0, i || 0, j || 0, k || 0, l !== e ? l: 1, m || 0, n || 0, o || 0, p || 0, q !== e ? q: 1)
    };
    ac.prototype = {
        constructor: ac,
        set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            var q = this.elements;
            return q[0] = a,
            q[4] = b,
            q[8] = c,
            q[12] = d,
            q[1] = e,
            q[5] = f,
            q[9] = g,
            q[13] = h,
            q[2] = i,
            q[6] = j,
            q[10] = k,
            q[14] = l,
            q[3] = m,
            q[7] = n,
            q[11] = o,
            q[15] = p,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        copy: function(a) {
            var b = a.elements;
            return this.set(b[0], b[4], b[8], b[12], b[1], b[5], b[9], b[13], b[2], b[6], b[10], b[14], b[3], b[7], b[11], b[15]),
            this
        },
        setRotationFromEuler: function(a, b) {
            var c = this.elements,
            d = a.x,
            f = a.y,
            g = a.z,
            h = Math.cos(d),
            i = Math.sin(d),
            j = Math.cos(f),
            k = Math.sin(f),
            l = Math.cos(g),
            m = Math.sin(g);
            if (b === e || "XYZ" === b) {
                var n = h * l,
                o = h * m,
                p = i * l,
                q = i * m;
                c[0] = j * l,
                c[4] = -j * m,
                c[8] = k,
                c[1] = o + p * k,
                c[5] = n - q * k,
                c[9] = -i * j,
                c[2] = q - n * k,
                c[6] = p + o * k,
                c[10] = h * j
            } else if ("YXZ" === b) {
                var r = j * l,
                s = j * m,
                t = k * l,
                u = k * m;
                c[0] = r + u * i,
                c[4] = t * i - s,
                c[8] = h * k,
                c[1] = h * m,
                c[5] = h * l,
                c[9] = -i,
                c[2] = s * i - t,
                c[6] = u + r * i,
                c[10] = h * j
            } else if ("ZXY" === b) {
                var r = j * l,
                s = j * m,
                t = k * l,
                u = k * m;
                c[0] = r - u * i,
                c[4] = -h * m,
                c[8] = t + s * i,
                c[1] = s + t * i,
                c[5] = h * l,
                c[9] = u - r * i,
                c[2] = -h * k,
                c[6] = i,
                c[10] = h * j
            } else if ("ZYX" === b) {
                var n = h * l,
                o = h * m,
                p = i * l,
                q = i * m;
                c[0] = j * l,
                c[4] = p * k - o,
                c[8] = n * k + q,
                c[1] = j * m,
                c[5] = q * k + n,
                c[9] = o * k - p,
                c[2] = -k,
                c[6] = i * j,
                c[10] = h * j
            } else if ("YZX" === b) {
                var v = h * j,
                w = h * k,
                x = i * j,
                y = i * k;
                c[0] = j * l,
                c[4] = y - v * m,
                c[8] = x * m + w,
                c[1] = m,
                c[5] = h * l,
                c[9] = -i * l,
                c[2] = -k * l,
                c[6] = w * m + x,
                c[10] = v - y * m
            } else if ("XZY" === b) {
                var v = h * j,
                w = h * k,
                x = i * j,
                y = i * k;
                c[0] = j * l,
                c[4] = -m,
                c[8] = k * l,
                c[1] = v * m + y,
                c[5] = h * l,
                c[9] = w * m - x,
                c[2] = x * m - w,
                c[6] = i * l,
                c[10] = y * m + v
            }
            return this
        },
        setRotationFromQuaternion: function(a) {
            var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = a.w,
            g = c + c,
            h = d + d,
            i = e + e,
            j = c * g,
            k = c * h,
            l = c * i,
            m = d * h,
            n = d * i,
            o = e * i,
            p = f * g,
            q = f * h,
            r = f * i;
            return b[0] = 1 - (m + o),
            b[4] = k - r,
            b[8] = l + q,
            b[1] = k + r,
            b[5] = 1 - (j + o),
            b[9] = n - p,
            b[2] = l - q,
            b[6] = n + p,
            b[10] = 1 - (j + m),
            this
        },
        lookAt: function(a, b, c) {
            var d = this.elements,
            e = ac.__v1,
            f = ac.__v2,
            g = ac.__v3;
            return g.subVectors(a, b).normalize(),
            0 === g.length() && (g.z = 1),
            e.crossVectors(c, g).normalize(),
            0 === e.length() && (g.x += 1e-4, e.crossVectors(c, g).normalize()),
            f.crossVectors(g, e),
            d[0] = e.x,
            d[1] = e.y,
            d[2] = e.z,
            d[4] = f.x,
            d[5] = f.y,
            d[6] = f.z,
            d[8] = g.x,
            d[9] = g.y,
            d[10] = g.z,
            this
        },
        multiply: function(a, b) {
            return b !== e ? this.multiplyMatrices(a, b) : this.multiplyMatrices(this, a)
        },
        multiplyMatrices: function(a, b) {
            var c = a.elements,
            d = b.elements,
            e = this.elements,
            f = c[0],
            g = c[4],
            h = c[8],
            i = c[12],
            j = c[1],
            k = c[5],
            l = c[9],
            m = c[13],
            n = c[2],
            o = c[6],
            p = c[10],
            q = c[14],
            r = c[3],
            s = c[7],
            t = c[11],
            u = c[15],
            v = d[0],
            w = d[4],
            x = d[8],
            y = d[12],
            z = d[1],
            A = d[5],
            B = d[9],
            C = d[13],
            D = d[2],
            E = d[6],
            F = d[10],
            G = d[14],
            H = d[3],
            I = d[7],
            J = d[11],
            K = d[15];
            return e[0] = f * v + g * z + h * D + i * H,
            e[4] = f * w + g * A + h * E + i * I,
            e[8] = f * x + g * B + h * F + i * J,
            e[12] = f * y + g * C + h * G + i * K,
            e[1] = j * v + k * z + l * D + m * H,
            e[5] = j * w + k * A + l * E + m * I,
            e[9] = j * x + k * B + l * F + m * J,
            e[13] = j * y + k * C + l * G + m * K,
            e[2] = n * v + o * z + p * D + q * H,
            e[6] = n * w + o * A + p * E + q * I,
            e[10] = n * x + o * B + p * F + q * J,
            e[14] = n * y + o * C + p * G + q * K,
            e[3] = r * v + s * z + t * D + u * H,
            e[7] = r * w + s * A + t * E + u * I,
            e[11] = r * x + s * B + t * F + u * J,
            e[15] = r * y + s * C + t * G + u * K,
            this
        },
        multiplyToArray: function(a, b, c) {
            var d = this.elements;
            return this.multiplyMatrices(a, b),
            c[0] = d[0],
            c[1] = d[1],
            c[2] = d[2],
            c[3] = d[3],
            c[4] = d[4],
            c[5] = d[5],
            c[6] = d[6],
            c[7] = d[7],
            c[8] = d[8],
            c[9] = d[9],
            c[10] = d[10],
            c[11] = d[11],
            c[12] = d[12],
            c[13] = d[13],
            c[14] = d[14],
            c[15] = d[15],
            this
        },
        multiplyScalar: function(a) {
            var b = this.elements;
            return b[0] *= a,
            b[4] *= a,
            b[8] *= a,
            b[12] *= a,
            b[1] *= a,
            b[5] *= a,
            b[9] *= a,
            b[13] *= a,
            b[2] *= a,
            b[6] *= a,
            b[10] *= a,
            b[14] *= a,
            b[3] *= a,
            b[7] *= a,
            b[11] *= a,
            b[15] *= a,
            this
        },
        multiplyVector3: function(a) {
            return a.applyProjection(this)
        },
        multiplyVector4: function(a) {
            return a.applyMatrix4(this)
        },
        multiplyVector3Array: function(a) {
            for (var b = ac.__v1,
            c = 0,
            d = a.length; d > c; c += 3) b.x = a[c],
            b.y = a[c + 1],
            b.z = a[c + 2],
            b.applyProjection(this),
            a[c] = b.x,
            a[c + 1] = b.y,
            a[c + 2] = b.z;
            return a
        },
        rotateAxis: function(a) {
            var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z;
            return a.x = c * b[0] + d * b[4] + e * b[8],
            a.y = c * b[1] + d * b[5] + e * b[9],
            a.z = c * b[2] + d * b[6] + e * b[10],
            a.normalize(),
            a
        },
        crossVector: function(a) {
            var b = this.elements,
            c = new Yb.Vector4;
            return c.x = b[0] * a.x + b[4] * a.y + b[8] * a.z + b[12] * a.w,
            c.y = b[1] * a.x + b[5] * a.y + b[9] * a.z + b[13] * a.w,
            c.z = b[2] * a.x + b[6] * a.y + b[10] * a.z + b[14] * a.w,
            c.w = a.w ? b[3] * a.x + b[7] * a.y + b[11] * a.z + b[15] * a.w: 1,
            c
        },
        determinant: function() {
            var a = this.elements,
            b = a[0],
            c = a[4],
            d = a[8],
            e = a[12],
            f = a[1],
            g = a[5],
            h = a[9],
            i = a[13],
            j = a[2],
            k = a[6],
            l = a[10],
            m = a[14],
            n = a[3],
            o = a[7],
            p = a[11],
            q = a[15];
            return n * ( + e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + o * ( + b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + p * ( + b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + q * ( - d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
        },
        transpose: function() {
            var a, b = this.elements;
            return a = b[1],
            b[1] = b[4],
            b[4] = a,
            a = b[2],
            b[2] = b[8],
            b[8] = a,
            a = b[6],
            b[6] = b[9],
            b[9] = a,
            a = b[3],
            b[3] = b[12],
            b[12] = a,
            a = b[7],
            b[7] = b[13],
            b[13] = a,
            a = b[11],
            b[11] = b[14],
            b[14] = a,
            this
        },
        flattenToArray: function(a) {
            var b = this.elements;
            return a[0] = b[0],
            a[1] = b[1],
            a[2] = b[2],
            a[3] = b[3],
            a[4] = b[4],
            a[5] = b[5],
            a[6] = b[6],
            a[7] = b[7],
            a[8] = b[8],
            a[9] = b[9],
            a[10] = b[10],
            a[11] = b[11],
            a[12] = b[12],
            a[13] = b[13],
            a[14] = b[14],
            a[15] = b[15],
            a
        },
        flattenToArrayOffset: function(a, b) {
            var c = this.elements;
            return a[b] = c[0],
            a[b + 1] = c[1],
            a[b + 2] = c[2],
            a[b + 3] = c[3],
            a[b + 4] = c[4],
            a[b + 5] = c[5],
            a[b + 6] = c[6],
            a[b + 7] = c[7],
            a[b + 8] = c[8],
            a[b + 9] = c[9],
            a[b + 10] = c[10],
            a[b + 11] = c[11],
            a[b + 12] = c[12],
            a[b + 13] = c[13],
            a[b + 14] = c[14],
            a[b + 15] = c[15],
            a
        },
        getPosition: function() {
            var a = this.elements;
            return (new $b).set(a[12], a[13], a[14])
        },
        setPosition: function(a) {
            var b = this.elements;
            return b[12] = a.x,
            b[13] = a.y,
            b[14] = a.z,
            this
        },
        getColumnX: function() {
            var a = this.elements;
            return ac.__v1.set(a[0], a[1], a[2])
        },
        getColumnY: function() {
            var a = this.elements;
            return ac.__v1.set(a[4], a[5], a[6])
        },
        getColumnZ: function() {
            var a = this.elements;
            return ac.__v1.set(a[8], a[9], a[10])
        },
        getInverse: function(a, b) {
            var c = this.elements,
            d = a.elements,
            e = d[0],
            f = d[4],
            g = d[8],
            h = d[12],
            i = d[1],
            j = d[5],
            k = d[9],
            l = d[13],
            m = d[2],
            n = d[6],
            o = d[10],
            p = d[14],
            q = d[3],
            r = d[7],
            s = d[11],
            t = d[15];
            c[0] = k * p * r - l * o * r + l * n * s - j * p * s - k * n * t + j * o * t,
            c[4] = h * o * r - g * p * r - h * n * s + f * p * s + g * n * t - f * o * t,
            c[8] = g * l * r - h * k * r + h * j * s - f * l * s - g * j * t + f * k * t,
            c[12] = h * k * n - g * l * n - h * j * o + f * l * o + g * j * p - f * k * p,
            c[1] = l * o * q - k * p * q - l * m * s + i * p * s + k * m * t - i * o * t,
            c[5] = g * p * q - h * o * q + h * m * s - e * p * s - g * m * t + e * o * t,
            c[9] = h * k * q - g * l * q - h * i * s + e * l * s + g * i * t - e * k * t,
            c[13] = g * l * m - h * k * m + h * i * o - e * l * o - g * i * p + e * k * p,
            c[2] = j * p * q - l * n * q + l * m * r - i * p * r - j * m * t + i * n * t,
            c[6] = h * n * q - f * p * q - h * m * r + e * p * r + f * m * t - e * n * t,
            c[10] = f * l * q - h * j * q + h * i * r - e * l * r - f * i * t + e * j * t,
            c[14] = h * j * m - f * l * m - h * i * n + e * l * n + f * i * p - e * j * p,
            c[3] = k * n * q - j * o * q - k * m * r + i * o * r + j * m * s - i * n * s,
            c[7] = f * o * q - g * n * q + g * m * r - e * o * r - f * m * s + e * n * s,
            c[11] = g * j * q - f * k * q - g * i * r + e * k * r + f * i * s - e * j * s,
            c[15] = f * k * m - g * j * m + g * i * n - e * k * n - f * i * o + e * j * o;
            var u = d[0] * c[0] + d[1] * c[4] + d[2] * c[8] + d[3] * c[12];
            if (0 == u) {
                var v = "Mat4.getInverse(): can't invert matrix, determinant is 0";
                if (b) throw new Error(v);
                return console.warn(v),
                this.identity(),
                this
            }
            return this.multiplyScalar(1 / u),
            this
        },
        compose: function(a, b, c) {
            var d = this.elements,
            e = ac.__m1,
            f = ac.__m2;
            return e.identity(),
            e.setRotationFromQuaternion(b),
            f.makeScale(c.x, c.y, c.z),
            this.multiplyMatrices(e, f),
            d[12] = a.x,
            d[13] = a.y,
            d[14] = a.z,
            this
        },
        decompose: function(a, b, c) {
            var d = this.elements,
            e = ac.__v1,
            f = ac.__v2,
            g = ac.__v3;
            e.set(d[0], d[1], d[2]),
            f.set(d[4], d[5], d[6]),
            g.set(d[8], d[9], d[10]),
            a = a instanceof $b ? a: new $b,
            b = b instanceof Yb.Quat ? b: new Yb.Quat,
            c = c instanceof $b ? c: new $b,
            c.x = e.length(),
            c.y = f.length(),
            c.z = g.length(),
            a.x = d[12],
            a.y = d[13],
            a.z = d[14];
            var h = ac.__m1;
            return h.copy(this),
            h.elements[0] /= c.x,
            h.elements[1] /= c.x,
            h.elements[2] /= c.x,
            h.elements[4] /= c.y,
            h.elements[5] /= c.y,
            h.elements[6] /= c.y,
            h.elements[8] /= c.z,
            h.elements[9] /= c.z,
            h.elements[10] /= c.z,
            b.setFromRotationMatrix(h),
            [a, b, c]
        },
        extractPosition: function(a) {
            var b = this.elements,
            c = a.elements;
            return b[12] = c[12],
            b[13] = c[13],
            b[14] = c[14],
            this
        },
        extractRotation: function(a) {
            var b = this.elements,
            c = a.elements,
            d = ac.__v1,
            e = 1 / d.set(c[0], c[1], c[2]).length(),
            f = 1 / d.set(c[4], c[5], c[6]).length(),
            g = 1 / d.set(c[8], c[9], c[10]).length();
            return b[0] = c[0] * e,
            b[1] = c[1] * e,
            b[2] = c[2] * e,
            b[4] = c[4] * f,
            b[5] = c[5] * f,
            b[6] = c[6] * f,
            b[8] = c[8] * g,
            b[9] = c[9] * g,
            b[10] = c[10] * g,
            this
        },
        translate: function(a) {
            var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z;
            return b[12] = b[0] * c + b[4] * d + b[8] * e + b[12],
            b[13] = b[1] * c + b[5] * d + b[9] * e + b[13],
            b[14] = b[2] * c + b[6] * d + b[10] * e + b[14],
            b[15] = b[3] * c + b[7] * d + b[11] * e + b[15],
            this
        },
        rotateX: function(a) {
            var b = this.elements,
            c = b[4],
            d = b[5],
            e = b[6],
            f = b[7],
            g = b[8],
            h = b[9],
            i = b[10],
            j = b[11],
            k = Math.cos(a),
            l = Math.sin(a);
            return b[4] = k * c + l * g,
            b[5] = k * d + l * h,
            b[6] = k * e + l * i,
            b[7] = k * f + l * j,
            b[8] = k * g - l * c,
            b[9] = k * h - l * d,
            b[10] = k * i - l * e,
            b[11] = k * j - l * f,
            this
        },
        rotateY: function(a) {
            var b = this.elements,
            c = b[0],
            d = b[1],
            e = b[2],
            f = b[3],
            g = b[8],
            h = b[9],
            i = b[10],
            j = b[11],
            k = Math.cos(a),
            l = Math.sin(a);
            return b[0] = k * c - l * g,
            b[1] = k * d - l * h,
            b[2] = k * e - l * i,
            b[3] = k * f - l * j,
            b[8] = k * g + l * c,
            b[9] = k * h + l * d,
            b[10] = k * i + l * e,
            b[11] = k * j + l * f,
            this
        },
        rotateZ: function(a) {
            var b = this.elements,
            c = b[0],
            d = b[1],
            e = b[2],
            f = b[3],
            g = b[4],
            h = b[5],
            i = b[6],
            j = b[7],
            k = Math.cos(a),
            l = Math.sin(a);
            return b[0] = k * c + l * g,
            b[1] = k * d + l * h,
            b[2] = k * e + l * i,
            b[3] = k * f + l * j,
            b[4] = k * g - l * c,
            b[5] = k * h - l * d,
            b[6] = k * i - l * e,
            b[7] = k * j - l * f,
            this
        },
        rotateByAxis: function(a, b) {
            var c = this.elements;
            if (1 === a.x && 0 === a.y && 0 === a.z) return this.rotateX(b);
            if (0 === a.x && 1 === a.y && 0 === a.z) return this.rotateY(b);
            if (0 === a.x && 0 === a.y && 1 === a.z) return this.rotateZ(b);
            var d = a.x,
            e = a.y,
            f = a.z,
            g = Math.sqrt(d * d + e * e + f * f);
            d /= g,
            e /= g,
            f /= g;
            var h = d * d,
            i = e * e,
            j = f * f,
            k = Math.cos(b),
            l = Math.sin(b),
            m = 1 - k,
            n = d * e * m,
            o = d * f * m,
            p = e * f * m,
            q = d * l,
            r = e * l,
            s = f * l,
            t = h + (1 - h) * k,
            u = n + s,
            v = o - r,
            w = n - s,
            x = i + (1 - i) * k,
            y = p + q,
            z = o + r,
            A = p - q,
            B = j + (1 - j) * k,
            C = c[0],
            D = c[1],
            E = c[2],
            F = c[3],
            G = c[4],
            H = c[5],
            I = c[6],
            J = c[7],
            K = c[8],
            L = c[9],
            M = c[10],
            N = c[11];
            return c[12],
            c[13],
            c[14],
            c[15],
            c[0] = t * C + u * G + v * K,
            c[1] = t * D + u * H + v * L,
            c[2] = t * E + u * I + v * M,
            c[3] = t * F + u * J + v * N,
            c[4] = w * C + x * G + y * K,
            c[5] = w * D + x * H + y * L,
            c[6] = w * E + x * I + y * M,
            c[7] = w * F + x * J + y * N,
            c[8] = z * C + A * G + B * K,
            c[9] = z * D + A * H + B * L,
            c[10] = z * E + A * I + B * M,
            c[11] = z * F + A * J + B * N,
            this
        },
        scale: function(a) {
            var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z;
            return b[0] *= c,
            b[4] *= d,
            b[8] *= e,
            b[1] *= c,
            b[5] *= d,
            b[9] *= e,
            b[2] *= c,
            b[6] *= d,
            b[10] *= e,
            b[3] *= c,
            b[7] *= d,
            b[11] *= e,
            this
        },
        getMaxScaleOnAxis: function() {
            var a = this.elements,
            b = a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
            c = a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
            d = a[8] * a[8] + a[9] * a[9] + a[10] * a[10];
            return Math.sqrt(Math.max(b, Math.max(c, d)))
        },
        makeTranslation: function(a, b, c) {
            return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(a) {
            var b = Math.cos(a),
            c = Math.sin(a);
            return this.set(1, 0, 0, 0, 0, b, -c, 0, 0, c, b, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(a) {
            var b = Math.cos(a),
            c = Math.sin(a);
            return this.set(b, 0, c, 0, 0, 1, 0, 0, -c, 0, b, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(a) {
            var b = Math.cos(a),
            c = Math.sin(a);
            return this.set(b, -c, 0, 0, c, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(a, b) {
            var c = Math.cos(b),
            d = Math.sin(b),
            e = 1 - c,
            f = a.x,
            g = a.y,
            h = a.z,
            i = e * f,
            j = e * g;
            return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(a, b, c) {
            return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1),
            this
        },
        makeFrustum: function(a, b, c, d, e, f) {
            var g = this.elements,
            h = 2 * e / (b - a),
            i = 2 * e / (d - c),
            j = (b + a) / (b - a),
            k = (d + c) / (d - c),
            l = -(f + e) / (f - e),
            m = -2 * f * e / (f - e);
            return g[0] = h,
            g[4] = 0,
            g[8] = j,
            g[12] = 0,
            g[1] = 0,
            g[5] = i,
            g[9] = k,
            g[13] = 0,
            g[2] = 0,
            g[6] = 0,
            g[10] = l,
            g[14] = m,
            g[3] = 0,
            g[7] = 0,
            g[11] = -1,
            g[15] = 0,
            this
        },
        makePerspective: function(a, b, c, d) {
            var e = c * Math.tan(Yb.Math.degToRad(.5 * a)),
            f = -e,
            g = f * b,
            h = e * b;
            return this.makeFrustum(g, h, f, e, c, d)
        },
        makeOrthographic: function(a, b, c, d, e, f) {
            var g = this.elements,
            h = b - a,
            i = c - d,
            j = f - e,
            k = (b + a) / h,
            l = (c + d) / i,
            m = (f + e) / j;
            return g[0] = 2 / h,
            g[4] = 0,
            g[8] = 0,
            g[12] = -k,
            g[1] = 0,
            g[5] = 2 / i,
            g[9] = 0,
            g[13] = -l,
            g[2] = 0,
            g[6] = 0,
            g[10] = -2 / j,
            g[14] = -m,
            g[3] = 0,
            g[7] = 0,
            g[11] = 0,
            g[15] = 1,
            this
        },
        clone: function() {
            var a = this.elements;
            return new ac(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15])
        },
        makeRotationFromQuaternion: function(a) {
            var b = this.elements,
            c = a.x,
            d = a.y,
            e = a.z,
            f = a.w,
            g = c + c,
            h = d + d,
            i = e + e,
            j = c * g,
            k = c * h,
            l = c * i,
            m = d * h,
            n = d * i,
            o = e * i,
            p = f * g,
            q = f * h,
            r = f * i;
            return b[0] = 1 - (m + o),
            b[4] = k - r,
            b[8] = l + q,
            b[1] = k + r,
            b[5] = 1 - (j + o),
            b[9] = n - p,
            b[2] = l - q,
            b[6] = n + p,
            b[10] = 1 - (j + m),
            b[3] = 0,
            b[7] = 0,
            b[11] = 0,
            b[12] = 0,
            b[13] = 0,
            b[14] = 0,
            b[15] = 1,
            this
        },
        getEulerAngles: function() {
            var a = (new ac).extractRotation(this).elements,
            b = a[0],
            c = a[1],
            d = a[2],
            e = a[5],
            f = a[6],
            g = a[10],
            h = Math.atan2(f, g),
            i = Math.atan2( - d, Math.sqrt(b * b + c * c)),
            j = Math.sin(h),
            k = Math.cos(h),
            l = Math.atan2(j * a[8] - k * a[4], k * e - j * a[9]);
            return new $b(h, i, l)
        },
        makeRotationAxisAndCenter: function(a, b, c) {
            var d = Math.cos(b),
            e = Math.sin(b),
            f = 1 - d,
            g = a.x,
            h = a.y,
            i = a.z,
            j = f * g,
            k = f * h,
            l = c.x,
            m = c.y,
            n = c.z,
            o = this,
            p = new Float32Array(16);
            return p[0] = j * g + d,
            p[4] = j * h - e * i,
            p[8] = j * i + e * h,
            p[12] = l - l * (j * g + d) - m * (j * h - e * i) - n * (j * i + e * h),
            p[1] = j * h + e * i,
            p[5] = k * h + d,
            p[9] = k * i - e * g,
            p[13] = m - l * (j * h + e * i) - m * (k * h + d) - n * (k * i - e * g),
            p[2] = j * i - e * h,
            p[6] = k * i + e * g,
            p[10] = f * i * i + d,
            p[14] = n - l * (j * i - e * h) - m * (k * i + e * g) - n * (f * i * i + d),
            p[3] = 0,
            p[7] = 0,
            p[11] = 0,
            p[15] = 1,
            o.elements = p,
            o
        },
        rotationTowards: function(a, b) {
            var c = Math.acos(b.dot(a) / b.length() / a.length()),
            d = (new Yb.Vec3).crossVectors(b, a).normalize();
            return this.makeRotationAxis(d, -c),
            this
        },
        equals: function(a) {
            if (a instanceof ac) {
                for (var b = 0; b < this.elements.length; b++) if (Math.abs(this.elements[b] - a.elements[b]) > 1e-4) return ! 1;
                return ! 0
            }
        }
    },
    ac.__v1 = new $b,
    ac.__v2 = new $b,
    ac.__v3 = new $b,
    ac.__m1 = new ac,
    ac.__m2 = new ac,
    Yb.Mat4 = ac,
    Yb.Euler = function(a, b, c, d) {
        this._x = a || 0,
        this._y = b || 0,
        this._z = c || 0,
        this._order = d || Yb.Euler.DefaultOrder
    },
    Yb.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
    Yb.Euler.DefaultOrder = "XYZ",
    Yb.Euler.prototype = {
        constructor: Yb.Euler,
        _x: 0,
        _y: 0,
        _z: 0,
        _order: Yb.Euler.DefaultOrder,
        _quaternion: e,
        _updateQuaternion: function() {
            this._quaternion !== e && this._quaternion.setFromEuler(this, !1)
        },
        get x() {
            return this._x
        },
        set x(a) {
            this._x = a,
            this._updateQuaternion()
        },
        get y() {
            return this._y
        },
        set y(a) {
            this._y = a,
            this._updateQuaternion()
        },
        get z() {
            return this._z
        },
        set z(a) {
            this._z = a,
            this._updateQuaternion()
        },
        get order() {
            return this._order
        },
        set order(a) {
            this._order = a,
            this._updateQuaternion()
        },
        set: function(a, b, c, d) {
            return this._x = a,
            this._y = b,
            this._z = c,
            this._order = d || this._order,
            this._updateQuaternion(),
            this
        },
        copy: function(a) {
            return this._x = a._x,
            this._y = a._y,
            this._z = a._z,
            this._order = a._order,
            this._updateQuaternion(),
            this
        },
        setFromRotationMatrix: function(a, b) {
            function c(a) {
                return Math.min(Math.max(a, -1), 1)
            }
            var d = a.elements,
            e = d[0],
            f = d[4],
            g = d[8],
            h = d[1],
            i = d[5],
            j = d[9],
            k = d[2],
            l = d[6],
            m = d[10];
            return b = b || this._order,
            "XYZ" === b ? (this._y = Math.asin(c(g)), Math.abs(g) < .99999 ? (this._x = Math.atan2( - j, m), this._z = Math.atan2( - f, e)) : (this._x = Math.atan2(l, i), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin( - c(j)), Math.abs(j) < .99999 ? (this._y = Math.atan2(g, m), this._z = Math.atan2(h, i)) : (this._y = Math.atan2( - k, e), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(c(l)), Math.abs(l) < .99999 ? (this._y = Math.atan2( - k, m), this._z = Math.atan2( - f, i)) : (this._y = 0, this._z = Math.atan2(h, e))) : "ZYX" === b ? (this._y = Math.asin( - c(k)), Math.abs(k) < .99999 ? (this._x = Math.atan2(l, m), this._z = Math.atan2(h, e)) : (this._x = 0, this._z = Math.atan2( - f, i))) : "YZX" === b ? (this._z = Math.asin(c(h)), Math.abs(h) < .99999 ? (this._x = Math.atan2( - j, i), this._y = Math.atan2( - k, e)) : (this._x = 0, this._y = Math.atan2(g, m))) : "XZY" === b ? (this._z = Math.asin( - c(f)), Math.abs(f) < .99999 ? (this._x = Math.atan2(l, i), this._y = Math.atan2(g, e)) : (this._x = Math.atan2( - j, m), this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + b),
            this._order = b,
            this._updateQuaternion(),
            this
        },
        setFromQuaternion: function(a, b, c) {
            function d(a) {
                return Math.min(Math.max(a, -1), 1)
            }
            var e = a.x * a.x,
            f = a.y * a.y,
            g = a.z * a.z,
            h = a.w * a.w;
            return b = b || this._order,
            "XYZ" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - e - f + g), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w))), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + e - f - g)) : "YXZ" === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z))), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - e - f + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - e + f - g)) : "ZXY" === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z))), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), h - e - f + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - e + f - g)) : "ZYX" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - e - f + g), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z))), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + e - f - g)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - e + f - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + e - f - g), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w)))) : "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - e + f - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + e - f - g), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + b),
            this._order = b,
            c !== !1 && this._updateQuaternion(),
            this
        },
        reorder: function() {
            var a = new Yb.Quat;
            return function(b) {
                a.setFromEuler(this),
                this.setFromQuaternion(a, b)
            }
        } (),
        fromArray: function(a) {
            return this._x = a[0],
            this._y = a[1],
            this._z = a[2],
            a[3] !== e && (this._order = a[3]),
            this._updateQuaternion(),
            this
        },
        toArray: function() {
            return [this._x, this._y, this._z, this._order]
        },
        equals: function(a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
        },
        clone: function() {
            return new Yb.Euler(this._x, this._y, this._z, this._order)
        }
    },
    Yb.math = {},
    Yb.math.Plane = function(a, b) {
        this.normal = a !== e ? a: new $b(1, 0, 0),
        this.constant = b !== e ? b: 0
    },
    Yb.math.Plane.prototype = {
        constructor: Yb.math.Plane,
        set: function(a, b) {
            return this.normal.copy(a),
            this.constant = b,
            this
        },
        setComponents: function(a, b, c, d) {
            return this.normal.set(a, b, c),
            this.constant = d,
            this
        },
        setFromNormalAndCoplanarPoint: function(a, b) {
            return this.normal.copy(a),
            this.constant = -b.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function(a, b, c) {
            var d = Yb.math.Plane.__v1.subVectors(c, b).cross(Yb.math.Plane.__v2.subVectors(a, b)).normalize();
            return this.setFromNormalAndCoplanarPoint(d, a),
            this
        },
        copy: function(a) {
            return this.normal.copy(a.normal),
            this.constant = a.constant,
            this
        },
        normalize: function() {
            var a = 1 / this.normal.length();
            return this.normal.multiplyScalar(a),
            this.constant *= a,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(a) {
            return this.normal.dot(a) + this.constant
        },
        distanceToSphere: function(a) {
            return this.distanceToPoint(a.center) - a.radius
        },
        projectPoint: function(a, b) {
            return this.orthoPoint(a, b).sub(a).negate()
        },
        orthoPoint: function(a, b) {
            var c = this.distanceToPoint(a),
            d = b || new $b;
            return d.copy(this.normal).multiplyScalar(c)
        },
        isIntersectionLine: function(a, b) {
            var c = this.distanceToPoint(a),
            d = this.distanceToPoint(b);
            return 0 > c && d > 0 || 0 > d && c > 0
        },
        isIntersectionFace: function(a, b) {
            var c = [];
            c.push(b[a.a]),
            c.push(b[a.b]),
            c.push(b[a.c]),
            null != a.d && c.push(b[a.d]);
            var d, e, f, g = [];
            for (d = 0; d < c.length; d++) g.push(this.distanceToPoint(c[d]));
            for (d = 0; d < g.length; d++) if (0 == d) e = f = g[d];
            else {
                if (f = g[d], 0 > e && f > 0 || 0 > f && e > 0) return "intersect";
                e = f
            }
            return f > 0 ? "in": "out"
        },
        intersectLine: function(a, b, c) {
            var d = c || new $b,
            f = Yb.math.Plane.__v1.subVectors(b, a),
            g = this.normal.dot(f);
            if (0 == g) return 0 == this.distanceToPoint(a) ? d.copy(a) : e;
            var h = -(a.dot(this.normal) + this.constant) / g;
            return 0 > h || h > 1 ? e: d.copy(f).multiplyScalar(h).add(a)
        },
        coplanarPoint: function(a) {
            var b = a || new $b;
            return b.copy(this.normal).multiplyScalar( - this.constant)
        },
        transform: function(a, b) {
            b = b || (new Yb.Mat3).getInverse(a).transpose();
            var c = Yb.math.Plane.__v1.copy(this.normal).applyMatrix3(b),
            d = this.coplanarPoint(Yb.math.Plane.__v2);
            return d.applyMatrix4(a),
            this.setFromNormalAndCoplanarPoint(c, d),
            this
        },
        translate: function(a) {
            return this.constant = this.constant - a.dot(this.normal),
            this
        },
        equals: function(a) {
            return a.normal.equals(this.normal) && a.constant == this.constant
        },
        clone: function() {
            return (new Yb.math.Plane).copy(this)
        }
    },
    Yb.math.Plane.__vZero = new $b(0, 0, 0),
    Yb.math.Plane.__v1 = new $b,
    Yb.math.Plane.__v2 = new $b,
    Yb.Frustum = function(a, b, c, d, f, g) {
        this.planes = [a !== e ? a: new Yb.math.Plane, b !== e ? b: new Yb.math.Plane, c !== e ? c: new Yb.math.Plane, d !== e ? d: new Yb.math.Plane, f !== e ? f: new Yb.math.Plane, g !== e ? g: new Yb.math.Plane]
    },
    Yb.Frustum.prototype = {
        set: function(a, b, c, d, e, f) {
            var g = this.planes;
            return g[0].copy(a),
            g[1].copy(b),
            g[2].copy(c),
            g[3].copy(d),
            g[4].copy(e),
            g[5].copy(f),
            this
        },
        setPoints: function(a) {
            this.points = a
        },
        copy: function(a) {
            for (var b = this.planes,
            c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
            return this
        },
        setFromMatrix: function(a) {
            var b = this.planes,
            c = a.elements,
            d = c[0],
            e = c[1],
            f = c[2],
            g = c[3],
            h = c[4],
            i = c[5],
            j = c[6],
            k = c[7],
            l = c[8],
            m = c[9],
            n = c[10],
            o = c[11],
            p = c[12],
            q = c[13],
            r = c[14],
            s = c[15];
            return b[0].setComponents(g - d, k - h, o - l, s - p).normalize(),
            b[1].setComponents(g + d, k + h, o + l, s + p).normalize(),
            b[2].setComponents(g + e, k + i, o + m, s + q).normalize(),
            b[3].setComponents(g - e, k - i, o - m, s - q).normalize(),
            b[4].setComponents(g - f, k - j, o - n, s - r).normalize(),
            b[5].setComponents(g + f, k + j, o + n, s + r).normalize(),
            this
        },
        intersectsObjectAccurate: function(a, b) {
            if (0 == b) return this.intersectsObject(a);
            var c, d, e = a.worldMatrix,
            f = (this.planes, a.vertices),
            g = [],
            h = f.length;
            for (d = 0; h > d; d++) if (c = f[d].clone(), c.applyMatrix4(e), g.push(c), this.containsPoint(c)) return ! 0;
            if (2 == b) if (a instanceof Yb.Line) for (d = 0, h = g.length; h - 1 > d; d++) {
                var i = g[d],
                j = g[d + 1];
                if (this.containsLine(i, j)) return ! 0
            } else {
                var k, l = a.faces;
                for (d = 0, h = l.length; h > d; d++) {
                    if (k = l[d], this.containsLine(g[k.a], g[k.b])) return ! 0;
                    if (this.containsLine(g[k.b], g[k.c])) return ! 0;
                    if (null != k.d) {
                        if (this.containsLine(g[k.c], g[k.d])) return ! 0;
                        if (this.containsLine(g[k.d], g[k.a])) return ! 0
                    } else if (this.containsLine(g[k.a], g[k.c])) return ! 0
                }
            }
            return ! 1
        },
        intersectsObject: function(a) {
            var b = a.worldMatrix,
            c = this.planes,
            d = b.getPosition();
            if (!a.computeBoundingSphere) return ! 1;
            a.boundingSphere || a.computeBoundingSphere();
            for (var e = -a.boundingSphere.radius * b.getMaxScaleOnAxis(), f = 0; 6 > f; f++) {
                var g = c[f].distanceToPoint(d);
                if (e > g) return ! 1
            }
            return ! 0
        },
        intersectsSphere: function(a) {
            for (var b = this.planes,
            c = a.center,
            d = -a.radius,
            e = 0; 6 > e; e++) {
                var f = b[e].distanceToPoint(c);
                if (d > f) return ! 1
            }
            return ! 0
        },
        intersectsBox: function(a) {
            for (var b = new $b,
            c = new $b,
            d = this.planes,
            e = 0; 6 > e; e++) {
                var f = d[e];
                b.x = f.normal.x > 0 ? a.min.x: a.max.x,
                c.x = f.normal.x > 0 ? a.max.x: a.min.x,
                b.y = f.normal.y > 0 ? a.min.y: a.max.y,
                c.y = f.normal.y > 0 ? a.max.y: a.min.y,
                b.z = f.normal.z > 0 ? a.min.z: a.max.z,
                c.z = f.normal.z > 0 ? a.max.z: a.min.z;
                var g = f.distanceToPoint(b),
                h = f.distanceToPoint(c);
                if (0 > g && 0 > h) return ! 1
            }
            return ! 0
        },
        containsLine: function(a, b) {
            for (var c = this.planes,
            d = new $b,
            e = 0; 6 > e; e++) if (d = c[e].intersectLine(a, b, d), d && this.containsPoint(d)) return ! 0;
            return ! 1
        },
        containsPoint: function(a) {
            for (var b = this.planes,
            c = 0; 6 > c; c++) if (b[c].distanceToPoint(a) < 0) return ! 1;
            return ! 0
        },
        clone: function() {
            return (new Yb.Frustum).copy(this)
        }
    },
    Yb.Ray = function(a, b) {
        this.origin = a !== e ? a: new $b,
        this.direction = b !== e ? b: new $b
    },
    Yb.Ray.prototype = {
        constructor: Yb.Ray,
        set: function(a, b) {
            return this.origin.copy(a),
            this.direction.copy(b),
            this
        },
        copy: function(a) {
            return this.origin.copy(a.origin),
            this.direction.copy(a.direction),
            this
        },
        at: function(a, b) {
            var c = b || new $b;
            return c.copy(this.direction).multiplyScalar(a).add(this.origin)
        },
        recast: function(a) {
            return this.origin.copy(this.at(a, Yb.Ray.__v1)),
            this
        },
        closestPointToPoint: function(a, b) {
            var c = b || new $b;
            c.subVectors(a, this.origin);
            var d = c.dot(this.direction);
            return c.copy(this.direction).multiplyScalar(d).add(this.origin)
        },
        distanceToPoint: function(a) {
            var b = Yb.Ray.__v1.subVectors(a, this.origin).dot(this.direction);
            return Yb.Ray.__v1.copy(this.direction).multiplyScalar(b).add(this.origin),
            Yb.Ray.__v1.distanceTo(a)
        },
        isIntersectionSphere: function(a) {
            return this.distanceToPoint(a.center) <= a.radius
        },
        isIntersectionPlane: function(a) {
            var b = a.normal.dot(this.direction);
            return 0 != b ? !0 : 0 == a.distanceToPoint(this.origin) ? !0 : !1
        },
        distanceToPlane: function(a) {
            var b = a.normal.dot(this.direction);
            if (0 == b) return 0 == a.distanceToPoint(this.origin) ? 0 : e;
            var c = -(this.origin.dot(a.normal) + a.constant) / b;
            return c
        },
        intersectPlane: function(a, b) {
            var c = this.distanceToPlane(a);
            return c === e ? e: this.at(c, b)
        },
        transform: function(a) {
            return this.direction.add(this.origin).applyMatrix4(a),
            this.origin.applyMatrix4(a),
            this.direction.sub(this.origin),
            this
        },
        distanceSqToSegment: function(a, b, c, d) {
            var e, f, g, h, i = a.clone().add(b).multiplyScalar(.5),
            j = b.clone().sub(a).normalize(),
            k = .5 * a.distanceTo(b),
            l = this.origin.clone().sub(i),
            m = -this.direction.dot(j),
            n = l.dot(this.direction),
            o = -l.dot(j),
            p = l.lengthSq(),
            q = Math.abs(1 - m * m);
            if (q >= 0) if (e = m * o - n, f = m * n - o, h = k * q, e >= 0) if (f >= -h) if (h >= f) {
                var r = 1 / q;
                e *= r,
                f *= r,
                g = e * (e + m * f + 2 * n) + f * (m * e + f + 2 * o) + p
            } else f = k,
            e = Math.max(0, -(m * f + n)),
            g = -e * e + f * (f + 2 * o) + p;
            else f = -k,
            e = Math.max(0, -(m * f + n)),
            g = -e * e + f * (f + 2 * o) + p;
            else - h >= f ? (e = Math.max(0, -( - m * k + n)), f = e > 0 ? -k: Math.min(Math.max( - k, -o), k), g = -e * e + f * (f + 2 * o) + p) : h >= f ? (e = 0, f = Math.min(Math.max( - k, -o), k), g = f * (f + 2 * o) + p) : (e = Math.max(0, -(m * k + n)), f = e > 0 ? k: Math.min(Math.max( - k, -o), k), g = -e * e + f * (f + 2 * o) + p);
            else f = m > 0 ? -k: k,
            e = Math.max(0, -(m * f + n)),
            g = -e * e + f * (f + 2 * o) + p;
            return c && c.copy(this.direction.clone().multiplyScalar(e).add(this.origin)),
            d && d.copy(j.clone().multiplyScalar(f).add(i)),
            g
        },
        equals: function(a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction)
        },
        clone: function() {
            return (new Yb.Ray).copy(this)
        }
    },
    Yb.Ray.__v1 = new $b,
    Yb.Ray.__v2 = new $b,
    Yb.Triangle = function(a, b, c) {
        this.a = a !== e ? a: new $b,
        this.b = b !== e ? b: new $b,
        this.c = c !== e ? c: new $b
    },
    Yb.Triangle.normal = function(a, b, c, d) {
        var e = d || new $b;
        e.subVectors(c, b),
        Yb.Triangle.__v0.subVectors(a, b),
        e.cross(Yb.Triangle.__v0);
        var f = e.lengthSq();
        return f > 0 ? e.multiplyScalar(1 / Math.sqrt(f)) : e.set(0, 0, 0)
    },
    Yb.Triangle.barycoordFromPoint = function(a, b, c, d, e) {
        Yb.Triangle.__v0.subVectors(d, b),
        Yb.Triangle.__v1.subVectors(c, b),
        Yb.Triangle.__v2.subVectors(a, b);
        var f = Yb.Triangle.__v0.dot(Yb.Triangle.__v0),
        g = Yb.Triangle.__v0.dot(Yb.Triangle.__v1),
        h = Yb.Triangle.__v0.dot(Yb.Triangle.__v2),
        i = Yb.Triangle.__v1.dot(Yb.Triangle.__v1),
        j = Yb.Triangle.__v1.dot(Yb.Triangle.__v2),
        k = f * i - g * g,
        l = e || new $b;
        if (0 == k) return l.set( - 2, -1, -1);
        var m = 1 / k,
        n = (i * h - g * j) * m,
        o = (f * j - g * h) * m;
        return l.set(1 - n - o, o, n)
    },
    Yb.Triangle.containsPoint = function(a, b, c, d) {
        var e = Yb.Triangle.barycoordFromPoint(a, b, c, d, Yb.Triangle.__v3);
        return e.x >= 0 && e.y >= 0 && e.x + e.y <= 1
    },
    Yb.Triangle.prototype = {
        constructor: Yb.Triangle,
        set: function(a, b, c) {
            return this.a.copy(a),
            this.b.copy(b),
            this.c.copy(c),
            this
        },
        setFromPointsAndIndices: function(a, b, c, d) {
            return this.a.copy(a[b]),
            this.b.copy(a[c]),
            this.c.copy(a[d]),
            this
        },
        copy: function(a) {
            return this.a.copy(a.a),
            this.b.copy(a.b),
            this.c.copy(a.c),
            this
        },
        area: function() {
            return Yb.Triangle.__v0.subVectors(this.c, this.b),
            Yb.Triangle.__v1.subVectors(this.a, this.b),
            .5 * Yb.Triangle.__v0.cross(Yb.Triangle.__v1).length()
        },
        midpoint: function(a) {
            var b = a || new $b;
            return b.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(a) {
            return Yb.Triangle.normal(this.a, this.b, this.c, a)
        },
        plane: function(a) {
            var b = a || new Yb.math.Plane;
            return b.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(a, b) {
            return Yb.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
        },
        containsPoint: function(a) {
            return Yb.Triangle.containsPoint(a, this.a, this.b, this.c)
        },
        equals: function(a) {
            return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
        },
        clone: function() {
            return (new Yb.Triangle).copy(this)
        },
        intersectLine: function(a, b) {
            var c = this.plane(),
            d = c.intersectLine(a, b);
            return null != d && this.containsPoint(d)
        }
    },
    Yb.Triangle.__v0 = new $b,
    Yb.Triangle.__v1 = new $b,
    Yb.Triangle.__v2 = new $b,
    Yb.Triangle.__v3 = new $b;
    var bc = {
        getLogicalPoint: function(a, b) {
            var c, d = a.getBoundingClientRect();
            if (cc.isTouchable && b.changedTouches && b.changedTouches.length > 0) {
                var e = b.changedTouches[0],
                f = cc.isAndroid ? 0 : $touch.scrollLeft(),
                g = cc.isAndroid ? 0 : $touch.scrollTop();
                c = {
                    x: e.clientX + a.scrollLeft - d.left - f,
                    y: e.clientY + a.scrollTop - d.top - g
                }
            } else {
                if (!bc.isValidEvent(a, b)) return null;
                c = {
                    x: b.clientX - d.left + a.scrollLeft,
                    y: b.clientY - d.top + a.scrollTop
                }
            }
            return c
        },
        isValidEvent: function(a, b) {
            if (!b) return ! 1;
            if (b.target === a) if (cc.isFirefox) {
                if (a.clientHeight < a.scrollHeight && b.layerX < 25) return ! 1;
                if (a.clientWidth < a.scrollWidth && b.layerY < 25) return ! 1
            } else if (b.offsetX > a.clientWidth || b.offsetY > a.clientHeight) return ! 1;
            return ! 0
        },
        isImage: function(a) {
            return a && a.nodeName && "img" === a.nodeName.toLowerCase()
        },
        isCanvas: function(a) {
            return a && a.nodeName && "canvas" === a.nodeName.toLowerCase()
        },
        createView: function(a, b) {
            var c = document.createElement("div");
            return c.style.position = sc.VIEW_POSITION,
            c.style.fontSize = sc.VIEW_FONT_SIZE,
            c.style.fontFamily = sc.VIEW_FONT_FAMILY,
            c.style.cursor = "default",
            c.style.outline = "none",
            c.style.textAlign = "left",
            c.style.msTouchAction = "none",
            c.tabIndex = 0,
            b || (c.onmousedown = bc.preventDefault),
            c.style.setProperty && (c.style.setProperty("-khtml-user-select", "none", null), c.style.setProperty("-webkit-user-select", "none", null), c.style.setProperty("-moz-user-select", "none", null), c.style.setProperty("-webkit-tap-highlight-color", "rgba(0, 0, 0, 0)", null)),
            a && (c.style.overflow = a),
            c
        },
        preventDefault: function(a) {
            sc.KEEP_DEFAULT_FUNCTION(a) || (a.preventDefault ? a.preventDefault() : a.preventManipulation ? a.preventManipulation() : a.returnValue = !1)
        },
        createCanvas: function(a) {
            var b = document.createElement("canvas"),
            c = a.getView();
            return b.width = c.width,
            b.height = c.height,
            b.style.msTouchAction = "none",
            b.style.position = "absolute",
            b
        },
        isCtrlDown: function(a) {
            return a.ctrlKey || a.metaKey
        },
        getScrollTop: function(a) {
            if (!a) return 0;
            var b = a.scrollTop,
            c = a.parentElement;
            return b + this.getScrollTop(c)
        },
        getScrollLeft: function(a) {
            if (!a) return 0;
            var b = a.scrollLeft,
            c = a.parentElement;
            return b + this.getScrollLeft(c)
        },
        debug: function(a, b) {
            try {
                a.call(b)
            } catch(c) {
                alert(c)
            }
        },
        setFocus: function(a) {
            if (document.activeElement !== a) {
                var b, c, d, e = document.documentElement;
                document.body,
                e && (cc.isIE || cc.isOpera || e.scrollLeft || e.scrollTop) && (b = e.scrollLeft, c = e.scrollTop, d = e),
                a.focus(),
                d && (d.scrollLeft = b, d.scrollTop = c)
            }
        },
        isRightClick: function(a) {
            var b;
            if (!a) var a = d.event;
            return a.which ? b = 3 == a.which: a.button && (b = 2 == a.button),
            b
        }
    };
    Yb.html = bc;
    var cc = function() {
        var a = {},
        b = navigator.userAgent.toLowerCase();
        return a.isOpera = /opera/.test(b),
        a.isIE = /msie/.test(b) || /trident/.test(b),
        a.isFirefox = /firefox/i.test(b),
        a.isChrome = /chrome/i.test(b),
        a.isSafari = !a.isChrome && /safari/i.test(b),
        a.isIPhone = /iphone/.test(b),
        a.isIPod = /ipod/.test(b),
        a.isIPad = /ipad/.test(b),
        a.isAndroid = /android/i.test(b),
        a.isWebOS = /webos/i.test(b),
        a.isMSToucheable = navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        a.isTouchable = "ontouchend" in document || a.isMSToucheable,
        a.isIOS = a.isIPhone || a.isIPod || a.isIPad,
        a
    } ();
    Yb.ua = cc,
    function() {
        function a(a) {
            var b, d, e, f, g, h;
            for (e = a.length, d = 0, b = ""; e > d;) {
                if (f = 255 & a.charCodeAt(d++), d == e) {
                    b += c.charAt(f >> 2),
                    b += c.charAt((3 & f) << 4),
                    b += "==";
                    break
                }
                if (g = a.charCodeAt(d++), d == e) {
                    b += c.charAt(f >> 2),
                    b += c.charAt((3 & f) << 4 | (240 & g) >> 4),
                    b += c.charAt((15 & g) << 2),
                    b += "=";
                    break
                }
                h = a.charCodeAt(d++),
                b += c.charAt(f >> 2),
                b += c.charAt((3 & f) << 4 | (240 & g) >> 4),
                b += c.charAt((15 & g) << 2 | (192 & h) >> 6),
                b += c.charAt(63 & h)
            }
            return b
        }
        function b(a) {
            var b, c, d, f, g, h, i;
            for (h = a.length, g = 0, i = ""; h > g;) {
                do b = e[255 & a.charCodeAt(g++)];
                while (h > g && -1 == b);
                if ( - 1 == b) break;
                do c = e[255 & a.charCodeAt(g++)];
                while (h > g && -1 == c);
                if ( - 1 == c) break;
                i += String.fromCharCode(b << 2 | (48 & c) >> 4);
                do {
                    if (d = 255 & a.charCodeAt(g++), 61 == d) return i;
                    d = e[d]
                } while ( h > g && - 1 == d );
                if ( - 1 == d) break;
                i += String.fromCharCode((15 & c) << 4 | (60 & d) >> 2);
                do {
                    if (f = 255 & a.charCodeAt(g++), 61 == f) return i;
                    f = e[f]
                } while ( h > g && - 1 == f );
                if ( - 1 == f) break;
                i += String.fromCharCode((3 & d) << 6 | f)
            }
            return i
        }
        var c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        e = new Array( - 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);
        d.btoa || (d.btoa = a),
        d.atob || (d.atob = b)
    } ();
    var dc = function() {
        var a = !1,
        b = document.createElement("canvas");
        if (b.getContext("2d") && (a = !0), !a) return {
            saveAsBMP: function() {},
            saveAsPNG: function() {},
            saveAsJPEG: function() {}
        };
        var c = !!b.getContext("2d").getImageData,
        e = !!b.toDataURL,
        f = !!d.btoa,
        g = function(a) {
            var b = parseInt(a.width),
            c = parseInt(a.height);
            return a.getContext("2d").getImageData(0, 0, b, c)
        },
        h = function(a) {
            var b = "";
            if ("string" == typeof a) b = a;
            else for (var c = a,
            d = 0; d < c.length; d++) b += String.fromCharCode(c[d]);
            return btoa(b)
        },
        i = function(a) {
            var b = [],
            c = a.width,
            d = a.height;
            b.push(66),
            b.push(77);
            var e = c * d * 3 + 54;
            b.push(e % 256),
            e = Math.floor(e / 256),
            b.push(e % 256),
            e = Math.floor(e / 256),
            b.push(e % 256),
            e = Math.floor(e / 256),
            b.push(e % 256),
            b.push(0),
            b.push(0),
            b.push(0),
            b.push(0),
            b.push(54),
            b.push(0),
            b.push(0),
            b.push(0);
            var f = [];
            f.push(40),
            f.push(0),
            f.push(0),
            f.push(0);
            var g = c;
            f.push(g % 256),
            g = Math.floor(g / 256),
            f.push(g % 256),
            g = Math.floor(g / 256),
            f.push(g % 256),
            g = Math.floor(g / 256),
            f.push(g % 256);
            var i = d;
            f.push(i % 256),
            i = Math.floor(i / 256),
            f.push(i % 256),
            i = Math.floor(i / 256),
            f.push(i % 256),
            i = Math.floor(i / 256),
            f.push(i % 256),
            f.push(1),
            f.push(0),
            f.push(24),
            f.push(0),
            f.push(0),
            f.push(0),
            f.push(0),
            f.push(0);
            var j = c * d * 3;
            f.push(j % 256),
            j = Math.floor(j / 256),
            f.push(j % 256),
            j = Math.floor(j / 256),
            f.push(j % 256),
            j = Math.floor(j / 256),
            f.push(j % 256);
            for (var k = 0; 16 > k; k++) f.push(0);
            var l = (4 - 3 * c % 4) % 4,
            m = a.data,
            n = "",
            o = d;
            do {
                for (var p = c * (o - 1) * 4, q = "", r = 0; c > r; r++) {
                    var s = 4 * r;
                    q += String.fromCharCode(m[p + s + 2]),
                    q += String.fromCharCode(m[p + s + 1]),
                    q += String.fromCharCode(m[p + s])
                }
                for (var t = 0; l > t; t++) q += String.fromCharCode(0);
                n += q
            } while (-- o );
            var u = h(b.concat(f)) + h(n);
            return u
        },
        j = function(a, b) {
            return "data:" + b + ";base64," + a
        },
        k = function(a) {
            var b = document.createElement("img");
            return b.src = a,
            b
        },
        l = function(a, b, c, d, e) {
            c = c || (b ? b.w: a.width),
            d = d || (b ? b.h: a.height);
            var f = document.createElement("canvas");
            f.width = c,
            f.height = d,
            f.style.width = c + "px",
            f.style.height = d + "px";
            var g = f.getContext("2d"),
            g = f.getContext("2d"),
            h = a.style.backgroundColor;
            return h || (h = "PNG" === e ? "rgba(255,255,255,0.0)": "BMP" === e ? "rgba(255,255,255,0.01)": "#FFFFFF"),
            g.fillStyle = h,
            g.fillRect(0, 0, c, d),
            b = b ? b: {
                x: 0,
                y: 0,
                w: a.width,
                h: a.height
            },
            g.drawImage(a, b.x, b.y, b.w, b.h, 0, 0, c, d),
            f
        };
        return {
            saveAsPNG: function(a, b, c, d, f) {
                if (!e) return ! 1;
                var g = l(a, b, d, f, "PNG"),
                h = g.toDataURL("image/png");
                return c ? k(h) : h
            },
            saveAsJPEG: function(a, b, c, d, f) {
                if (!e) return ! 1;
                var g = l(a, b, d, f, "JPEG"),
                h = "image/jpeg",
                i = g.toDataURL(h);
                return 5 != i.indexOf(h) ? !1 : c ? k(i) : i
            },
            saveAsBMP: function(a, b, d, e, h) {
                if (!c || !f) return ! 1;
                var m = l(a, b, e, h, "BMP"),
                n = g(m),
                o = i(n);
                return d ? k(j(o, "image/bmp")) : j(o, "image/bmp")
            }
        }
    } (),
    ec = {},
    fc = {
        cache: {},
        g: document.createElement("canvas").getContext("2d"),
        getTextSize: function(a, b) {
            fc.g.font = a ? a: sc.FONT;
            var c = fc.cache[fc.g.font];
            return c || (c = 2 * fc.g.measureText("e").width + 4, fc.cache[fc.g.font] = c),
            {
                width: fc.g.measureText(b).width + 4,
                height: c
            }
        }
    };
    ec.g = fc,
    Yb.g = fc;
    var gc = {};
    setTimeout,
    gc.bcld = function(a, b, c, d, e, f, g, h, i) {
        var j, k, l = a / 2,
        m = [],
        n = [],
        o = {
            vertices: [],
            faces: [],
            uvs: [],
            uv2s: []
        };
        for (k = 0; b >= k; k++) {
            var p = [],
            q = [],
            r = k / b,
            s = r * (c - d) + d;
            for (j = 0; e >= j; j++) {
                var t = j / e,
                u = new $b;
                u.x = s * Math.sin(t * h + i),
                u.y = -r * a + l,
                u.z = s * Math.cos(t * h + i),
                o.vertices.push(u),
                p.push(o.vertices.length - 1),
                q.push(new Zb(t, 1 - r))
            }
            m.push(p),
            n.push(q)
        }
        var v, w, x = (c - d) / a;
        for (j = 0; e > j; j++) for (0 !== d ? (v = o.vertices[m[0][j]].clone(), w = o.vertices[m[0][j + 1]].clone()) : (v = o.vertices[m[1][j]].clone(), w = o.vertices[m[1][j + 1]].clone()), v.setY(Math.sqrt(v.x * v.x + v.z * v.z) * x).normalize(), w.setY(Math.sqrt(w.x * w.x + w.z * w.z) * x).normalize(), k = 0; b > k; k++) {
            var y = m[k][j],
            z = m[k + 1][j],
            A = m[k + 1][j + 1],
            B = m[k][j + 1],
            C = v.clone(),
            D = v.clone(),
            E = w.clone(),
            F = w.clone(),
            G = n[k][j].clone(),
            H = n[k + 1][j].clone(),
            I = n[k + 1][j + 1].clone(),
            J = n[k][j + 1].clone();
            o.faces.push(new pc(y, z, B, [C, D, F], null, 0)),
            o.uvs.push([G, H, J]),
            o.uv2s.push([G.clone(), H.clone(), J.clone()]),
            o.faces.push(new pc(z, A, B, [D, E, F], null, 0)),
            o.uvs.push([H, I, J]),
            o.uv2s.push([H.clone(), I.clone(), J.clone()])
        }
        var K = !1;
        if (f === !1 && d > 0) for (o.vertices.push(new $b(0, l, 0)), K = !0, j = 0; e > j; j++) {
            var y = m[0][j],
            z = m[0][j + 1],
            A = o.vertices.length - 1,
            C = new $b(0, 1, 0),
            D = new $b(0, 1, 0),
            E = new $b(0, 1, 0),
            L = o.vertices[y],
            M = o.vertices[z],
            G = new Zb((L.x / d + 1) / 2, 1 - (L.z / d + 1) / 2),
            H = new Zb((M.x / d + 1) / 2, 1 - (M.z / d + 1) / 2),
            I = new Zb(.5, .5);
            o.faces.push(new pc(y, z, A, [C, D, E], null, 1)),
            o.uvs.push([G, H, I]),
            o.uv2s.push([G.clone(), H.clone(), I.clone()])
        }
        var N = !1;
        if (g === !1 && c > 0) for (o.vertices.push(new $b(0, -l, 0)), N = !0, j = 0; e > j; j++) {
            var y = m[k][j + 1],
            z = m[k][j],
            A = o.vertices.length - 1,
            C = new $b(0, -1, 0),
            D = new $b(0, -1, 0),
            E = new $b(0, -1, 0),
            L = o.vertices[y],
            M = o.vertices[z],
            G = new Zb((L.x / c + 1) / 2, (L.z / c + 1) / 2),
            H = new Zb((M.x / c + 1) / 2, (M.z / c + 1) / 2),
            I = new Zb(.5, .5);
            o.faces.push(new pc(y, z, A, [C, D, E], null, 2)),
            o.uvs.push([G, H, I]),
            o.uv2s.push([G.clone(), H.clone(), I.clone()])
        }
        if (h !== 2 * Math.PI) { ! K && o.vertices.push(new $b(0, l, 0)),
            !N && o.vertices.push(new $b(0, -l, 0));
            var y = m[0][0],
            z = m[b][0],
            A = o.vertices.length - 1,
            B = o.vertices.length - 2,
            G = new Zb(0, 0),
            H = new Zb(0, 1),
            I = new Zb(1, 1),
            J = new Zb(1, 0);
            o.faces.push(new pc(y, A, z)),
            o.uvs.push([G, I, H]),
            o.uv2s.push([G.clone(), I.clone(), H.clone()]),
            o.faces.push(new pc(B, A, y)),
            o.uvs.push([J, I, G]),
            o.uv2s.push([J.clone(), I.clone(), G.clone()]),
            y = m[0][e],
            z = m[b][e];
            var G = new Zb(0, 0),
            H = new Zb(0, 1),
            I = new Zb(1, 1),
            J = new Zb(1, 0);
            o.faces.push(new pc(y, z, B)),
            o.uvs.push([G, H, J]),
            o.uv2s.push([G.clone(), H.clone(), J.clone()]),
            o.faces.push(new pc(z, A, B)),
            o.uvs.push([H, I, J]),
            o.uv2s.push([H.clone(), I.clone(), J.clone()])
        }
        return o
    },
    gc.buildCubeData = function(a, b, c, d, e, f, g, h) {
        function i(i) {
            var o, p, q, r, s, t, u, v, w, x;
            j = k.length;
            var y, z = "six-each" == g || "front-other" == g || "back-other" == g || "left-other" == g || "right-other" == g || "top-other" == g || "bottom-other" == g,
            A = new Zb(0, 0),
            B = z ? new Zb(1 / 3, .5) : new Zb(1, 1),
            C = g.split("-")[0];
            "six" == C ? C = null: B = new Zb(.5, 1),
            "right" == i ? (o = "z", p = "y", q = "x", r = -1, s = -1, t = a / 2, u = c, v = b, w = f, x = e, y = 0, A = new Zb(2 / 3, 0)) : "left" == i ? (o = "z", p = "y", q = "x", r = 1, s = -1, t = -a / 2, u = c, v = b, w = f, x = e, y = 1) : "top" == i ? (o = "x", p = "z", q = "y", r = 1, s = 1, t = b / 2, u = a, v = c, w = d, x = f, y = 2, A = new Zb(1 / 3, .5)) : "bottom" == i ? (o = "x", p = "z", q = "y", r = 1, s = -1, t = -b / 2, u = a, v = c, w = d, x = f, y = 3, A = new Zb(0, .5)) : "front" == i ? (o = "x", p = "y", q = "z", r = 1, s = -1, t = c / 2, u = a, v = b, w = d, x = e, y = 4, A = new Zb(1 / 3, 0)) : "back" == i && (o = "x", p = "y", q = "z", r = -1, s = -1, t = -c / 2, u = a, v = b, w = d, x = e, y = 5, A = new Zb(2 / 3, .5)),
            C && (A = C == i ? new Zb(0, 0) : new Zb(.5, 0));
            var D, E, F = w + 1,
            G = x + 1;
            for (E = 0; G > E; E++) for (D = 0; F > D; D++) {
                var H = new $b;
                H[o] = (D / w * u - u / 2) * r + h[o],
                H[p] = (E / x * v - v / 2) * s + h[p],
                H[q] = t + h[q],
                k.push(H)
            }
            z && (y = 0);
            var I = new $b;
            for (I[q] = t > 0 ? 1 : -1, E = 0; x > E; E++) for (D = 0; w > D; D++) {
                var J = D + F * E,
                K = D + F * (E + 1),
                L = D + 1 + F * (E + 1),
                M = D + 1 + F * E,
                N = [new Zb(D / w, 1 - E / x), new Zb(D / w, 1 - (E + 1) / x), new Zb((D + 1) / w, 1 - (E + 1) / x), new Zb((D + 1) / w, 1 - E / x)];
                if (z) for (var O = 0; O < N.length; O++) N[O].multiply(B).add(A);
                var P = new qc(J + j, K + j, L + j, M + j);
                P.normal.copy(I),
                P.vertexNormals.push(I.clone(), I.clone(), I.clone(), I.clone()),
                P.materialIndex = y,
                l.push(P),
                m.push([N[0], N[1], N[2], N[3]]),
                n.push([N[0].clone(), N[1].clone(), N[2].clone(), N[3].clone()])
            }
        }
        var j, k = [],
        l = [],
        m = [],
        n = [];
        i("right"),
        i("left"),
        i("top"),
        i("bottom"),
        i("front"),
        i("back");
        var o = {
            vertices: k,
            faces: l,
            uvs: m,
            uv2s: n
        };
        return o
    },
    gc.bsd = function(a, b, c, d, e, f, g) {
        var h, i, j = [],
        k = [],
        l = [],
        m = [],
        n = [],
        o = [];
        for (i = 0; c >= i; i++) {
            var p = [],
            q = [];
            for (h = 0; b >= h; h++) {
                var r = h / b,
                s = i / c,
                t = new $b;
                t.x = -a * Math.cos(d + r * e) * Math.sin(f + s * g),
                t.y = a * Math.cos(f + s * g),
                t.z = a * Math.sin(d + r * e) * Math.sin(f + s * g),
                j.push(t),
                p.push(j.length - 1),
                q.push(new Zb(r, 1 - s))
            }
            n.push(p),
            o.push(q)
        }
        for (i = 0; c > i; i++) for (h = 0; b > h; h++) {
            var u = n[i][h + 1],
            v = n[i][h],
            w = n[i + 1][h],
            x = n[i + 1][h + 1],
            y = j[u].clone().normalize(),
            z = j[v].clone().normalize(),
            A = j[w].clone().normalize(),
            B = j[x].clone().normalize(),
            C = o[i][h + 1].clone(),
            D = o[i][h].clone(),
            E = o[i + 1][h].clone(),
            F = o[i + 1][h + 1].clone();
            Math.abs(j[u].y) === a ? (l.push(new pc(u, w, x, [y, A, B])), k.push([C, E, F]), m.push([C.clone(), E.clone(), F.clone()])) : Math.abs(j[w].y) === a ? (l.push(new pc(u, v, w, [y, z, A])), k.push([C, D, E]), m.push([C.clone(), D.clone(), E.clone()])) : (l.push(new pc(u, v, x, [y, z, B])), k.push([C, D, F]), m.push([C.clone(), D.clone(), F.clone()]), l.push(new pc(v, w, x, [z.clone(), A, B.clone()])), k.push([D.clone(), E, F.clone()]), m.push([D.clone(), E.clone(), F.clone()]))
        }
        return {
            vertices: j,
            faces: l,
            uvs: k,
            uv2s: m
        }
    };
    var hc = function(a) {
        var b, c, d, f, g, h, i, j = {},
        k = a.primitive;
        if (k.groups) return a.groups = k.groups,
        void(a.groupList = k.groupList);
        k.groups = {};
        var l = a.material,
        m = a.getMaterialMapping();
        for (b = 0, c = k.faces.length; c > b; b++) d = k.faces[b],
        f = l instanceof Yb.ArrayMaterial ? d.materialIndex: 0,
        f = m[f],
        h = f !== e ? f: -1,
        j[h] === e && (j[h] = {
            hash: h,
            counter: 0
        }),
        i = j[h].hash + "_" + j[h].counter,
        k.groups[i] === e && (k.groups[i] = {
            faces3: [],
            faces4: [],
            materialIndex: f,
            vertices: 0
        }),
        g = d instanceof pc ? 3 : 4,
        k.groups[i].vertices + g > 65535 && (j[h].counter += 1, i = j[h].hash + "_" + j[h].counter, k.groups[i] === e && (k.groups[i] = {
            faces3: [],
            faces4: [],
            materialIndex: f,
            vertices: 0
        })),
        d instanceof pc ? k.groups[i].faces3.push(b) : k.groups[i].faces4.push(b),
        k.groups[i].vertices += g;
        k.groupsList = [];
        for (var n in a.groups) k.groupsList.push(a.groups[n]);
        a.groups = k.groups,
        a.groupList = k.groupsList
    },
    ic = function(a, b, c, d) {
        var f, g, h, i, j, k, l, m, n, o, p, q, r = a,
        s = r,
        t = s.vertices,
        u = t.length,
        v = s.colors,
        w = v.length,
        x = d.__vertexArray,
        y = d.__colorArray,
        z = d.__sortArray,
        A = s.verticesNeedUpdate,
        B = (s.elementsNeedUpdate, s.colorsNeedUpdate),
        C = s.__webglCustomAttributesList;
        if (r.sortParticles) {
            for (_projScreenMatrixPS.copy(_projScreenMatrix), _projScreenMatrixPS.multiply(r.matrixWorld), f = 0; u > f; f++) h = t[f],
            _vector3.copy(h),
            _vector3.applyProjection(_projScreenMatrixPS),
            z[f] = [_vector3.z, f];
            for (z.sort(numericalSort), f = 0; u > f; f++) h = t[z[f][1]],
            i = 3 * f,
            x[i] = h.x,
            x[i + 1] = h.y,
            x[i + 2] = h.z;
            for (g = 0; w > g; g++) i = 3 * g,
            k = v[z[g][1]],
            y[i] = k.r,
            y[i + 1] = k.g,
            y[i + 2] = k.b;
            if (C) for (l = 0, m = C.length; m > l; l++) if (q = C[l], q.boundTo === e || "vertices" === q.boundTo) if (i = 0, o = q.value.length, 1 === q.size) for (n = 0; o > n; n++) j = z[n][1],
            q.array[n] = q.value[j];
            else if (2 === q.size) for (n = 0; o > n; n++) j = z[n][1],
            p = q.value[j],
            q.array[i] = p.x,
            q.array[i + 1] = p.y,
            i += 2;
            else if (3 === q.size) if ("c" === q.type) for (n = 0; o > n; n++) j = z[n][1],
            p = q.value[j],
            q.array[i] = p.r,
            q.array[i + 1] = p.g,
            q.array[i + 2] = p.b,
            i += 3;
            else for (n = 0; o > n; n++) j = z[n][1],
            p = q.value[j],
            q.array[i] = p.x,
            q.array[i + 1] = p.y,
            q.array[i + 2] = p.z,
            i += 3;
            else if (4 === q.size) for (n = 0; o > n; n++) j = z[n][1],
            p = q.value[j],
            q.array[i] = p.x,
            q.array[i + 1] = p.y,
            q.array[i + 2] = p.z,
            q.array[i + 3] = p.w,
            i += 4
        } else {
            if (A) for (f = 0; u > f; f++) h = t[f],
            i = 3 * f,
            x[i] = h.x,
            x[i + 1] = h.y,
            x[i + 2] = h.z;
            if (B) for (g = 0; w > g; g++) k = v[g],
            i = 3 * g,
            y[i] = k.r,
            y[i + 1] = k.g,
            y[i + 2] = k.b;
            if (C) for (l = 0, m = C.length; m > l; l++) if (q = C[l], q.needsUpdate && (q.boundTo === e || "vertices" === q.boundTo)) if (o = q.value.length, i = 0, 1 === q.size) for (n = 0; o > n; n++) q.array[n] = q.value[n];
            else if (2 === q.size) for (n = 0; o > n; n++) p = q.value[n],
            q.array[i] = p.x,
            q.array[i + 1] = p.y,
            i += 2;
            else if (3 === q.size) if ("c" === q.type) for (n = 0; o > n; n++) p = q.value[n],
            q.array[i] = p.r,
            q.array[i + 1] = p.g,
            q.array[i + 2] = p.b,
            i += 3;
            else for (n = 0; o > n; n++) p = q.value[n],
            q.array[i] = p.x,
            q.array[i + 1] = p.y,
            q.array[i + 2] = p.z,
            i += 3;
            else if (4 === q.size) for (n = 0; o > n; n++) p = q.value[n],
            q.array[i] = p.x,
            q.array[i + 1] = p.y,
            q.array[i + 2] = p.z,
            q.array[i + 3] = p.w,
            i += 4
        }
        if ((A || r.sortParticles) && (c.bindBuffer(c.ARRAY_BUFFER, d.__webglVertexBuffer), c.bufferData(c.ARRAY_BUFFER, x, b)), (B || r.sortParticles) && (c.bindBuffer(c.ARRAY_BUFFER, d.__webglColorBuffer), c.bufferData(c.ARRAY_BUFFER, y, b)), C) for (l = 0, m = C.length; m > l; l++) q = C[l],
        (q.needsUpdate || r.sortParticles) && (c.bindBuffer(c.ARRAY_BUFFER, q.buffer), c.bufferData(c.ARRAY_BUFFER, q.array, b))
    };
    gc.buildGroupBufferData = function(a, b, c, d, f, g, h, i) {
        var j = "basic" == f._type ? !1 : !0,
        k = f.isVertexColor(),
        l = f.needUV();
        j = !0;
        var m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L = i.needSmoothNormal(b, f),
        M = 0,
        N = 0,
        O = 0,
        P = 0,
        Q = 0,
        R = 0,
        S = 0,
        T = 0,
        U = 0,
        V = 0,
        W = h.__vertexArray,
        X = h.__uvArray,
        Y = h.__uv2Array,
        Z = h.__normalArray,
        $ = h.__colorArray,
        _ = h.__webglCustomAttributesList,
        aa = h.__faceArray,
        ba = h.__lineArray,
        ca = b,
        da = ca.verticesNeedUpdate,
        ea = ca.elementsNeedUpdate,
        fa = ca.uvsNeedUpdate,
        ga = ca.normalsNeedUpdate,
        ha = (ca.tangentsNeedUpdate, ca.colorsNeedUpdate),
        ia = (ca.morphTargetsNeedUpdate, ca.vertices),
        ja = a.faces3,
        ka = a.faces4,
        la = ca.faces,
        ma = ca.uvs,
        na = ca.uv2s;
        if (ca.colors, ca.skinIndices, ca.skinWeights, ca.morphTargets, ca.morphNormals, da) {
            for (m = 0, n = ja.length; n > m; m++) p = la[ja[m]],
            w = ia[p.a],
            x = ia[p.b],
            y = ia[p.c],
            W[N] = w.x,
            W[N + 1] = w.y,
            W[N + 2] = w.z,
            W[N + 3] = x.x,
            W[N + 4] = x.y,
            W[N + 5] = x.z,
            W[N + 6] = y.x,
            W[N + 7] = y.y,
            W[N + 8] = y.z,
            N += 9;
            for (m = 0, n = ka.length; n > m; m++) p = la[ka[m]],
            w = ia[p.a],
            x = ia[p.b],
            y = ia[p.c],
            z = ia[p.d],
            W[N] = w.x,
            W[N + 1] = w.y,
            W[N + 2] = w.z,
            W[N + 3] = x.x,
            W[N + 4] = x.y,
            W[N + 5] = x.z,
            W[N + 6] = y.x,
            W[N + 7] = y.y,
            W[N + 8] = y.z,
            W[N + 9] = z.x,
            W[N + 10] = z.y,
            W[N + 11] = z.z,
            N += 12;
            g.bindBuffer(g.ARRAY_BUFFER, h.__webglVertexBuffer),
            g.bufferData(g.ARRAY_BUFFER, W, c),
            h.__vertexArray = W
        }
        if (ha && k) {
            for (m = 0, n = ja.length; n > m; m++) p = la[ja[m]],
            s = p.vertexColors,
            t = p.color,
            3 === s.length && k === Yb.VertexColors ? (A = s[0], B = s[1], C = s[2]) : (A = t, B = t, C = t),
            $[T] = A.r,
            $[T + 1] = A.g,
            $[T + 2] = A.b,
            $[T + 3] = B.r,
            $[T + 4] = B.g,
            $[T + 5] = B.b,
            $[T + 6] = C.r,
            $[T + 7] = C.g,
            $[T + 8] = C.b,
            T += 9;
            for (m = 0, n = ka.length; n > m; m++) p = la[ka[m]],
            s = p.vertexColors,
            t = p.color,
            4 === s.length && k === Yb.VertexColors ? (A = s[0], B = s[1], C = s[2], D = s[3]) : (A = t, B = t, C = t, D = t),
            $[T] = A.r,
            $[T + 1] = A.g,
            $[T + 2] = A.b,
            $[T + 3] = B.r,
            $[T + 4] = B.g,
            $[T + 5] = B.b,
            $[T + 6] = C.r,
            $[T + 7] = C.g,
            $[T + 8] = C.b,
            $[T + 9] = D.r,
            $[T + 10] = D.g,
            $[T + 11] = D.b,
            T += 12;
            T > 0 && (g.bindBuffer(g.ARRAY_BUFFER, h.__webglColorBuffer), g.bufferData(g.ARRAY_BUFFER, $, c))
        }
        if (ga && j) {
            for (m = 0, n = ja.length; n > m; m++) if (p = la[ja[m]], q = p.vertexNormals, r = p.normal, 3 === q.length && L) for (E = 0; 3 > E; E++) G = q[E],
            Z[R] = G.x,
            Z[R + 1] = G.y,
            Z[R + 2] = G.z,
            R += 3;
            else for (E = 0; 3 > E; E++) Z[R] = r.x,
            Z[R + 1] = r.y,
            Z[R + 2] = r.z,
            R += 3;
            for (m = 0, n = ka.length; n > m; m++) if (p = la[ka[m]], q = p.vertexNormals, r = p.normal, 4 === q.length && L) for (E = 0; 4 > E; E++) G = q[E],
            null == Z && console.log("normal array is null"),
            Z[R] = G.x,
            Z[R + 1] = G.y,
            Z[R + 2] = G.z,
            R += 3;
            else for (E = 0; 4 > E; E++) Z[R] = r.x,
            Z[R + 1] = r.y,
            Z[R + 2] = r.z,
            R += 3;
            g.bindBuffer(g.ARRAY_BUFFER, h.__webglNormalBuffer),
            g.bufferData(g.ARRAY_BUFFER, Z, c),
            h.__normalArray = Z
        }
        if (fa && ma && l) {
            for (m = 0, n = ja.length; n > m; m++) if (o = ja[m], u = ma[o], u !== e) for (E = 0; 3 > E; E++) H = u[E],
            X[O] = H.x,
            X[O + 1] = H.y,
            O += 2;
            for (m = 0, n = ka.length; n > m; m++) if (o = ka[m], u = ma[o], u !== e) for (E = 0; 4 > E; E++) H = u[E],
            X[O] = H.x,
            X[O + 1] = H.y,
            O += 2;
            O > 0 && (g.bindBuffer(g.ARRAY_BUFFER, h.__webglUVBuffer), g.bufferData(g.ARRAY_BUFFER, X, c), h.uvArray = X)
        }
        if (fa && na && l) {
            for (m = 0, n = ja.length; n > m; m++) if (o = ja[m], v = na[o], v !== e) for (E = 0; 3 > E; E++) I = v[E],
            Y[P] = I.x,
            Y[P + 1] = I.y,
            P += 2;
            for (m = 0, n = ka.length; n > m; m++) if (o = ka[m], v = na[o], v !== e) for (E = 0; 4 > E; E++) I = v[E],
            Y[P] = I.x,
            Y[P + 1] = I.y,
            P += 2;
            P > 0 && (g.bindBuffer(g.ARRAY_BUFFER, h.__webglUV2Buffer), g.bufferData(g.ARRAY_BUFFER, Y, c))
        }
        if (ea) {
            for (m = 0, n = ja.length; n > m; m++) aa[Q] = M,
            aa[Q + 1] = M + 1,
            aa[Q + 2] = M + 2,
            Q += 3,
            ba[S] = M,
            ba[S + 1] = M + 1,
            ba[S + 2] = M,
            ba[S + 3] = M + 2,
            ba[S + 4] = M + 1,
            ba[S + 5] = M + 2,
            S += 6,
            M += 3;
            for (m = 0, n = ka.length; n > m; m++) aa[Q] = M,
            aa[Q + 1] = M + 1,
            aa[Q + 2] = M + 3,
            aa[Q + 3] = M + 1,
            aa[Q + 4] = M + 2,
            aa[Q + 5] = M + 3,
            Q += 6,
            ba[S] = M,
            ba[S + 1] = M + 1,
            ba[S + 2] = M,
            ba[S + 3] = M + 3,
            ba[S + 4] = M + 1,
            ba[S + 5] = M + 2,
            ba[S + 6] = M + 2,
            ba[S + 7] = M + 3,
            S += 8,
            M += 4;
            g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, h.__webglFaceBuffer),
            g.bufferData(g.ELEMENT_ARRAY_BUFFER, aa, c),
            g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, h.__webglLineBuffer),
            g.bufferData(g.ELEMENT_ARRAY_BUFFER, ba, c),
            h.__lineArray = ba
        }
        if (_) for (E = 0, F = _.length; F > E; E++) if (K = _[E], K.__original.needsUpdate) {
            if (U = 0, V = 0, 1 === K.size) {
                if (K.boundTo === e || "vertices" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) p = la[ja[m]],
                    K.array[U] = K.value[p.a],
                    K.array[U + 1] = K.value[p.b],
                    K.array[U + 2] = K.value[p.c],
                    U += 3;
                    for (m = 0, n = ka.length; n > m; m++) p = la[ka[m]],
                    K.array[U] = K.value[p.a],
                    K.array[U + 1] = K.value[p.b],
                    K.array[U + 2] = K.value[p.c],
                    K.array[U + 3] = K.value[p.d],
                    U += 4
                } else if ("faces" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) J = K.value[ja[m]],
                    K.array[U] = J,
                    K.array[U + 1] = J,
                    K.array[U + 2] = J,
                    U += 3;
                    for (m = 0, n = ka.length; n > m; m++) J = K.value[ka[m]],
                    K.array[U] = J,
                    K.array[U + 1] = J,
                    K.array[U + 2] = J,
                    K.array[U + 3] = J,
                    U += 4
                }
            } else if (2 === K.size) {
                if (K.boundTo === e || "vertices" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) p = la[ja[m]],
                    w = K.value[p.a],
                    x = K.value[p.b],
                    y = K.value[p.c],
                    K.array[U] = w.x,
                    K.array[U + 1] = w.y,
                    K.array[U + 2] = x.x,
                    K.array[U + 3] = x.y,
                    K.array[U + 4] = y.x,
                    K.array[U + 5] = y.y,
                    U += 6;
                    for (m = 0, n = ka.length; n > m; m++) p = la[ka[m]],
                    w = K.value[p.a],
                    x = K.value[p.b],
                    y = K.value[p.c],
                    z = K.value[p.d],
                    K.array[U] = w.x,
                    K.array[U + 1] = w.y,
                    K.array[U + 2] = x.x,
                    K.array[U + 3] = x.y,
                    K.array[U + 4] = y.x,
                    K.array[U + 5] = y.y,
                    K.array[U + 6] = z.x,
                    K.array[U + 7] = z.y,
                    U += 8
                } else if ("faces" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) J = K.value[ja[m]],
                    w = J,
                    x = J,
                    y = J,
                    K.array[U] = w.x,
                    K.array[U + 1] = w.y,
                    K.array[U + 2] = x.x,
                    K.array[U + 3] = x.y,
                    K.array[U + 4] = y.x,
                    K.array[U + 5] = y.y,
                    U += 6;
                    for (m = 0, n = ka.length; n > m; m++) J = K.value[ka[m]],
                    w = J,
                    x = J,
                    y = J,
                    z = J,
                    K.array[U] = w.x,
                    K.array[U + 1] = w.y,
                    K.array[U + 2] = x.x,
                    K.array[U + 3] = x.y,
                    K.array[U + 4] = y.x,
                    K.array[U + 5] = y.y,
                    K.array[U + 6] = z.x,
                    K.array[U + 7] = z.y,
                    U += 8
                }
            } else if (3 === K.size) {
                var oa;
                if (oa = "c" === K.type ? ["r", "g", "b"] : ["x", "y", "z"], K.boundTo === e || "vertices" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) p = la[ja[m]],
                    w = K.value[p.a],
                    x = K.value[p.b],
                    y = K.value[p.c],
                    K.array[U] = w[oa[0]],
                    K.array[U + 1] = w[oa[1]],
                    K.array[U + 2] = w[oa[2]],
                    K.array[U + 3] = x[oa[0]],
                    K.array[U + 4] = x[oa[1]],
                    K.array[U + 5] = x[oa[2]],
                    K.array[U + 6] = y[oa[0]],
                    K.array[U + 7] = y[oa[1]],
                    K.array[U + 8] = y[oa[2]],
                    U += 9;
                    for (m = 0, n = ka.length; n > m; m++) p = la[ka[m]],
                    w = K.value[p.a],
                    x = K.value[p.b],
                    y = K.value[p.c],
                    z = K.value[p.d],
                    K.array[U] = w[oa[0]],
                    K.array[U + 1] = w[oa[1]],
                    K.array[U + 2] = w[oa[2]],
                    K.array[U + 3] = x[oa[0]],
                    K.array[U + 4] = x[oa[1]],
                    K.array[U + 5] = x[oa[2]],
                    K.array[U + 6] = y[oa[0]],
                    K.array[U + 7] = y[oa[1]],
                    K.array[U + 8] = y[oa[2]],
                    K.array[U + 9] = z[oa[0]],
                    K.array[U + 10] = z[oa[1]],
                    K.array[U + 11] = z[oa[2]],
                    U += 12
                } else if ("faces" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) J = K.value[ja[m]],
                    w = J,
                    x = J,
                    y = J,
                    K.array[U] = w[oa[0]],
                    K.array[U + 1] = w[oa[1]],
                    K.array[U + 2] = w[oa[2]],
                    K.array[U + 3] = x[oa[0]],
                    K.array[U + 4] = x[oa[1]],
                    K.array[U + 5] = x[oa[2]],
                    K.array[U + 6] = y[oa[0]],
                    K.array[U + 7] = y[oa[1]],
                    K.array[U + 8] = y[oa[2]],
                    U += 9;
                    for (m = 0, n = ka.length; n > m; m++) J = K.value[ka[m]],
                    w = J,
                    x = J,
                    y = J,
                    z = J,
                    K.array[U] = w[oa[0]],
                    K.array[U + 1] = w[oa[1]],
                    K.array[U + 2] = w[oa[2]],
                    K.array[U + 3] = x[oa[0]],
                    K.array[U + 4] = x[oa[1]],
                    K.array[U + 5] = x[oa[2]],
                    K.array[U + 6] = y[oa[0]],
                    K.array[U + 7] = y[oa[1]],
                    K.array[U + 8] = y[oa[2]],
                    K.array[U + 9] = z[oa[0]],
                    K.array[U + 10] = z[oa[1]],
                    K.array[U + 11] = z[oa[2]],
                    U += 12
                } else if ("faceVertices" === K.boundTo) {
                    for (m = 0, n = ja.length; n > m; m++) J = K.value[ja[m]],
                    w = J[0],
                    x = J[1],
                    y = J[2],
                    K.array[U] = w[oa[0]],
                    K.array[U + 1] = w[oa[1]],
                    K.array[U + 2] = w[oa[2]],
                    K.array[U + 3] = x[oa[0]],
                    K.array[U + 4] = x[oa[1]],
                    K.array[U + 5] = x[oa[2]],
                    K.array[U + 6] = y[oa[0]],
                    K.array[U + 7] = y[oa[1]],
                    K.array[U + 8] = y[oa[2]],
                    U += 9;
                    for (m = 0, n = ka.length; n > m; m++) J = K.value[ka[m]],
                    w = J[0],
                    x = J[1],
                    y = J[2],
                    z = J[3],
                    K.array[U] = w[oa[0]],
                    K.array[U + 1] = w[oa[1]],
                    K.array[U + 2] = w[oa[2]],
                    K.array[U + 3] = x[oa[0]],
                    K.array[U + 4] = x[oa[1]],
                    K.array[U + 5] = x[oa[2]],
                    K.array[U + 6] = y[oa[0]],
                    K.array[U + 7] = y[oa[1]],
                    K.array[U + 8] = y[oa[2]],
                    K.array[U + 9] = z[oa[0]],
                    K.array[U + 10] = z[oa[1]],
                    K.array[U + 11] = z[oa[2]],
                    U += 12
                }
            } else if (4 === K.size) if (K.boundTo === e || "vertices" === K.boundTo) {
                for (m = 0, n = ja.length; n > m; m++) p = la[ja[m]],
                w = K.value[p.a],
                x = K.value[p.b],
                y = K.value[p.c],
                K.array[U] = w.x,
                K.array[U + 1] = w.y,
                K.array[U + 2] = w.z,
                K.array[U + 3] = w.w,
                K.array[U + 4] = x.x,
                K.array[U + 5] = x.y,
                K.array[U + 6] = x.z,
                K.array[U + 7] = x.w,
                K.array[U + 8] = y.x,
                K.array[U + 9] = y.y,
                K.array[U + 10] = y.z,
                K.array[U + 11] = y.w,
                U += 12;
                for (m = 0, n = ka.length; n > m; m++) p = la[ka[m]],
                w = K.value[p.a],
                x = K.value[p.b],
                y = K.value[p.c],
                z = K.value[p.d],
                K.array[U] = w.x,
                K.array[U + 1] = w.y,
                K.array[U + 2] = w.z,
                K.array[U + 3] = w.w,
                K.array[U + 4] = x.x,
                K.array[U + 5] = x.y,
                K.array[U + 6] = x.z,
                K.array[U + 7] = x.w,
                K.array[U + 8] = y.x,
                K.array[U + 9] = y.y,
                K.array[U + 10] = y.z,
                K.array[U + 11] = y.w,
                K.array[U + 12] = z.x,
                K.array[U + 13] = z.y,
                K.array[U + 14] = z.z,
                K.array[U + 15] = z.w,
                U += 16
            } else if ("faces" === K.boundTo) {
                for (m = 0, n = ja.length; n > m; m++) J = K.value[ja[m]],
                w = J,
                x = J,
                y = J,
                K.array[U] = w.x,
                K.array[U + 1] = w.y,
                K.array[U + 2] = w.z,
                K.array[U + 3] = w.w,
                K.array[U + 4] = x.x,
                K.array[U + 5] = x.y,
                K.array[U + 6] = x.z,
                K.array[U + 7] = x.w,
                K.array[U + 8] = y.x,
                K.array[U + 9] = y.y,
                K.array[U + 10] = y.z,
                K.array[U + 11] = y.w,
                U += 12;
                for (m = 0, n = ka.length; n > m; m++) J = K.value[ka[m]],
                w = J,
                x = J,
                y = J,
                z = J,
                K.array[U] = w.x,
                K.array[U + 1] = w.y,
                K.array[U + 2] = w.z,
                K.array[U + 3] = w.w,
                K.array[U + 4] = x.x,
                K.array[U + 5] = x.y,
                K.array[U + 6] = x.z,
                K.array[U + 7] = x.w,
                K.array[U + 8] = y.x,
                K.array[U + 9] = y.y,
                K.array[U + 10] = y.z,
                K.array[U + 11] = y.w,
                K.array[U + 12] = z.x,
                K.array[U + 13] = z.y,
                K.array[U + 14] = z.z,
                K.array[U + 15] = z.w,
                U += 16
            } else if ("faceVertices" === K.boundTo) {
                for (m = 0, n = ja.length; n > m; m++) J = K.value[ja[m]],
                w = J[0],
                x = J[1],
                y = J[2],
                K.array[U] = w.x,
                K.array[U + 1] = w.y,
                K.array[U + 2] = w.z,
                K.array[U + 3] = w.w,
                K.array[U + 4] = x.x,
                K.array[U + 5] = x.y,
                K.array[U + 6] = x.z,
                K.array[U + 7] = x.w,
                K.array[U + 8] = y.x,
                K.array[U + 9] = y.y,
                K.array[U + 10] = y.z,
                K.array[U + 11] = y.w,
                U += 12;
                for (m = 0, n = ka.length; n > m; m++) J = K.value[ka[m]],
                w = J[0],
                x = J[1],
                y = J[2],
                z = J[3],
                K.array[U] = w.x,
                K.array[U + 1] = w.y,
                K.array[U + 2] = w.z,
                K.array[U + 3] = w.w,
                K.array[U + 4] = x.x,
                K.array[U + 5] = x.y,
                K.array[U + 6] = x.z,
                K.array[U + 7] = x.w,
                K.array[U + 8] = y.x,
                K.array[U + 9] = y.y,
                K.array[U + 10] = y.z,
                K.array[U + 11] = y.w,
                K.array[U + 12] = z.x,
                K.array[U + 13] = z.y,
                K.array[U + 14] = z.z,
                K.array[U + 15] = z.w,
                U += 16
            }
            g.bindBuffer(g.ARRAY_BUFFER, K.buffer),
            g.bufferData(g.ARRAY_BUFFER, K.array, c)
        }
        d && gc.deleteGroupBufferData(a)
    },
    gc.buildLineBufferData = function(a, b, c, d) {
        var f, g, h, i, j, k, l, m, n, o, p, q, r = a,
        s = r.vertices,
        t = r.colors,
        u = r.lineDistances,
        v = s.length,
        w = t.length,
        x = u.length,
        y = d.__vertexArray,
        z = d.__colorArray,
        A = d.__lineDistanceArray,
        B = r.verticesNeedUpdate,
        C = r.colorsNeedUpdate,
        D = r.lineDistancesNeedUpdate,
        E = r.__webglCustomAttributesList;
        if (B) {
            for (f = 0; v > f; f++) i = s[f],
            j = 3 * f,
            y[j] = i.x,
            y[j + 1] = i.y,
            y[j + 2] = i.z;
            c.bindBuffer(c.ARRAY_BUFFER, d.__webglVertexBuffer),
            c.bufferData(c.ARRAY_BUFFER, y, b)
        }
        if (C) {
            for (g = 0; w > g; g++) k = t[g],
            j = 3 * g,
            z[j] = k.r,
            z[j + 1] = k.g,
            z[j + 2] = k.b;
            c.bindBuffer(c.ARRAY_BUFFER, d.__webglColorBuffer),
            c.bufferData(c.ARRAY_BUFFER, z, b)
        }
        if (D) {
            for (h = 0; x > h; h++) A[h] = u[h];
            c.bindBuffer(c.ARRAY_BUFFER, d.__webglLineDistanceBuffer),
            c.bufferData(c.ARRAY_BUFFER, A, b)
        }
        if (E) for (l = 0, m = E.length; m > l; l++) if (q = E[l], q.needsUpdate && (q.boundTo === e || "vertices" === q.boundTo)) {
            if (j = 0, o = q.value.length, 1 === q.size) for (n = 0; o > n; n++) q.array[n] = q.value[n];
            else if (2 === q.size) for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.x,
            q.array[j + 1] = p.y,
            j += 2;
            else if (3 === q.size) if ("c" === q.type) for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.r,
            q.array[j + 1] = p.g,
            q.array[j + 2] = p.b,
            j += 3;
            else for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.x,
            q.array[j + 1] = p.y,
            q.array[j + 2] = p.z,
            j += 3;
            else if (4 === q.size) for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.x,
            q.array[j + 1] = p.y,
            q.array[j + 2] = p.z,
            q.array[j + 3] = p.w,
            j += 4;
            c.bindBuffer(c.ARRAY_BUFFER, q.buffer),
            c.bufferData(c.ARRAY_BUFFER, q.array, b)
        }
    },
    gc.buildLineBufferData = function(a, b, c, d) {
        var f, g, h, i, j, k, l, m, n, o, p, q, r = a,
        s = r.vertices,
        t = r.colors,
        u = r.lineDistances,
        v = s.length,
        w = t.length,
        x = u.length,
        y = d.__vertexArray,
        z = d.__colorArray,
        A = d.__lineDistanceArray,
        B = r.verticesNeedUpdate,
        C = r.colorsNeedUpdate,
        D = r.lineDistancesNeedUpdate,
        E = r.__webglCustomAttributesList;
        if (B) {
            for (f = 0; v > f; f++) i = s[f],
            j = 3 * f,
            y[j] = i.x,
            y[j + 1] = i.y,
            y[j + 2] = i.z;
            c.bindBuffer(c.ARRAY_BUFFER, d.__webglVertexBuffer),
            c.bufferData(c.ARRAY_BUFFER, y, b)
        }
        if (C) {
            for (g = 0; w > g; g++) k = t[g],
            j = 3 * g,
            z[j] = k.r,
            z[j + 1] = k.g,
            z[j + 2] = k.b;
            c.bindBuffer(c.ARRAY_BUFFER, d.__webglColorBuffer),
            c.bufferData(c.ARRAY_BUFFER, z, b)
        }
        if (D) {
            for (h = 0; x > h; h++) A[h] = u[h];
            c.bindBuffer(c.ARRAY_BUFFER, d.__webglLineDistanceBuffer),
            c.bufferData(c.ARRAY_BUFFER, A, b)
        }
        if (E) for (l = 0, m = E.length; m > l; l++) if (q = E[l], q.needsUpdate && (q.boundTo === e || "vertices" === q.boundTo)) {
            if (j = 0, o = q.value.length, 1 === q.size) for (n = 0; o > n; n++) q.array[n] = q.value[n];
            else if (2 === q.size) for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.x,
            q.array[j + 1] = p.y,
            j += 2;
            else if (3 === q.size) if ("c" === q.type) for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.r,
            q.array[j + 1] = p.g,
            q.array[j + 2] = p.b,
            j += 3;
            else for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.x,
            q.array[j + 1] = p.y,
            q.array[j + 2] = p.z,
            j += 3;
            else if (4 === q.size) for (n = 0; o > n; n++) p = q.value[n],
            q.array[j] = p.x,
            q.array[j + 1] = p.y,
            q.array[j + 2] = p.z,
            q.array[j + 3] = p.w,
            j += 4;
            c.bindBuffer(c.ARRAY_BUFFER, q.buffer),
            c.bufferData(c.ARRAY_BUFFER, q.array, b)
        }
    },
    gc.deleteGroupBufferData = function(a) {
        delete a.__inittedArrays,
        delete a.__colorArray,
        delete a.__normalArray,
        delete a.__tangentArray,
        delete a.__uvArray,
        delete a.__uv2Array,
        delete a.__faceArray,
        delete a.__vertexArray,
        delete a.__lineArray,
        delete a.__skinIndexArray,
        delete a.__skinWeightArray
    },
    gc.getMaterial = function(a, b) {
        var c = a.material;
        return c instanceof Yb.ArrayMaterial ? (b > c.materials.length - 1 && (b = c.materials.length - 1), c.materials[b]) : c
    },
    Yb.FontUtils = {
        faces: {},
        face: "helvetiker",
        weight: "normal",
        style: "normal",
        size: 150,
        divisions: 10,
        getFace: function() {
            return this.faces[this.face][this.weight][this.style]
        },
        loadFace: function(a) {
            var b = a.familyName.toLowerCase(),
            c = this;
            return c.faces[b] = c.faces[b] || {},
            c.faces[b][a.cssFontWeight] = c.faces[b][a.cssFontWeight] || {},
            c.faces[b][a.cssFontWeight][a.cssFontStyle] = a,
            c.faces[b][a.cssFontWeight][a.cssFontStyle] = a,
            a
        },
        drawText: function(a) {
            var b, c = this.getFace(),
            d = this.size / c.resolution,
            e = 0,
            f = String(a).split(""),
            g = f.length,
            h = [];
            for (b = 0; g > b; b++) {
                var i = new Yb.Path,
                j = this.extractGlyphPoints(f[b], c, d, e, i);
                e += j.offset,
                h.push(j.path)
            }
            var k, l, m, n = e / 2;
            for (b = 0; g > b; b++) {
                var i = h[b];
                for (m = 0; m < i.actions.length; m++) {
                    var k = i.actions[m].args;
                    for (l = 0; l < k.length; l++) l % 3 === 0 && (k[l] -= n)
                }
            }
            return {
                paths: h,
                offset: n
            }
        },
        extractGlyphPoints: function(a, b, c, d, e, f) {
            var g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z = [],
            A = b.glyphs[a] || b.glyphs["?"],
            B = 0;
            if (A) {
                if (A.o) for (j = A._cachedOutline || (A._cachedOutline = A.o.split(" ")), l = j.length, m = c, n = c, g = 0; l > g;) switch (k = j[g++]) {
                case "m":
                    o = j[g++] * m + d,
                    p = j[g++] * n - B,
                    e.moveTo(o, p, 0);
                    break;
                case "l":
                    o = j[g++] * m + d,
                    p = j[g++] * n - B,
                    e.lineTo(o, p, 0);
                    break;
                case "q":
                    if (q = j[g++] * m + d, r = j[g++] * n - B, u = j[g++] * m + d, v = j[g++] * n - B, e.quadraticCurveTo(u, v, 0, q, r, 0), y = z[z.length - 1]) for (s = y.x, t = y.y, h = 1, i = this.divisions; i >= h; h++) {
                        var C = h / i;
                        Yb.Shape.Utils.b2(C, s, u, q),
                        Yb.Shape.Utils.b2(C, t, v, r)
                    }
                    break;
                case "b":
                    if (q = j[g++] * m + d, r = j[g++] * n - B, u = j[g++] * m + d, v = j[g++] * -n - B, w = j[g++] * m + d, x = j[g++] * -n - B, e.bezierCurveTo(q, r, 0, u, v, 0, w, x, 0), y = z[z.length - 1]) for (s = y.x, t = y.y, h = 1, i = this.divisions; i >= h; h++) {
                        var C = h / i;
                        Yb.Shape.Utils.b3(C, s, u, w, q),
                        Yb.Shape.Utils.b3(C, t, v, x, r)
                    }
                }
                return {
                    offset: A.ha * c,
                    path: e
                }
            }
        }
    },
    Yb.FontUtils.generateShapes = function(a, b) {
        b = b || {};
        var c = b.size !== e ? b.size: 100,
        d = b.curveSegments !== e ? b.curveSegments: 4,
        f = b.font !== e ? b.font: "helvetiker",
        g = b.weight !== e ? b.weight: "normal",
        h = b.style !== e ? b.style: "normal";
        Yb.FontUtils.size = c,
        Yb.FontUtils.divisions = d,
        Yb.FontUtils.face = f,
        Yb.FontUtils.weight = g,
        Yb.FontUtils.style = h;
        for (var i = Yb.FontUtils.drawText(a), j = i.paths, k = [], l = 0, m = j.length; m > l; l++) Array.prototype.push.apply(k, j[l].toShapes());
        return k
    },
    function(a) {
        var b = 1e-10,
        c = function(a, b) {
            var c = a.length;
            if (3 > c) return null;
            var f, g, h, i = [],
            j = [],
            k = [];
            if (d(a) > 0) for (g = 0; c > g; g++) j[g] = g;
            else for (g = 0; c > g; g++) j[g] = c - 1 - g;
            var l = c,
            m = 2 * l;
            for (g = l - 1; l > 2;) {
                if (m--<=0) return console.log("Warning, unable to triangulate polygon!"),
                b ? k: i;
                if (f = g, f >= l && (f = 0), g = f + 1, g >= l && (g = 0), h = g + 1, h >= l && (h = 0), e(a, f, g, h, l, j)) {
                    var n, o, p, q, r;
                    for (n = j[f], o = j[g], p = j[h], i.push([a[n], a[o], a[p]]), k.push([j[f], j[g], j[h]]), q = g, r = g + 1; l > r; q++, r++) j[q] = j[r];
                    l--,
                    m = 2 * l
                }
            }
            return b ? k: i
        },
        d = function(a) {
            for (var b = a.length,
            c = 0,
            d = b - 1,
            e = 0; b > e; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
            return.5 * c
        },
        e = function(a, c, d, e, f, g) {
            var h, i, j, k, l, m, n, o, p;
            if (i = a[g[c]].x, j = a[g[c]].y, k = a[g[d]].x, l = a[g[d]].y, m = a[g[e]].x, n = a[g[e]].y, b > (k - i) * (n - j) - (l - j) * (m - i)) return ! 1;
            var q, r, s, t, u, v, w, x, y, z, A, B, C, D, E;
            for (q = m - k, r = n - l, s = i - m, t = j - n, u = k - i, v = l - j, h = 0; f > h; h++) if (h !== c && h !== d && h !== e && (o = a[g[h]].x, p = a[g[h]].y, w = o - i, x = p - j, y = o - k, z = p - l, A = o - m, B = p - n, E = q * z - r * y, C = u * x - v * w, D = s * B - t * A, E >= -b && D >= -b && C >= -b)) return ! 1;
            return ! 0
        };
        return a.Triangulate = c,
        a.Triangulate.area = d,
        a
    } (Yb.FontUtils),
    self._typeface_js = {
        faces: Yb.FontUtils.faces,
        loadFace: Yb.FontUtils.loadFace
    },
    Yb.typeface_js = self._typeface_js;
    var jc = {
        easeNone: function(a, b, c, d) {
            return c * a / d + b
        },
        easeIn: function(a, b, c, d) {
            return c * (a /= d) * a + b
        },
        easeOut: function(a, b, c, d) {
            return - c * (a /= d) * (a - 2) + b
        },
        easeBoth: function(a, b, c, d) {
            return (a /= d / 2) < 1 ? c / 2 * a * a + b: -c / 2 * (--a * (a - 2) - 1) + b
        },
        easeInStrong: function(a, b, c, d) {
            return c * (a /= d) * a * a * a + b
        },
        easeOutStrong: function(a, b, c, d) {
            return - c * ((a = a / d - 1) * a * a * a - 1) + b
        },
        easeBothStrong: function(a, b, c, d) {
            return (a /= d / 2) < 1 ? c / 2 * a * a * a * a + b: -c / 2 * ((a -= 2) * a * a * a - 2) + b
        },
        elasticIn: function(a, b, c, d, e, f) {
            var g;
            return 0 === a ? b: 1 === (a /= d) ? b + c: (f || (f = .3 * d), !e || e < Math.abs(c) ? (e = c, g = f / 4) : g = f / (2 * Math.PI) * Math.asin(c / e), -(e * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a * d - g) * Math.PI / f)) + b)
        },
        elasticOut: function(a, b, c, d, e, f) {
            var g;
            return 0 === a ? b: 1 === (a /= d) ? b + c: (f || (f = .3 * d), !e || e < Math.abs(c) ? (e = c, g = f / 4) : g = f / (2 * Math.PI) * Math.asin(c / e), e * Math.pow(2, -10 * a) * Math.sin(2 * (a * d - g) * Math.PI / f) + c + b)
        },
        elasticBoth: function(a, b, c, d, e, f) {
            var g;
            return 0 === a ? b: 2 === (a /= d / 2) ? b + c: (f || (f = .3 * d * 1.5), !e || e < Math.abs(c) ? (e = c, g = f / 4) : g = f / (2 * Math.PI) * Math.asin(c / e), 1 > a ? -.5 * e * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a * d - g) * Math.PI / f) + b: e * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a * d - g) * Math.PI / f) * .5 + c + b)
        },
        backIn: function(a, b, c, d, f) {
            return f === e && (f = 1.70158),
            a === d && (a -= .001),
            c * (a /= d) * a * ((f + 1) * a - f) + b
        },
        backOut: function(a, b, c, d, e) {
            return "undefined" == typeof e && (e = 1.70158),
            c * ((a = a / d - 1) * a * ((e + 1) * a + e) + 1) + b
        },
        backBoth: function(a, b, c, d, e) {
            return "undefined" == typeof e && (e = 5.70158),
            (a /= d / 2) < 1 ? c / 2 * a * a * (((e *= 1.525) + 1) * a - e) + b: c / 2 * ((a -= 2) * a * (((e *= 1.525) + 1) * a + e) + 2) + b
        },
        bounceIn: function(a, b, c, d) {
            return c - jc.bounceOut(d - a, 0, c, d) + b
        },
        bounceOut: function(a, b, c, d) {
            return (a /= d) < 1 / 2.75 ? 7.5625 * c * a * a + b: 2 / 2.75 > a ? c * (7.5625 * (a -= 1.5 / 2.75) * a + .75) + b: 2.5 / 2.75 > a ? c * (7.5625 * (a -= 2.25 / 2.75) * a + .9375) + b: c * (7.5625 * (a -= 2.625 / 2.75) * a + .984375) + b
        },
        bounceBoth: function(a, b, c, d) {
            return d / 2 > a ? .5 * jc.bounceIn(2 * a, 0, c, d) + b: .5 * jc.bounceOut(2 * a - d, 0, c, d) + .5 * c + b
        }
    },
    kc = function() {
        if (this._as = [], 1 === arguments.length) {
            var a = arguments[0];
            if (a instanceof kc && (a = a._as), a instanceof Array) for (var b = a.length,
            c = 0; b > c; c++) this._as.push(a[c]);
            else null != a && this._as.push(a)
        } else if (arguments.length > 1) for (b = arguments.length, c = 0; b > c; c++) this._as.push(arguments[c])
    };
    Yb.List = kc,
    Yb.extend(Yb.List, Object, {
        size: function() {
            return this._as.length
        },
        isEmpty: function() {
            return 0 === this._as.length
        },
        add: function(a, b) {
            return b === e ? this._as.push(a) : this._as.splice(b, 0, a)
        },
        addAll: function(a) {
            if (a instanceof kc && (a = a._as), a instanceof Array) for (var b = a.length,
            c = 0; b > c; c++) this._as.push(a[c]);
            else this._as.push(a)
        },
        get: function(a) {
            return this._as[a]
        },
        remove: function(a) {
            var b = this._as.indexOf(a);
            return b >= 0 && b < this._as.length && this.removeAt(b),
            b
        },
        removeAt: function(a) {
            return this._as.splice(a, 1)[0]
        },
        set: function(a, b) {
            return this._as[a] = b
        },
        clear: function() {
            return this._as.splice(0, this._as.length)
        },
        contains: function(a) {
            return this.indexOf(a) >= 0
        },
        indexOf: function(a) {
            return this._as.indexOf(a)
        },
        forEach: function(a, b) {
            for (var c = this._as.length,
            d = 0; c > d; d++) {
                var e = this._as[d];
                b ? a.call(b, e) : a(e)
            }
        },
        forEachReverse: function(a, b) {
            for (var c = this._as.length,
            d = c - 1; d >= 0; d--) {
                var e = this._as[d];
                b ? a.call(b, e) : a(e)
            }
        },
        toArray: function(a, b) {
            if (a) {
                for (var c = [], d = this._as.length, e = 0; d > e; e++) {
                    var f = this._as[e];
                    b ? a.call(b, f) && c.push(f) : a(f) && c.push(f)
                }
                return c
            }
            return this._as.concat()
        },
        toList: function(a, b) {
            if (a) {
                for (var c = new kc,
                d = this._as.length,
                e = 0; d > e; e++) {
                    var f = this._as[e];
                    b ? a.call(b, f) && c.add(f) : a(f) && c.add(f)
                }
                return c
            }
            return new kc(this)
        },
        sort: function(a) {
            return a ? this._as.sort(a) : this._as.sort(),
            this
        },
        toString: function() {
            return this._as.toString()
        }
    }),
    Yb.ImageCache = function() {};
    var lc = Yb.ImageCache;
    lc.AlarmBillboardImage = new Image,
    lc.AlarmBillboardImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAABrCAYAAAAy/A+bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAABoKSURBVHja3F17jFxXff7O4z7n6fXa3uw6TuI81KiYFhRIpKA2iVBBaUNRvQlxSloQpNSiKaUgolR1wBRKCrRNWilIkIQKFSIcLw0EQitEmgImJXJL3ZgQk7h1nX16Z3fnPfd9+8fec3PmzJ31PmY3gSNdzezOzH189/f4fo9zLonjGFljYmICWzhyAC4GcAkAC8A2ACYAB4ALoA1gHsAUgDMA/M0+of379/f9jGPrRw7ArwG4lhDyRsbYaxljuwghIIQAAOI47novXpMtiKLohSiKfhzH8b8D+FcAJ7fyArYKtBKAmwkhN2uadh1jTBegyMD0AalrI4RwSumVjLEroyi6LfnuZBiGXwdwBMD3ft5Bu4YQ8j5N025hjNmU0hQQSmkqTYQQRFGEKIq6fkwI6ZI68XcYhoiiCGEYin3tZoy9H8D7oyh6Po7jhwE8BGDx5wm06wkhh0zTvF6AE8cxGGMpaEEQdF14lrTJ4KnvCSHQdR2UUvi+jyAIEAQBOOe/RCn9dBzHh4IgeIAx9jcAzr2aQXsNIeTvDcO4jnOeXhylFHEcpxcXRVGXyp1v9ANRSCYhBJxz6LqOMAzhui4AFDjndwG4MwzDexljnwXQeTWBVgDwSV3XD+q6zgGk6hcEAVzXTSVKVUEB4GqHAEzcCPE/oeKEENi2jTAM0el0AMDmnH88iqJ3x3H8x4yxb74aQLuGMfaPhmFcyhhLL0BIlbA/MmDiYsMwhOd56XdkAMV3BfhCYiml0DQNmqZ1qaqwl7IdzOVyCMMQzWYTjLFLOOePB0HwBUrpBymlrVcCNALgz3Rd/5iu61zYLN/34XleFwiyOnqeB9/34fs+wjBEu92G4zjodDpwXTcFOgxDiJvAGIOmaTBNE5ZlIZfLwTAMUErBOYdhGOCcd0mhDF6xWITrunAcB5zzOwgh14dh+DuMsWe3EjSLEPJF0zTfwRhL77LjOPB9vwcsoaK+78N1XSwtLaFWq6FaraYqtZYRxzEsy0KhUMD27dtRKBRS6TNNMwVLgEcpha7r0DQN9XodYRhepmnaD+M4fifn/OtbAdp2Qsi3Lct6gzDAQrqCIOgBSwBZq9UwNzeHpaWlLvskHIaQkH5DtYVCcs6dOwfTNDE0NISRkRG4rgvDMGAYRuqxwzBMASyXy2g0Guh0Onld178WRdGHOOf3rXTsjYK2kzH2HcMwXitUw3XdVB0FhwrDEI7jwPM8LC4uYnp6Gq1Wq8f+yHYoCzj5uzJosucVdnFmZgazs7MYHh7G2NgYLMuCYRgwTbPH9uXzeTiOg1arRXVd/9s4ji1N0z61WuDWAtoOxthTpmleCQCMsVSKZGPvui5c10Wr1cKZM2dQq9Ugvi+DJNsfSmn6uaxWqtqqNEXcIHmbn59HpVLB6OgoRkdHEYYhTNMEYwyMsdQcmKYJSilqtRp0Xf/LKIqoruufFFxyEKDZhJDHDcO4EgA45+h0OinnEiTVcRy4rovJyUlMTU11gSVAEJsw7uJi5O/JxlzlairHE8cWDkRI/fT0NBYWFnDppZeiVCrBNE3oup4eGwB0XUe5XMbS0hJ0Xf8LAGd0Xf/y+YDjq/SSj5imebU4oAyYuMOdTgftdhunT59GrVbrAUtIFOc8BYxznv5fBanfkFVIlbg4jmEYRuqdfd/Hc889h4suuggjIyOIogimaaY2TtCXUqmExcVFYhjGw4SQGULIkxsF7S7Lst4mAHMcpwsw3/fhOA7q9TpOnToFz/NSwGTQdF1PWbsArh9QWWqZ9ZmQNrE/8Z5zDk3TUm89NTWFVquFvXv3IooiWJbVdRMMw0CxWES9XtcBHKGUvg7AS32l6Dz5tGt1XX+KL4+UNqiALS0t4YUXXkAURV1gCbXTNA26rkPX9S7bNoihZkWECotz9DwPnufBdV3k83ns3bsXtm3DsqwuDSCEoFarodVqwTTNH9i2fd2tt94aZkr7SqERY+zLjDEuB8WyDXFdF7VaDadOneoCTBh2TdNgWVZ6kpqm9TiDQW1ZN0vXdZimCdu2Ydt2aj4EmVaJd6lUAmMMruu+qdPp/HlfE7ECaPdqmnaRYNYi3BGe0nVdNBoNnDp1qsvgC8AMw4BlWbAsK81GqJ5zEEPen0poBQ8UpNe2bbiuizNnzsDzPDiO0+ORh4eHhYTe/aUvfemKVYM2MTFxlaZp7xN3TQ6LAMDzPHQ6HTz//POIoqgLMPkEZekaNFj9wOsneSLcsiwLnU4H09PTKSmX01OMMZTLZXieZ3Q6nc995StfIatyBISQT1NKGaW0Z6eCzJ4+fRpBEKSAiRPTdR22bXep4lYPOXUkczP55lWrVeTzeQwNDUGmGIL8tlot+L5/g+M4NwH4xoqOYGJi4npd15+UvaVKLaampnD27NkULBUwwYfOFxpt5pAzKmoEIRKWnufhiiuugGVZKQEW5+z7PqampmAYxolCofC622+/Pe6rnoSQjwsbJTylOAHf99Fut3sAE0ZXACar6ys1ZPuqkmpBSzjnmJ6eRhRFaWQjhqZpsG0bvu//SqfT2d/Xpk1MTLyBc/4mORcv7pYgi2fOnOmxF8JLCcBebUMGTgZU0zR0Oh00m82uJKnQvm3btiGKInie96GVHMFBWTzlnFgQBKhWq2g0Gl0H5Zz3ALYR6lAqlbBnzx5ceOGF2L17N3bs2NGToV3rJgOXxSFnZ2cBIM3SiONJ0nbN5z//+Tf2OIKJiYltjLFb5dBELoKEYYjp6en0wEIFTdOEYRjQdT2Tza9lvP71r8cNN9zQ8//Z2Vk8+OCDXdRlvRIn1xVkLarX6yiVSl0ZZkopisUims0mHMd5L4BnVEm7iRBiUUoRBEHXwUTKuNlspictuJhhGGnqeaOUQgCvjpGREdRqNfi+v2E6ooZ3wsYtLCyAEJKqqQDUNE1omoYgCMYfeughXQXt7XLSTq0vzs3NZTLuraIWjuN0Ger1gieDJoMnQsKsEC2fzyOKom2O41yXgjYxMWFRSt+qxnBCz4MgwNLSUpdqilhSzrxu5lhtuW+14Mk2TrwXuT+VsuRyOXHjbpRt2huTvH9PyjqKIlSr1bQqLrPrQdix9ajYIGmJuC5KKer1Oi644II0jpbpB6UUURT9egpaFEXXCjslOwDxWqvV0rsjFyk240KyRlK/HMix5DYHkU4SAIokhG3bXRGFKAfW6/V9DzzwQIkmP3iduhPhAKIoQrPZ7EkkipLZVkiZINODOJYa4MsOgnOOdrsNtYNJVL/iOGau6+4T6vnLWXYjiqK0QCLXIIXr34yMRb//iyzvII4npE2oplxGbLfbmclPTdOEIL2GT0xMaAAul7mZbAQdx+kymrLHlKtFmwVaHMeIJHs6qOMJ4i6He+J6ZUlMCW2iWVEUXUkBjArbltW5kzSTdEUBagluUKNer2cABkQD8por9YXI/SBqjVWk0ZPPL+EAdvcryIpUkMxx1DhukOrZaDRetqdRjBgxwihCpPSoDcpzCrVU9+15XpczEF5W13UEQbCbh2E4KnQ2K9/u+35XzkwlhpvBx5alaxmsKIoRhvGmSVlWaVEVHllF4zge5QCKAvGsL8uxmuBoqrQN8kIiLAMWRomURTGiONqUVLmQNpmzqbREjV3jOLY5AFvOImSxbtklZ2UQBogaoihCECagxUmrQ3IRm+GtVTWV+9yEd1VAK/A4jnP9xFG1IZvOyeIYYRQjSKQrSqRtcWFxyzihKtFZNVcex7HfL6ZTg1o1QzBwzJKTDKNw2REkUlZdWtwUG6p2VQqpW4kVxHEccACLsi5nGT/VLW+m5C3bsmUJEyBCCuG2oqKVlYSQ8mxVDmBGTm2rOxFMuB/NGOhFEJI4AQkwAHSFTqKNeOl+Q9hu9TtJsXyBEkLOytGA6oblvgfZMG6Gii4tLCzTDInyUEJAN0G6Vjp30ZraowVhCELIS1wGTS2KiOysfAAR+W+GpAVBAIKXpZkRAkYp2IBvVD+GIAhsFtEX0VEcx/9Hb7nlliaAKVnSZAoimHG/A8kh1kY3xhhAlqWLUwqNM+icgTM6sGOoM2XU+Nm27S7PKYPn+z4IIado8uNn5bqAfEc557Btu6tRRAVskIOCQGMMutg4AyUDPoYUoKvA5HK5noq7ACwhvc+KszkRBEEPAKJmUCqVBp5y7us9Qx8aY9D48sYpxdLS1vE0y7JSCiJfq+hnoZT+F0+k5piwKUKEhboyxlAsFjE3N5emwlcKNTY6Jo4cwa5du8AZBxDjxRdfxOTkJMrl8qbm7kQXpWEYmUyi0+kgiqL/PXTo0CxPgPkhpTT2fZ8YhtGz43w+D8MweoxjVnf2RofrODj1/PPp1CBCCIaGhmBZVtcEi0EVaWRpKpVK4Jx3CYcY7XYbQRAcWzYhAA4cOLBAKT3heV6PXQvDEJxzbN++fTkuTBr7sjzMIJrzbNvG5Zdfjje/+c24+uqrsXfv3vSmZTU8r7XSroIhA1gqlVIvqqb9XdcFpfRJuRoFAP/suu6vFgqFTCB27tyJSqWSdt2o9m8QEpDP57F///6eovFTTz2FkydPdnUjbTRrqzq0crks8mU9oCU115hS+i+ppCUq+oTwEqpXDIIAmqZh586d8DyvR7RVr7rebd++fZlV9muuuQaNRiNV1/VIWD/wRGF8+/btXekheSQNMicOHTo03QUa5/wYY2xWlMtU0iekTQCrTjnsV+VZyzY0NJR5caZpCpuyLsD61R7Eq5hnIGiFanZarRbCMDz6Mi1KxoEDByJK6dfk0rxM/nzfh67rGB0dTZuW1QNs1KOuRGdkW7rRcEkuHBFCsGvXrq76gHweSUckGGOP9oCWSNsjoiKT5R2jKMLw8DA0TeuaoykXIzbC4+QawSDT52onpDyHa2RkBJqmpWZHvTGNRgNBEPzHPffc87N+oB1jjJ2SVVQWcVFkufjii9MmP9V9q0Z0LaokOsXV8cwzz/SdLrRaT6m2vwNAoVDA0NBQpoQJr5mo5he7oxZp3HbbbTHn/B8ER1LzaAI40zQxNjbWI21ZgK1lzM3N4ciRI3j66adx+vRpnDx5Eo899hieeOKJlKdtRO3lsIkxhrGxMRBCuqRMlrRmswnP8zqMsUe6hEs9gK7rDzqO87FOp2Pk8/keiRFzCMrlMlzXRb1eT4mvHNOtJ+fGOcfS0hImJyfT6USCu6kN0Ku1jTJQYiOE4MILL0wnxsmeVN7/0tISfN8/cvjw4cW+kgYAt99+e4Vz/lXZvqiiLybEjo6Oolgspmoqt873Y93nm3Wi6zpKpRK2b9+OHTt2YMeOHdi2bRts2+5pOs6iFVlSpS5lsWfPHti2nU6+kCVM3Ph2uy3M0d/1JhWyk3D3iR/KO5JVVXiVsbGxdIK9fHKquq7WQYhSoZgoIToRV5NNUac3qk4qiiLs2bMHuVwubfWXz1mVsiAIvn/48OH/XBVo73rXu37MGPvOStJGCEGj0YDv+9izZw8KhUIKnDx5X7V3a11SYlXFZWX//baLL74YhUIhXWBABkwWDjHJNwzDT2enr/oMXdf/SsxB7ydtwHL/heu62L17N3bu3Nklaf1WTMhS4fVSiCyw5MmzwuhfdtllyOfz6HQ6qTmRuZ8sZYuLi/B9/yTn/FuZtneFPPl3Hcf5Qa1We5Npmn1L+XEcixUIMDw8jHw+j7Nnz2YmLbNWRlALGCux95UyFbIEy9PDi8Uidu/enXpDWSVlwIRQeJ4nQrZPHD58OF4TaLquwzCMj7bb7e86jpPO+RazcuUeL5k5Dw0N4YorrsDs7Gy6MoL4br95Bv0AXIk6ZPFCGSxKKXbv3i0mh6HdbnfNiRCACecixsLCAnzfPylHAKsGLTHGTzqO82S1Wr1hZGRkRWkTd6lSqaBQKGBsbAzDw8OYmppKvZR8V+OMVoOVwrCVkgQqOR0eHsYFF1yQMno5ppQlTJ4LJWxZImWHDh8+HK0ZNFHKMk3zrlar9Uyr1SK5XK5L2rIuRnSCdzodbNu2DZdffjlarRZmZ2dTbywvNqKmaFYLWtYiTzt27MDw8HDKv4SHlCeSyUZflfRKpQLf948xxh5bkU+u9CFjDKZpHncc56u1Wu1W0RouGprlBhKVUDqOg7m5OViWhXK5jMsuuwy+72NhYUGQxq5UjwpYv/U4VLUUoZBIIDqOg0aj0QWWLGFyw7V8nFarhWazGYdh+BG51rtm0IRtsyzrrnq9/rZqtWqXy+W+FEQFTsRurutC0zQUCgWMjIxgbGwsnchVr9fTpSlk0PpNtBDTuwuFAgqFQnoDm81mV8pKBUtufZd70cSYn5+H7/uPcM5/KMqW6wYtsW1nNU37bL1evyefz6dNw+JEVKcgv5fnVonlczRNQy6Xw9DQEIaHh1NplVe4EqCJY4m1hGSD32q1ulafkT8TPDGLZ6pEOTEn7SiK7hYh24ZAE9KWy+Xurdfrty8sLFyya9euTKcgN8mpwKmTVD3PS+cnyLNgxMw+UeARFy9LkqquMjeUDf1KgAkp830flUoFnud9Qtf1syIK2TBoibR1NE27s9PpfLPdbsO27R6nIDfDrURM5eBYrnyLwk5WIbqfbZPVL6uYLXvsfsbf87yfMsb+2jRN5HK5vhPb1gSaUJN8Pv+tIAgerVQqN4+NjXVxnCzbtloAs/bRrzaZRTlW4nb9EgOC7Nbr9TgMw4OGYXi5XK5rWnb/LoBVDhFEm6b5R3EcVwRxzZrRpq5MtdrQSF7zo98mx7T9wrB+M1LkcwvDEOfOnYPrul/gnP+bWMxuNTOj19QkQSmFbdvndF3/k2azmeaiZPc9yOa/9cSoq1XLc+fOwXGcaQAfMU0ThUIBhmFsDmi6riOfz3+ZUvr4wsJCl+FXJW6remT7AdZPyoRa+r7/Xl3Xa2INkdVmhtfcjpMQXti2/YdBECwtLi72MOysVaq2EkDVwcjaEASBUMuHOOfftiwL+Xw+pTObApoALpfLTRuG8b5Go5Guwpdl37YKuJVqrrLKzc3NwXGc/wHwQdM005aHtazysC7QhJrmcrlHKaUPz8/Pp/PeVfu2FRLXz46px65Wq2g2m6Hv++/Udb2Zy+XSNPqarn+9J8oYQyLaHwDws3Pnzp23DrCVdkz15K7rYn5+Ho7jfFTTtKdt20Y+n1/XCgwbajFkjMG27aZpmr/ruq6n2rfNlrbzSZhML6anp+F53pOMsXuFt1wNJxs4aJI3Pc4Yu6tarXYVYzbK3zYiYTIYCb2YDcPwnbquh/l8HrZtr7uOuuFmVuFNi8XifYSQR0XH5GbytyzG30+ql5aWUK/XQ8/z3qFp2kw+n4dIOqxbWAahJpxzscLxewA8Pzc315NOHqSqrlYt2+22sGN3c86/J1JKa/WWmwIakK7L0zBNc7/ruq1KpdIljYOiImqisp/h930fs7Oz8Dzvnxhjn7UsC8Vicd12bFNAE6t4FgqF5zjnv99sNuNqtdpXjdYDXJYdW8nwdzqdn0RR9G5d1+NisZguhrfhax2k+xc0pFQqTRBCPr64uJjpGNYD3PlUUjX87XZ7MQzDt+u6XisUCgMDbOCgycAVi8XDhJCJubm5NE+metTVzqpbC2CVSkUY/ps55y/KdmxQE0U2ZWWlJPcW27b9e3Ec//f09HRP65bczKJSkX7Sl2UXVca/uLgIx3Hu5Jw/ads2SqUSLMsa6GJ4mwKamLpdKBTalmX9ZhiGkzMzMz2dOVn2aCXwZA6m/q7VaglPeT9j7HOJmVhXmPSKgCYnLQuFwqRpmm9xXXd+bm4u06Oeb2GUfk5EfnjE7OwsXNf9BoAPiWWlB2nHtgQ02b4lHvWmZrPZXg1wWYvE9eNivu9jZmYGjuP8KIqiA4ZhhMViEblcblMA23TQpPgU5XL5R5qmHWg2m2E/DrcSQFkqGYYhpqam0Ol0XgzD8CZd19vFYhGFQmHDSyG+oqAJx5AY5W9QSu+s1WpYWFjoAk5dAlb9W62Mh2GIyclJtNvtSd/3b9A0bb5QKKBYLG6Y8b8qQBMRQy6XQ7FY/Bwh5N5qtYpqtdqlhur63/IyPbK3jaIIMzMzaLfbC77v36hp2kvJvgfC+M8rBFuZw0+oCOI4vrter+cWFxfvpJR2TUtU29nV/4unWjQajZrneW/VNO3ZXC6Hcrm8KZ7yFQdNtBckPbofaDab9vz8/HuA5YV4zxcVCBvWaDRanufdqGna8cRebhlgWwba+Pg4wfJjR1hiEigAcu211/7pjTfemJ+fn39HHMcYGhrKJLaiH2Rqagr1er1dr9dv+cxnPnMCgA0sL08ktqNHj0Y/t6CNj4/zZP9MASsF7dixY+Sll1768B133JGbm5v7Ld/30/4yWR07nY6wYU6lUvmD+++//8dYfv5enIAlXqPx8fEQQAggABAePXo0HPS1kUE/fnd8fJwB0AFoCVg8AalLyqRXPjw8nDt48OCnDMN4S0KIoet6Clij0YDnec7Zs2c//PDDDz+F5acnxlmgJYBFCWgBAO/o0aPeWq9jpcfvDhS08fFxCsBIANMUSWMKYHkAwwCKAHKGYVgHDx787XK5/BuUUiZLmuM4lRMnTjz0xBNP/AzLzzFuAahi+bmdvgRcKAEXJp/56wFuK59ZLIPSo47KZ6VkKwDIua5r3Hfffd+/6qqrfrJv377XmKa5PY5jv1KpnH388cd/6i5PHylKEhwlEieSdpFEoWLpbwqAjo+Pk6NHj8avRpumqkokgUWkzwCglgAQJ2pkAtCOHz/eOn78+HTyfUiSE+Dlp2U3k9/XpeOox40VBxFvuk1ba+pZjpxWadNkqbOx/ChxI/ktVUALAHh4+fHizlpsWrL1jPVeOxnElJs+4J3Xe2Zs6S7V68t4lQFTQQsl0KJBgTVQ0FYJYj9pywKt34gl4LIAizYDpC0B7Rd9/P8A12VCYmM3Gg8AAAAASUVORK5CYII=",
    lc.Logo = new Image,
    lc.Logo.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAIACAYAAAAczR65AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAF+CSURBVHja7N13nCT3ed/5pzpMT+40s5M6zGycXSxyIhY5ESQCqURR1FnW2Zb0kixLtuTzvex72eezzz6dJcq0jmfLd7Ysn2wSFCiSEgkQAEEiExkL7GLDbN6ZDhM6T0/q6VD3B0SQABbY2d3f02k+77+ADc+v6vlV9XZ9p6p+1tv7H7UFAGDErIMeAIApVRmlCQBgEF9VAQAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAAAAgAAAAAAAEAAAAAAAAAACAAAAAAAAAABAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAAACAAAAAAAAQAAAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAIAAAAAAABAAAAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAABAA0AIAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAAACAAAAAAAAQAAAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAIAAAAAAABAAAAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAACgVbloQfPyxo/J+KP/kEa0sdi9/0qy266iEWg5ll2Tu//074hrLaU2xul9vyPHr7qbZl/w3Nhy15/9XXEvx4zXfvkLfyIF/xBN3oBb/+J/k56FN1Rq19y98oO//d+l6uRrHKDlypf+m4Te/pJa/VP7/qVMXfUgjUbdcQcAAOCC2ZZDsuO3q44RjL1Noy+CNzuncvEvIjKQOE6DN8CztqJ28S8ikovcwcU/oMhZLcvw1J+rjjF25Jti2TbNBgEAAKA1pKJXqdbvTzwv7nKJRl+gwfiUWu2BmQM0eCN9mjutWj8duZImA4pGZw6Iay2pOkZn/m0ZmD9Fs0EAAABoDQtjO1TrW7WqBOfO0ugLvficflOttjf+rDirZZp8HoHElGr91NhOmgwoCk19ry7jhI89TbNBAAAAaA2lzh4pjtysezGbOEqjL0BHaVX6E8/rfWmorElwfoZGny8AiOnd/r/mm5Sl/iBNBpR0L+ckcPYbdRlr6PjD4i6v0XQQAAAAWkN6/HrdC6np12jyBRicPSWWXVMdY0D5p9utf/FQkK7sIbX6mfF9NBlQFD75kkidns13lAsyduZNmg4CAABAa1gI79a9mMoclO7lAo3e6MX5zDvqYwSm+bL6cYLKz/+nwpfRZECJZdsydvibdR0zdPS7NB4EAACA1pAPjkq5e1T3ojbJS5I2+sV14Mzz6uP0LrwmnatLNPyjAoC43mMrtsMl6eFxmgxo/Xszf0q68m/VdUxv4nHpL8zTfBAAAACan21Zktl6p+4XsvghGr2RL5GKy/99aE5mCWU+SmDmFbXahdCdUnF7aDKgpFEv5Qsff4HmgwAAANAaUpHLVev7p19kreQN0Fz+70MBQPwIDT+H3sWMdBT1HgFIR6+myYASd3lNho4/3JCxR49+XRy1KpMAAgAAQAsEACPbxLb0/jlxryTFm+P2yPNelNfx2fzAGX5adc45SJ7UPddY/g9QM3bmTXGUG/POmY6lEzKUZNUbEAAAAFrAuqdLFkN36F5YJY7T6I/78qi8/N+Hxluekf7cAo3/gIDispXrPREpBIZpMqCk0S/jC039gEkAAQAAoDWko9eo1g/GDtDkj1GP5f8+aCB5gsb/BMu2JTDzolr9zMStNBlQ0l+YF2/i8cZ+jp/8qnjWeMEqCAAAAC1AezlAb+xZcVbLNPqjLsbrsPzfh8cklHnfBURuXlyrc2r10+G9NBlQ0gwv4bNqZQmffo3JAAEAAKD5FfxDUurbpvePVbUkwfkZGn2uL411Wv7vg3yxZ8VZrTABf21gVvH5f8uS1Oh2mgxo/PtSq8ro0a83xbaMHfkrJgQEAACA1pDZqnuL8kBiiiafQz2X/3vfF4jKigQWCGV+JKC4XGVxeJ+se7poMqBgKHlUOpaa45Gm3oUXxJ+JMSkgAAAANL9U+DLdC6w6vuW+ldRz+b8PGkgcYwJExFGriS+mdwtxevw6mgwoCU19v6m2J3z8OSYFBAAAgBYIAEa2ie10q9XvXXhNPGvLNPqDF+ENDEaC028wASLiyyTEua63fFgqNEmTAQWetSUZPPlwU23TyNGv8XgVCAAAAM2v4u6QfPgu1TEGlddZbzX1Xv7vg3rnXxXP2sqmn4eg4nFZ6RyU3MAYBzugIHzqVbFqzfWCWddaUkZiB5kcEAAAAJpfavxa3Qut+FGa/BMasfzfBw3Mntr08xCI631Zz0ZvF9vi6xqgYezot5tyu0JHn2RyoMZFC5rX4ugOOfS3v9HS+9BVmJdt3/i7KrWP/tJXpOrubOn+1FycgmizAGBsl+zUDACmXxKRX6DRP7r4bsDyfx/ahthhSUxcvmnnwFktizeudxdGOnIFBzqgwJ+JSe/CC025bcGzfyHdy78hKz0+JgoEAJuJ7XBItcPT0vtQdeltf9Xd2fL9AdpN0RuUNd9u6czr/KS+o3ha+vMpWfQNbvpeN2r5vw99Ud3koUwgFRdHtaRWn+X/AB2RY8828UWALeGTL8mxK+9nomAc95QBAIxKb71Ftf5A8gRNlsYt//dBPwplNqug4koIy4PXympPPwc7YJizWpHhqT83Vm9uz69JZqvZIHTsyDdFxGayQAAAAGhuC8rLAQYV11tvJY1c/u+DNnMoE4gdUKudid7AgQ4oGJk5IK61pLF6iwNbpbBll9Ft7Mrtl8F53rECAgAAQJPLDI9LzdWtVt83/Yw4atVN3+dGLv/3QcFN+sZqd7kkfbM/VKufCu/mAwVQEJ4y+5K9oj8kiwPjxrcz1MyPKYAAAAAAEZGq0yW58XvU6jvLRQmk4pu6x41e/u+D/DPPbspQJjh3Vm0Vhpq7V7JbInygAIZ1L+ckcNbsS7YXfaOSD4SMb+vwsa+Iu1xi0kAAAABobqnIlboXXorPXbeCZlj+731fJspLEliIbbp5CMweV6udi9whVSfvagZMC598WcQ292z9es82WenxyXJvQCqeYcOfrQUZPbufSQMBAACguS2EdqnWD868tan72wzL/31omxJTm24egjN6j2GklUM0YHOyZeyw4Z/+j9z41/9lSXHoRuNbHD76XaYNBAAAgOa20uuTlYGr1er3zf5QOtbXNmVvm2X5vw9dDE9vrp9SedZWpGfhDbX6qbGdfJAAhg3OnZKuvNkAOT/043d1FAfNh9/e+GPSt7jA5IEAAADQ3NITn1C8CK5JcO70puxrsyz/90F98y+Lp7SyaeZhQPH4W/NNylJ/kA8RwLDw8WeM18wO//iiP79lu852n3iRyQMBAACguWkvBzgQO7op+2pq+b817y5J7fwZcxtm2zKQ3DxLVgUUH3nIjO/jAwQwzF0uydCxrxqtWXP1SPYn3v6f2bJNZdvHDn+9qd77AgIAAAA+JLslLNUOv94F2Myrm7Kvppb/W+8dlvVun9FtCyY2TygTiCne/q8cngGb0djZN8VRLhitmQ996n0v61zp8cua7yrj296xdEyGklNMIggAAADNq+ZwSnbiLrX6Xbkj0rOU21Q9Nbn8X6l3QMqdvWYDgLMvb4p56F4uSFf2kEpt2+GS9PA4HyCAYaEjjxmvOb/1lg/9Wjp6h8r2h6e+zySCAAAA0Ny0lwMcSJzcVP00ufxfqdsnZU+30e3zLJ6QvkK67edB8/0ThdCdUnF7+PAADOorLIg38bjZopYlyeiHX3Y7P36dzuf/yYfFU1pmMkEAAABoXgsh3TeZD8QPbap+mlz+r9Tjl1JXn/ltTJ5o/wAgrveoQzp6tQAwK3LiBeM1c+HPylpX/4f/3RvZKZXOMePjWdWShE6/xmSCAAAA0LzWunplaUhvNQD/9Ati2fam6KXp5f9W+gdkrdtrPgCIvdP2cxGYeUWtNsv/AaY/O2syeuQR43WTu+4556/XHC6Zm/ycyr6EDn+bCQUBAACguaUmblCr7VpbEF8muSn6aHr5vyXvoKz0mX9Jo2/6GXHUqm07D72LGeko6jwCsN4TkUJgmA8NwKDhxBHpWDJ7Z1LN2SWJ6DUf+fvxHbfpfP4sPCe+bJxJBQEAAKCJA4DwbtX6A4njm6KPppb/+5HlPr+sdveJ7XAaressFyWQat8vqANJvfdOZCZu5QMDMCw09QPjNdPbf0HKHZ0ffS4PRmXVf43K/oSPP8+kggAAANC8cgMhKXeNqNUPxg5sij6aWv5PRKTUv10qrg6xLYeU+neYn5PEsbadh4DiUofp8F4+MACDPGtLMnjyq8brJnbecZ4/YUly90+p7NPokYfFUaswuSAAAAA0J9uyJDtxu1p9b+I5cVXW27qHJpf/ExFZGph8779XAtvMBwAz+9tyHizblsDMi0rFLUmNbucDAzAofPo1sWplozXLXWGZGzv/nW3xbTrvv3GtJWR05iCTCwIAAEDzSkWu0Lsoq5YlOHe2rftncvk/EZHFoR9faBYHxo1vb//sD6WjtNp289CfmxfX6pxK7eLwPln3dPFhARg0duSvjNec3/WzUnO4zvvnlvoGpBC6X2W/QlNPMbkgAAAANK+FsR0ilqVWf6CNbzkXMbv8n4hIYTDy4zAgGDK/wbYtA3On228eZvWe/08rrR0ObFb+TEx6F8wv/xffsfF3dSR23aeyb8Ezj0jXSoFJBgEAAKA5rXu6ZHH0NrX6gZnX27Z3ppf/ExHJDfx4jeqiX+et8wOxI203F4H4IbXaqdAkHxSAQeHjzxmvueq7WjKD4xsPAMavFdvpMb9zti3hky8xySAAAAA0r5TiTzh7Uvulc7XYln0zvfzfmm9SSp09Pw4AvEGpuXvNXyxPv9xeX5hqNfHFXlCpXekcfF8oA+DSOKsVGTn6NeN1Zyc/IyIbv5tt3dMtqW2fV9nH0JFviYjNZIMAAADQpAGA8nKAg4rLszWS6eX/spEb3vf/tuWQfOgW49vdWTguvYuZtpkHXyYhznWdW25z0dvEtvhKBpgyMnNAXGtJ43Xj22+64L+T2Hmnyj52Zd+QgYUzTDYIAAAAzSkfGJb13qha/WD8SFv2zeTyfyIimXO8vTo/ohPOtFMoE1TcF82XZAKbUXjqSeM1F0c/KcX+LRf89+ZCl0mlU+cOn/CxZ5hsEAAAAJpXZkLvPQDBsy+2Xb9ML/8nIpIe2fqhX8uO6Cw/F4y90zZzEYjrLbuVGt3BhwNgSPdyTgJnv2G8bvIiX+hXc7hkbvJzKvs6NPVVcZVLTDoIAAAAzWkherlabfdyTPpzC23VL9PL/y1tueF9z///SG5gTGquTuPb759+Thy1WsvPg7NaFm/8eZXay4PXyGpPPx8OgCHhky+L2Gafjbcth8Qnrr/ovx/foRN+O8s5GZvez6SDAAAA0JzSw9vE3sD6yRd9wZw83lb9Mr38XyZ67hcxVp0uKYTuMP/ldD0n/nS85echkIqLo6rzU7ZM9EY+GABzl+oydtj8T/8zW39eSp0X/7LUzGBUVv3XqOxx6OgTTDsIAAAAzanc4ZF8+E61+sGZg23TK43l/1LhPR/5e+noVSr7MZA41vJzEVTchzTL/wHGDM6dkq78W8brJnfedamf6JLc/VMq++yLfUd6i2kmHwQAAIDmlI5eo1bbF3tWnNVKW/TJ9PJ/VXefZLeEPzocGNupc/HcBrenBmIHVOrWXN2SGYryoQAYEjr+rPGa1Y6gzIYv/UWd8W2fUNvvyPEXmXwQAAAAmlNK8SeejsqK+FOxtuiT6eX/cuN3S83h/MjfX/RtkfW+rcb3o2/2h+JeX2vZeXCXS9I3+0OV2rnoXVJ1uvhQAAydq8PHvmK87vzOz0vF1XHJdZb6BqQQul9l30ePfN3o+2JAAAAAgDGLvkFZ8+5Uq2/6wrlRTC//l97AUnOZ8VuM74dl12RgrnXXqg7OnVX7Yp2OXMkHAmDI2Nk3xVEuGK+b2HGruVoXuZLA+XiKR2VL8hgHAQgAAADNKb31VrXagZm3Wr4/Gsv/beQW/1T4MpX9GYgdadm5CMzqvVhS67ELYDMKHf2u8ZrrvbskNWxumc7E+LViOz0q+x8+9gMOAhAAAACaNABQutAUEembf1k8pZWW7o/p5f9WA5fLcq/v/PMyslVsy/xXg+D0Ky07F8GZN1XqrvkmZak/yIcBYOJzf3FBvHHzAcDs5M8Y/Uxc93RLatvndf7dOPGweErLHAwgAAAANJ/UyITKuvMiImLbMjB7uqX7Y3r5v/TETRv8ctolxVHzjwF05o9KTzHbcvPgWVuRnoU3VGpnxvfxQQAYEjn+gkrd+A7z52lyp85KOI7qqoydfp2DAQQAAIDmU3W6JR+5W61+MN66t5yrLP8X2rPxC9OIzioNg8mTLTcXA3N6QVI6vIcPAsDIZ2ZNRo88Yrzu8uDNkvePGa87G7pMKp2jKr0IHfkOBwQIAAAAzSmltO68iEighW85N738X83VKZnhjS81p7VKQzB2qOXmIpDQeaGk7XBJaniCDwHAgKHEUelYOmG8bnLyQZXtrTlcMrfr51Vq980/I75cgoMCBAAAgOazoLgcYGfhuPQuZlqyL6ZXMciH75Kq073hP58bGJNK5xbj++Wffr7llqkKxHRu/y+E7pCK28OHAGCAysvvLEviW29Q2+b4jlv0+qH0OAQIAAAAuCTLfX5ZCV6hVr8VbzkXUVj+7wLvtLAtS7LjtxnfL1cpLf506/xkqnu5IF1ZnbsW0tGr+QAADPCUlmXwxFeM182FPysrPX617c5smZBVn87nwMiRr4mjVuHgAAEAAKD5bPTldBcjGHun5frRqOX/PjQvEZ1gZiBxvGXmIqj4/H9qbBcnP2BA+NSrYtXKxusmd92jvOWWzO7+rEpl9+qMjLTgI1cgAAAAbAIpxeUA/TOtd8u56eX/1rw7pegduPB5Gd2uc1E981brBADxoyp1yz1hKQSGOfkBA8aOfNt4zZqzSxLRa9S3PbZdbyWQ0NT3ODhAAAAAaD6ZoahU3X0qtZ2lrARS8Zbqh+nl/zLjN1/U31vt7pflwWuN719/4nlxr5daYi4CMzovkkxP3MaJDxjgz8Sld+F543VTO74g5Y5O9e1f6huQwtinVGoHTz8iXauLHCQgAAAANJeawynZcb1bLYPJEy3TC43l/y5lqblM9AaFfaypLq1nSu9iRjqKOtuZCV3GiQ8YED7+nErdxI7b67YPiUmdAMCyaxI++RIHCQgAAADNJx29Ui8AaKFbzk0v/2c7XJIa2XrRfz8V3q0zJ0pL65k0oPUCScuS1Nh2TnrgEjmrFRk5+rDxuuWusMyP7a7bfiTHrxXb4VapPXb4WyJic7CAAAAA0FwWQjvVavcnXxB3uTVuOTe9/N+lLjWX3RKRmqvbfABw9pWmn4tAQuf5/+LwPil5ujnpgUs0EjsorrWk8brzu35Oag5X3faj5OmR9LYvqNTuzr4uwdRZDhYQAAAAmstqd78sbdFZb9mqVWVg7kxL9MH88n+X9hKrqtMluchdxvezK3dYepbyTTsPlm1LYOZFldrp8es44QEDQkefVKkb33Fr3fclsfMOtdrhY89ysIAAAADQfNITN6jVboVbzptl+b8Phwg6j2cMNPG7Gfpz8+JandM5zln+D7hk3ct5CZ79C+N1V31XS2YwWvf9mQ3vlUrnqErt4amviauyzkEDAgAAQHNJXcLL6s4bAJx9ten33/Tyf+u9USNLzaVHdR7PGGjiNaoHZnWe/690Dkp2MMTJDlyi8MmXRGzzz7bP7v6siFh135+awyVzu35epbZzPSWj029x0IAAAADQXLKDIal0DqrU7sq+I93Lhabef/PL/91ipE7RG5Q1r/kQwD/9vFh2c76cKhDXCSdy0dvEtvjaBVwaW8aOfFOlcnzbTQ3bq/iOW9Rqh44+wWEDAgAAQJN9pbMckpm4S62+2lvdDVBZ/i9yucEwYZ/xfXatpcSXSTbdXDhqNfHFXlCpnYpcwYkOXKLB+VPSldtvvO7i6Cel2D/YsP3KbJmQVd/VKrX9M38lvcU0Bw8IAAAAzcXkReuHAoD44abdb9PL/4llSWpkm7l5CeusWz+QON50c+HLJMS5rnO3SGp0Byc5cIlCSi+1S+76VIP3zPrrRxB0hE/8kIMHBAAAgOayMLZDxNJ5/tJ/9oWmveXc9PJ/i6O3yrqny1wAMLxVbIfT+H4HZ95uurkIKt0psjx4jaz29HOSA5fAXS7J8LGvGK9rO1wSn2j8Ch2x7fvUao8d+Yum/TcQBAAAgE2q1NkjxWGdL0Du1Vnx5uabcr/NL/93rdF65Q6PLI7dbny/vYlnxVUuNdVcBOIHVepmojdyggOXehF79k1xlM3foZOZ+DkpdfY2fP+W+gakMKZzJ4Jn8bBsmT3GQQQCAABAc0kpLgc4kGi+Lz8qy/+FJo1vZzpi/tlUq1aVgbmzTTMXzmpZvPHnVWqnFeYE2GxCR7+rUjex8+6m2cfEpN6jCKFjT3MQgQAAANBkAUBot1rtYOxg0+2v6eX/Kl3Dkg+OKsyLzgXsQOJo08xFIBUXR9X8HQk1V7dkhqKc3MAl6FtcEG/cfABQ7QjKXPjyptnP5Pi1YjvcKrW3HP+KdKyvcDCBAAAA0DzywREp94RVantjz4qzWm6q/TW//N/tYiu8R6EQGJZyt/lgIXj21aaZi6DSHSK56F1Sdbo4uYFLEDmuszrH/M7PS8XV0TT7WfL0SHrbF3Qu+qqrEjr9BgcTCAAAAM3DtixJT9ym9OWnJMH5mabZV8u2ZeD0c0ZrpiN71eYlO25+Xrqy70j3cqEp5iMQO6BSNx25khMbuKTPypqMHnlEpXZix61Nt7+JnXeo1Q4d+Q4HFAgAAADNRXc5wKmm2U9fZlbcK3GjNTWXmkuHdcKFAaU3718Id7kkfbM6y2SlxnZyUgOXYCg5JR1LJ4zXXe/dJanh5luecy60VyqeYZXafXM/EG9uloOKAAAAgOaxMLpdbEvnn6fAzJtNs5+DcbPPvy8NfULWuvTeZJ0a3a4TAMQONXwugnNnjb6L4UfWfJOy1B/kpAYuQXjq+yp1Zyd/Ru3fmktRdbpkbvLzavUjx5/joCIAAACgeZQ7OqUQulOldu/Ca+JZW26K/TS+/N+47jrWa129sjRkfjm7wPQLDV+fOjB7XKVuZnwfJzRwCTylZRk8+bBK7fiO5j0/E9tvUas9cvQRcdSqHFwEAAAANI/0+LVqtQeb4JbzjtKq9CfNvtQqrbiCwo/n5XrjNV2rc+LLNvaW1KDSnSHp8B5OZuAShE69KpbC6hzLg7dI3j/WvP8GDm2VNd9VKrXdK2dlOH6Ig4sAAACA5pEK7dK72Isfafj+bUmcEDH4U+9qh1+ygyH9L6VjSssBxo81bC48ayvSs2D+zdi2wyWp4QlOZuBSAgCll9YlJx9o8j23JDn5WbXqWo9VgAAAAICLUvAPSalf55nz4PTLDd8/08+9Z8fvlJrDqb7d2S1hqbr7zM+J0hv4NzQXc6d1juHQHVJxeziZgYvkz8Sld0HheXXLkvjWG5t+/+Pb9R5RCJ56WDpXixxkBAAAADSP9ITOM5AdxdPSn081bL8s25bgmWfN9ip8eV22veZwSm78LuN1vYnnxFVZb8h8BBI6K0Oko1dzEgOXIHxC52V1uchPyUqPr+n3v9g/KIuj9yn9O1ST8MmXOcgIAAAAaB4pzeUAkycatl/vLv+XNNurUP2WmkuHrzD/ZbRaluDc2cYEALE3dI7fsV2cxMBFclYrMnLkayq1kzvvbpk+JCY/pVY7dOQvOdAIAAAAaB7p4QmpOXVuoQ7G3mnYfple/m9l4CpZ6fHWbfu11rUfUPpJ/MfpXi5IV9b8y7DKPWEpBIY5iYGLNBI7KK61hPG6NWeXJMavaZ0AYOI6sR1unc+/zCsSTJ3lYCMAAACgOVTcHZKP6CwH6Jt5tmHLIJlf/q++z7Iu9/ll1W/+7fbB6dfqPhfBuTMqddMTt3ECA5cgdPR7KnVTO74gZXdny/Sh5OmR9LbPq9UPH3+Wg40AAACA5pGO6vykxlkuSiAVr/v+6Cz/V/+l5jIT5l9O1Z1+W7qWF+sbACitCJEJXcbJC1zsZ8FyXoJnv65SO7Hj9pbrR2LnXWq1h48+3LD3r4AAAACAD1nQXA4wUf+l50wv/1dzdUtmKFr3/dAKHQZnT9Z1P/wzr5ovalmSGtvOyQtcpPDJl4x+Tv5IuSss82N7Wq4fc6G9UvHoPFLkXE/J6MwBDjoCAAAAmsNSf1DldnMRkeDM/rrvj+nl/3KRu6TqdNU/ABgaF9tp/rnUYOxw3fahdzEjnuIp43WLw/uk5Onm5AUuii1jR76lcyE9+bm6LJdqWtXpkrlJvccAQkef4LAjAAAAoHmkt+osB9g3+5J0rK/VbT9Ulv+LXtmQOam4OyQfusN43cD0C2Ip/OTvXAZmT+kcr+PXcdICF3tezp+WrtybKrUT229p2b5obrt/+lvSs5Th4CMAAACgOaTCOncAWHZNgnOn67YfKsv/je1s2LxkIubXuXevJMWbm6/L9gcSOs//p1n+D7ho4WPPqNRd9V8jmcFoy/YlPbRV1nxXqdWPnPghBx8BAAAAzSEzNC41d69K7YHY0brth+nl/9Z8k7LUH2zYvKSU3s8wUId3M1i2LYHpF43XrXQOSnYwxEkLXAR3uSRDxx5WqT07+RkRsVq4O5YkJz+rVn30yDfqdvcVCAAAAPhYVadLstG7VWoHp1+p234YX/5v4uaGzkvBPyTrPRHzc1KHF1L15xfEtTpnvG4uepvYFl+tgIu6CD27X5zlnErt+LabWr4/8e371Gp3Ft6RwbnjHIQEAAAANAetZ90780elZymnvv3tsvzfB2UmbjVe0xd/RpyVsup2DyRPqNRNRa7gZAUuUvjod1XqLo7eJ8X+wZbvT7F/UBZH79Pr/9TTHIQEAAAANAfN5QAHEvpLz5le/s92uiU9PNHweUmH9xqvaVXLMjB/VnW7A3Gd1QZSozs4WYGL0Le4IN74Yyq1k7vua5s+JSY/pffv1ImviruOL8YFAQAAAB9ppccry4PX6gQA8UPq2296+b986A6puDsaHwCMbhOxzD9XG1R8D4Bl18QXe9543eXBa2S1p5+TFbgI4RMvqtS1HS6JT7TPyhyJievEdrhVajsqyxI68zoHIwEAAADNIT1+o0pd//Tzqi8/0ln+75qmmJOSp1uKw+afrQ1O630J9acT4lwvGK+bid7ISQpc1GdkTcYOf12ldmbic1Lq7G2bXpU8PZLe9nm1+qEjj3JAEgAAANAcUhGdZ95daynxZZJq262x/F+6gcv/fWhbxq83XrMn9aZ0rhZVtjeY1HnkIx2a5CQFLsJQcko6lnTu+knsvKvt+pXYcada7f7Zp6Q/P8dBSQAAAEDjZQcjUvUEVGoPJPTefmx6+b/1vq1S8A81TwCgtO79oNKFeiB+0HjNmqtbMkNRTlLgIoSnvq9St9oRlNk2fDHnXHivVDzDavUjx1/goCQAAACg8WoOh2TGdX6aE4zpLT1nevm/zPgtTTUv2cGQSjATjB0xXtNZLYs3Yf7LbS56l1SdLk5S4AJ5SssyePJhldrzOz8vVae77XpWdbplftfn1OqPHvmaOGpVDk4CAAAAGi+ltBygN/6suCrrxutqLP+XCl/WVHNiWw7Jjpu/JTV49gXj72YIpOLiqJh/y3U6ciUnJ3ARQqdeFataUqmd2HFr2/YtvuM2tdrulTMyrLRSCggAAAC4sIvfMZ1l1qxaRYJzZ43XNb78n+V49837TSYdvlzhS2hc+vMLZkMFpUc9Uk30TgagpQKAI99RqVvqm5TUcPsuy5nZslXWvHqPN4SOfZ+DkwAAAIDGW+vqleLwPpXaAwpLz5le/m9x7DZZ7+hsunnRCmZMv5shEDf/qMeab1KW+oOcnMAF8mfi0rvwnErt2cmfFttq38sc27Ikufun1OoPnPqadK4VOUjbFA+sAQBaSnrieumbe8l43cDM6yI3PmSsnsbyf5kmWf7vg1Z6vLISvFK6M2YvsAdmDsipvWZu43WXS9KXNL/WeGZ8HyclcBHCJ55Tqz3++u/J+Ou/R5Mv9t+vWkVCp16Vk5fdQzPaEHcAAABaykJYZznAntR+6Vox9xMPjeX/UmPNu9RcZvwTxmt648+Ks1o2Uis4Py2WXTO+jWml4xFoZ85qRUaOfI1GNLHQ4b+kCQQAAAA0Xj44KuWuEZXaA7Pmlp4zvfxfuXtU8sGRpp2XVGi3+S8plTUJzs8YqRVImn/Ew3a4JDU8wUkJXKCR2EFxrSVoRBPrSb8kgfQ0jSAAAACgsWzLkszWO1Rqm1x6zvTyf9nx28S2rKadl8xwVGou8+8nGIhPmZnbmf3Gt60QukMqbg8nJXCBQlNP0YQWED72HE0gAAAAoPE03jovIhKcNvOMuMryf5HLm3pOqk635MN3mJ+TmTcuuYantCI9C6+bPw6jV3MyAheoa6UgwTOP0IgWMDL1VWOPYYEAAACAi7YwtkPlDc/u5Zh4c/OXXMf08n8iIqnR7U0/L+mI+QvinoXXpXN16ZJqDMyeVtnf1NguTkbgAoVPvmT88xE6nKUFGZ1+m0YQAAAA0Fjrni5ZHLtNpfZA8sSl1zC8/F9xeJ+UOnuaPwAY26kzJ7OnLunvBxSWeCz3hKUQGOZkBC6ILaHD36QNLSQ09SRNIAAAAKAJLjbHr1OpG5y5tKXsdJb/u7Yl5mTRNyilfvN3KgzEL+3dDIGYwu3/E7dxEgIXei7Pn5au3Js0ooUEpr8lPUtZGkEAAABAYy2EdJbE88WeE2e1cvF/X2P5v/DulpmXzPg+819Az1z8+xS6lwvSlT1kfj9Dl3ESAhcofOwZmtBqbPvdxzZAAAAAQCMVAsOy3mt+CTZHZUUCqdhF/33Ty/9VPQHJDoZaZl7SYfMXxh3LM9KfW7iovxucO2N+Jy1LUmPbOQmBC+Aql2To2MM0ogWNHfmmWLy3gQAAAICGX2xuvVWl7qUsPWd++b87VV54qDYnI9tUtncwefziAoD4EePbUhzeJyVPNycgcCEXkWf3i7OcoxEtqDP/tgzOn6ARBAAAADSW1tJ4gYtcM15j+b90ky//90HrHZ0qL2i82Hcz+GdeNb4tWu+fANpZaOpxmtDK88fjGwQAAAA0PAAY2Sq2w2W8bt/8K+IprVzw39NY/m9hdGfLzUtGYTnAi3k3Q+9iRjzFU8a3Jc3yf8CFfaYupsQXe5RGtLChY18V9/oajSAAAACgcSpuj+TDd5ovbNsXtXa86eX/lgevkdWe/pabl5TCCxodlRUJLMxc2HzMmr/4r3QOttQ7GYBmED7xIk1o9YvGSlFCZ9+gEQQAAAA0VnpcZ4m8C312XGf5vxtbck7ywVGpdG4xXncgceyC/nwgYf75/1z0tpZ6JwPQaJZdk7HDj9CINhA68hhNIAAAAKCxtJYDDJ59+YL+/GZf/u8n2ZYl2Yk7zM/J9MZ/+mTZtgSmzf/UMRW5gpMOuABDySnpWDpGI9pAf/JJ6S/M0wgCAAAAGqfoHZA1n/kQwLN4QnoXMxv+86aX/6u5eyW7JdKy85IKm395Ye/8q+JZW97YF9X8grhW58zv1+gOTjrgAoSnfkAT2mk+j79AEwgAAABorPTEzSp1B5MnN/xnTS//l4veJVWnq3XnZHR7Q+dkIGl+yapWfScD0Cie0rIMnvwqjWgjo0ceEUetSiMIAAAAaJxUZK9K3WDsnQ39OZXl/8Ktfav5anefLG8xv1xecIN3WgTih42P3arvZAAaJXT6NbGqJRrRRjqWT8pQ4iiNIAAAAKBx0sPjUnN1Gq/rn35OLLt23j+nsvxfaGfLz0smer35AGD6pfP+GcuuiS/2vPnjTOl9E0DbBgCHv00T2lB46vs0oYW5aAEAoNVVnW7JRe+R4Cmz60w713MSSMUlc55n8U0v/7fq3yPLfYGWn5dUaLdEXjdbs6N4WvrzKVn0DX7kn/GnE+JcLxgdt+bqlsxQlJMN2CBfNi69C8+p1X/lc9+URe8wjT6HocRhufLxX1WrP3DqYfHc+itS6uyl2QQAAAA0RjpylfEAQEQkmDzxsQGAyvJ/E/vaYk6yWyJSc/eKo7xk9stn8sTHBgDBC3h3w0a1+jsZgHoLH39erfby4M2SGRynyR8hGb1K9nSPi3vlrEp9q1aW8KlX5ORl99DsFsQjAACAtrAQVloOcOatj/19jeX/0qE9bTEnVadLcpE7Febk4Mf+fiB+0PiY6ciVnGTARi8wahUZPfKw3gXu5AM0+WPUHE5J7vm86hihIzzeQQAAAEADLff6ZCVo/iKtP/G8uMsf/RIr48v/OT2SGp5om3lJR8y/zNAfe1ac1co5f89ZLYs3YX6ZqtTYTk4yYINGZw6Kay2hVj++lRdynk9sx22q9XtSL4o/E6PRBAAAADTwYnPiJuM1LbsmwbmzH/n7A9P7jY5XCN8hVZe7beZE48LZUV4Sf+rcXzwDqbg4KmtGx1vz7pKl/iAnGLBBoamn1Grnww/JSo+fJp/v3xL/iBSH71YdI3LsWRpNAAAAQAMvNiOXqdT1z50656+710vSZ3r5v+jVbTUnS/1BWfOZfzwjOHvu5/yDyRPGx8pM3MzJBWxQ10pBgmceUauf3HUvTd6g+G7dRyWGp/5cnNUyjSYAAACgMTJbIlLtMP+TIX/y3G/5H5g/s6FlAi9EO95qnhk3/1JDf+LIOX89EDtgfKx0aDcnF7BB4ZMvGV8W9Udsp0cS49fQ5I0GAFtvkJqzS62+ay0pozMHaDQBAAAAjVFzOCU7bv6lc32zPxRn5cM/5QgmpoyOU+rfLou+LW03LxoX0P3JFz70HgBXuSR9sy+aveBwOCU1spWTC9jYGSOhw9/U+yzZ+nlZ7+imzRu07umW1I4vqI4RmvoejSYAAACgcVJR8y8CtGpV8afjH/r1wPRrRsfR+El5UwQAI1vFdjjNfoGprIk3O/u+XwsuzIhVqxodpxC6UypuDycWsAED86elK/emWv3Ezjto8gWK7dJ9D0Dg7DekezlHowkAAABoUACgdAu99wMBQNdKUbozZpebS0X2tuWclN0eKYTM35nR/4EAwD932vgYmchVnFTABoWPPaNWu+IZlrnQZTT5Ai2M7pJS36TeALb97mMfIAAAAKARVrv7ZGnI/BJRfemZ9/1/YGHa7HcoyyHp4W1tOy8aF9L9qbPv+3/vvPkXAC6EJjmpgA1wlUsydOxhvQvZnT8nVaebRl/Evy3JPZ9THWPs8DdFxKbZBAAAADRGevwG8wFA6vj7/v+jVga4WIuhO6Tc0b63mqfGdpkPAOaPvffflm1Lf/JVo/XLPWFZ9A9xQgEbuQic3i/Ost6t4PEdt9LkixTbcYtq/a78WzJo+N9EEAAAALDxi82w+ZfOdWfeft9L57zJw0brpyNXt/WcFALDUu4eNVqzJ73/vVUYehcz4lw3e/GRmbhNbMvihAI2IHT0CbXapb7dkh7aTpMvUrF/UAoh3SUBw8efodEEAAAANEZ2MCyVTrNv07dqVekpZkVExFVZl975V4zWT7X5rea2ZUlm4nazc1ItS/dSXkREvJmE8W1O87wxsCG9xbT4Yt9Rqz+7+2cI4y5RbPf9qvWHjn1V3OUSjSYAAACgUReb5l8611189yfMvszsez95NqHcHZJCYLjt5yUdNv+Sw75C+t0LkNys2cKWJalRfuIIbETk+Auq9ePbbqLJlyg5fo3U3F69i8pyQcbOvkmjCQAAAGiMVPQKhQAg8+5FZzZptO5mudVc44K6Jz//bgCQjRutWxy+SUqdrDcOnI9l12T0yNfV6i8P3iIF/yiNvkRlt0fmd/2i6hihI4/RaAIAAAAadbG5Q8TwRXVX8d2fNvdlzF5spsOb41bzUmePFIfN/iSvp/BuANCTPm52Tsav5yQCNmAoOSWe4pRa/eTkAzTZkNjOO1XrexOPS19hgUYTAAAA0IiLzW5ZHDX71uiuxXcvNvtSJ80Vtax3w4pNIhO91mi9zsU5cdSq0pU/ajYAUFi1AGhHoWNPq9aPb72BJpv6XBvaJqs+3RfORk68QKMJAAAAaNCXHcMXmx0reRER6Um9ZaxmcXjfprrVPG34ZYddhbh0ri6J2ObWoK54BiQ7GOIEAs7DU1qWLSe+olY/F/msrPT4abQhtmVJcs9Pq44xeuQRo+/IAQEAAAAbthDeY7SeezUrnrVlcVRWzF0Qj1+3qeYkOxiWaoe5L/SdhWPStVwwe9ExfrvYFl+RgPMJnX5drKrem9+TO++hyYbN7LjZ+ONxP6lj6YQMJY7SaAIAAADqrxAYlnJP2FwAsDIv3UtmLzbbffm/D6o5nJKLmlsO0KqWxZuKGd3GdORyTh5gIwHAkW/rfVY4uyQ5fjVNNmylxy/ZqO5dAOFjP6DRBAAAANSfbVmS3nqHsXqutYX3VgIwodI5KLmBsU03L+mI2RUadj73e0brLYzu5OQBzsOXTUjv/LN6nxPbPifrHazEoSE++SnV+oMnviKe0jKNJgAAAKD+UobXnr/88X9irFZ2k95qnhpr3pcergxcLas9/Zw4wHmEjz+nWj+54w6arNXb6JVS9WxRq2/VyhI+9SqNJgAAAKABF5uj28V2OJty29LhKzblnCz3+mU1sLc552T8Rk4a4HwXELWKjBz9c7X6Fc+wzIX20mglVadbZie/oDrGmOLjISAAAADgI5U7PFII3dmU29bMPwnXlhm/qTkDgNBuThrgPEZm3hH3akyt/vyuz0nV6aLRiuI7b1et37vwvPgzcRpNAAAAQAMu6qLXNN02LW+5Xla7+zbvnDThhXbN1S2ZoSgnDHAe4amnVOsntt9Kk5VlBsdleUA3iNV+TAQEAAAAnNNCuPnetJ+OXr+p5yQ9PC62091U25SL3MVPHYHz6FopSPCM3u3/pb7dkh7aRqPrILH7s6r1R45+TZzVCo0mAAAAoL4WfVuk1N9ct9unwpv7VvOKq0Py4buaapvS0Ss5WYDzCJ98ScS21erP7v4ZsRXXqcePxbbfpPoiWtdaQkZiB2k0AQAAAA24uNvaPLeUVt19kt0SYU4iVzXX9rD8H3AetoSOfEt1hPi2m2hznax19Ulm2y+ojhE6+j0aTQAAAED9pcKXNc225MbvklqTrkxQ1wvusea54F7z7pKiN8iJAnyMgYUz0pV9Q63+8uAtUvCP0ug6ik/eq1o/ePbr0r2cp9EEAAAA1DkAGNkqNaenOS58N+nyfx9U8A/Jeu9EU2xLZuJmJgQ4j/CxZ1TrJycfoMl1Nhu6TMrd43oD2Pa7j42AAAAAgHqqutySjzTHM+epELeav3fhPd4cF94s/wd8PFe5JENTX1UdI771BhpdZzWHS2Z3/7zqGGNHviUiNs0mAAAAoM4X3uONXw5wNbBXlnv9TMaPLryb4NEM2+GU1MhWJgP4uIu46f3iLOfU6ucin5WVHj4bGyG2Q/cdOV25N2Vg/jSNJgAAAKDOAUBoV+MveCf2MRE/OSej20Ua/MbvQuhOqbg9TAbwMUJHn1Ctn9x5D01ukHxgTIpDd6qOof34CAgAAAD4kKW+gKwG9jY2AOBW8/dZ93TJ4khjHwPINNlqBECz6S2mxRf7jlr9mrNLkk1wh9ZmltjzkGr9oWMPi6tcotEEAAAA1PkCvIE/ga+5OiU9PM4kfPACPHptQ8dfCE0yCcDHiBx/QfdzedvPy3pHF41uoPjW68VWfFGus5yTsbP7aTQBAAAA9dXI5QDz4Tuk6nQzCR/88j/WuEczyj1hWfQPMQnAR7Dsmowe+brqGMmdd9DoBit5eiS1/RdVxwhNPU6jCQAAAKivzFBUau7exlzoRrnF9VyygyGpdA425niYuE3sBr+DAGhmQ8kp8RSn1OpXPMMyG7qMRjeB2OTdqvV9sUelbzFFowkAAACon6rTJdnxxrxsKj26gwk4B9tySC56W2PmhAsP4GOFjj2tWn9+8uel5nDR6CYwPzop6726d2SFT7xIowkAAACor1TkyrqPuebdKYu+QZr/URfikcvrP6hlvbsKAYBz8pSWZfDEw6pjJLbfQqObhG05JLnn51THGDv8iFh2jWYTAAAAUMcAILSz7mNmxln+72PnpAF3RxSHb5JSZzfNBz7qYu306+KorqrVL/VfJukt22h0E5nZeatq/Y6lYzKUnKLRBAAAANTPSo9XlrdcV9cx02FuNT/fnKwMXF3fORm/nsYDHyN05Duq9Wcnf4p3cDSZYv8WKYx9WnWM8NQPaDQBAAAA9ZUev7FuY9kOp6RHttL0887JDfUdr4GrDwDNzpdNSN/8M6pjxLdxZ1Qziu++X7X+4Mmviqe0TKMJAAAAqJ9UeE/dxiqE7pSy20PTz3dBHtpdt7EqngHJDoZoOvARwsefV62/tOVWKfhHaHQTSkxcKzVXn1p9q1qS0OnXaTQBAAAA9ZMdDNdt6blM5CoavpE+DY1LzdVZl7Fy47eLbfE1CDjnBUKtIiNH/1x1jOSuB2h0kyq7O2V+1/+gOkboyLdpNAEAAAD1U3M4JDt+e13GWghN0vANqDpdkg/fVZexGrLqANAiRmKHxL06ozeAZUli6w00uonFd92hWr93/lnxZRM0ugGst/c/atMGADBjllgVAIypyihNAACD+KoKAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAIAAAAAAABAAAAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAAAAgAAAAAAAEAAAAAAAAAACAAAAAAAAAABAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAAACAAAAAAAAQAAAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAgACAFgAAAAAAQAAAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAIAAAAAAAAAAGOeSFE0AAFP6yiGaAACG9MoyTQAAg7gDAAAAAAAAAgAAAAAAAEAAAAAAAAAACAAAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAAAQAAAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAAACAAAAAAAAQAAAAAAAAAABAC0AAAAAAIAAAAAAAAAAEAAAAAAAAAACAAAAAAAAQAAAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAAAQAAAAAAAAAAIAAAAAAABAAAAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAIAAAAAAAAAAAgAAAAAAAEAAAAAAAAAAWpWLFjSfPU/+T+JemlKrXwx9Vk7f+Ks0ukk4qhW57LG/JY5yTme+Rx+U0zf9Oo0G6uATj98vznKSRih5895nZK3LTyOAFrP38Z8VZ3muLffNdnRKzRWUmjsgVXe/VDyDUvX4pOwJSLkrKOtdQVnvDspa96DUnG4OBhAA4MNy0U/KlsN6AUBv8glxlX9JKu5Omt0EvAvH1C7+3z2ebqbJAAAACqzamjjXE+JcT8j5Lu/LPXtl1btXVv07ZcU7Lsu+qFRdfB8HAQABQOha2XJY84OqJN65I5IJX0Ozm4Av9qpa7Zo7IIWh3TQZAACgwdzLh8S9fEj6f3SjmOWQNd8tsjR4gyxuuUKWfONiO5w0CgQAm81ab1BWgzdLV+aHihedLxMANAFnpSR9icfU6hciD0rNyWkOAADQdOyadOael87c8zJwXKTmHpLF0YckP/oJWRzYKbZFGADzeAlgk8pF71Ct3zv3pLjWV2h0g/lmD4tVK6nVz0ZupMkAAACtcGFWnhff9H+W8Zd/RfY89bdk9NhfiWc1R2NAALAZ5EevELEUp8euiT/5Do1udAAQe0mtdrl3UpYCUZoMAADQYlxrp2Tw2O/L5FMPycT+P5aeQoymgACgnZU9PVIcuV91DK/ixSfOz11akt7ZJ9Xq58bvo8kAAAAtzZb++H+X7c/9gmx9/d9K92KcloAAoF3lIrpvb+9ZeFo61hZpdIP4EwdFxFarnw1dS5MBAADaRN/sN2THs5+X6MH/Ku4S3+FBANB2CsO7pObyKo5gi4/HABrGN/OcWu2VwTuk1BOgyQAAAO32HfLsf5LJp/+mDMReErFtGgICgHZRc3bIYvgB5YvQ52l0A3iWs6qrPOSit9FkAACAdr2IK6dk7K1/JNtf+T3pWCvQEBAAtIuc8lvcuzI/FM8KbxetN3/iLbXatsPz7kskAQAA0NZ6Uo/Jzmd/VbwLh2kGCADaQTG4VSpdum9y9yfeptF15pt+Wu+YCT0kFXcnTQYAANgEnOsJGX/l12Tk5OM0AwQArc62LMlHP606hjfGYwD11F2YFc/iAbX62chNNBkAAGCT2XLkX8n4W/+vWLUqzQABQCvLha5Trd+Ze126iikaXSf+xH612lXPqCxu2UGTAQAANiFv7P+TrW98SRzVMs0AAUCrWvEOS8l7teoYvuTbNLoebFt800+qlc+PPyC2xWkNAACwWfXOfUu2vvFvCQFAANDKcuP36AYA09+nyXXQl50W18pptfrZ8PU0GQAAYJPrmf+2TLz5ZbFsHgcAAUBrBgBjV6nW7ygelu7CLI1W5ou/oVa75L1aVryjNBkAAADSO/cNCR16mEaAAKAVrXd5ZXlI9y4AzWfTIWLVquKd+a5afe27RAAAANBaAmf+WAaneeE3CABaUj5yi2p978wPRGybRivpT50U5/qCUnVLcqGraTIAAADeZ+TgP5Oe/DSNAAFAq8mN7BXb4VGr714+Lr25GI1W4o+9plZ7aeQ+We/sp8kAAAB4H8uuSOTN/1Mc1XWaAXHRgtZRdXdKMfSg9M98Q20MX2K/LAUiNNswZ2Vd+uPfUaufU747BEBjHbr1m7LcN8K/g85ODgYA7zl161dktW+4fhfStao4qmVx2BVxlYriLi2Kq1SQjtW0eIpnpbMwJe6Vw03Zq47lgzI29Q2JXfYFDhwCALSSXOQm1QDAO/OkJPZ+VmzLotkm+zp/VKzqikrtmqtP8iN7aDLQzhe+rk6puLpoBAC877PRI1VXg4LB7oFz/rKzUpKe/LT0ZqekJ/WWdGeeEpHmeMQ2cOrfSzZ0iyx7wxw8mxiPALSYwuAOqXZsUavvWotJb+YMjTbMN/OyWu3F8Gek5uygyQAAAA1WdXlkcWCnJHd+Rk7c/M/lyH2Py+yV/4esBpvhZc22jL3zn5gkAgC0EtvhlEL0QdUx/PE3abRBrvUV6Z19XK1+LnIjTQYAAGhCZU+fLERvl+M3/ws5cccjUgj/sog07k7bruwPxD93gIkhAEAryYWuU63fH3tcrFqVRhvimz0klq3Tz3L3NlkMTtBkAACAJrfSPyZnr/41mbrnr6QQ+qWGbcfQsT9j5S8CALSSpUBEyr2TavWd6wvSnz5Fow3xK669mh//tAjvawAAAGgZpe6gnL3m1+XMzX8q5Z7L6z6+p/CKeFNHmAgCALSSXPSTqvV9sddpsgEdqwXpTj2rVj8bvo4mAwAAtKDF4E45dvu/a8jdAIOn/ooJIABASwUAoWtV6/fHvyuOaoVGXyJ/Qu8Zq9XgPlnrHaDJAAAALarq6pSz1/y6zO/5p3Udtyf1mHQup5gAAgC0irXeoKwGb9Y7MCoF8S4co9GXyDf9tFrtXPROGgwAANAG5rZ/WhJX/0FdxwzEX6LxBABoJbnoHboXr3EeA7gUXcWUdObfUKltO1ySG7uSJgMAALSJdHifJK/8vbqN54s9RtMJANBK8qNXiFh6U9iXeFSclRKNvkiayykujT4glY5umgwAANBGUtHbJLP979dlLPfKYeleTNB0AgC0irKnR4oj96vVt6pr4p2fotEXyTfzlFrtbORmGgwAANCGEpM/K6vBe+syVv/COzScAACtJKd8IeiLvUyTL0JPLibuJZ13KFQ7BqUwtIsmAwAAtCHb4ZTpq39LbGev+li9qf00nAAAraQwvEtqLq/eh8LsE+Iqr9HoC+SPv6E359GHxHY4aTIAAECbKnUHZWHX76iP0515Shy1Mg0nAECrqDk7ZDH8gFp9q1YRX5Jbgy6oZ3ZNvDPfU6ufDd9AkwEAANrcwsRdUvVEdL+31talqzhHswkA0EpykRtV63sTr9LkC9CXPi2utZhK7fW+vbLsD9FkAACANldzdkhqx99RH6e7ME2zCQDQSorBrVLpiqrV7519UtylJRq9Qf6Y3vKJufFP0mAAAIBNIh25RWrOftUxOhdnaDQBAFqJbVmSj35acwTxzR6i0Rs5oaoV6Y89qlY/G76GJgMAAGwSVVenFMd+RnUMzxJ3ABAAoOXkQtep1vfNvECTN8A7PyWOSkGl9vKWu2W9y0eTAQAANtP3/DHdVb88xeM0mQAArWbFOywl79Vq9btTz0nHaoFGn4cv9oreh3/0NhoMAACwyRSDO8V2dKrVd62dFMuu0WgCALSa3Pg9qvX9iQM0+eM+PMtr0pd8XKW27eyW/OhemgwAALDJ1BwuWQ3coTeAXRPXOu/7IgBA6wUAY1ep1vfGXqTJH8M3e0isWkml9mLoIam6PDQZAABgE1oeuFK1vmt9mSYTAKDVrHd5ZXlI7y6AruxL0rmcodEfFQDEXlKrnY3eRIMBAAA2qdW+sGp9Z2WVJhMAoBXlI7foXuTyGMA5udeK0jP3lErtSldUigNbaTIAAMAmtd4d1A0AygQABABoSbnRy8V26N0q7pt5miafgz95UERsldr56KfFtjhVAQAANm0A0BWgCSAAwIdVXR4phh5Sq+8pvC1dxQUa/QG+mefUamfD19NgAACATazc0ata31kt0WQCALSqXOQTqvX98f00+Sd0LmekK6Pz/P+a/wZZ7R+iyQAAAJtczeVTq83dpgQAaGGFwR1S9Qyr1ffO/IAm/wR//C212rnoXTQYAAAAYjv17gKoOdw0mAAALfvh4HBKIXK/Wv2OpaPSk0/Q6L/m0wpELIfkQlfRYAAAAIht6b3ny3Z20GACALSynPJz474EjwGIiHQXktKx+I5K7eLI/VL29NJkAAAAiFVdVqtdczhpMAEAWtmSPyzrvbv1AoCZp0Rse9P3WfN9CLnozRzIAAAAEBERZ3lOLwBwemgwAQBaXT56r1pt18pp6c3NbOr+WrYtvpnv6XwIuwNSGJrkIAYAAIA4ahXV+mVPP00mAECry4WvVa3vj7+5qfvbmz0rrpXTKrULkQel5uRlLAAAABDpWMur1bYtp1Q6emgyAQBa3VpPUFYHblGr7515Qiy7tmn764+9oVY7G7mRAxgAAADvBgArGbXalc7tLANIAIB2kYvcrlbbWUpKX/rMpuyrVauKd+Yxldrl3klZ8kc4eAEAACAiIp6VlFrtck+UBhMAoF3kx64QUUz0fPHXN2VfvakT4iinVWrnxu8TsSwOXgAAAIiISGfhrFrttb5tNJgAAO2i3NEjxdH79S6EY0+IVatuur76Yq+q1c6GruXABQAAwHt6Mnrv3lrzjtNgAgC0k1xYbzk5Rzkt3oXjm6qfzkpJ+uM6t/+vDN4upZ4ABy0AAABERMS1viyexdfU6q/2hWgyAQDaSWF4Umour1p9X+KNTdVP79xRsaorKrVz0ds5YAEAAPCe/vSUYnVLVvtGaDIBANpJzemWxfCDavX74o+Jo7q+afrpj72sUtd2eCQ/egUHLAAAAN7jS7ygVns1cJdUXR6aTACAdpOL3KB3EFWWxDu/OR4DcK2vSO/s4yq1i6EHpeLu5GAFAADAu989yyvSO/cttfrFoRtoMgEA2lExuFUqXRNq9bV+Kt5s/Ml3ROyaSu1sZB8HKgAAAN4TSLwmll3Ru0YYuIwmEwCgHdmWJfnofWr1e5NPiLNSavs++maeV6lb9YzK4pYdHKgAAAAQERGrVpWBUw+r1a+6h2XZG6HRBABoV7nwdYofUCXxzR5u6/55VvLSnXpOpXY++oDYFqcjAAAA3hVMvCbu5UNq9QuRnxPb4aTRBABoVyv9w1LyXaNW3xt/ra3750u+rVY7G7meAxQAAAAiIuKslmRo6v9RHSM7djONJgBAu8tF71ar3Tf7XXGtr7Rt7/zTz6jULXmvlhXvKAcnAAAARERk+Pij4lo9oVZ/ve86WfZx+z8BANo/ABi7Sq+4XWvbxwC6igviyb+pMyfj93BgAgAAQEREenNnZeDEl1THyEz8NI0mAMBmsN7lleWhe9Xq+2ZebMu++eP7lSpbkgtdzYEJAAAAcZVXJPLmvxYRW22MqntYMuGbaDYBADaLfETveZ+ehafFvVZsu575pr+nUndp5D5Z7+znoAQAANjkrFpVxt/8srhXjqiOk97xK1J1emg4AQA2i9zo5WI7tE56W/zJg23Vr97sjLiXj+vMReQWDkgAAABI5J0/k56Fb6uOUfVEJTV+J80mAMBmUnV5pBh6SK2+L9ZejwH442+o1K25+iQ/socDEgAAYJMLH/6a+Kb/s/o4c7t/U6quThpOAIDNJhf5hFrtrvQL4lnJtUWfLLsm3pknVGovhh+SmrODgxEAAGCTsmpViR74LxI49WX1sVYDd/LsPwgANqvC4A6peobV6vva5DGAvtQpcZaSKrU1QxgAAAA0N9f6smx77Yvim/4T9bFsyyXxK35DbIvLPwIAbEq2wymFyP16AcDMs23RJ3/8NZW65e5tshic4EAEAADYhHry07Lz+d9Rf+b/Rxb2/C+y0j9G4yEuWrB55cLXS+DEf1Gp3Zl7XTqX0rLWO9Cy/XFUy9If+65K7fz4p0Qsi4MQwIZc+cz9m26fj33iv0l6y+VMPoC24qiVZfjEd2Xw+BdF7Fpdxlze8hmZ33ovzce7xyAt2LyW/GFZ792tVt+feKul++OdPyaOSkGldjZ8PQcgAADAZmHbEki+KZPP/D0ZPPb7dbv4L3fvkelrfpNb/0EAgHflo3ppoG/m6ZbujT/2skrd1eC+lr4zAgAAABtj2VXxzR+UXS/8Ywm/8dviXj5Ut7FrrqCcufFfSrmjl4nAe3gEYJPLha+VLYd1ancsviPdhTlZ8Q633olRXpPe5GM6PY+y9ioAAEA761jNSSDxigTPPCKu1eN1H992dMjZG/9QVvtGmAwQAODH1nqCsjpwi3SlX1Sp70u8JSveT7dcX3zJd8SqVRQ+jF2SG7uSAw8AAKCNOKpl6S4mpC91WPpnX5DO/AsN2xbb0SHTN/57KQZ3MDEgAMCH5SK36wUAM09Jck8LBgCxl1TqLo0+IJWObg46AACAFuGslMSyq+KorIujVhbX+pJ0rGbFvZYVz/KcdOUOiafwslh2teHbaju7ZfqGP5LC4B4mDgQAOLf82BUy+pZD5WUk7uXj0puLyZI/3DL96FhblJ7576vUzkX2ccABAAAYsPOZn6MJP6HaMSpnb/wDWfKP0wx8JF4CCCl39EhxVG+JKV9if0v1w5c4KCK2wofyoOSHJjngAAAAYFSp/wY5eet/4OIfBADYmFz4ZrXa3pknxbLtlumFf+Y5lbqF6ENiO5wcbAAAADBmMfQ35MQtvydrPYM0A+fFIwB49+J0eFJqLq/Kuveu1RnpzZ6VYnCi6fvQuZyRzqzO8n/Z8PUcaAAAADCi5uyX2cv/qaQjN9MMbBh3AOCvP0Dcshh+UK2+L/5mS/TBH9d5XGG9b68st9B7EAAAANC8VgY/Lcfv/O9c/IMAABcvF7lBrbY39oRYCi8ZNM03rfTyv/FPcoABAADgklQ9EUlc84dy4qZ/KqXuIA3BBeMRALynGNwqla4Jca2eMV7bWZqT/tRJKWzZ2bT735NPSkfxsE4AELqGAwwAAAAXxXb2Smrnb8nCxD1SdXXSEFw07gDAjz9YLEvy0fvU6jf7YwBa27e85W4pdfs4wAAAAHBh388dHZKb+HU5es/XZXbHg1z845JxBwDeJxe+TgamdGr3xx4Vx5Wfk5qz+Q47y7bFN/OETk+jt3FgAQAAYMNq7kHJTvyyLEzcLWVPPw0BAQB0rPQPS8l3jXjy5l+G56gUpD91XPLDe5puv3szZ8S1Om28ru3slPzoXg4sAAAAnNd633WSmfgpyYRu4qf9IABAfeSid8twXudt+P7Ya00ZAPjjb6jUXQx9VqouDwcVAAAAzqnmCkoh/DnJhm+VJd84DQEBAOocAIxdJcMHdGr3Jb4rzqt/UaqujqbZX6tWFe/Md1VqZ6M3cUABAADg/Rf97iFZHHlAFoevl8LgpNScHTQFBABojPUurywP3Ss980+Zv9iuroh3/qhkx65smv31LhwXRzltvG6lKyLFga0cUAAAABARkaXhn5bUts9KMbBVbMtJQ1B3rAKAc8pHblar7Yu/1lT76o+9qtPD6P1iW5xiAAAAeFdH8ZR4lufFqlVpBhqCOwBwTrnRy2XU4RGrVjJeuzf5mLjKvyQVd+NfbOKslKQv8ahK7Wz4eg4kAEYcuvWbstw3sqn2ucrtsADaMQBYPiijbx+ULVPbZGHXr0g6vE9sB5dkIABAo794uTxSDD0k/TN/Yby2VauId/awZCLXNnw/fXNHxKquGa+75r9eVvuHOJAAGPpM7pSKq4tGAEC7XIStnZLRA/9EBk5dI4krflMWByZpCuqC+5PxkXKRT+hdeMdfbop99M28pNO76N0cQAAAAPhYHUv7ZeKlvyPRA38irvIqDQEBABqnMLhDqp5hldq9c98Td2m5ofvnLi1L79yT5gtbDsmFruIAAgAAwIb4pv+L7Hzut6U3f5ZmgAAAjWE7nFKI3K9UvCa+2UON/aBNHhSxa8brLo18WsqeXg4gAAAAbJh75YhsfeGXZSD2Es0AAQAaI6f4IjvfzAuNDQBiL6rUzUZv4cABAADABbPsioy99Y9k9Nhf0gyo4CWA+FhL/rCs9+6WjqWjxmt3p56VjrVfk/XO/rrvl2clJ92p54zXrbkDUhjiJS4AAADaTt36FVntu7THVS3bFmdlTVzrS+Jey0vn0qx0Lp6V7ux+cS+/07B9Gzz2B+KsrEnssl9gokEAgPrKR++VLYePqtT2JQ7IwrZb675P/sTbKnULkQel5nRz0AAAACirujxSdV36stIVd5eUuvwi3rDI0OXv/bpnJSP96aPiiz8t3ekn675/gVNfFltE4oQAMIhHAHBeubDecn2+WGMeA/BNP61SNxu5kQMGAACgDZS6g5KK3CIn9v2vcuyev5LM9t+WmrO+d64GT31Zhk8+wWSAAAD1s9YTlNUBnefauzIvSedypq770704L57CW8brlnsnZckf4YABAABot+/D3QMS3/N5mbrnEclu/U2xLWfdxh468r+Lf/YtJgEEAKifXOR2tdq+5MG67osvsV+nR9FPilgWBwsAAECbKnv6JLb3F+Xk7Q/Lmndf3cYN7//H0r0YZwJAAID6yI9dIWLpHC5at+Ofk22Lb/p7KqWz4es4UAAAADaBlf4xOX7r70lm+2/XZTyruiTR1/+1OMurNB8EANBX7uiR4uj9KrU9hbekq5iqy3705mbEvXzC/D8Cg7dLqSfAgQIAALBJ2A6XxPd8XuLXfklsR4f6eB3LByVy8E9pPAgAUB+58M1qtf1Kt+V/aJz4mzq9id7OAQIAALAJZcZukLOf+I91eUFgf+IrMjj9PE0HAQD0FYYnpebyqtT2zug/BmDZNfHOfNd4Xdvhkfzo5RwgAAAAm9TiwC45e9P/XZcQYOSdfy7dBd4HAAIAKKs53bIYflCldkfxsPTkE6rb3586Kc7SnPG6xdCDUnF3cYAAAABsYsXANpn+xB+pPw5g1dYluv/3xVEt03QQAEBXLnKDWm1f8m3VbffFXlOpm43s48AAAACALAZ3Suy6P1Ifp6P4powe+xYNBwEAdBWDW6XSNaFzgT79pIht6xzo1XXpjz9mvG7VMyqLg9s5MAAAACAiIrnhK2Ru779QHyd48o+kL3uKhoMAAHpsy5J89D6V2q6V09Kbi6nU9s4fE0elaLxuPvqA2A4nBwYAAADeM7/1HslHf0V9nPD+fyPOSomGgwAAenKK693742/o1J15WaVuNnI9BwQAAAA+JHb535A1362qY7hXDsvY0UdoNggAoGelf1hKvmtUavfHnhLLrhmt6SqvSu+s+bf/l7xXyYp3lAMCAAAAH1JzuOXs9f+zVDt0vy/6z/xH6c8cp+EgAICeXPRulbqutZj0pc8YrelLHhKrVjHfg/F7ORAAAADwkUpdAYlf/c/Uxxl7+0usCgACACgGAGNXqdX2Jd40W2/mRYWttCQXupoDAQAAAB8rP3SFZCd+Q3WMjuWDMnLiUZoNAgDoWO/yyvKQzk/AvTPfFatWNfNhuLYoPQs/ML6Ny8OflPXOfg4EAAAAnFdiz8/Let+1qmMET3xJuotJmg0CAOjIR27WOSjLaelPnTRSy584oLKN2eitHAAAAADYkJqzQ2JX/a6IWGpjWHZVQgf+g/H3aYEAABARkdzo5WI7PCq1/fHXjNTxTT9r/gPc1Sf5kT0cAAAAANiwJf+4pHf8juoYXdlnZHD6eZoNAgCYV3V5pBh6SKV2X/yJS36RSedSWjpzrxrftsXwQ1JzdnAAAAAA4ILM7vyM+qMAQ4f/jXSs5mk2CABgXi7yCZ0Ds1IQ7/yxS6rhj+9vqX0GAABAe6s53RK/8h/oXuBVFyV06E9pNggAYF5hcIdUPcMqtX2X+BiAb8b8y//K3dtkMTjBxAMAAOCiFANbJTf+a6pj9M3+hfjn3qbZIACAWbbDKYXI/TofXInHxFkpXdTf7cknpKN42Pg25cc/JWJZTDwAAAAuWnL356TqiaiOMXrwD8VZXqXZIACAWbnw9Sp1rVpJvHNHL+rv+uNvqGxTVmlfAQAAsHlU3N0yu1f3hYCutdMyOvUNmg0CAJi15A/Leu9uldq+2CsX/Hcs2xbvzJPGt2U1uE/WegeYcAAAAFyyzNgNsjJwn+oYgTN/LL25MzQbBAAwKx+9V6Vu79wT4lpfuaC/05c5La7VGePbkoveyUQDAADAmPjlvya25VQdI3Tgy2LVKjQbBAAweHEc1lnOxKpVxDd7Yc/y+2KvG98O2+GS3NiVTDQAAACMWe0bluz231Idw7P4qgydfopmgwAA5qz1BGV14BaV2r7YSxs/oKsV8caeML4NS6MPSKWjm4kGAACAUbM7PiOVrh2qY2yZ+qJ0LqdoNggAYE4ucrtK3Z7574u7tLShP9u/cFwc5bTCvu1jggEAAGBc1eWR5N6/rzqGVVuT0Dv/mWaDAADm5MeuELE0Dilb/MmDG/qT/vir5j+UOwYlPzTJBAMAAEBFbuRqWR76jOoYPQuPSlDhuzIIALBJlTt6pDh6v0ptb+yH5/0zzkpJ+uKPGh+7EHlQbIeTCQYAAICa+N6/JbblUh1j5NAXxb2+RLMJAAAzcuGbVep2p54Tz0ruY/+Mb/awWLWS8bGzkRuYWAAAAKha69ki6Z2/qzqGcz0pY0ceptkEAIAZheFJqbm8KrV9yXc+/vcv4GWBG7Xet1eW/WEmFgAAAOrmtn9ayt17VMfwzvxX6U8fo9kEAMClqzndshh+UOfDKvHyR/6ee31Zeue+Z3zM3Pi9TCoAAADq9F26Q5KX/5b6OKEDXxJHtUzDCQAAAxfNSrfMd6VfEPda8Zy/50seErFr5vcldC0TCgAAgLrJD10hxZGfVR3DvfyOjJx4lGYTAACXrhjcKpWuCZXa3vmj5w4ANvCSwAu1vOVuKXX7mFAAAADUVeKyXxbb0ak6RvDEl6S7mKTZBADApbEtS/LR+1Rq988d+NCvudeK0r3wtPGx8tFbmUwAAADUXak7KKld/1B1DMuuSujAH4ulcBctCACwyeTC16nU7Zn/oVi2/f5QIHXS+Di2s1Nyo5czkQAAAGiI+W33ynrPFapjdGWfloGZF2k2AQBwaVb6h6Xku8b8AVtOS9fi3Pt+rW/+oPFxFkOflarLw0QCAACgIWoOtySv+G31cYYP/4F0rBVoOAEAcGly0btV6vZmTr3335ZtS+/sc8bHyEY+wQQCAACgoQqDu2Vx9Bd0LwgrWQkd+jOaTQAAXGIAMHaVSt3u7I8DgO7CrDjXF4zWr3RFpDi4jQkEAABAwyUu+yWpOftVx+hLfk18CnfVggAAm8h6l1eWh+41Xrcre/jHAUA+Zrx+Pnq/2BanBgAAAJrhO7VPFnb/rvo4Ywf/rTgrazScAAC4hIvpyM3Ga3YUj4iz/O6HU3fG/AsAc+HrmTgAAAA0jYXxO2W97zrVMVyrJ2T02LdoNgEAcAkX06OXi+0w/zK97r9+EWB35h2jddf818tK/xATBwAAgKZhO1wSv+LvqY8TOPXvpSc/TcMJAICLU3V5pBh6yHjdzuK8OCsl6SgeMlpX68WFAAAAwKUoBndIIfw3lUexJXzgy2LVqjScAAC4yItqhTfqdywtiGc5a7ao5ZBc6ComDAAAAE0psecLUnMFVcfwFF6WoTPfp9kEAMDFKQzukKpn2OwHUzEhnUspozWXRj4tZU8vEwYAAICmVPb0y/zu31EfZ8vUF8WzkqbhBADAhbMdTilE7jcbACyeEs+y2QAgG72FyQIAAEBTS43fJmvefapjWNUVCb/zJzSbAAC4OKbfrN+xdFS2vPMlY/Vqbr8UhiaZKAAAADQ123JK4oq/qz5Oz/y3JZh4nYYTAAAXbskflvXe3U27fYXIQ1JzupkoAAAAtMB36wnJR39FfZyRQ18U1/oyDW8jLlqAeslH75Uth4825bZlIzcyQQCa1pXP3E8TzuGHn3mbJgDYtJK7Pyf9ye+IozyvNoazFJexo38u01f+bRreJrgDAHWTC1/blNtV7t0lS/4IEwQAAICWUe7olbnLfld9HN/0n0hf5gQNJwAALsxaT1BWB5rvRXu56H0ilsUEAQAAoKWkw/tkzX+7+jihA/9OHNUyDScAAC7wYjtye9NtUzZ8HRMDAACAlmNbDolf8esiovvDrI6lt2X41OM0nAAAuDD5sStErOY57FYHbpNST4CJAQAAQEta9kYku/U31McZOPZF6Vqao+EEAMDGlTt6pDjaPC+zyo7fwaQAAACgpc3u+mmpdoypjmHZVQkf+GMR26bhBADAxuXCNzfFdtgOj+RHL2dCAAAA0NIq7m6Z3fsP1cfpynxfBmM/pOEEAMDGFYYnpebyNnw7imMPSMXdxYQAAACg5WXGbpDV4L3q4wwf/qK4S4s0nAAA2Jia0y2L4Qcbvh3Z6M1MBgAAANqDZUn8il9Tf9+Wo5yS0KH/Rr8JAICNy0VuaOj4Vc+oLA5uZyIAAADQNlb6RiWz7e+pj9Of+Kr4Fg7RcAIAYGOKwa1S6Zpo2Pj56P1iO5xMBAAAANrK7I7PSKVzq/o4owe/JM5KiYYTAADnZ1uW5KP3NWz8bIPvQAAAAAA0VN1dMrv3H6iP416ZkpHjf0XDCQCAjcmFr2vIuCXvVbLiHWUCAAAA0Jayo9fKyuCn1ccJnvy/pKcQo+EEAMD5rfQPS8l3Td3HzY3fS/MBAADQ1uKX/6rYlvYjr7aEDnxZLLtKwwkAgA1cjEfvrvOIluRCV9N4AAAAtLXV3iHJ7PgH6uN05n8oW848S8MJAIANBABjV9V1vOXhT8p6Zz+NBwAAQNub2/GAlLt2qY8zdPT3xbOapeEEAMDHW+/yyvJQ/W7Jz0ZvpekAAADYFKpOj8xe/tvq41jVJQkd/BMaTgAAnF8+cnNdxqm5+qQwvIeGAwAAYNPIDV8lS0M/pT5O7/xfSiD5Jg0nAADO86E0ernYDo/6OIvhh6Tq6qDhAAAA2FQSe/9HsR3634NH3/lDcZVXaDgBAPDRqi6PFEMPqY+Ti3yCZgMAAGDTWesZlNTO31Ufx1maltGjX6fhTcx6+8lHbdoAAGYslUM0AQAM6ZVlmgAABnEHAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAAACAAAAAAAAQAAAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAIAAAAAAABAAAAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAABAAAAAAAAAAAgAAAAAAAEAAAAAAAAAACAAAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAACAFoAAAAAAAABAAAAAAAAIAAAAAAAAAAEAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAIAAAAAAABAAAAAAAAAAAgAAAAAAAAgAAAAAAAAAAQAAAAAAACAAAAAAAAAABAAAAAAAAAAAgAAAAAAAGDc/z8AZKi2E5CoEaAAAAAASUVORK5CYII=",
    Yb.ImageUtils = {},
    Yb.ImageUtils.registerDefaultImage = function(a) {
        null != a.src ? lc.Logo.src = a.src: lc.Logo.src = a
    },
    Yb.ImageUtils.registerAlarmImage = function(a) {
        null != a.src ? lc.AlarmBillboardImage.src = a.src: lc.AlarmBillboardImage.src = a
    },
    lc.ssaoNormalImage = new Image,
    lc.ssaoNormalImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAhB0lEQVR42h2a53IjSZalXbuHhKDMUiNs9nnXbN9vpnu6qzKTJGQo1+570L/KLIsEIsLvPef7ANL/93/rxy2PO+5V6j+KPUr+lfJQl0XtVNIy26BTzUaThcVh0uRAlliahmyMmtvW7tsphNbnu2l2U3FHkSNpTCBX5bscl9ARkyQVLPBaryQNQs6Rval4v8nmkNbImRNKl5yYEXlKlfXS0BDPtb4o/ZnXLqtJ2ybteSFZXUp+E+UuMrsZ8paHzMUaiZLX250rW05Hqq7E6qpSrqYJPG9rVY1bbZZJWOM7M39c6Y5zv7IQKRuqO11oVjMr1dtbm/r/FtddyV9K8itZm9wFWrfFEpfL3ojjQn+ITLowfcbcNrf/DcVo3kbl65nwXRaS48aI87w9ZPtJnSAsZjdoWvOEB9auKdBrpiU51i3rB1PjTty3MvIY7qKqyG4600xVqSvlXRBTvvRiXMvAY66cRbYGelD4n/lJ8ESXy9T9h65/KcuKefH0RGvd4z1DKnUU9cZK8srFwnrbZ1mneBvkPtg848ok9TkPXOssNJlmujd03WJtk75LIeJ6k7J63gk+4TmUbgunRr7MPHPPiE6Z2UCMoLgKoSUrW2sOLjAz8/q+0dvKW87zhduh7EJKtIRWMsWHuZy7uqdVOrWSTHQ78PJFWJ8F0/zCaLOpeV/7leM2Vh2lk6I43/Nyb2W/cdV46wPnpYsvDAPZSBrSIqLLWol1wU+3dY27Q/pSXORKvUy3XKTu73TpdZNr4oF2wnO238TfRO1lDkmLvfBnsrVrs+qyj2zZkXaWtuT4ksz2OHpNyuzY+yVfWvrs6xaUSdU1tlbcuqK5SlrWjzAe6GlX9xNNLQ1rbCZaWrdG+pSt0yoGRXzVRkcdqNWe5pCzSYx3bomt8avsJM2WkThtxngaSeVDLdlY4vMzlyuRJXpCyVpUrLeGvaVyX9QfDRFr0ZKbaR/fVnajrIvpPNanQMk1hlFQJkiu4yy2LvEos8mMlXmoo+2iTWlI1MogC+sSNkxdo9tz7SjtoihkKbrTrmaRlGg3b3ckp4bcS6OEpcpgiSR+ve/YZhtO7yV38pmKz6fcOxIDl5nd29pVrq9l2dHKECiJztx1qXPKNxG3/DVW4b3HcPc3fiJEDs57sj/n1JZ8YOpUiuG44nWsbcisQaoQ19fnW72X2u2ZO9fR2Pmu8jNpZNGcFMqLnZkweALGhVlUlgRzMRmhU9zCnfZ0S6yrDpePEccq0MzCmtUgyhYmpbtrvQmkYp7n1HjBFXF70iCUTI20lEFol3JXw62aIfQzVmjU/mJXVg8i+ZNJpGhDPyhGWSAXsBnDv9bbRtlEYfeltTFVkk2zfs/q9xxOjB+Lniqe5pmKjgd+NNEpHn1si/aiSi6GOl3ZSJhmpm6FNOzqybEh2ZIl16GheAyJBaIUn9Ld1F9KOX/Xe11PQhIehNNpF7C9BnHpWVeEX3R8iuNWMgK6rKs1pV+Zpzo3RQhipW8XESwzMUrh3GzKaDGRPBc6h4A46qrZrHim80doj5ReGtx1UEE2VeRELnwZFgyAiSLQFFKoZ/pHX/5Jpcyeclasf9I4WDKxIJDIKmPoqcvBpNip/UbuzPB9Xgttuy1fZLSZ6iobv91lt98cCsGTZs0Rx90hQLA+S2zG8vOavu3pxSnmOK2UfsvYtXuRpsvywqlkiyJDqy4RA12lZvfsVaeZzamn0ti6oakoSf32Mu9uLenTmsqgCylNtul7oMNSt1bsmciZTraivAyGztD4PWE9mhYdgMxg+zHdL2FQlXETTpUqEn8hT5le0ShHok9q6wg3JVGWqH4NQuQSBafnH+z5EOc0DOHmexMpJR/MjyhInJ5YR3qq27do7reweyaE4Ce54DE6c9Rp4TVuRFTSLtG3XP2U5SXGWyGtdGgemfaa3CMJHS5AfPg4vFW1SnIt9C2RT8XekPvV8dxm2nH6/R/85Rc/1XGYzvnYqijMqcydTCE8Z4Jb2YIfkPvO5j2ZlBSyshoz/V2mSfR2u7dtXmtDUzmEuDWNirj6fGFH3Zykefk3ejvj8UeSCgtKGbJQJQPj1sg+rAMeawrHSq6aHnF7RTE6Vnaq6DWyZjaJ+tKq7btzbfztWP9cRPtGYsShiG5KVnPpsvovVS+0CX5tO3KnlHk/1t4rbfIJrX1TR8MTfvBI5aXK1otAKmuZ+PLR1NJgMmsr46TQN7TlsQYaQ6yjkjff6LRdMXFCBVGTrEMqjoEZJOhAh1k2MiXULgbaHZzauHWkU/lnEzoqxVITBjsFlwlrCyvdT+WRbORGZVbi2TmbqOdhx/h3V3rGeEGOHZpoBSsZUe59og3W4kjryS1tGiemOp4dE1qQr3MZR5Zzlniyia5K77c8c+a7olD6mW6XzPfGLRzXpi6EGUmec/8lAVRxJoVFwMZuqrOgQ2Xz4OhiMk3diwRijUt1W26PqO56zeIoq0XxktJeJPDFaEaaKf+j5z3nfVl/SPrGiKd4SY0pJ7q6WCWJR6XuhLRk+6zyxQxX6mQql9K+tkIw1rcedx8LpikrmpwvYWB5YeqzxpHQmF5b9rd7fR4BVlTu3VcVB2dW4xklfCiR6MMd8xMCYynl6GWfY1VoMoQ3S46w32hKZFgpjuge8WxjL+IXTy9F20zKR6+/MTGFa2THd2fvBBMCdMqhEuznSMO98rWkHXVzejfiH5f8uqdkpuzg77wI56mImpjKXeWV+51QpNabGwcZKcl3RnqBFTyYbZmHrg120QMgpHpqKGKe8Kgnd8Vv3dHoADR57OO9FQikLkVJWKZgtYKzJa0LzaNN5djltDWg3FDQ092h3LfYdThIxSYCtom3CEzWB14KrTern4AhpFhWdxjdLDmZ7qptCvCkJiqahO2ldOH8gMIQ86fnIzUHYlNNZ77v07QCjZI66Ja6ZePj3nnLWDCc1Nig9KV84tlnHOOpELpzt4n3HQlmCxcEqNdKSZZ1BQQQlEshhs/LxpDUlWpC1oBarJGZ3lx9ypTmqdDntF/YXz/D846EPdiRppnVpnYL+QK17CVaLzrUUWh1KzZA4ZwoxnrRCIfxIG4htje8ARGvOW6SN+ugm8+tNKWiisJNDTqcOypsamdxquUbKMnEbdNG1M0JoaARjp9M2OW21eCM/aLzIZeToV1gMbGh8bkMK6YreE2ajQx7Ot9c07UA4xR1czM3k/YHZj2AUnKV1xfWO+aF3Rn1ZWnralWZbxwjIpSM0WQflSphPtP9b7n/YRzq81DlwmdwpWCLTSN6tAHgh6lP/IO1r1s1yGap1XrZ6mDrXaS24c1MQ+PSyMQuDxu/N5v5Z0P7BNRH1GB8HrsR4hPJJyWOlTWFb0jqST+1dMPNEdooevP+6S7iW2UTtzgnRbqFkc1FVqdAZcE8qy8Sqi7Son+uEpyrmHINf2Ph6595HOtVwHgQoan7VemFWTzTVEDjhpXemeU/wmHiCV6kmIyMHBSxHNHNbBJje8ri1w+xdg+qef9L358TkCXbKm+ZiEIbKmj9snIYsIil7pJy0vaJwO82jEMdoxY43jXfPsPQNUwUP5VRl/Nr8y2lS4QrSqAkCtgwc3tnwpnSIl2qB49P8IgdnJbqrSJhFLLwWj1LZtb00frAJVHQMre8xpqZ3sWcRFkuybSUzxIxtkLfsGjPUALMBl4Ng8eBfwoB9UYbV26pNETrYcV1T4eqz6yTs0jQyZVxvWPkQ9lDLBedevWvt16x53XxfMfjpRK+ymKkJJg9EWc2TFmMxZ8c7oo/3dza9AQtM7NYCdl7ZLS6c5qJbSuTPnNNcqBPiVwl6WinRLLb2ulxZjcSecfQa3jtAiByGTVagthgPYnJsSBWko3UqydN5lq1K1uR7Z1vwjVDr+Dysa1ivS8Mctd5iINeZW2wJ7xMPR5IovceUUNa03BvJZzKtmNsgxERw60V3nLpekLL/hp/dPKdxemTqZZwaeeWdKR+nMTvfIMRBjjNnhOEvrdBtPTPnHZVWoREhkvqDBSsAxEpIFJZq8B4Xn5pALzFlDdI00furU6N3bZS3Ut2yqGPKqagubZdaVf6s1E7POzZXTv9VHN74Unm3G2cCyXq14W/4sF5oncpmArj4NQT0nEC/aZy5vI5MafEcBTXJRyTllitRPbjCkNb2mkgHbQmY5d4QE6z/5PZatDgxKod0LOk7178ZtgHzF42DjpZTR7YNkbxExQIwwNRU/rE3aa4qXmriglQAAfGU8YXUkaEDPWFJKOfnbr3Xu8pRSrODXpndeW98650pFszwplJsdEqmkpRGUe2D+HvW2xRlgTiUZ+asqaEx2uKXFcxN+5FdrfzmoeGAxBSYo0Y/ynPQ2k3w5t8g/7sxX8Wfq4h4mEpqAc6qEgXw4nHdyHXEGHwOpYNJ+Zva9M95fZngguXh/SJ3KMLiN5XnfIN3czjfq6XqvY7cHEk3O8Tv0EgmrgXZtuchoFwSTWAbdH8FL7E8Fzsuq8mpGZVN0gcQ3q09q2UhT9d80V43nUgeranPIGx5KS23lfbc3Oh0MXdrc4EoYaGIooWkG4FAqBxn7kA7HdBeFl8pozoRuM2wv9w+l4fLPAly4AKSHaW+Z5LbQxj1mCjwnERd2AcxMJp+8riVv64lh8Uqt4OpIibi+/Y9JiV0UItPyh/skxYfhkzr9RUsqT0eimBs6+jHyYIVSI83YGlnPUsPx49smjN4oWnTtYpaV8DfEMxLDwfS1gpaSkcmSu6LXgTWw1XiXxfyDgG1vDPWp9ZZR2BqqYbZZlwIWi3nKN+rWW5qnwoQJJ9YaeUDlMiRP2JgYxkSDnBuP8g+Tvtnsd0zuSwgax1sp59G/TsOX5Yu9ry1XPFcRHjuYnHlK2TzZHQlViRVJalq7LWsFT9yfNOWZoUafSYvSSwftPjNIDMPE9ZdmypHE8BMrY31Z8rM6ZLa70p2+CtA9qxM3kmIFS9k3K9BfVbS4FGqVg8g5FuKxaav6ThhDXJ1fKH4Gnkh9XCWKxmbVWen/LhZC8tMomUpAmmqPI5p0OTapvLxtRWHcpl5GUNdxrbla0Llc+F6A2BPfR08zFXyr8wKCLcMx+iISL7OivEFmiMLug0SsihFuuaBAnm39p4usMbgLGyiTiMUhhvfivutEI0NKH3JFWhI6k/awiGCu1dlDoxsUh6AB7NyJHc9gTzmU4ksyis5CLhv6HSIJJuuFvI/v6gYzZyReh2LZzLAY17Y/1rXm8CboxomRbfMzrdw04CLVBGIPPmhi34zddbvImmB9nxQGxk0QhMjmSNqp8/VHcMWciyEobdeRbG1c9z/QYk9ewm486LhZObrr2Um0/syjjj6omJXtDzLZhYdadWy/KQhqCs3pBqVDBfcw9chDpfLOJqIWa/91vAFnPWRGP45zntWhnOtN+xJSS0Gc/1nNPY8JU5ODhpCO7rjXf/xEY05GXNM4MnyiYz/Nguyc6U71N8f0PZNcLbOVM8n3apfw75aZNLs44blZgUBJPlBip0R9PQzCXvUohJ+EiY0oHHoST81O1UB0nu89D0KVqCJVMmLU6YA/xFNMQFdERIipOTNe2c+kFrwedv2V6IkpRXcoLzPOo2jlbFHrRs3pT+4GH8S6IZv1T9JaUPZFufjx7uBYDNo2nv1GE8OVWdigET4NXuA7+ay/3odkEsxRu926cH8+7SxMRIbAi0z6BGZz8c+b2tP0V9krkNBel76MTmhRjCZmtXxcC3i1VH4q2tTHmCTLyk9oncM6ZwKksTChcxDsR8EHdoKVziGHAcail89PlHpq8rnZ7Kzxz+zcqTJL8T9/evmjp+I+QXyZYSuglBiJhuv9VwHmqDl7O5MYVq6xJpDwnC6jAzYiaxqdFW/CPg+9ciTs/NYVodVoEKyfxW5cDoDb9MabiavXa4k6TUsVJHK3pKbnW9gHkUhawwQei4qdLeotqJuYZnpudzpapa2eG0eigOZ5LQ7538NScP9BsgkebThF90PUuxW+t3y15Qdz3aNI85+NCYewFaIqZhBxmqGISdWWOwkPzKmy6UPXq5o/vAyRVT4fJspVdxlGGFw+IIZmh0NSK5nXITRd4iMT3FtLEIIzSUrLCmoZYWvL1LKfYEmw3Ae/LU0tK85LqWbeODMqwJV527ewScLC0Ha+BOO5aWq5yE4zaxth44p5pZTK3pXaqOuvce5qVNk6mvZM2q5Vtfy0xXIOojOP2ydebgA1gzzkJs6NMywL5njHZuzmXpAeR0CcTIQBpZfZAC1CFcD54vcsq56ZgGwIC++4kZeU+5Z4fZ2UbUO1GmnoXSu2Bk+ZH401e+Gt0PWdCySPP4ZgH9nPII8aKBWjHzKG/ixTQfpQxY+I7ax0e2Od+Qy1TsJPAD7TZr8u7omZKG9fmp6Cgf29trsbZZrdFemBK8RuKfEoYUj5lONXHW7nDgoNAau/x6LydX+hY1XTcbW4uwsr1gxFCHhUcspNjsql1NBzYJ+baJB6L2tYc9ZZk2NqRwfykNcJpBDJSgQLhEIFYlWDwlFaiu6cQxAG0pn0/p9avZaJIXElAgXbYd9KZanRo8MliL4gHxNFr5ycSgozV6jvn4N1meOV6WPgEIS/CCTRQyac7JjSA7ZhvOVq6kB/7SMoBVAJllZpspv0f2SZgeLN243AlWmI9JZ/xYIZyFt4RyHiKdHH/qAhxkqqBTOUB2pRAycieBKbrB9pvTFIf/0dsLZUHUt6yC34rGkmlB3ezVgdSJu4Ht8ZuPD1TuKe1YnOPAi/q1g0pXUxgDbjZsiCsnA64RuhKbYcxiLj6lRMyB++/Z7cYyXQob607QuyM9ZGYhCVgEm5miGDMoMD/pEMjhziLDMdR2DOezQHP3vrS9+TjHF8jkS0ZbX6N7H+l8jqoFjOsUkWT1s/oxtXLwjy8fUNSSmNzMfdRrRr6ItFF+aOO58L5wn+8hDqJ6QHvcabO4S6ubaNdEd49v+2aL58nogIXAuJlBuNsXGRq8caWr8cU91kVVxliZiuglWQI/sHCqY1fPG33eRTze6Hw3VOSUY5TO9oAne3D0R0u7wHdt+GL6ENJCg8wVw7nVp7VfYeiXfTQbs5EcBKJAAr8qIzsi2N7l7whP1qS80A6VjK1u2mVdEEl8YPEUeDfWCp5tE+6WHGi/+rXKNZVeNFfE0IrYxoJusNGesBMprS0g0EHGHy1vL6Td4ZqVeYXHJSiiigUQAmAVJUaiiuJ84vSbpyH0P+qGqFhzJ01E+IGo+oUuba1Kkw1SWwfaIqk6zBvNO2q2AsnQTNmqyVokR0nBUjJbbv1xhzZg2P+RyRQ2mvOVqaGl4UddhoahvhugMmltxn2IimElogt3aEBlpUVCJvZZ+7GmXzO90TxQg8UmnKYgcAtQQEauz8Dj5koSfuo+iSfSPSaPUKKlJcA51jCezh1/kfQey+PohSg2uBKkPDbs8knoqxE3XpAONQqatkeXk7qYeHBw4SRFwi5Mce6AwbG+m/xRFDtmsz0+cAVk8Z66jBetIm8gT4X4L9XL2lsy0kqOJm5RXWr0ghf4qqAKLSaiysctf2dy96mAXazFe1Gj/6V4Q2EW74gGpF6QRdNfZg4g5T2B/UA8afdwx1dRPopUBwBQElzQaFmBzyAsnKivjHyy8OLIVkswy0ifmf28Atvy6SoHs7lG5IenEe0NxNoAUxINpSk92RI7SPrnjcL0kIglRGUEi9U+pTaL6GHPTD0XMNkH5L0l7CxmRY+34loSnICUrlvtaKOCRSyFlosTId9cmGncOD3CuZfLZdQqLqsQ3BdAdWEC6wIvTsqiKfcm+p8YCck/oCaYu+Rzxf1jDxdS4a9LoHlOus1Nya4IrbevOe1EbGgjS5lCdVt62fENzqAiUCDUJExqSTPb0GBcxxKv6LHSEKUv25WrDjKgQ0/UnSJZCHBiE74eSGOjPyP2pP0uGAK9Eh28jShCXyAyfUbQwy2bpyD2Q/3BgBkG/G0rett0JYd9wboPqoSLOeziVahXES8rLxqbDXyHDMS6r9nm/c74UAedLncxdijsMiPWDImI0Ao2kXxVlSasjMIpWDGxDG3gYpmZbg1xiC/Gc0hmFG0qf/f1D8FPaBUSnWiHHNhTPnv6ruuPi/5tDF+aPyt6nqXUvsVEgq/RELGygdWC5bLM97B1UqFEvCEL2b0Et8AyYngggDsE5SikhJinx/QzEjtSgwzWFrmjeSm5U9gO9KtM+v7Aa08e3zPJoXoY2WRsk9RS03OlNHL+r69WycJ5iDAcNGNHyjWRHiuFEdyRmpl14SDMdcqvjyuRsKN6q9gOedWhxQHjqvdi95MivEAptmdqzrlQdaRxovEo9JSZpDlSBgOoGdEQBH/8YxJM0aKaLQcd24y72zLdk/4rfPAyEp2lhfCsmRmVJwKpqrso3m7yS1FKkn08uuotqfCvJvIGqQUYBtnyWxMXL8c++1sMlPM9qxMGgOZzJQ0smDr16F7EGrgs+SLOl3rQUdyRUqUi5mtKe6FOFDKg1wrtHmwyxxg/jXihYYV6pw1DjSGc5kX1vwCwJBS3O8p0dVUaRA1SIR8DucB6AU4b4jA3nsKv51YaTEXDiheBpbo95htBt5J0KHxdUYbJrFKRuM5M8MhHqj/Ztg9izlPlu5WqvRdnHY91CXngQMoqRvO4oqb3m5HOinat9CtzpfjM8GQHg2Os5W7Ur7L9pJcBt4rh0mgd+p99/zNddNWxEQ29T3oQZT6w/h7IYB5wFLnfMrye4PUq3AvVmoJmqLOjYEs24rdAPyS2O0dp28irVpmNOv0cGF8F20r5GV2n2/nxARHrkTl5W018l92F3Q2sOrmDFDDHk9ia1WBGO9Bbz3QAqsN7sj5nn0vTlVny/s88dfW4wXPRfSSMhVwCB1tBTsGJc963/AvzuJSi6OzcvhLfOlzuE1k321sjWlAfdg+De22Q8njlbuVURBfFjroliIY7AolyZsS1ARRwUEp77lnL2bWOK55z1fXxBfas8j7CucX+RsRUZRvaqY37xGxbgdS3vnldCz0Vv+OPz9OvdSAsvAd+V0SkyGJ5rm1SaY0BpQ1hspQJXJ3AKDlYHaEteXwml+0Dgb3W6ZAGn9c3Rp2Jf8EP0fptL7DWqaiul9FaKh3qQT8xcW4Sz5Qw4Fv5gtWuHJG0DTUpg/0klJZnr2fIzgrgu3RRCO23lWJUrhlVGTBW+y9vn1hWRC+PT28Fq3Oi3f3xWUi2NPGKvcITY0+cXoowJcwiHIH+xYDwofXLFpQChEgXpqEe0Af36o+qvYcl3eWOPYgvOQBD5LTJTjHugX870m3+QmQrCKh2bMmMIJw8fWPZEr4B/h/fQgep9L1W4awVOuZWEuGpVsM2TWy3g4Q0cYq7Xn2fYkelGtI2STrgdJk/Sa34NpQdLemrhp1mf8X6DUAT2Vsdf5CyY+ulyjFqJgFssBM4kFnF4wOYX+J8qTtaG9oi4zi8WmQcbbOySdD9VKDaJCbXmzbErzv54xjPttmnfOm0uwQltex8PSv+muEp4wXV8vj7lX0R+SaglHa2da8FEjtN2bRsCls/8sdnKhZcuuIZEYczBgoKafMs6OEFJ5zNQLYJ8UPheWmvtC14Ayg/TXVSy8GKBy4XXFd0ofx7Zf+7k3rdKDWFzuOGpVR3vrVc+iEoUL2r3COx5KsCucGZ8mqkBh8PIq6JbZwfbZ64qd7pwlnF262CDggo2WuQ9OOzzX+I9/d6ARxpVb4kbSuRYCRdZW0tpE4/TH4gYQLopl7wGeiK7IaxUDaSWDTJniH8bGOP0SBwsDKvtNyPTb/lPzkbLtntuxF2eTfbsYo5GWl4pKmUDaeheUWxNeKIAvhvOfyRYGAUuHUWpaVPOl7co3nGTU6GkYx+YXFrBBPCw0ZDcisZX/0i++G+rJ1kvySMaxEJJz4Uub7UeV1faDv/iM0zxhypDI9EX4te0WmsFjxeeIv+B5Lf0TI1OYIYfXwIZ8uD/XAWgh3W+lFS8171JggMWj7+jC1Q1gc6i0epjzf6sbDxv5z1ff85TU9qfC5zoKg7kvIgKXnP4bYOvI8np1/JjDt4/AXbpa7wIkqbzU2qoY4za5td8B9NM9ibkvyvDotxW8X+d7KCZlpLJ8Q7hFbc5iQGIkuDNTk3cueCHUmJVL2UxT6WTHoGxsUAxi5Ogb8qtZ3srPNvhpyKcJlSxRZIXgFOw9ITf2vElg3gvmvogmR1KD+Bi+jjRejuH92wg5HJ8gdglvHXIILl5ZU1qw2PPyRjCmDEVkeRYfTQ5SmyZovzvo7Jyp1xuFyU3EksPaKAYDfqq9Y/ocZ4GQ2n23rWftHZeLw6zqip9QZHeUhSmrx6495BHNqqvPpUWaVEaYWqtEN8fIdviX8V4gsV9zh8BFUvfQIBTqJpC6Ko+yj51WobTjvyfEfMcf7BRBl9uBSlhITubbhfcIbpU1oGsbYJY5CY7OeUdVszsYpqV8qzfHyrZ/kdD/iEi64isn2gt8TaG9u+beLSZp17QqesO0BuxpUS2tCvJF9Ri1kqnIkjUxWqlapc858D+EkcQ/1S8SCbpeI5Bhjtoh8MOdKsifKs/CHLKcdeHzJyggwu5m9H0S3axoumfCqYlYj3W5rkGl63yM88dAVr0mv6T5ch0+hgJfyXl7tRurMlUUhRNqV2Ls40OMnGMeRH4IYCzcHPtjliSMDzXd19VKofhq0z7Cl8T+RXgZEpaxjNjjfeXS9yJ7yaSWCqgJXAbZrqjrkp1Z807wvC/5sWf3fljTKyldxHP2exqTKGzjZFAsWCvvdEUyqTVfsu7jw9M6/FPZEdNN92YyqLNuMWEXX+HeAkfRuHyZ6Vgh22Jqw/TP8S1iiLlmOOBQkrhZWgEpKOjysyCXnWeuqOhCG4w8Z3Y73HVXSwaqq5XsGCIRPfiA7qzxEvct/Rp1g+Re1ZBfWTuCSwPorGEOSgDtTXwu88NZtskMdM6igFXWZogdBPhX2VgF6F8QxhGR+PKh8IUtp8EZhnXiQfHp8hdYO7WNq82S2BeMD7LmTMQ8UYo3aQNx7qpx3QSdlti6LuMmdEPGUoHmEcGBsqFhkrQYTxcIF/OLrvAquMLiU8/t64tqfySR9/eBiGFCvnNUnTCL7Dy3TmjlfrIi/PPV0vRSPSjARvtREUZHvR3JEMc6yaw1b3W7xAwl/j8dRdVBxXCfLMXj3Tik7QhTx+NUAPEdzcjfW48HrIyFl1j0BK+aRorTuU4TkuMh0EM3sRzvHYGvVimxuUcDjv6jue9imzI28CO2tmaAUFja06T7WDDzbwFCEo//9wY9hCWlkh5gAAAABJRU5ErkJggg==",
    lc.ssaoNormalImage.loaded = !0,
    Yb.EventDispatcher = function() {
        this.listeners = {}
    },
    Yb.extend(Yb.EventDispatcher, null, {
        constructor: Yb.EventDispatcher,
        addEventListener: function(a, b) {
            this.listeners[a] === e && (this.listeners[a] = []),
            -1 === this.listeners[a].indexOf(b) && this.listeners[a].push(b)
        },
        removeEventListener: function(a, b) {
            var c = this.listeners[a].indexOf(b); - 1 !== c && this.listeners[a].splice(c, 1)
        },
        dispatchEvent: function(a) {
            var b = this.listenters[a.type];
            if (b != e) {
                a.target = this;
                for (var c = 0; c < b.length; c++) {
                    var d = b[c];
                    d.call(this, a)
                }
            }
        },
        contains: function(a, b) {
            if (this._ls) for (var c, d = 0,
            e = this._ls.size(); e > d; d++) if (c = this._ls.get(d), a === c.l && b === c.s) return ! 0;
            return ! 1
        },
        add: function(a, b, c) {
            if (null == a) return void console.error("TGL.EventDispatcher#add:listener is null");
            var d = {
                l: a,
                s: b,
                a: c
            };
            this._ls || (this._ls = new kc),
            this._f ? (this._addPendings || (this._addPendings = new kc), this._addPendings.add(d)) : d.a ? this._ls.add(d, 0) : this._ls.add(d)
        },
        remove: function(a, b) {
            this._ls && (this._f ? (this._removePendings || (this._removePendings = new kc), this._removePendings.add({
                l: a,
                s: b
            })) : this._remove(a, b))
        },
        _remove: function(a, b) {
            for (var c, d = 0,
            e = this._ls.size(); e > d; d++) if (c = this._ls.get(d), c.l === a && c.s === b) return void this._ls.removeAt(d)
        },
        fire: function(a) {
            if (this._ls) {
                var b, c, d = this._ls.size();
                for (this._f = !0, b = 0; d > b; b++) c = this._ls.get(b),
                c.s ? c.l.call(c.s, a) : c.l(a);
                if (this._f = !1, this._removePendings) {
                    for (d = this._removePendings.size(), b = 0; d > b; b++) c = this._removePendings.get(b),
                    this._remove(c.l, c.s);
                    delete this._removePendings
                }
                if (this._addPendings) {
                    for (d = this._addPendings.size(), b = 0; d > b; b++) c = this._addPendings.get(b),
                    c.a ? this._ls.add(c, 0) : this._ls.add(c);
                    delete this._addPendings
                }
            }
        }
    }),
    Yb.PropertyChangeDispatcher = function() {
        this._dispatcher = new Yb.EventDispatcher
    },
    Yb.extend(Yb.PropertyChangeDispatcher, Object, {
        addPropertyChangeListener: function(a, b, c) {
            this._dispatcher.add(a, b, c)
        },
        removePropertyChangeListener: function(a, b) {
            this._dispatcher.remove(a, b)
        },
        firePropertyChange: function(a, b, c) {
            if (b == c) return ! 1;
            var d = {
                property: a,
                oldValue: b,
                newValue: c,
                source: this
            };
            return this._dispatcher.fire(d),
            this.onPropertyChanged(d),
            !0
        },
        onPropertyChanged: function(a) {}
    }),
    Yb.Texture = function(a, b, c, d, f, g, h, i, j) {
        Yb.PropertyChangeDispatcher.call(this),
        this.id = Yb.TextureIdCount++,
        this.name = "",
        null != a && this.setImage(a),
        this.mipmaps = [],
        this.mapping = b !== e ? b: new Yb.UVMapping,
        this.wrapS = c !== e ? c: Yb.RepeatWrapping,
        this.wrapT = d !== e ? d: Yb.RepeatWrapping,
        this.magFilter = f !== e ? f: Yb.LinearFilter,
        this.minFilter = g !== e ? g: Yb.LinearMipMapLinearFilter,
        this.anisotropy = j !== e ? j: 1,
        this.format = h !== e ? h: Yb.RGBAFormat,
        this.type = i !== e ? i: Yb.UnsignedByteType,
        this.repeatX = 1,
        this.repeatY = 1,
        this.offsetX = 0,
        this.offsetY = 0,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !1,
        this.flipX = !1,
        this.unpackAlignment = 4,
        this.needsUpdate = !1,
        this.onUpdate = null
    },
    Yb.extend(Yb.Texture, Yb.PropertyChangeDispatcher, {
        getUniqueCode: function() {
            if (bc.isImage(this._image) || "string" == typeof this._image || tc.isArray(this._image)) return this._imageSrc + " " + this.format + " " + this.type + "  " + this.wrapS + " " + this.wrapT + " " + this.magFilter + " " + this.minFilter + " " + this.flipY + " " + this.flipX + this.anisotropy;
            if (bc.isCanvas(this._image)) {
                var a = this._image;
                return a.__uniqueCode || (a.__uniqueCode = Yb.id("texture")),
                a.__uniqueCode + " " + this.format + " " + this.type + " " + this.wrapS + " " + this.wrapT + " " + this.magFilter + " " + this.minFilter + " " + this.flipY + " " + this.flipX + this.anisotropy
            }
        },
        resetValue: function() {
            this.name = "",
            this._image = null,
            this.mipmaps = [],
            this.mapping = new Yb.UVMapping,
            this.wrapS = Yb.RepeatWrapping,
            this.wrapT = Yb.RepeatWrapping,
            this.magFilter = Yb.LinearFilter,
            this.minFilter = Yb.LinearMipMapLinearFilter,
            this.anisotropy = 1,
            this.format = Yb.RGBAFormat,
            this.type = Yb.UnsignedByteType,
            this.generateMipmaps = !0,
            this.premultiplyAlpha = !1,
            this.flipY = !1,
            this.flipX = !1,
            this.unpackAlignment = 4,
            this.needsUpdate = !1,
            this.onUpdate = null
        },
        clone: function(a, b) {
            return a === e && (a = new Yb.Texture),
            null == b || b ? a.setImage(this._image) : a._image = this._image,
            a._imageSrc = this._imageSrc,
            a.mipmaps = this.mipmaps.slice(0),
            a.mapping = this.mapping,
            a.wrapS = this.wrapS,
            a.wrapT = this.wrapT,
            a.magFilter = this.magFilter,
            a.minFilter = this.minFilter,
            a.anisotropy = this.anisotropy,
            a.format = this.format,
            a.type = this.type,
            a.generateMipmaps = this.generateMipmaps,
            a.premultiplyAlpha = this.premultiplyAlpha,
            a.flipY = this.flipY,
            a.flipX = this.flipX,
            a.unpackAlignment = this.unpackAlignment,
            a
        },
        onloadTexture: function() {},
        setImageSrc: function(a) {
            if ("string" == typeof a) this._imageSrc = a;
            else if (tc.isArray(a)) {
                for (var b = "",
                c = 0; c < a.length; c++) b += "string" == typeof a[c] ? a: a[c].src;
                this._imageSrc = b
            } else this._imageSrc = a.src
        },
        loadAllImages: function(a, b) {
            function c(c) {
                c.onload = function() {
                    c.loaded = !0,
                    c.onload = null,
                    e++,
                    e == d && (f.onloadTexture(), f.firePropertyChange("image", b, f._image), a.loaded = !0)
                }
            }
            for (var d = a.length,
            e = 0,
            f = this,
            g = 0; d > g; g++) c(a[g])
        },
        setImage: function(a) {
            var b = this._image;
            if (tc.isArray(a)) {
                for (var c, d = "",
                e = [], f = 0; f < a.length; f++)"string" == typeof a[f] ? (d += a, c = new Image, a[f].startsWith("data:image") || (c.crossOrigin = "use-credentials"), c.src = a[f], e.push(c)) : (d += a[f].src, e.push(a[f]));
                this._imageSrc = d,
                this.loadAllImages(e, b),
                this._image = e
            } else if ("string" == typeof a) {
                if (this._image && this._image.src === a) return;
                this._imageSrc = a;
                var g = new Image;
                a.startsWith("data:image") || (g.crossOrigin = "use-credentials"),
                g.src = a;
                var h = this;
                h._image = g,
                g.onload = function(a) {
                    g.loaded = !0,
                    g.onload = null,
                    h.onloadTexture(),
                    h.firePropertyChange("image", b, g)
                }
            } else {
                if (this._image === a) return;
                this._imageSrc = a.src;
                var b = this._image;
                if (bc.isCanvas(a) && (a.loaded = !0), a && !a.loaded) {
                    var h = this;
                    h._image = a;
                    var i = a.onload;
                    a.onload = function(c) {
                        i && i.call(null, c),
                        a.loaded = !0,
                        a.onload = null,
                        h.onloadTexture(),
                        h.firePropertyChange("image", b, a)
                    }
                } else this._image = a,
                this.firePropertyChange("image", b, a)
            }
        },
        getImage: function() {
            return this._image
        },
        dispose: function() {
            this.firePropertyChange("disposed", !1, !0)
        }
    }),
    Yb.TextureIdCount = 0,
    Yb.PixelsTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
        Yb.Texture.call(this, null, f, g, h, i, j, d, e, k),
        this.image = {
            data: a,
            width: b,
            height: c
        }
    },
    Yb.PixelsTexture.prototype = Object.create(Yb.Texture.prototype),
    Yb.PixelsTexture.prototype.clone = function() {
        var a = new Yb.PixelsTexture;
        return Yb.Texture.prototype.clone.call(this, a),
        a
    },
    Yb.CompressedTexture = function(a, b, c, d, e, f, g, h, i, j, k) {
        Yb.Texture.call(this, null, f, g, h, i, j, d, e, k),
        this.image = {
            width: b,
            height: c
        },
        this.mipmaps = a,
        this.generateMipmaps = !1
    },
    Yb.CompressedTexture.prototype = Object.create(Yb.Texture.prototype),
    Yb.CompressedTexture.prototype.clone = function() {
        var a = new Yb.CompressedTexture;
        return Yb.Texture.prototype.clone.call(this, a),
        a
    };
    var mc = {
        pools: {},
        useTimes: {},
        size: 0,
        setTexture: function(a, b) {
            mc.size++,
            mc.pools[a] = b
        },
        getTexture: function(a) {
            return mc.pools[a]
        },
        useTexture: function(a) {
            if (a) {
                var b = a.id,
                c = mc.useTimes[b] || 0;
                c++,
                mc.useTimes[b] = c
            }
        },
        unUseTexture: function(a) {
            if (a) {
                var b = a.id,
                c = mc.useTimes[b] || 0;
                if (c--, mc.useTimes[b] = c, 0 >= c) {
                    var d = a.getUniqueCode();
                    delete mc.pools[d],
                    mc.size--,
                    a.dispose()
                }
            }
        }
    };
    Yb.TexturePool = mc,
    Yb.TexturePool.TestTexture = new Yb.Texture,
    Yb.SerializationSettings = function() {
        var a = Yb.SerializationSettings;
        this.isDataBoxSerializable = a.isDataBoxSerializable,
        this.isStyleSerializable = a.isStyleSerializable,
        this.isClientSerializable = a.isClientSerializable,
        this.encodeURI = a.encodeURI,
        this._pm = Yb.clone(a._pm),
        this._sm = Yb.clone(a._sm),
        this._cm = Yb.clone(a._cm)
    },
    function() {
        var a = Yb.SerializationSettings;
        a.isDataBoxSerializable = !0,
        a.isStyleSerializable = !0,
        a.isClientSerializable = !0,
        a.encodeURI = !0,
        a._pm = {},
        a._sm = {},
        a._cm = {},
        a.setPropertyType = function(b, c) {
            a._pm[b] = c
        },
        a.getPropertyType = function(b) {
            return a._pm[b]
        },
        a.setStyleType = function(b, c) {
            a._sm[b] = c
        },
        a.getStyleType = function(b) {
            return a._sm[b]
        },
        a.setClientType = function(b, c) {
            a._cm[b] = c
        },
        a.getClientType = function(b) {
            return a._cm[b]
        }
    } (),
    Yb.extend(Yb.SerializationSettings, Object, {
        setPropertyType: function(a, b) {
            this._pm[a] = b
        },
        getPropertyType: function(a) {
            return this._pm[a]
        },
        setStyleType: function(a, b) {
            this._sm[a] = b
        },
        getStyleType: function(a) {
            return this._sm[a]
        },
        setClientType: function(a, b) {
            this._cm[a] = b
        },
        getClientType: function(a) {
            return this._cm[a]
        }
    }),
    Yb.Styles = {
        _m: {},
        setStyle: function(a, b) {
            return null == b ? delete Yb.Styles._m[a] : Yb.Styles._m[a] = b,
            Yb.Styles
        },
        getStyle: function(a) {
            return Yb.Styles._m[a]
        }
    },
    Yb.Styles.MaterailType = "S:m.type",
    Yb.Styles.NormalType = "S:m.normalType",
    Yb.Styles.PREFIX_STYLE = "S:",
    function() {
        var a = function(a, b) {
            Yb.SerializationSettings.setPropertyType(a, b)
        };
        a("combos", "data.list"),
        a("name", "cdata"),
        a("toolTip", "cdata"),
        a("parent", "data"),
        a("fromNode", "data"),
        a("toNode", "data"),
        a("alarmState", "alarmstate"),
        a("vertices", "list.vec3"),
        a("faces", "serializeabe.list"),
        a("uvs", "list.vec2"),
        a("position", "vec3"),
        a("rotation", "vec3"),
        a("scale", "vec3"),
        a("location", "point"),
        a("materialSize", "number"),
        a("color", "color"),
        a("ambient", "color"),
        a("diffuse", "color"),
        a("specular", "color"),
        a("intensity", "number"),
        a("distance", "number"),
        a("type", "number"),
        a("startClosed", "boolean"),
        a("endClosed", "boolean"),
        a("curveSegments", "number"),
        a("amount", "number"),
        a("vertical", "boolean"),
        a("repeat", "number"),
        a("centralized", "boolean"),
        a("visible", "boolean"),
        a = function(a, b, c) {
            null == c && (c = null != b ? b instanceof Yb.Vec2 ? "vec2": b instanceof Yb.Vec3 ? "vec3": typeof b: "string"),
            Yb.Styles.setStyle(a, b),
            Yb.SerializationSettings.setStyleType(a, c)
        },
        a("select.style", "border"),
        a("select.width", 1),
        a("select.color", 65280),
        a("select.offset", 0),
        a("outer.width", 1),
        a("outer.offset", 0),
        a("outer.color", null, "color"),
        a("m.type", "basic"),
        a("m.color", 16777215, "color"),
        a("m.side", "front"),
        a("m.alphaTest", 0),
        a("m.polygonOffset", !1),
        a("m.polygonOffsetFactor", 0),
        a("m.polygonOffsetUnits", 0),
        a("m.wireframe", !1),
        a("m.wireframeLinewidth", 1),
        a("m.gradient", {}),
        a("m.gradientType", 1),
        a("m.transparent", !1),
        a("m.opacity", 1),
        a("m.visible", !0),
        a("m.depthTest", !0),
        a("m.depthMask", !0),
        a("m.alignment", new Yb.Vec2(0, 0)),
        a("m.linewidth", 1),
        a("m.texture.image", null),
        a("m.texture.offset", new Yb.Vec2(0, 0)),
        a("m.texture.repeat", new Yb.Vec2(1, 1)),
        a("m.texture.wrapS", Yb.RepeatWrapping),
        a("m.texture.wrapT", Yb.RepeatWrapping),
        a("m.texture.flipX", !1),
        a("m.texture.flipY", !1),
        a("m.normalmap.image", null),
        a("m.envmap.image", null),
        a("m.specularmap.image", null),
        a("right.m.type", "basic"),
        a("left.m.type", "basic"),
        a("top.m.type", "basic"),
        a("bottom.m.type", "basic"),
        a("front.m.type", "basic"),
        a("back.m.type", "basic"),
        a("side.m.type", "basic"),
        a("alarm.billboard.scale", null),
        a("alarm.billboard.position", "top"),
        a("alarm.billboard.vertical", !1),
        a("annotation.class", "tgl_annotation")
    } (),
    Yb.extend(Yb.Styles, Object, {});
    var nc = function(a, b) {
        this.min = a !== e ? a: new Zb(1 / 0, 1 / 0),
        this.max = b !== e ? b: new Zb( - (1 / 0), -(1 / 0))
    };
    Yb.Box2 = nc,
    nc.prototype = {
        constructor: Yb.Box2,
        set: function(a, b) {
            return this.min.copy(a),
            this.max.copy(b),
            this
        },
        setFromPoints: function(a) {
            if (a.length > 0) {
                var b = a[0];
                this.min.copy(b),
                this.max.copy(b);
                for (var c = 1,
                d = a.length; d > c; c++) b = a[c],
                b.x < this.min.x ? this.min.x = b.x: b.x > this.max.x && (this.max.x = b.x),
                b.y < this.min.y ? this.min.y = b.y: b.y > this.max.y && (this.max.y = b.y)
            } else this.makeEmpty();
            return this
        },
        setFromCenterAndSize: function() {
            var a = new Zb;
            return function(b, c) {
                var d = a.copy(c).multiplyScalar(.5);
                return this.min.copy(b).sub(d),
                this.max.copy(b).add(d),
                this
            }
        } (),
        copy: function(a) {
            return this.min.copy(a.min),
            this.max.copy(a.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -(1 / 0),
            this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        center: function(a) {
            var b = a || new Zb;
            return b.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(a) {
            var b = a || new Zb;
            return b.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            return this.min.min(a),
            this.max.max(a),
            this
        },
        expandByVector: function(a) {
            return this.min.sub(a),
            this.max.add(a),
            this
        },
        expandByScalar: function(a) {
            return this.min.addScalar( - a),
            this.max.addScalar(a),
            this
        },
        containsPoint: function(a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
        },
        getParameter: function(a, b) {
            var c = b || new Zb;
            return c.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
        },
        isIntersectionBox: function(a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
        },
        clampPoint: function(a, b) {
            var c = b || new Zb;
            return c.copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var a = new Zb;
            return function(b) {
                var c = a.copy(b).clamp(this.min, this.max);
                return c.sub(b).length()
            }
        } (),
        intersect: function(a) {
            return this.min.max(a.min),
            this.max.min(a.max),
            this
        },
        union: function(a) {
            return this.min.min(a.min),
            this.max.max(a.max),
            this
        },
        translate: function(a) {
            return this.min.add(a),
            this.max.add(a),
            this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        },
        clone: function() {
            return (new nc).copy(this)
        }
    },
    Yb.BoundingBox = function(a, b) {
        this.min = a !== e ? a: new $b(1 / 0, 1 / 0, 1 / 0),
        this.max = b !== e ? b: new $b( - (1 / 0), -(1 / 0), -(1 / 0))
    },
    Yb.BoundingBox.prototype = {
        constructor: Yb.BoundingBox,
        set: function(a, b) {
            return this.min.copy(a),
            this.max.copy(b),
            this
        },
        setFromPoints: function(a) {
            if (a.length > 0) {
                var b = a[0];
                this.min.copy(b),
                this.max.copy(b);
                for (var c = 1,
                d = a.length; d > c; c++) b = a[c],
                b.x < this.min.x ? this.min.x = b.x: b.x > this.max.x && (this.max.x = b.x),
                b.y < this.min.y ? this.min.y = b.y: b.y > this.max.y && (this.max.y = b.y),
                b.z < this.min.z ? this.min.z = b.z: b.z > this.max.z && (this.max.z = b.z)
            } else this.makeEmpty();
            return this
        },
        setFromCenterAndSize: function(a, b) {
            var c = Yb.BoundingBox.__v1.copy(b).multiplyScalar(.5);
            return this.min.copy(a).sub(c),
            this.max.copy(a).add(c),
            this
        },
        copy: function(a) {
            return this.min.copy(a.min),
            this.max.copy(a.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -(1 / 0),
            this
        },
        empty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        center: function(a) {
            var b = a || new $b;
            return b.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        size: function(a) {
            var b = a || new $b;
            return b.subVectors(this.max, this.min)
        },
        expandByPoint: function(a) {
            return this.min.min(a),
            this.max.max(a),
            this
        },
        expandByVector: function(a) {
            return this.min.sub(a),
            this.max.add(a),
            this
        },
        expandByScalar: function(a) {
            return this.min.addScalar( - a),
            this.max.addScalar(a),
            this
        },
        containsPoint: function(a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
        },
        containsBox: function(a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
        },
        getParameter: function(a) {
            return new $b((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
        },
        isIntersectionBox: function(a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
        },
        clampPoint: function(a, b) {
            return b || new $b,
            (new $b).copy(a).clamp(this.min, this.max)
        },
        distanceToPoint: function(a) {
            var b = Yb.BoundingBox.__v1.copy(a).clamp(this.min, this.max);
            return b.sub(a).length()
        },
        getBoundingSphere: function(a) {
            var b = a || new Yb.Sphere;
            return b.center = this.center(),
            b.radius = .5 * this.size(Yb.BoundingBox.__v0).length(),
            b
        },
        intersect: function(a) {
            return this.min.max(a.min),
            this.max.min(a.max),
            this
        },
        union: function(a) {
            return this.min.min(a.min),
            this.max.max(a.max),
            this
        },
        transform: function(a) {
            var b = [Yb.BoundingBox.__v0.set(this.min.x, this.min.y, this.min.z).applyMatrix4(a), Yb.BoundingBox.__v0.set(this.min.x, this.min.y, this.min.z).applyMatrix4(a), Yb.BoundingBox.__v1.set(this.min.x, this.min.y, this.max.z).applyMatrix4(a), Yb.BoundingBox.__v2.set(this.min.x, this.max.y, this.min.z).applyMatrix4(a), Yb.BoundingBox.__v3.set(this.min.x, this.max.y, this.max.z).applyMatrix4(a), Yb.BoundingBox.__v4.set(this.max.x, this.min.y, this.min.z).applyMatrix4(a), Yb.BoundingBox.__v5.set(this.max.x, this.min.y, this.max.z).applyMatrix4(a), Yb.BoundingBox.__v6.set(this.max.x, this.max.y, this.min.z).applyMatrix4(a), Yb.BoundingBox.__v7.set(this.max.x, this.max.y, this.max.z).applyMatrix4(a)];
            return this.makeEmpty(),
            this.setFromPoints(b),
            this
        },
        translate: function(a) {
            return this.min.add(a),
            this.max.add(a),
            this
        },
        equals: function(a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        },
        clone: function() {
            return (new Yb.BoundingBox).copy(this)
        }
    },
    Yb.BoundingBox.__v0 = new $b,
    Yb.BoundingBox.__v1 = new $b,
    Yb.BoundingBox.__v2 = new $b,
    Yb.BoundingBox.__v3 = new $b,
    Yb.BoundingBox.__v4 = new $b,
    Yb.BoundingBox.__v5 = new $b,
    Yb.BoundingBox.__v6 = new $b,
    Yb.BoundingBox.__v7 = new $b,
    Yb.BoundingSphere = function(a, b) {
        this.center = a !== e ? a: new $b,
        this.radius = b !== e ? b: 0
    },
    Yb.BoundingSphere.prototype = {
        constructor: Yb.BoundingSphere,
        set: function(a, b) {
            return this.center.copy(a),
            this.radius = b,
            this
        },
        setFromCenterAndPoints: function(a, b) {
            for (var c = 0,
            d = 0,
            e = b.length; e > d; d++) {
                var f = a.distanceToSquared(b[d]);
                c = Math.max(c, f)
            }
            return this.center = a,
            this.radius = Math.sqrt(c),
            this
        },
        copy: function(a) {
            return this.center.copy(a.center),
            this.radius = a.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(a) {
            return a.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(a) {
            return a.distanceTo(this.center) - this.radius
        },
        intersectsBoundingSphere: function(a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b
        },
        clampPoint: function(a, b) {
            var c = this.center.distanceToSquared(a),
            d = b || new $b;
            return d.copy(a),
            c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center)),
            d
        },
        getBoundingBox: function(a) {
            var b = a || new Yb.Box3;
            return b.set(this.center, this.center),
            b.expandByScalar(this.radius),
            b
        },
        transform: function(a) {
            return this.center.applyMatrix4(a),
            this.radius = this.radius * a.getMaxScaleOnAxis(),
            this
        },
        applyMatrix4: function(a) {
            return this.center.applyMatrix4(a),
            this.radius = this.radius * a.getMaxScaleOnAxis(),
            this
        },
        translate: function(a) {
            return this.center.add(a),
            this
        },
        equals: function(a) {
            return a.center.equals(this.center) && a.radius === this.radius
        },
        clone: function() {
            return (new Yb.BoundingSphere).copy(this)
        }
    },
    Yb.Primitive = function(a, b) {
        a = a || {},
        this.data = a,
        this.vertices = a.vertices,
        this.faces = a.faces,
        this.uvs = a.uvs,
        this.uv2s = a.uv2s,
        this.uniqueCode = b
    },
    Yb.extend(Yb.Primitive, Object, {
        clone: function(a) {
            if (a) {
                var b, c = {};
                for (c.vertices = [], b = 0; b < this.vertices.length; b++) c.vertices.push(this.vertices[b].clone());
                for (c.faces = [], b = 0; b < this.faces.length; b++) c.faces.push(this.faces[b].clone());
                for (c.uvs = [], b = 0; b < this.uvs.length; b++) {
                    for (var d = this.uvs[b], e = [], f = 0; f < d.length; f++) e.push(d[f].clone);
                    c.uvs.push(e)
                }
                for (c.uv2s = [], b = 0; b < this.uv2s.length; b++) c.uv2s.push(this.uv2s[b].clone());
                return new Yb.Primitive(c)
            }
            return new Yb.Primitvie(this.data)
        }
    }),
    Yb.PrimitiveCache = {
        _cache: {},
        _useCount: {},
        getPrimitive: function(a) {
            return a ? Yb.PrimitiveCache._cache[a] : null
        },
        setPrimitive: function(a, b) {
            a && (Yb.PrimitiveCache._cache[a] = b)
        },
        usePrimitive: function(a) {
            var b = Yb.PrimitiveCache._useCount[a] || 0;
            b++,
            Yb.PrimitiveCache._useCount[a] = b
        },
        unUsePrimitive: function(a) {
            var b = Yb.PrimitiveCache._useCount[a] || 0;
            b--,
            0 >= b && delete Yb.PrimitiveCache._useCount[a]
        }
    },
    Yb.PrimitiveGroupCache = {},
    Yb.Color = function(a) {
        return a !== e && this.set(a),
        this
    },
    Yb.extend(Yb.Color, Object, {
        r: 1,
        g: 1,
        b: 1,
        getUniqueCode: function() {
            return "" + this.r + this.g + this.b
        },
        set: function(a) {
            switch (typeof a) {
            case "number":
                this.setHex(a);
                break;
            case "string":
                this.setStyle(a)
            }
        },
        setHex: function(a) {
            return a = Math.floor(a),
            this.r = (a >> 16 & 255) / 255,
            this.g = (a >> 8 & 255) / 255,
            this.b = (255 & a) / 255,
            this
        },
        setRGB: function(a, b, c) {
            return this.r = a,
            this.g = b,
            this.b = c,
            this
        },
        setHSV: function(a, b, c) {
            var d, e, f, g, h;
            return 0 === c ? this.r = this.g = this.b = 0 : (d = Math.floor(6 * a), e = 6 * a - d, f = c * (1 - b), g = c * (1 - b * e), h = c * (1 - b * (1 - e)), 0 === d ? (this.r = c, this.g = h, this.b = f) : 1 === d ? (this.r = g, this.g = c, this.b = f) : 2 === d ? (this.r = f, this.g = c, this.b = h) : 3 === d ? (this.r = f, this.g = g, this.b = c) : 4 === d ? (this.r = h, this.g = f, this.b = c) : 5 === d && (this.r = c, this.g = f, this.b = g)),
            this
        },
        setStyle: function(a) {
            if (/^rgb\((\d+),(\d+),(\d+)\)$/i.test(a)) {
                var b = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec(a);
                return this.r = Math.min(255, parseInt(b[1], 10)) / 255,
                this.g = Math.min(255, parseInt(b[2], 10)) / 255,
                this.b = Math.min(255, parseInt(b[3], 10)) / 255,
                this
            }
            if (/^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.test(a)) {
                var b = /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.exec(a);
                return this.r = Math.min(100, parseInt(b[1], 10)) / 100,
                this.g = Math.min(100, parseInt(b[2], 10)) / 100,
                this.b = Math.min(100, parseInt(b[3], 10)) / 100,
                this
            }
            if (/^\#([0-9a-f]{6})$/i.test(a)) {
                var b = /^\#([0-9a-f]{6})$/i.exec(a);
                return this.setHex(parseInt(b[1], 16)),
                this
            }
            if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) {
                var b = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a);
                return this.setHex(parseInt(b[1] + b[1] + b[2] + b[2] + b[3] + b[3], 16)),
                this
            }
            return /^(\w+)$/i.test(a) ? (this.setHex(Yb.ColorKeywords[a]), this) : void 0
        },
        copy: function(a) {
            return this.r = a.r,
            this.g = a.g,
            this.b = a.b,
            this
        },
        copyGammaToLinear: function(a) {
            return this.r = a.r * a.r,
            this.g = a.g * a.g,
            this.b = a.b * a.b,
            this
        },
        copyLinearToGamma: function(a) {
            return this.r = Math.sqrt(a.r),
            this.g = Math.sqrt(a.g),
            this.b = Math.sqrt(a.b),
            this
        },
        convertGammaToLinear: function() {
            var a = this.r,
            b = this.g,
            c = this.b;
            return this.r = a * a,
            this.g = b * b,
            this.b = c * c,
            this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r),
            this.g = Math.sqrt(this.g),
            this.b = Math.sqrt(this.b),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice( - 6)
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        getHSV: function(a) {
            var b, c, d = this.r,
            f = this.g,
            g = this.b,
            h = Math.max(Math.max(d, f), g),
            i = Math.min(Math.min(d, f), g),
            j = h;
            if (i === h) b = 0,
            c = 0;
            else {
                var k = h - i;
                c = k / h,
                b = d === h ? (f - g) / k: f === h ? 2 + (g - d) / k: 4 + (d - f) / k,
                b /= 6,
                0 > b && (b += 1),
                b > 1 && (b -= 1)
            }
            return a === e && (a = {
                h: 0,
                s: 0,
                v: 0
            }),
            a.h = b,
            a.s = c,
            a.v = j,
            a
        },
        add: function(a) {
            return this.r += a.r,
            this.g += a.g,
            this.b += a.b,
            this
        },
        addColors: function(a, b) {
            return this.r = a.r + b.r,
            this.g = a.g + b.g,
            this.b = a.b + b.b,
            this
        },
        addScalar: function(a) {
            return this.r += a,
            this.g += a,
            this.b += a,
            this
        },
        multiply: function(a) {
            return this.r *= a.r,
            this.g *= a.g,
            this.b *= a.b,
            this
        },
        multiplyScalar: function(a) {
            return this.r *= a,
            this.g *= a,
            this.b *= a,
            this
        },
        lerp: function(a, b) {
            return this.r += (a.r - this.r) * b,
            this.g += (a.g - this.g) * b,
            this.b += (a.b - this.b) * b,
            this
        },
        clone: function() {
            return (new Yb.Color).setRGB(this.r, this.g, this.b)
        }
    }),
    Yb.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Yb.Data = function(a) {
        Yb.PropertyChangeDispatcher.call(this),
        this._childList = new kc,
        this._childMap = {},
        this._clientMap = {},
        this._id = a
    },
    Yb.extend(Yb.Data, Yb.PropertyChangeDispatcher, {
        ___accessor: ["name"],
        constructor: Yb.Data,
        getId: function() {
            return this._id
        },
        onAlarmChange: function() {},
        onPropertyChange: function(a, b, c) {},
        setGroupId: function(a) {
            if (this._groupId !== a) {
                var b = this._groupId;
                this._groupId = a,
                this.firePropertyChange("groupId", b, a)
            }
        },
        getGroupId: function() {
            return this._groupId
        },
        hasChildren: function() {
            return this._childList.size() > 0
        },
        getChildren: function() {
            return this._childList
        },
        isDescendantOf: function(a) {
            if (!a) return ! 1;
            if (!a.hasChildren()) return ! 1;
            for (var b = this._parent; b;) {
                if (a === b) return ! 0;
                b = b.getParent()
            }
            return ! 1
        },
        getParent: function() {
            return this._parent
        },
        getRoot: function() {
            var a = this._parent;
            return a && null == a._parent ? a: a && null != a._parent ? a.getRoot(a) : arguments[0]
        },
        setParent: function(a) {
            if (! (this._isUpdatingParent || this._parent === a || this === a || a && a.isDescendantOf(this))) {
                var b = this._parent;
                this._parent = a,
                this._isUpdatingParent = !0,
                b && b.removeChild(this),
                a && a.addChild(this),
                delete this._isUpdatingParent,
                this.firePropertyChange("parent", b, a),
                this.onParentChanged(b, a)
            }
        },
        onParentChanged: function(a, b) {},
        addChild: function(a, b) {
            return b === e && (b = this._childList.size()),
            a && a !== this ? this._childMap[a.getId()] ? !1 : this.isDescendantOf(a) ? !1 : (a.getParent() && a.getParent().removeChild(a), (0 > b || b > this._childList.size()) && (b = this._childList.size()), this._childList.add(a, b), this._childMap[a._id] = a, a.setParent(this), this.firePropertyChange("children", null, a), this.onChildAdded(a, b), !0) : !1
        },
        onChildAdded: function(a, b) {},
        clearChildren: function() {
            if (null != this._childList && this._childList.size() > 0) {
                var a = this._childList.toList(),
                b = this;
                a.forEach(function(a) {
                    b.removeChild(a)
                })
            }
        },
        removeChild: function(a) {
            if (!a) return ! 1;
            if (!this._childMap[a._id]) return ! 1;
            var b = this._childList.remove(a);
            return delete this._childMap[a._id],
            this.firePropertyChange("children", a, null),
            a.setParent(null),
            this.onChildRemoved(a, b),
            !0
        },
        onChildRemoved: function(a, b) {},
        c: function(a) {
            if (a) for (var b in a) this.setClient(b, a[b])
        },
        setClient: function(a, b) {
            if (null == a) return this;
            null == this._clientMap && (this._clientMap = new Object);
            var c = this._clientMap[a];
            return c !== b ? (null == b ? delete this._clientMap[a] : this._clientMap[a] = b, this._clientMap[a] = b, this.firePropertyChange("C:" + a, c, b), this.onClientChanged(a, c, b), this) : void 0
        },
        getClient: function(a) {
            return this._clientMap[a]
        },
        onClientChanged: function(a, b, c) {},
        setPropertyValue: function(a, b) {
            if (this[a] === b) return ! 1;
            var c = this[a];
            return c instanceof Yb.Color && null != b ? (c = c.clone(), b instanceof Yb.Color ? this[a].copy(b) : this[a].set(b)) : this[a] = b,
            !0
        }
    }),
    Yb.Element = function(a) {
        Yb.Data.call(this, a),
        this._id = a || Yb.id("E"),
        this.styleMap = {},
        this._visible = !0,
        this._selected = !1,
        this._selectable = !0,
        this._editable = !0,
        this.editing = !1,
        this.up = new $b(0, 1, 0),
        this._position = new $b(0, 0, 0),
        this._rotation = new $b(0, 0, 0),
        this._scale = new $b(1, 1, 1),
        this.eulerOrder = Yb.defaultEulerOrder,
        this.rotationAutoUpdate = !0,
        this.matrix = new ac,
        this.worldMatrix = new ac,
        this.rotationWorldMatrix = new ac,
        this.matrixAutoUpdate = !1,
        this.worldMatrixNeedsUpdate = !0,
        this.quaternion = new Yb.Quat,
        this.useQuaternion = !1,
        this._sizeFixed = !1,
        this._fixedSize = 108,
        this.castShadow = !0,
        this.receiveShadow = !0,
        this.frustumCulled = !0,
        this._vector = new $b,
        this.renderDepth = null,
        this._attachId = "",
        this._groupId = null,
        this.editTransformToParent = !1,
        this._alarmState = new Yb.AlarmState(this),
        this.colors = []
    },
    Yb.Element.__m1 = new ac,
    Yb.ElementIdCount = 0,
    Yb.extend(Yb.Element, Yb.Data, {
        IStyle: !0,
        ___accessor: ["visible", "selected", "selectable", "editable", "sizeFixed"],
        constructor: Yb.Element,
        getAlarmState: function() {
            return this._alarmState
        },
        onAlarmChange: function(a, b) {
            var c = this._alarmState.getHighestNativeAlarmSeverity();
            c ? this.setStyle("m.alarmColor", new Yb.Color(c.color)) : this.setStyle("m.alarmColor", null)
        },
        getDefaultInstance: function() {
            return this.constructor.defaultInstance === e && (this.constructor.defaultInstance = new this.constructor),
            this.constructor.defaultInstance
        },
        onParentChanged: function(a, b) {
            this.updateWorldMatrix(!0, !1)
        },
        onChildAdded: function(a, b) {
            a.updateWorldMatrix(!0, !1)
        },
        onChildRemoved: function(a, b) {
            a.updateWorldMatrix(!0, !1)
        },
        generatePrimitiveKey: function() {
            return null
        },
        serializeProperty: function() {},
        clear: function(a) {},
        getSelectStyle: function() {
            return this.getStyle("select.style")
        },
        isSpaceChangedProperty: function(a) {
            return "scale" === a || "position" === a || "rotation" === a
        },
        isStyleEquals: function(a, b, c) {
            return null == b && null == c ? !0 : b === c
        },
        setStyle: function(a, b) {
            if (null == a) return this;
            null == this.styleMap && (this.styleMap = {});
            var c = this.styleMap[a];
            return this.isStyleEquals(a, c, b) ? this: (null == b ? delete this.styleMap[a] : this.styleMap[a] = b, this.onStyleChanged(a, c, b), this.firePropertyChange(Yb.Styles.PREFIX_STYLE + a, c, b), this)
        },
        c: function(a) {
            if (a) for (var b in a) this.setClient(b, a[b])
        },
        s: function(a) {
            if (null != a) {
                null == this.styleMap && (this.styleMap = {});
                var b, c, d, e = {},
                f = {};
                for (b in a) c = a[b],
                d = this.styleMap[b],
                this.isStyleEquals(b, d, c) || (null == c ? delete this.styleMap[b] : this.styleMap[b] = c, f[b] = d, this.isMaterialStyle(b) && (e[b] = [c, d]));
                this.onMaterialStylesChanged(e);
                for (b in a) this.firePropertyChange(Yb.Styles.PREFIX_STYLE + b, f[b], this.styleMap[b]);
                return this
            }
        },
        getStyle: function(a, b, c) {
            null == c && (c = !0);
            var d;
            return null != this.styleMap && (d = this.styleMap[a]),
            b && (d = this.getCloneObject(d)),
            null == d && c && (d = this.getDefaultStyle(a, b)),
            d
        },
        getCloneObject: function(a) {
            if (null == a) return null;
            if (Yb.Utils.isArray(a)) {
                for (var b = [], c = 0; c < a.length; c++) b.push(this.getCloneObject(a[c]));
                return b
            }
            return a.clone ? a.clone() : a
        },
        getSideIndexMapping: function() {},
        setMaterialStyle: function(a, b) {},
        setMaterialStyles: function(a) {
            var b, c, d, e;
            for (var f in a) {
                if (f.startsWith("m.")) b = f.substr(f.indexOf(".") + 1);
                else if (this.getSideIndexMapping() && this.isSideStyle(d)) {
                    var g = d.substr(0, d.indexOf(".")),
                    h = this.getSideMaterialIndex(g);
                    if (h != i) continue;
                    d = d.substr(d.indexOf(".") + 1),
                    b = d.substr(f.indexOf(".") + 1)
                } else f.startsWith("alarm.billboard.") && (e = !0);
                var j = a[f];
                c = j[0],
                null == c ? c = Yb.Styles.getStyle(f) : tc.isArray(c) && (c = c[i]),
                this._A97(this.material, b, c)
            }
            e && this._alarmBillboard && this._setAlarmBillboardPositionAndSize(this._alarmBillboard)
        },
        onMaterialStylesChanged: function(a) {
            this.setMaterialStyles(a)
        },
        isMaterialStyle: function(a) {
            return a.startsWith("m.") ? !0 : this.getSideIndexMapping() && this.isSideStyle(a) ? !0 : !1
        },
        onStyleChanged: function(a, b, c) {
            if (a.startsWith("m.")) this.setMaterialStyle(a, c);
            else if (this.getSideIndexMapping() && this.isSideStyle(a)) {
                var d = a.substr(0, a.indexOf("."));
                a = a.substr(a.indexOf(".") + 1);
                var e = this.getSideMaterialIndex(d);
                this.setMaterialStyle(a, c, e)
            } else a.startsWith("alarm.billboard.") && this._alarmBillboard && this._setAlarmBillboardPositionAndSize(this._alarmBillboard)
        },
        textureMapping: {
            texture: "map",
            texture1: "map1",
            texture2: "map2",
            textureb: "blendMap",
            texturebp: "bumpMap",
            lightMap: "lightMap",
            lightmap: "lightMap",
            normalmap: "normalMap",
            envmap: "envMap",
            specularmap: "specularMap"
        },
        _A97: function(a, b, c) {
            if (b.startsWith("texture.") || b.startsWith("texture1.") || b.startsWith("texture2.") || b.startsWith("textureb.") || b.startsWith("texturen.") || b.startsWith("texturebp.") || b.startsWith("lightmap") || b.startsWith("envmap") || b.startsWith("normalmap") || b.startsWith("specularmap")) {
                var d = b.substr(0, b.indexOf(".")),
                e = b.substr(b.indexOf(".") + 1);
                if ("offset" === e || "repeat" === e) return void a.setPropertyValue(e, this.getCloneObject(c));
                var f = this.textureMapping[d],
                g = a[f],
                h = Yb.TexturePool.TestTexture;
                if ("image" === e) {
                    var i = c;
                    if (b.startsWith("envmap") && tc.isArray(i)) for (var j = 0; j < i.length; j++) if (null == i[j]) {
                        i = null;
                        break
                    }
                    if (null == g && null != i) {
                        h.resetValue(),
                        h._image = i,
                        h.setImageSrc(i);
                        var k = h.getUniqueCode(),
                        l = Yb.TexturePool.getTexture(k);
                        null == l && (l = new Yb.Texture(i), Yb.TexturePool.setTexture(k, l)),
                        a.setMap(l, f)
                    } else if (null == i) a.setMap(null, f);
                    else {
                        g.clone(h, !1),
                        h._image = i,
                        h.setImageSrc(i);
                        var k = h.getUniqueCode(),
                        l = Yb.TexturePool.getTexture(k);
                        l !== g && (null == l && (l = new Yb.Texture, g.clone(l, !1), l.setImage(i), Yb.TexturePool.setTexture(k, l)), a.setMap(l, f))
                    }
                } else if (null != g) {
                    g.clone(h, !1),
                    h[e] = this.getCloneObject(c);
                    var k = h.getUniqueCode(),
                    l = Yb.TexturePool.getTexture(k);
                    l != g && (null == l && (l = new Yb.Texture, g.clone(l), l[e] = c), a.setMap(l, f))
                }
            } else "type" === b && a.setType ? a.setType(c) : a.setPropertyValue(b, this.getCloneObject(c))
        },
        getDefaultStyle: function(a, b) {
            if (null == a) return null;
            if (a.startsWith("m.")) {
                var c = [],
                d = a.substr(a.indexOf(".") + 1);
                if (this.material.materials) {
                    var e = this.material.materials;
                    e = e || [this.material];
                    for (var f = 0; f < e.length; f++) {
                        var g = e[f];
                        if (d.startsWith("texture.") || d.startsWith("texture1.") || d.startsWith("texture2.") || d.startsWith("textureb.") || d.startsWith("texturen.") || d.startsWith("texturebp.") || d.startsWith("lightmap") || d.startsWith("envmap") || d.startsWith("normalmap") || d.startsWith("specularmap")) {
                            var h = d.substr(0, d.indexOf(".")),
                            i = d.substr(d.indexOf(".") + 1),
                            j = (d.substr(d.indexOf(".") + 1), this.textureMapping[h]),
                            k = g[j];
                            if (k) if ("image" === i) if (tc.isArray(k._image)) {
                                var l = [];
                                c.push(l);
                                for (var m = 0; m < k._image.length; m++) l.push(k._image[m].src)
                            } else c.push(k._image.src);
                            else "offset" === i || "repeat" === i ? c.push(g[i]) : c.push(g.map[i]);
                            else c.push(Yb.Styles.getStyle(a))
                        } else c.push(g[d])
                    }
                }
                b && (c = this.getCloneObject(c));
                for (var n = !0,
                f = 0; f < c.length; f++) if (0 != c.indexOf(c[f])) {
                    n = !1;
                    break
                }
                return n ? c[0] : c
            }
            if (this.isSideStyle(a)) {
                var o = a.substr(0, a.indexOf("."));
                a = a.substr(a.indexOf(".") + 1);
                var d = a.substr(a.indexOf(".") + 1),
                p = this.getSideMaterialIndex(o);
                if (null != p) {
                    var q, g = this.material.materials[p];
                    return d.startsWith("texture.") ? g.map && (q = "texture.image" === d ? g.map._image.src: g.map[d]) : q = g[d],
                    b && (q = this.getCloneObject(q)),
                    q
                }
            }
            return Yb.Styles.getStyle(a)
        },
        isSideStyle: function(a) {
            if ( - 1 === a.indexOf(".")) return ! 1;
            var b = this.getSideIndexMapping();
            if (!b) return ! 1;
            var c = a.substr(0, a.indexOf("."));
            return b[c] !== e ? !0 : !1
        },
        setUp: function(a, b, c) {
            var d;
            if (3 === arguments.length) {
                if (this.up.x === a && this.up.y === b && this.up.z === c) return;
                d = new $b(a, b, c)
            } else {
                if (this.up.x === a.x && this.up.y === a.y && this.up.z === a.z) return;
                d = a
            }
            var e = this.up;
            this.up = d,
            this.onUpChanged(e, newValue),
            this.firePropertyChange("up", e, d)
        },
        getUp: function() {
            return this.up
        },
        onUpChanged: function(a, b) {},
        checkNumber: function(a, b, c, d) {
            tc.isNaN(a) && console.error(d + ",x is not a number"),
            tc.isNaN(b) && console.error(d + ",y is not a number"),
            tc.isNaN(c) && console.error(d + ",z is not a number")
        },
        invalidateTexture: function(a) {
            var b, c, d, e = this.material;
            if (null != a && e instanceof Yb.ArrayMaterial) {
                if ("string" == typeof a) {
                    var f = this.getSideIndexMapping();
                    if (null != f && (a = f[a]), null == a) return
                }
                if ("number" != typeof a) return;
                d = e instanceof Yb.ArrayMaterial ? e.materials[a] : materail,
                this._dirtyMaterialTexture(d)
            } else if (e instanceof Yb.ArrayMaterial) for (c = e.materials, b = 0; b < c.length; b++) d = c[b],
            this._dirtyMaterialTexture(d);
            else this._dirtyMaterialTexture(e)
        },
        _dirtyMaterialTexture: function(a) {
            null != a && a.map && a.map instanceof Yb.Texture && this._dirtyTexture(a.map)
        },
        _dirtyTexture: function(a) {
            var b = a._image;
            a.firePropertyChange("image", null, b)
        },
        p: function(a, b, c) {
            return 0 === arguments.length ? this.getPosition() : void(3 === arguments.length ? this.setPosition(a, b, c) : this.setPosition(a))
        },
        checkPosition: function(a) {
            return ! 0
        },
        setPosition: function(a, b, c) {
            var d;
            if (3 === arguments.length) {
                if (this._position.x === a && this._position.y === b && this._position.z === c) return;
                this.checkNumber(a, b, c, "setPosition"),
                d = new $b(a, b, c)
            } else {
                if (this._position.x === a.x && this._position.y === a.y && this._position.z === a.z) return;
                if (! (a instanceof $b)) throw "Element.setPosition : position is not instanceof TGL.Vec3";
                d = a
            }
            if (this.checkPosition(d)) {
                var e = this._position;
                this._position = d,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("position", e, d)
            }
        },
        getPosition: function(a) {
            return a == e && (a = !0),
            a ? this._position.clone() : this._position
        },
        setPositionX: function(a) {
            if (this._position.x !== a) {
                this.checkNumber(a, 0, 0, "setPositionX");
                var b = this._position.x,
                c = this._position.clone();
                return c.x = a,
                this.checkPosition(c) ? (this._position.x = a, this.updateWorldMatrix(!0, !1), void this.firePropertyChange("positionX", b, a)) : !1
            }
        },
        setX: function(a) {
            this.setPositionX(a)
        },
        getPositionX: function() {
            return this._position.x
        },
        getX: function() {
            return this.getPositionX()
        },
        setPositionY: function(a) {
            if (this._position.y !== a) {
                this.checkNumber(0, a, 0, "setPositionY");
                var b = this._position.y,
                c = this._position.clone();
                return c.y = a,
                this.checkPosition(c) ? (this._position.y = a, this.updateWorldMatrix(!0, !1), void this.firePropertyChange("positionY", b, a)) : !1
            }
        },
        setY: function(a) {
            this.setPositionY(a)
        },
        getPositionY: function() {
            return this._position.y
        },
        getY: function() {
            return this.getPositionY()
        },
        setPositionZ: function(a) {
            if (this._position.z !== a) {
                this.checkNumber(0, 0, a, "setPositionZ");
                var b = this._position.z,
                c = this._position.clone();
                return c.z = a,
                this.checkPosition(c) ? (this._position.z = a, this.updateWorldMatrix(!0, !1), void this.firePropertyChange("positionZ", b, a)) : !1
            }
        },
        setZ: function(a) {
            this.setPositionZ(a)
        },
        getPositionZ: function() {
            return this._position.z
        },
        getZ: function() {
            return this.getPositionZ()
        },
        setScale: function(a, b, c) {
            var d;
            if (3 === arguments.length) {
                if (this._scale.x === a && this._scale.y === b && this._scale.z === c) return;
                this.checkNumber(a, b, c, "setScale"),
                d = new $b(a, b, c)
            } else {
                if (this._scale.x === a.x && this._scale.y === a.y && this._scale.z === a.z) return;
                if (! (a instanceof $b)) throw "Element.setScale : scale is not instanceof TGL.Vec3";
                d = a
            }
            var e = this._scale;
            d.x = d.x || 1,
            d.y = d.y || 1,
            d.z = d.z || 1,
            this._scale = d,
            this.updateWorldMatrix(!0, !1),
            this.firePropertyChange("scale", e, d)
        },
        getScale: function(a) {
            return a == e && (a = !0),
            a ? this._scale.clone() : this._scale
        },
        setScaleX: function(a) {
            if (this._scale.x !== a) {
                this.checkNumber(a, 0, 0, "setScalX");
                var b = this._scale.x;
                this._scale.x = a,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("scaleX", b, a)
            }
        },
        getScaleX: function() {
            return this._scale.x
        },
        setScaleY: function(a) {
            if (this._scale.y !== a) {
                this.checkNumber(0, a, 0, "setScaleY");
                var b = this._scale.y;
                this._scale.y = a,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("scaleY", b, a)
            }
        },
        getScaleY: function() {
            return this._scale.y
        },
        setScaleZ: function(a) {
            if (this._scale.z !== a) {
                this.checkNumber(0, 0, a, "setScaleZ");
                var b = this._scale.z;
                this._scale.z = a,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("scaleZ", b, a)
            }
        },
        getScaleZ: function() {
            return this._scale.z
        },
        setRotation: function(a, b, c) {
            var d;
            if (3 === arguments.length) {
                if (this._rotation.x === a && this._rotation.y === b && this._rotation.z === c) return;
                this.checkNumber(a, b, c, "setRotation"),
                d = new $b(a, b, c)
            } else {
                if (this._rotation.x === a.x && this._rotation.y === a.y && this._rotation.z === a.z) return;
                if (! (a instanceof $b)) throw "Element.setRotation : rotation is not instanceof TGL.Vec3";
                d = a
            }
            var e = this._rotation;
            this._rotation = d,
            this.updateWorldMatrix(!0, !1),
            this.firePropertyChange("rotation", e, d)
        },
        getRotation: function(a) {
            return a == e && (a = !0),
            a ? this._rotation.clone() : this._rotation
        },
        setRotationX: function(a) {
            if (this._rotation.x !== a) {
                this.checkNumber(a, 0, 0, "setRotationX");
                var b = this._rotation.x;
                this._rotation.x = a,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("rotationX", b, a)
            }
        },
        getRotationX: function() {
            return this._rotation.x
        },
        setRotationY: function(a) {
            if (this._rotation.y !== a) {
                this.checkNumber(0, a, 0, "setRotationY");
                var b = this._rotation.y;
                this._rotation.y = a,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("rotationY", b, a)
            }
        },
        getRotationY: function() {
            return this._rotation.y
        },
        setRotationZ: function(a) {
            if (this._rotation.z !== a) {
                this.checkNumber(0, 0, a, "setRotationZ");
                var b = this._rotation.z;
                this._rotation.z = a,
                this.updateWorldMatrix(!0, !1),
                this.firePropertyChange("rotationZ", b, a)
            }
        },
        getRotationZ: function() {
            return this._rotation.z
        },
        applyMatrix: function(a) {
            var b = this.matrix.clone();
            this.matrix.multiplyMatrices(a, this.matrix),
            this._scale.getScaleFromMatrix(this.matrix);
            var c = (new ac).extractRotation(this.matrix);
            this._rotation.setEulerFromRotationMatrix(c, this.eulerOrder),
            this._position.getPositionFromMatrix(this.matrix),
            this.updateWorldMatrix(!0, !1),
            this.firePropertyChange("matrix", b, this.matrix)
        },
        translate: function(a, b) {
            this.matrix.rotateAxis(b),
            this.setPosition(this._position.clone().add(b.multiplyScalar(a)))
        },
        translateX: function(a) {
            this.translate(a, this._vector.set(1, 0, 0))
        },
        translateY: function(a) {
            this.translate(a, this._vector.set(0, 1, 0))
        },
        translateZ: function(a) {
            this.translate(a, this._vector.set(0, 0, 1))
        },
        rotateFromAxis: function(a, b, c) {
            b = b.clone().applyMatrix4(this.matrix),
            a = a.clone().normalize().applyMatrix4((new ac).extractRotation(this.matrix));
            var d = (new ac).makeRotationAxisAndCenter(a, c, b);
            this.applyMatrix(d)
        },
        rotateFromWorldAxis: function(a, b) {
            var c = new ac;
            c.makeRotationAxis(a.normalize(), b),
            c.multiply(this.matrix),
            this.matrix = c;
            var d = (new ac).extractRotation(this.matrix),
            e = new $b;
            e.setEulerFromRotationMatrix(d, this.eulerOrder),
            this.setRotation(e)
        },
        getEulerAngles: function() {
            return this.matrix.getEulerAngles()
        },
        rotateFromWorldXAxis: function(a) {
            this.rotateFromWorldAxis(new $b(1, 0, 0), a)
        },
        rotateFromWorldYAxis: function(a) {
            this.rotateFromWorldAxis(new $b(0, 1, 0), a)
        },
        rotateFromWorldZAxis: function(a) {
            this.rotateFromWorldAxis(new $b(0, 0, 1), a)
        },
        getRelativeTransform: function(a) {
            if (a instanceof Yb.Element) {
                var b = (new ac).getInverse(a.matrix.clone()),
                c = (new ac).multiplyMatrices(b, this.matrix.clone()),
                d = (new $b).getPositionFromMatrix(c),
                e = (new $b).setEulerFromRotationMatrix(c),
                f = (new $b).getScaleFromMatrix(c),
                g = {
                    position: d,
                    rotation: e,
                    scale: f,
                    matrix: c
                };
                return g
            }
            return null
        },
        localToWorld: function(a) {
            return null == this._parent ? a: a.clone().applyMatrix4(this._parent.worldMatrix)
        },
        localToWorld2: function(a) {
            return a.clone().applyMatrix4(this.worldMatrix)
        },
        getWorldPosition: function() {
            return this.worldMatrix.getPosition()
        },
        direction: function(a) {
            var b = a.applyMatrix4((new ac).extractRotation(this.worldMatrix));
            return b.normalize(),
            b
        },
        frontDirection: function() {
            var a = new $b(0, 0, 1);
            return a = a.applyMatrix4((new ac).extractRotation(this.worldMatrix)),
            a.normalize(),
            a
        },
        worldPosition: function(a, b) {
            b = b > 0 ? b: a.length();
            var c = this.worldMatrix.getPosition();
            return c.add(this.direction(a).multiplyScalar(b))
        },
        frontWorldPosition: function(a) {
            a = a > 0 ? a: 1;
            var b = this.worldMatrix.getPosition();
            return b.add(this.frontDirection().multiplyScalar(a))
        },
        worldToLocal: function(a) {
            return a.clone().applyMatrix4(Yb.Element.__m1.getInverse(this.worldMatrix))
        },
        lookAt: function(a, b) {
            this.matrix.lookAt(a, this._position, b ? b: this.up),
            this.rotationAutoUpdate && (this.useQuaternion === !1 ? this._rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder) : this.quaternion.copy(this.matrix.decompose()[1])),
            this.worldMatrixNeedsUpdate = !0
        },
        iterator: function(a) {
            a(this),
            this._childList && this._childList.forEach(function(b) {
                b.iterator(a)
            })
        },
        getChildByName: function(a, b) {
            for (var c = 0,
            d = this.children.length; d > c; c++) {
                var f = this.children[c];
                if (f.name === a) return f;
                if (b === !0 && (f = f.getChildByName(a, b), f !== e)) return f
            }
            return e
        },
        getDescendants: function(a) {
            a === e && (a = []);
            var b = this.getChildren().toArray();
            Array.prototype.push.apply(a, b);
            for (var c = 0,
            d = b.length; d > c; c++) b[c].getDescendants(a);
            return a
        },
        fixSize: function(a) {
            if (this._sizeFixed) {
                this.updateWorldMatrix();
                var b = new $b,
                c = new $b;
                b.getPositionFromMatrix(this.worldMatrix),
                a.updateWorldMatrix(),
                c.getPositionFromMatrix(a.worldMatrix),
                scale = b.distanceTo(c) / this._fixedSize,
                0 === scale && (scale = 1e-5),
                this.setScale(scale, scale, scale)
            }
        },
        updateMatrix: function() {
            this.matrix.setPosition(this._position),
            this.useQuaternion === !1 ? this.matrix.setRotationFromEuler(this._rotation, this.eulerOrder) : this.matrix.setRotationFromQuaternion(this.quaternion),
            (1 !== this._scale.x || 1 !== this._scale.y || 1 !== this._scale.z) && this.matrix.scale(this._scale),
            this.worldMatrixNeedsUpdate = !0
        },
        updateWorldMatrix: function(a, b) {
            if (b = b == e ? !0 : b, this.matrixAutoUpdate === !0 && this.updateMatrix(), this.worldMatrixNeedsUpdate === !0 || a === !0) {
                this.matrixAutoUpdate === !1 && this.updateMatrix();
                var c = this.worldMatrix.clone();
                this._parent == e ? this.worldMatrix.copy(this.matrix) : this.worldMatrix.multiplyMatrices(this._parent.worldMatrix, this.matrix),
                this.worldMatrixNeedsUpdate = !1,
                a = !0,
                c.equals(this.worldMatrix) || (b && this.firePropertyChange("worldMatrix", c, this.worldMatrix), this.updateCameraMatrix && this.updateCameraMatrix(!1))
            }
            this._childList.forEach(function(b) {
                b.updateWorldMatrix(a)
            })
        },
        cloneCallback: function(a) {},
        clonePrefab: function(a) {
            var b = new mono.Entity;
            a === e && (a = !0),
            b.name = this.name,
            null == b.up && (b.up = new $b(0, 1, 0)),
            b.up.copy(this.up),
            b._position.copy(this._position),
            b._rotation.copy(this._rotation),
            b.eulerOrder = this.eulerOrder,
            b._scale.copy(this._scale),
            b.renderDepth = this.renderDepth,
            b.rotationAutoUpdate = this.rotationAutoUpdate,
            b.matrix.copy(this.matrix),
            b.worldMatrix.copy(this.worldMatrix),
            b.rotationWorldMatrix.copy(this.rotationWorldMatrix),
            b.matrixAutoUpdate = this.matrixAutoUpdate,
            b.worldMatrixNeedsUpdate = this.worldMatrixNeedsUpdate,
            b.quaternion.copy(this.quaternion),
            b.useQuaternion = this.useQuaternion,
            b._visible = this._visible,
            b.castShadow = this.castShadow,
            b.receiveShadow = this.receiveShadow,
            b.frustumCulled = this.frustumCulled,
            b.styleMap = b.styleMap || {},
            a && this._childList && this._childList.forEach(function(c) {
                b.addChild(c.clonePrefab(a))
            }),
            b.vertices = this.vertices,
            b.faces = this.faces,
            b.uvs = this.uvs,
            b.uv2s = this.uv2s,
            b.primitive = this.primitive,
            b.data = this.primitive.data,
            b.computed = !0;
            for (var c in this.styleMap) b.styleMap[c] = this.getCloneObject(this.styleMap[c]);
            if (null != this._clientMap) for (var d in this._clientMap) b.setClient(d, this._clientMap[d]);
            if (b.material = this.material, this.material instanceof Yb.ArrayMaterial) {
                b.material = new Yb.ArrayMaterial,
                b.material.materials = [];
                for (var f = 0; f < this.material.materials.length; f++) b.material.materials.push(this.material.materials[f])
            }
            return b.materialSize = this.getMaterialSize(),
            b
        },
        createCloneObject: function() {
            return this.constructor ? object = new this.constructor: object = new Yb.Element,
            object
        },
        clone: function(a, b, c) {
            if ("boolean" == typeof a && (c = b, b = a, a = e), a == e && (a = this.createCloneObject()), c === e && (c = !0), a.name = this.name, null == a.up && (a.up = new $b(0, 1, 0)), a.up.copy(this.up), a._position.copy(this._position), a._rotation.copy(this._rotation), a.eulerOrder = this.eulerOrder, a._scale.copy(this._scale), a.renderDepth = this.renderDepth, a.rotationAutoUpdate = this.rotationAutoUpdate, a.matrix.copy(this.matrix), a.worldMatrix.copy(this.worldMatrix), a.rotationWorldMatrix.copy(this.rotationWorldMatrix), a.matrixAutoUpdate = this.matrixAutoUpdate, a.worldMatrixNeedsUpdate = this.worldMatrixNeedsUpdate, a.quaternion.copy(this.quaternion), a.useQuaternion = this.useQuaternion, a._visible = this._visible, a.castShadow = this.castShadow, a.receiveShadow = this.receiveShadow, a.frustumCulled = this.frustumCulled, a.styleMap = a.styleMap || {},
            c && this._childList && this._childList.forEach(function(d) {
                a.addChild(d.clone(b, c))
            }), this.constructor) {
                var d = this.constructor.prototype.__accessor,
                f = this.constructor.prototype.__bool;
                if (d && d.length > 0) for (var g = 0; g < d.length; g++) {
                    var h = d[g],
                    i = Yb.getter(h, f),
                    j = Yb.setter(h);
                    "vertices" === h ? a.vertices = this.vertices: "faces" === h ? a.faces = this.faces: a[j] && a[j](this[i]())
                }
            }
            if (b && this.vertices) {
                var k = a,
                l = this.vertices;
                k.vertices = [],
                k.faces = [],
                k.uvs = [];
                for (var g = 0,
                m = l.length; m > g; g++) k.vertices.push(l[g].clone());
                for (var n = this.faces,
                g = 0,
                m = n.length; m > g; g++) k.faces.push(n[g].clone());
                for (var o = this.uvs,
                g = 0,
                m = o.length; m > g; g++) {
                    for (var p = o[g], q = [], r = 0, s = p.length; s > r; r++) q.push(new Yb.Vec2(p[r].x, p[r].y));
                    k.uvs.push(q)
                }
            }
            for (var t in this.styleMap) a.setStyle(t, this.getCloneObject(this.styleMap[t]));
            if (null != this._clientMap) for (var u in this._clientMap) a.setClient(u, this._clientMap[u]);
            return a.cloneCallback(b),
            a
        }
    }),
    Yb.Annotation = function(a, b, c, d) {
        Yb.Element.call(this, d),
        this._label = a,
        this._text = b,
        this.buttons = c,
        this._cameraPosition = null
    },
    Yb.extend(Yb.Annotation, Yb.Element, {
        ___accessor: ["label", "text", "cameraPosition"]
    }),
    Yb.Node = function(a) {
        Yb.Element.call(this, a),
        this.name = "",
        this.computed = !1,
        this.selectionData = null,
        this.stylesMap = new Object,
        this.renderGroup = [],
        this.primitive = null,
        this.vertices = [],
        this.faces = [],
        this.uvs = [],
        this.uv2s = [],
        this.colors = [],
        this.normals = [],
        this.faces = [],
        this.morphTargets = [],
        this.morphColors = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.hasTangents = !1,
        this.dynamic = !0,
        this.verticesNeedUpdate = !1,
        this.morphTargetsNeedUpdate = !1,
        this.elementsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.tangentsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.buffersNeedUpdate = !1,
        this.computeNodeData(),
        this._alarmBillboard = null
    },
    Yb.extend(Yb.Node, Yb.Element, {
        __accessor: ["vertices", "faces", "uvs", "linkAgent"],
        __SizePropeties: [],
        setUpdateFlags: function(a) {
            this.verticesNeedUpdate = a,
            this.morphTargetsNeedUpdate = a,
            this.elementsNeedUpdate = a,
            this.uvsNeedUpdate = a,
            this.normalsNeedUpdate = a,
            this.tangentsNeedUpdate = a,
            this.colorsNeedUpdate = a
        },
        getLinks: function() {
            return this._links
        },
        getFromLinks: function() {
            return this._fromLinks
        },
        getToLinks: function() {
            return this._toLinks
        },
        _addFromLink: function(a) {
            this._allLinks || (this._allLinks = new kc),
            this._fromLinks || (this._fromLinks = new kc),
            this._allLinks.add(a),
            this._fromLinks.add(a),
            this._resetLinkSet()
        },
        _addToLink: function(a) {
            this._allLinks || (this._allLinks = new kc),
            this._toLinks || (this._toLinks = new kc),
            this._allLinks.add(a),
            this._toLinks.add(a),
            this._resetLinkSet()
        },
        _removeFromLink: function(a) {
            this._allLinks.remove(a),
            this._fromLinks.remove(a),
            0 === this._allLinks.size() && delete this._allLinks,
            0 === this._fromLinks.size() && delete this._fromLinks,
            this._resetLinkSet()
        },
        _removeToLink: function(a) {
            this._allLinks.remove(a),
            this._toLinks.remove(a),
            0 === this._allLinks.size() && delete this._allLinks,
            0 === this._toLinks.size() && delete this._toLinks,
            this._resetLinkSet()
        },
        _resetLinkSet: function() {
            if (delete this._loopedLinks, !this._allLinks || 0 === this._allLinks.size()) return void delete this._links;
            var a;
            this._allLinks.forEach(function(b) {
                b.isLooped() && (a || (a = {}), a[b._id] || (this._loopedLinks || (this._loopedLinks = new kc), this._loopedLinks.add(b), a[b._id] = b))
            },
            this),
            a ? (this._links = new kc, this._allLinks.forEach(function(b) {
                a[b._id] ? a[b._id] !== !1 && (a[b._id] = !1, this._links.add(b)) : this._links.add(b)
            },
            this)) : this._links = this._allLinks
        },
        onAlarmChange: function(a, b) {
            Yb.Element.prototype.onAlarmChange.call(this, a, b);
            var c = this;
            setTimeout(function() {
                var a = c._alarmState.getPropagateSeverity();
                a || (a = c._alarmState.getHighestNativeAlarmSeverity());
                var b = c._parent,
                d = !1;
                if (null != b && b._alarmState) {
                    var e = b._alarmState.getPropagateSeverity();
                    e || (d = !0)
                } else d = !0;
                a && d ? (null == c._alarmBillboard && c.setAlarmBillboard(new Yb.Billboard), c._alarmBillboard.setStyle("m.texture.image", Yb.ImageCache.AlarmBillboardImage), c._alarmBillboard.setStyle("m.color", a.color), c._alarmBillboard.setStyle("m.alignment", Yb.BillboardAlignment.bottomCenter)) : c.setAlarmBillboard(null)
            },
            10)
        },
        _setAlarmBillboardPositionAndSize: function(a) {
            var b = this.getStyle("alarm.billboard.position"),
            c = this.getBoundingBox(),
            d = c.min,
            e = c.max,
            f = c.center(),
            g = c.size();
            "topLeft" === b ? a._position.set(d.x, e.y, f.z + 1) : "topRight" === b ? a._position.set(e.x, e.y, f.z + 1) : "topBack" === b ? a._position.set(f.x, e.y, d.z - 1) : "topFront" === b ? a._position.set(f.x, e.y, e.z + 1) : a._position.set(f.x, e.y, f.z + 1);
            var h = this.getStyle("alarm.billboard.scale");
            h instanceof $b ? a._scale.copy(h) : a._scale.set(g.x / 2, g.x / 2, 1);
            var i = this.getStyle("alarm.billboard.vertical");
            a.setStyle("m.vertical", i)
        },
        getLinkOffset: function(a) {
            return new mono.Vec3(0, 0, 0)
        },
        getLinkExtend: function(a) {
            return new mono.Vec3(0, 0, 0)
        },
        clearLinkOrthogonal: function(a, b) {
            return ! 1
        },
        clearLinkExtend: function(a, b) {
            return ! 1
        },
        setAlarmBillboard: function(a) {
            if (this._alarmBillboard != a) {
                var b = this._alarmBillboard;
                a ? (this._alarmBillboard = a, a.setParent(this), a.setClient("alarmBillboard", !0), this._setAlarmBillboardPositionAndSize(a)) : (this._alarmBillboard.setParent(null), delete this._alarmBillboard),
                this.firePropertyChange("alarmBillboard", b, a)
            }
        },
        needUpdate: function() {
            return this.verticesNeedUpdate || this.morphTargetsNeedUpdate || this.elementsNeedUpdate || this.uvsNeedUpdate || this.normalsNeedUpdate || this.tangentsNeedUpdate || this.colorsNeedUpdate
        },
        getVerticesWithChildren: function(a, b) {
            function c(c) {
                c.applyMatrix4(a),
                b.push(c)
            }
            null == b && (b = []),
            null == a && (a = new ac);
            var d;
            if (this instanceof Yb.Node) {
                if (null != this.vertices && 0 != this.vertices.length) {
                    var e = this.getBoundingBox(),
                    f = e.min,
                    g = e.max;
                    c(f.clone()),
                    c(g.clone()),
                    c(new $b(f.x, f.y, g.z)),
                    c(new $b(f.x, g.y, f.z)),
                    c(new $b(g.x, f.y, f.z)),
                    c(new $b(g.x, g.y, f.z)),
                    c(new $b(g.x, f.y, g.z)),
                    c(new $b(f.x, g.y, g.z))
                }
                for (var d = 0; d < (this._childList ? this._childList.size() : 0); d++) {
                    var h = this._childList.get(d),
                    i = new ac;
                    i.multiplyMatrices(a, h.matrix.clone()),
                    h.getVerticesWithChildren && h.getVerticesWithChildren(i, b)
                }
            }
            return b
        },
        getBoundingBoxWithChildren: function(a) {
            var b = this.getVerticesWithChildren();
            if (a) for (var c = 0; c < a.length; c++) {
                var d = a[c];
                if (d.getParent() === this.getParent() && d !== this) {
                    var e = (new ac).getInverse(this.matrix.clone()),
                    f = (new ac).multiplyMatrices(e, d.matrix.clone());
                    b = b.concat(d.getVerticesWithChildren(f))
                }
            }
            var g = new Yb.BoundingBox;
            return g.setFromPoints(b),
            g
        },
        getWorldBoundingBox: function() {
            for (var a = [], b = 0; b < this.vertices.length; b++) {
                var c = this.vertices[b].clone();
                c.applyMatrix4(this.worldMatrix),
                a.push(c)
            }
            var d = new Yb.BoundingBox;
            return d.setFromPoints(a),
            d
        },
        getBoundingBox: function() {
            return null == this.boundingBox && this.computeBoundingBox(),
            this.boundingBox
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Yb.BoundingBox),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Yb.BoundingSphere),
            this.boundingSphere.setFromCenterAndPoints(this.boundingSphere.center, this.vertices)
        },
        createPropagateAlarmCube: function(a) {
            if (null == this.boundingBox && this.computeBoundingBox(), a._attachId = this._id, null == this.propagateAlarmData) {
                var b = this.getStyle("outer.offset"),
                c = this.boundingBox.min,
                d = this.boundingBox.max;
                a.width = d.x - c.x + b,
                a.height = d.y - c.y + b,
                a.depth = d.z - c.z + b,
                a.computed = !1,
                a.computeNodeData(),
                this.propagateAlarmData = a.data,
                hc(a, !0),
                this.propagateAlarmData.primitive = a.primitive,
                this.propagateAlarmData.groups = a.groups;
                for (var e = (new $b).center(c, d), f = 0; f < a.vertices.length; f++) {
                    var g = a.vertices[f];
                    g.add(e)
                }
                this.propagateAlarmData.vertices = a.vertices
            } else {
                var h = this.propagateAlarmData;
                a.primitive = h.primitive,
                a.data = h,
                a.vertices = h.vertices,
                a.uvs = h.uvs,
                a.faces = h.faces,
                a.groups = h.groups
            }
            this.updateMatrix(!0),
            a._position.copy(this._position),
            a._scale.copy(this._scale),
            a._rotation.copy(this._rotation),
            a.useQuaternion = this.useQuaternion,
            a.quaternion = this.quaternion,
            a.worldMatrix = this.worldMatrix,
            a._parent = this.getParent(),
            a.updateMatrix(!0);
            var i = a.material;
            i.wireframeLinewidth = this.getStyle("outer.width");
            var j = this.getAlarmState().getPropagateSeverity();
            return i.color.set(j.color),
            a
        },
        createCanvasSelectionCube: function() {
            return null == this._csc && (this._csc = new rc, this._csc.material = new Yb.EntityMaterial, this._csc.material.wireframe = !0),
            this.createSelectionCube(this._csc),
            this._csc
        },
        createSelectionCube: function(a) {
            if (null == this.boundingBox && this.computeBoundingBox(), a._attachId = this._id + "_selection", null == this.selectionData) {
                var b = this.getStyle("select.offset"),
                c = this.boundingBox.min,
                d = this.boundingBox.max,
                e = (new $b).center(c, d);
                a.width = d.x - c.x + b,
                a.height = d.y - c.y + b,
                a.depth = d.z - c.z + b,
                a.offset = e,
                a.computed = !1,
                a.computeNodeData(),
                this.selectionData = a.data,
                hc(a, !0),
                this.selectionData.primitive = a.primitive,
                this.selectionData.groups = a.groups,
                this.selectionData.vertices = a.vertices
            } else {
                var f = this.selectionData;
                a.primitive = f.primitive,
                a.data = f,
                a.vertices = f.vertices,
                a.uvs = f.uvs,
                a.faces = f.faces,
                a.groups = f.groups
            }
            this.updateMatrix(!0),
            a._position.copy(this._position),
            a._scale.copy(this._scale),
            a._rotation.copy(this._rotation),
            a.useQuaternion = this.useQuaternion,
            a.quaternion = this.quaternion,
            a.worldMatrix = this.worldMatrix,
            a._parent = this.getParent(),
            a.updateMatrix(!0);
            var g = a.material;
            return g.wireframeLinewidth = this.getStyle("select.width"),
            g.color.set(this.getStyle("select.color")),
            a
        },
        mergeVertices: function() {
            var a, b, c, d, f, g, h, i = {},
            j = [],
            k = [],
            l = 4,
            m = Math.pow(10, l);
            for (this.__tmpVertices = e, null == this.vertices && console.log("vertices is null"), c = 0, d = this.vertices.length; d > c; c++) a = this.vertices[c],
            b = [Math.round(a.x * m), Math.round(a.y * m), Math.round(a.z * m)].join("_"),
            i[b] === e ? (i[b] = c, j.push(this.vertices[c]), k[c] = j.length - 1) : k[c] = k[i[b]];
            var n = [];
            for (c = 0, d = this.faces.length; d > c; c++) if (f = this.faces[c], f instanceof pc) {
                f.a = k[f.a],
                f.b = k[f.b],
                f.c = k[f.c],
                g = [f.a, f.b, f.c];
                for (var o = -1,
                p = 0; 3 > p; p++) if (g[p] == g[(p + 1) % 3]) {
                    o = p,
                    n.push(c);
                    break
                }
            } else if (f instanceof qc) {
                f.a = k[f.a],
                f.b = k[f.b],
                f.c = k[f.c],
                f.d = k[f.d],
                g = [f.a, f.b, f.c, f.d];
                for (var o = -1,
                p = 0; 4 > p; p++) g[p] == g[(p + 1) % 4] && (o >= 0 && n.push(c), o = p);
                if (o >= 0) {
                    g.splice(o, 1);
                    var q = new pc(g[0], g[1], g[2], f.normal, f.color, f.materialIndex);
                    h = this.uvs[c],
                    h && h.splice(o, 1),
                    f.vertexNormals && f.vertexNormals.length > 0 && (q.vertexNormals = f.vertexNormals, q.vertexNormals.splice(o, 1)),
                    f.vertexColors && f.vertexColors.length > 0 && (q.vertexColors = f.vertexColors, q.vertexColors.splice(o, 1)),
                    this.faces[c] = q
                }
            }
            for (c = n.length - 1; c >= 0; c--);
            var r = this.vertices.length - j.length;
            return this.vertices = j,
            r
        },
        computeVertexNormals: function(a) {
            var b, c, d, f, g, h;
            if (this.__tmpVertices === e) {
                for (this.__tmpVertices = new Array(this.vertices.length), h = this.__tmpVertices, b = 0, c = this.vertices.length; c > b; b++) h[b] = new Yb.Vec3;
                for (d = 0, f = this.faces.length; f > d; d++) g = this.faces[d],
                g.vertexNormals = [new Yb.Vec3, new Yb.Vec3, new Yb.Vec3]
            } else for (h = this.__tmpVertices, b = 0, c = this.vertices.length; c > b; b++) h[b].set(0, 0, 0);
            if (a) {
                var i, j, k, l = new Yb.Vec3,
                m = new Yb.Vec3;
                for (new Yb.Vec3, new Yb.Vec3, new Yb.Vec3, d = 0, f = this.faces.length; f > d; d++) g = this.faces[d],
                i = this.vertices[g.a],
                j = this.vertices[g.b],
                k = this.vertices[g.c],
                l.subVectors(k, j),
                m.subVectors(i, j),
                l.cross(m),
                h[g.a].add(l),
                h[g.b].add(l),
                h[g.c].add(l),
                g.d != e && h[g.d].add(l)
            } else for (d = 0, f = this.faces.length; f > d; d++) g = this.faces[d],
            h[g.a].add(g.normal),
            h[g.b].add(g.normal),
            h[g.c].add(g.normal);
            for (b = 0, c = this.vertices.length; c > b; b++) h[b].normalize();
            for (d = 0, f = this.faces.length; f > d; d++) g = this.faces[d],
            g.vertexNormals[0].copy(h[g.a]),
            g.vertexNormals[1].copy(h[g.b]),
            g.vertexNormals[2].copy(h[g.c]),
            g.d != e && (g.vertexNormals[3] = h[g.d].clone())
        },
        computeCentroids: function() {
            var a, b, c;
            for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a],
            c.centroid = c.centroid || new $b,
            null == c.centroid && console.log("fdasfdsa"),
            c.centroid.set || (c.centroid = new $b),
            c.centroid.set(0, 0, 0),
            c instanceof pc ? (c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3)) : c instanceof qc && (c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.add(this.vertices[c.d]), c.centroid.divideScalar(4))
        },
        computeFaceNormals: function() {
            var a, b, c, d, e, f, g = new $b,
            h = new $b;
            for (a = 0, b = this.faces.length; b > a; a++) c = this.faces[a],
            d = this.vertices[c.a],
            e = this.vertices[c.b],
            f = this.vertices[c.c],
            g.subVectors(f, e),
            h.subVectors(d, e),
            g.cross(h),
            g.normalize(),
            c.normal.copy || (c.normal = new $b),
            c.normal.copy(g)
        },
        computeVertex: function() {},
        computePrimitive: function() {},
        generalteGroup: function() {},
        getMatetial: function() {
            return this.material
        },
        computeNodeMaterial: function(a) {},
        cacheNodeMaterial: function(a) {},
        needComputeVertexNormal: function() {
            return ! 0
        },
        computeNodeData: function(a) {
            if (this.computed === !1) {
                var b = this.generatePrimitiveKey();
                this._attachId && (b += "_" + this._attachId);
                var c = Yb.PrimitiveCache.getPrimitive(b),
                d = !1;
                if (c) this.primitive && Yb.PrimitiveCache.unUsePrimitive(c),
                this.computeNodeMaterial(c);
                else {
                    var e = this.computeData();
                    if (this.needComputeVertexNormal() && (Yb.Node.prototype.mergeVertices.call(e), Yb.Node.prototype.computeFaceNormals.call(e), Yb.Node.prototype.computeVertexNormals.call(e, !0)), (null == e.uv2s || 0 == e.uv2s.length) && (e.uv2s = [], null != e.uvs && e.uvs.length > 0)) for (var f = 0; f < e.uvs.length; f++) {
                        for (var g = [], h = e.uvs[f], i = 0; i < h.length; i++) g.push(h[i].clone());
                        e.uv2s.push(g)
                    }
                    c = new Yb.Primitive(e, b),
                    Yb.PrimitiveCache.setPrimitive(b, c),
                    this.cacheNodeMaterial(c),
                    d = !0
                }
                return Yb.PrimitiveCache.usePrimitive(c),
                this.primitive = c,
                this.data = c.data,
                this.vertices = c.vertices,
                this.faces = c.faces,
                this.uvs = c.uvs,
                this.uv2s = c.uv2s,
                this.computed = !0,
                d
            }
        },
        computeData: function() {
            var a = {
                vertices: [],
                faces: [],
                uv2s: [],
                uvs: []
            };
            return this.vertices = a.vertices,
            this.uvs = a.uvs,
            this.faces = a.faces,
            this.data = a,
            a
        },
        setMaterial: function(a, b, c) {
            var d = b.getUniqueCode ? b.getUniqueCode() : null,
            e = $c.getMaterial(d);
            e ? (this.material.materials[a] = e, $c.useMaterial(e)) : (this.material.materials[a] = b, $c.setMaterial(d, b), $c.useMaterial(b)),
            $c.unUseMaterial(c)
        },
        onMaterialMapping: function() {
            this.groups = e
        },
        getMaterialSize: function() {
            return this.materialSize || 1
        },
        startBatch: function() {
            this.batch = !0
        },
        endBatch: function() {
            this.materialMappingChanges !== e && (this.onSizeChanged(), this.onMaterialMapping(), this.firePropertyChange("materialMapping", this.materialMappingChanges[0], this.materialMappingChanges[1]), this.materialMappingChanges = e),
            this.batch = !1
        },
        compareAndSetMaterial: function(a, b, c) {
            this.setMaterial(c, b, a)
        },
        cloneStyle: function(a) {
            if (this.getClassName() != a.getClassName()) return void console.warn("ApplyStyle fail, the source with not the same class");
            for (var b = this.getMaterialMapping(), c = 0; c < this.getMaterialSize(); c++) {
                var d = this.material.materials[c],
                e = a.material.materials[c];
                this.compareAndSetMaterial(d, e, c)
            }
            var f = this.getMaterialMapping();
            Yb.Utils.isSame(b, f) || (this.batch ? this.materialMappingChanges = [b, f] : (this.onSizeChanged(), this.onMaterialMapping(), this.firePropertyChange("materialMapping", b, f)))
        },
        _considerArray: function(a, b) {
            if (!a.startsWith("envmap.image")) return tc.isArray(b);
            var c = !1;
            if (tc.isArray(b)) for (var d = 0; d < b.length; d++) if (tc.isArray(b[d])) {
                c = !0;
                break
            }
            return c
        },
        setMaterialStyles: function(a) {
            var b, c, d, e, f, g, h = this.getMaterialMapping(),
            h = this.getMaterialMapping();
            for (var i in a) var j = a[i];
            for (var k = 0; k < this.getMaterialSize(); k++) {
                c = this.material.materials[k],
                d = c.clone();
                var l = !1;
                for (var i in a) {
                    var m = !1;
                    if (i.startsWith("m.")) e = i.substr(i.indexOf(".") + 1);
                    else if (this.getSideIndexMapping() && this.isSideStyle(i)) {
                        var n = i.substr(0, i.indexOf(".")),
                        f = this.getSideMaterialIndex(n);
                        if (f != k) continue;
                        m = !0,
                        g = i.substr(i.indexOf(".") + 1),
                        e = g.substr(g.indexOf(".") + 1)
                    }
                    var j = a[i];
                    b = j[0],
                    null == b ? b = Yb.Styles.getStyle(i) : this._considerArray(e, b) && (b = b[k]),
                    this._A97(d, e, b),
                    l = !0
                }
                l && this.compareAndSetMaterial(c, d, k)
            }
            this.changeMapping(h)
        },
        setMaterialStyle: function(a, b, c) {
            var b, d, e, f, g, h = a;
            if (a.startsWith("m.") && (h = a.substr(a.indexOf(".") + 1)), null == c && !Yb.Utils.isArray(b)) {
                var i = [];
                for (k = 0; k < this.getMaterialSize(); k++) i.push(b);
                this.styleMap[a] = i,
                b = i
            }
            var j = !1;
            if (h.startsWith("envmap.image") && b && tc.isArray(b)) for (var k = 0; k < b.length; k++) {
                if (tc.isArray(b[k])) {
                    j = !1;
                    break
                }
                j = !0
            }
            var l = this.getMaterialMapping();
            if (null != c || Yb.Utils.isArray(b) && !j) {
                if (Yb.Utils.isArray(b)) {
                    d = b;
                    for (var k = 0; k < this.getMaterialSize(); k++) e = d[k],
                    f = this.material.materials[k],
                    g = f.clone(),
                    null == e && (e = Yb.Styles.getStyle(a)),
                    this._A97(g, h, e),
                    this.compareAndSetMaterial(f, g, k)
                } else if (null != c) {
                    var l = this.getMaterialMapping();
                    f = this.material.materials[c],
                    g = f.clone(),
                    this._A97(g, h, b),
                    this.compareAndSetMaterial(f, g, c),
                    this.synchronizeIndexStyle(a, c, b)
                }
            } else for (var m = [], k = 0; k < this.getMaterialSize(); k++) m[k] !== !0 && (e = b, f = this.material.materials[k], g = f.clone(), null == e && (e = Yb.Styles.getStyle(a)), this._A97(g, h, e), this.compareAndSetMaterial(f, g, k));
            this.changeMapping(l)
        },
        changeMapping: function(a) {
            var b = this.getMaterialMapping();
            Yb.Utils.isSame(a, b) || (this.batch ? this.materialMappingChanges = [a, b] : (this.onSizeChanged(), this.onMaterialMapping(), this.firePropertyChange("materialMapping", a, b)))
        },
        synchronizeSideStyle: function(a, b, c) {
            var d = this.getMaterialIndexSide(b);
            d && null != this.styleMap[d + "." + a] && (this.styleMap[d + "." + a] = c)
        },
        synchronizeIndexStyle: function(a, b, c) {
            var d = this.styleMap[a];
            if (null == d && (d = this.getStyle(a), this.styleMap[a] = d), Yb.Utils.isArray(d)) d[b] = c;
            else {
                var e = [];
                for (i = 0; i < this.getMaterialSize(); i++) e.push(d);
                e[b] = c,
                this.styleMap[a] = e
            }
        },
        getDefaultMaterial: function(a, b) {
            return a ? a instanceof Yb.ArrayMaterial ? 0 === a.materials.length ? $c.DefaultMaterial: (b >= a.materials.length && (b = a.materials.length - 1), a.materials[b]) : a: $c.DefaultMaterial
        },
        createMaterial: function(a) {
            var b = new Yb.ArrayMaterial;
            this.material = b;
            for (var c = this.getMaterialSize(), d = 0; c > d; d++) this.setMaterial(d, this.getDefaultMaterial(a, d))
        },
        onPropertyChange: function(a, b, c) {
            this.changeProperty = a,
            this.oldGroups = this.groups;
            var d = this.isSizeChangedProperty(a);
            d && this.onSizeChanged(),
            d && this.onMaterialMapping(),
            d && this.firePropertyChange("materialMapping", 0, 1)
        },
        onSizeChanged: function() {
            this.computed = !1,
            this.computeNodeData(),
            this.computeCentroids(),
            this.computeFaceNormals(),
            this.computeBoundingBox(),
            this.selectionData = null,
            this.boundingSphere = null,
            this.changeProperty = null
        },
        isSizeChangedProperty: function(a) {
            return - 1 !== this.__SizePropeties.indexOf(a) || "vertices" == a || "faces" == a || "uvs" == a
        },
        isGroupChangedProperty: function(a) {},
        getMaterialMapping: function() {
            var a = {},
            b = this.material.materials;
            for (var c in b) a[c] = b.indexOf(b[c]);
            return a
        },
        getSideMaterialIndex: function(a) {
            var b = this.getSideIndexMapping();
            return b ? b[a] : void 0
        },
        getMaterialIndexSide: function(a) {
            var b = this.getIndexSideMapping();
            return b ? b[a] : void 0
        },
        getIndexSideMapping: function() {
            var a = this.getSideIndexMapping();
            if (a && !this.IndexSideMapping) {
                this.IndexSideMapping = {};
                var b, c;
                for (b in a) c = a[b],
                this.IndexSideMapping[c] = b
            }
            return this.IndexSideMapping
        },
        getSideIndexMapping: function() {},
        disposeMaterial: function() {},
        getMaterial: function() {
            return this.material
        }
    });
    var oc = function(a, b, c) {
        this.normal = a instanceof Yb.Vec3 ? a: new Yb.Vec3,
        this.vertexNormals = a instanceof Array ? a: [],
        this.color = b instanceof Yb.Color ? b: new Yb.Color,
        this.vertexColors = b instanceof Array ? b: [],
        this.materialIndex = c ? c: 0,
        this.centroid = new Yb.Vec3,
        this.needVertexNormal = !1
    };
    Yb.Face = oc,
    oc.prototype = {
        constructor: Yb.Face,
        subClone: function() {},
        clone: function() {
            var a = this.subClone();
            a.normal.copy(this.normal),
            a.color.copy(this.color),
            a.centroid.copy(this.centroid),
            a.materialIndex = this.materialIndex;
            var b, c;
            for (b = 0, c = this.vertexNormals.length; c > b; b++) a.vertexNormals.push(this.vertexNormals[b]);
            for (b = 0, c = this.vertexColors.length; c > b; b++) a.vertexColors.push(this.vertexColors[b]);
            return a
        }
    };
    var pc = function(a, b, c, d, e, f) {
        Yb.Face.call(this, d, e, f),
        this.a = a,
        this.b = b,
        this.c = c
    };
    Yb.Face3 = pc,
    pc.prototype = Object.create(Yb.Face.prototype),
    pc.prototype.constructor = Yb.Face3,
    pc.prototype.subClone = function() {
        var a = new pc(this.a, this.b, this.c);
        return a
    },
    pc.prototype.vertexCount = 3,
    pc.prototype.serializeJsonValue = function() {
        return {
            a: this.a,
            b: this.b,
            c: this.c
        }
    };
    var qc = function(a, b, c, d, e, f, g) {
        Yb.Face.call(this, e, f, g),
        this.a = a,
        this.b = b,
        this.c = c,
        this.d = d
    };
    Yb.Face4 = qc,
    qc.prototype = Object.create(Yb.Face.prototype),
    qc.prototype.constructor = Yb.Face4,
    qc.prototype.subClone = function() {
        var a = new qc(this.a, this.b, this.c, this.d);
        return a
    },
    qc.prototype.splitToFace3s = function() {
        var a = new pc(this.a, this.b, this.d, this.normal, this.color, this.materialIndex),
        b = new pc(this.d, this.b, this.c, this.normal, this.color, this.materialIndex);
        return [a, b]
    },
    qc.prototype.vertexCount = 4,
    qc.prototype.serializeJsonValue = function() {
        return {
            a: this.a,
            b: this.b,
            c: this.c,
            d: this.d
        }
    },
    Yb.Entity = function(a, b) {
        a instanceof Yb.ArrayMaterial ? (this.material = a, this.materialSize = this.material.materials.length || 1) : a instanceof Yb.Material ? (this.material = a, this.materialSize = 1) : a && (this.materialSize = a),
        this.materialSize = this.materialSize || 1,
        this.createMaterial(this.material),
        b != e && null == this._id && (this._id = b),
        Yb.Node.call(this, this._id),
        this.groups = null
    },
    Yb.extend(Yb.Entity, Yb.Node, {
        constructor: Yb.Entity,
        className: "TGL.Entity",
        __accessor: ["computeVertexNormal"],
        __SizePropeties: ["computeVertexNormal"],
        setUpdateFlags: function(a) {
            this.verticesNeedUpdate = a,
            this.morphTargetsNeedUpdate = a,
            this.elementsNeedUpdate = a,
            this.uvsNeedUpdate = a,
            this.normalsNeedUpdate = a,
            this.colorsNeedUpdate = a,
            this.tangentsNeedUpdate = a,
            this.buffersNeedUpdate = a
        },
        cloneCallback: function(a) {
            a && "TGL.Entity" === this.className && (this.computed = !1, this.computeNodeData())
        },
        needComputeVertexNormal: function() {
            return this.computeVertexNormal
        },
        computeData: function() {
            var a = {
                vertices: this.vertices,
                faces: this.faces,
                uvs: this.uvs,
                uv2s: this.uv2s
            };
            return a
        },
        createCloneObject: function() {
            return this.constructor === Yb.Entity ? new Yb.Entity(this.materialSize) : Yb.Element.prototype.createCloneObject.call(this)
        },
        getMaterialSize: function() {
            return this.materialSize
        },
        setMaterialSize: function(a) {
            "number" == typeof a && (this.materialSize = a, this.createMaterial(this.material))
        }
    });
    var rc = function() {
        var a, b, c, d, e, f, g, h;
        1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0]) ? (g = arguments[0], a = g.width, b = g.height, c = g.depth, d = g.segmentsW, e = g.segmentsH, f = g.segmentsD, h = g.wrapMode, this._id = g.id) : arguments[0] instanceof Yb.Material ? (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4], e = arguments[5], f = arguments[6], h = arguments[7]) : (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], e = arguments[4], f = arguments[5], h = arguments[6]),
        this.width = a || 1,
        this.height = b || 1,
        this.depth = c || 1,
        this.segmentsW = d || 1,
        this.segmentsH = e || 1,
        this.segmentsD = f || 1,
        this.wrapMode = (h || "").toLowerCase(),
        this.materialSize = null == this.wrapMode || "" == this.wrapMode ? 6 : 1,
        this.offset = new $b(0, 0, 0),
        Yb.Entity.call(this)
    };
    Yb.Cube = rc,
    Yb.extend(Yb.Cube, Yb.Entity, {
        __accessor: ["width", "height", "depth", "wrapMode"],
        __SizePropeties: ["width", "height", "depth", "wrapMode"],
        className: "TGL.Cube",
        getUVs: function() {
            return this.uvs
        },
        setPropertyValue: function(a, b) {
            var c = this[a];
            if (c === b) return ! 1;
            if (this[a] = b, "wrapMode" === a) {
                var d = this.wrapMode,
                e = "six-each" == d || "front-other" == d || "back-other" == d || "left-other" == d || "right-other" == d || "top-other" == d || "bottom-other" == d;
                this.materialSize = null == this.wrapMode || "" == this.wrapMode ? 6 : 1,
                e || (this[a] = "")
            }
            return ! 0
        },
        getLinkOffset: function(a) {
            a.length(),
            a.normalize();
            var b = a.x / this.getWidth(),
            c = a.y / this.getHeight(),
            d = a.z / this.getDepth(),
            e = Math.max(Math.abs(b), Math.abs(c), Math.abs(d));
            return e == Math.abs(b) ? new $b(this.getWidth() / 2 * (0 > b ? -1 : 1), 0, 0) : e == Math.abs(c) ? new $b(0, this.getHeight() / 2 * (0 > c ? -1 : 1), 0) : new $b(0, 0, this.getDepth() / 2 * (0 > d ? -1 : 1))
        },
        getLinkExtend: function(a) {
            var b = this.worldMatrix.clone();
            return b = (new mono.Mat4).extractRotation(b),
            this.getLinkOffset(a.applyMatrix4((new ac).getInverse(b)))
        },
        computeData: function() {
            var a = gc.buildCubeData(this.width, this.height, this.depth, this.segmentsW, this.segmentsH, this.segmentsD, this.wrapMode, this.offset || new $b(0, 0, 0));
            return this.vertices = a.vertices,
            this.uvs = a.uvs,
            this.faces = a.faces,
            this.data = a,
            a
        },
        getSideIndexMapping: function() {
            return this.wrapMap ? null: Yb.Cube.SideIndexMapping
        },
        generatePrimitiveKey: function() {
            return "cube_" + this.width + "_" + this.height + "_" + this.depth + "_" + this.segmentsW + "_" + this.segmentsH + "_" + this.segmentsD + "_" + (this.material instanceof Yb.ArrayMaterial ? 1 : 0) + "_" + this.wrapMode + "_" + this.offset.x + "_" + this.offset.y + "_ " + this.offset.z + "_" + Yb.Utils.toString(this.getMaterialMapping())
        },
        serialize: function(a) {
            var b = a;
            1 !== this.width && b.serializeSimple("p", "width", this.width, "number"),
            1 !== this.height && b.serializeSimple("p", "height", this.height, "number"),
            1 !== this.depth && b.serializeSimple("p", "depth", this.depth, "number"),
            1 !== this.widthSegemtns && b.serializeSimple("p", "widthSegemtns", this.widthSegemtns, "number"),
            1 !== this.heightSegments && b.serializeSimple("p", "heightSegments", this.heightSegments, "number"),
            1 !== this.depthSegments && b.serializeSimple("p", "depthSegments", this.depthSegments, "number"),
            Yb.Element.serialize.call(this, b)
        }
    }),
    rc.SideIndexMapping = {
        right: 0,
        left: 1,
        top: 2,
        bottom: 3,
        front: 4,
        back: 5
    },
    Yb.Sphere = function() {
        var a, b, c, d, f, g, h;
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var i = arguments[0];
            a = i.radius,
            b = i.segmentsW,
            c = i.segmentsH,
            d = i.longitudeStart,
            f = i.longitudeLength,
            g = i.latitudeStart,
            this._id = i.id
        } else arguments[0] instanceof Yb.Material ? (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4], f = arguments[5], g = arguments[6], h = arguments[7]) : (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], f = arguments[4], g = arguments[5], h = arguments[6]);
        this.radius = a || 50,
        this.segmentsW = Math.max(3, Math.floor(b) || 22),
        this.segmentsH = Math.max(2, Math.floor(c) || 15),
        this.longitudeStart = d !== e ? d: 0,
        this.longitudeLength = f !== e ? f: 2 * Math.PI,
        this.latitudeStart = g !== e ? g: 0,
        this.latitudeLength = h !== e ? h: Math.PI,
        this.materialSize = 1,
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.extend(Yb.Sphere, Yb.Entity, {
        constructor: Yb.Sphere,
        __accessor: ["radius", "segmentsW", "segmentsH", "latitudeStart", "latitudeLength", "longitudeStart", "longitudeLength"],
        __SizePropeties: ["radius", "segmentsW", "segmentsH", "latitudeStart", "latitudeLength", "longitudeStart", "longitudeLength"],
        className: "TGL.Sphere",
        computeData: function() {
            var a = gc.bsd(this.radius, this.segmentsW, this.segmentsH, this.longitudeStart, this.longitudeLength, this.latitudeStart, this.latitudeLength);
            return this.vertices = a.vertices,
            this.uvs = a.uvs,
            this.faces = a.faces,
            this.data = a,
            a
        },
        setWidthSegments: function(a) {
            console.log("TGL.Sphere.setWidthSegments has deprecated,please use setSegmentsW"),
            this.setSegmentsW(a)
        },
        setHeightSegments: function(a) {
            console.log("TGL.Sphere.setHeightSegments has deprecated,please use setSegmentsW"),
            this.setSegmentsH(a)
        },
        generatePrimitiveKey: function() {
            return "sphere_" + this.radius + "_" + this.segmentsW + "_" + this.segmentsH + "_" + this.longitudeStart + "_" + this.longitudeLength + "_" + this.latitudeStart + "_" + this.latitudeLength
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Yb.BoundingSphere(new Yb.Vec3, this.radius))
        },
        getLinkOffset: function(a) {
            return a.length(),
            a.normalize(),
            a.multiplyScalar(this.radius)
        },
        serialize: function(a) {
            var b = a;
            50 !== this.radius && b.serializeSimple(Wc, "radius", this.radius, "number"),
            24 !== this.widthSegments && b.serializeSimple(Wc, "widthSegments", this.widthSegments, "number"),
            18 !== this.heightSegments && b.serializeSimple(Wc, "heightSegments", this.heightSegments, "number"),
            0 !== this.phiStart && b.serializeSimple(Wc, "phiStart", this.phiStart, "number"),
            this.phiLength !== 2 * Math.PI && b.serializeSimple(Wc, "phiLength", this.phiLength, "number"),
            0 !== this.thetaStart && b.serializeSimple(Wc, "thetaStart", this.thetaStart, "number"),
            this.thetaLength !== Math.PI && b.serializeSimple(Wc, "thetaLength", this.thetaLength, "number")
        }
    }),
    Yb.Plane = function() {
        var a, b, c, d;
        arguments[0] instanceof Yb.Material ? (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4]) : (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3]),
        this.width = a || 5,
        this.height = b || 5,
        this.segmentsW = c || 1,
        this.segmentsH = d || 1,
        this.vertices = [],
        this.faces = [],
        this.uvs = [],
        this.uv2s = [],
        this.materialSize = 1,
        this.computeData = function() {
            var a, b, c = this.width / 2,
            d = this.height / 2,
            e = this.segmentsW,
            f = this.segmentsH,
            g = e + 1,
            h = f + 1,
            i = this.width / e,
            j = this.height / f,
            k = new Yb.Vec3(0, 0, 1),
            l = {
                vertices: [],
                faces: [],
                uvs: []
            };
            for (b = 0; h > b; b++) for (a = 0; g > a; a++) {
                var m = a * i - c,
                n = b * j - d;
                l.vertices.push(new Yb.Vec3(m, -n, 0))
            }
            for (b = 0; f > b; b++) for (a = 0; e > a; a++) {
                var o = a + g * b,
                p = a + g * (b + 1),
                q = a + 1 + g * (b + 1),
                r = a + 1 + g * b,
                s = new Yb.Vec2(a / e, 1 - b / f),
                t = new Yb.Vec2(a / e, 1 - (b + 1) / f),
                u = new Yb.Vec2((a + 1) / e, 1 - (b + 1) / f),
                v = new Yb.Vec2((a + 1) / e, 1 - b / f),
                w = new Yb.Face4(o, p, q, r);
                w.normal.copy(k),
                w.vertexNormals.push(k.clone(), k.clone(), k.clone(), k.clone()),
                l.faces.push(w),
                l.uvs.push([s, t, u, v])
            }
            return l
        },
        Yb.Entity.call(this),
        this.computeCentroids()
    },
    Yb.extend(Yb.Plane, Yb.Entity, {
        constructor: Yb.Plane,
        className: "TGL.Plane",
        __accessor: ["width", "height", "segmentsW", "segmentsH"],
        __SizePropeties: ["width", "height", "segmentsW", "segmentsH"],
        clone: function() {
            var a = new Yb.Plane(this.material, this.width, this.height, this.segmentsW, this.segmentsH);
            return this.superClass.clone.call(this, a),
            a
        },
        getSelectStyle: function() {
            var a = this.getStyle("select.style");
            return ("outline.normal" == a || "outline" == a) && (a = "outline.wireframe"),
            a
        }
    }),
    Yb.Cylinder = function() {
        var a, b, c, d, f, g, h, i, j;
        1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0]) ? (options = arguments[0], a = options.radiusTop, b = options.radiusBottom, c = options.height, d = options.segmentsR, f = options.segmentsH, g = options.openTop, h = options.openBottom, i = options.arcLength, j = options.arcStart, this._id = options.id) : arguments[0] instanceof Yb.Material ? (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4], f = arguments[5], g = arguments[6], h = arguments[7], i = arguments[8], j = arguments[9]) : (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], f = arguments[4], g = arguments[5], h = arguments[6], i = arguments[7], j = arguments[8]),
        this.radiusTop = a = a !== e ? a: 20,
        this.radiusBottom = b = b !== e ? b: 20,
        this.height = c = c !== e ? c: 100,
        this.segmentsR = d = d || 20,
        this.segmentsH = f = f || 1,
        this.openTop = g !== e ? g: !1,
        this.openBottom = h != e ? h: !1,
        this.arcLength = i !== e ? i: 2 * Math.PI,
        this.arcStart = j !== e ? j: 0,
        this.materialSize = 3,
        Yb.Entity.call(this),
        this.computeNodeData(),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.extend(Yb.Cylinder, Yb.Entity, {
        constructor: Yb.Cylinder,
        __accessor: ["radiusTop", "radiusBottom", "height", "segmentsR", "segmentsH", "openTop", "openBottom", "arcLength", "arcStart"],
        __bool: ["openTop", "openBottom"],
        __SizePropeties: ["radiusTop", "radiusBottom", "height", "segmentsR", "segmentsH", "openTop", "openBottom", "arcLength", "arcStart"],
        className: "TGL.Cylinder",
        computeData: function() {
            return gc.bcld(this.height, this.segmentsH, this.radiusBottom, this.radiusTop, this.segmentsR, this.openTop, this.openBottom, this.arcLength, this.arcStart)
        },
        getLinkOffset: function(a) {
            var b = a.length();
            a.normalize();
            var c = a.x,
            d = a.y,
            e = a.z,
            f = Math.sqrt(c * c + e * e),
            g = d > 0 ? this.radiusTop: this.radiusBottom;
            if (Math.abs(d / f) > this.height / 2 / g && b > 0) {
                var h = new $b(0, this.height / 2 * (d > 0 ? 1 : -1), 0);
                return h
            }
            return new $b(c, 0, e).normalize().multiplyScalar((this.radiusTop + this.radiusBottom) / 2)
        },
        getLinkExtend: function(a) {
            var b = this.worldMatrix.clone();
            return b = (new mono.Mat4).extractRotation(b),
            this.getLinkOffset(a.applyMatrix4((new ac).getInverse(b)))
        },
        clearLinkOrthogonal: function(a, b, c, d) {
            d = d || 0;
            var e = this.getHeight() / 2 + d,
            f = (this.radiusTop + this.radiusBottom) / 2 + d;
            return "orthogonal.x" == c || "orthogonal.x.n" == c ? !(Math.abs(a.y - b.y) > e || Math.abs(a.z - b.z) > f) : "orthogonal.y" == c || "orthogonal.y.n" == c ? !(Math.abs(a.x - b.x) > f || Math.abs(a.z - b.z) > f) : "orthogonal.z" == c || "orthogonal.z.n" == c ? !(Math.abs(a.y - b.y) > e || Math.abs(a.z - b.z) > f) : !1
        },
        clearLinkExtend: function(a, b) {
            return "extend.x" !== b && "extend.y" === b && a > this.getHeight() / 2 ? !0 : !1
        },
        getSideIndexMapping: function() {
            return Yb.Cylinder.SideIndexMapping
        },
        generatePrimitiveKey: function() {
            return "cylinder_" + this.height + "_" + this.segmentsH + "_" + this.radiusTop + "_" + this.radiusBottom + "_" + this.segmentsR + "_" + this.openTop + "_" + this.openBottom + "_" + this.arcLength + "_" + this.arcStart + Yb.Utils.toString(this.getMaterialMapping())
        },
        needComputeVertexNormal: function() {
            return ! 1
        }
    }),
    Yb.Cylinder.SideIndexMapping = {
        side: 0,
        top: 1,
        bottom: 2
    },
    Yb.Circle = function() {
        var a, b, c, d;
        4 === arguments.length ? (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3]) : (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4]),
        this.radius = a = a || 50,
        this.segments = b = b !== e ? Math.max(3, b) : 8,
        this.thetaStart = c = c !== e ? c: 0,
        this.thetaLength = d = d !== e ? d: 2 * Math.PI,
        this.materialSize = 1,
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals(),
        this.boundingSphere = new Yb.BoundingSphere(new Yb.Vec3, a)
    },
    Yb.extend(Yb.Circle, Yb.Entity, {
        clone: function() {
            var a = new Yb.Circle(this.material, this.radius, this.segments, this.thetaStart, this.thetaLength);
            return this.constructor.superClass.clone.call(this, a),
            a
        },
        computeData: function() {
            var a, b = this.segments,
            c = [],
            d = new Yb.Vec3,
            e = new Yb.Vec2(.5, .5),
            f = {
                vertices: [],
                faces: [],
                uvs: [],
                uv2s: []
            };
            for (f.vertices.push(d), c.push(e), a = 0; b >= a; a++) {
                var g = new Yb.Vec3,
                h = this.thetaStart + a / b * this.thetaLength;
                g.x = this.radius * Math.cos(h),
                g.y = this.radius * Math.sin(h),
                f.vertices.push(g),
                c.push(new Yb.Vec2((g.x / this.radius + 1) / 2, (g.y / this.radius + 1) / 2))
            }
            var i = new Yb.Vec3(0, 0, 1);
            for (a = 1; b >= a; a++) {
                var j = a,
                k = a + 1,
                l = 0;
                f.faces.push(new Yb.Face3(j, k, l, [i, i, i])),
                f.uvs.push([c[a], c[a + 1], e])
            }
            return f
        }
    }),
    Yb.Torus = function() {
        var a, b, c, d, e;
        1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0]) ? (options = arguments[0], a = options.radius, b = options.tube, c = options.segmentsR, d = options.segmentsT, e = options.arc, this._id = options.id) : arguments[0] instanceof Yb.Material ? (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4], e = arguments[5]) : (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], e = arguments[4]),
        this.materialSize = 1,
        this.radius = a || 100,
        this.tube = b || 40,
        this.segmentsR = c || 8,
        this.segmentsT = d || 6,
        this.arc = e || 2 * Math.PI,
        Yb.Entity.call(this),
        this.computeNodeData(),
        this.computeCentroids()
    },
    Yb.extend(Yb.Torus, Yb.Entity, {
        __accessor: ["radius", "tube", "segmentsR", "segmentsT", "arc"],
        __SizePropeties: ["radius", "tube", "segmentsR", "segmentsT", "arc"],
        className: "TGL.Torus",
        generatePrimitiveKey: function() {
            return "torus_" + this.radius + "_" + this.tube + "_" + this.segmentsR + "_" + this.segmentsT + "_" + this.arc
        },
        computeData: function() {
            for (var a = new Yb.Vec3,
            b = [], c = [], d = {
                vertices: [],
                faces: [],
                uvs: [],
                uv2s: []
            },
            e = 0; e <= this.segmentsR; e++) for (var f = 0; f <= this.segmentsT; f++) {
                var g = f / this.segmentsT * this.arc,
                h = e / this.segmentsR * Math.PI * 2;
                a.x = this.radius * Math.cos(g),
                a.y = this.radius * Math.sin(g);
                var i = new Yb.Vec3;
                i.x = (this.radius + this.tube * Math.cos(h)) * Math.cos(g),
                i.y = (this.radius + this.tube * Math.cos(h)) * Math.sin(g),
                i.z = this.tube * Math.sin(h),
                d.vertices.push(i),
                b.push(new Yb.Vec2(f / this.segmentsT, e / this.segmentsR)),
                c.push(i.clone().sub(a).normalize())
            }
            for (var e = 1; e <= this.segmentsR; e++) for (var f = 1; f <= this.segmentsT; f++) {
                var j = (this.segmentsT + 1) * e + f - 1,
                k = (this.segmentsT + 1) * (e - 1) + f - 1,
                l = (this.segmentsT + 1) * (e - 1) + f,
                m = (this.segmentsT + 1) * e + f,
                n = new Yb.Face3(j, k, m, [c[j], c[k], c[m]]);
                n.normal.add(c[j]),
                n.normal.add(c[k]),
                n.normal.add(c[m]),
                n.normal.normalize(),
                d.faces.push(n),
                d.uvs.push([b[j].clone(), b[k].clone(), b[m].clone()]),
                n = new Yb.Face3(k, l, m, [c[k], c[l], c[m]]),
                n.normal.add(c[k]),
                n.normal.add(c[l]),
                n.normal.add(c[m]),
                n.normal.normalize(),
                d.faces.push(n),
                d.uvs.push([b[k].clone(), b[l].clone(), b[m].clone()])
            }
            return d
        }
    }),
    Yb.Arrow = function() {
        var a, b, c, d, e;
        arguments[0] instanceof Yb.Material ? (this.material = arguments[0], a = arguments[1], b = arguments[2], c = arguments[3], d = arguments[4], e = arguments[5]) : (a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[3], e = arguments[4]),
        this.materialSize = 1,
        this.tailHeight = a || 100,
        this.tailRadius = b || 20,
        this.headHeight = c || 20,
        this.headRadius = d || 30,
        this.radiusSegments = e || 30,
        this.computeData = function() {
            var f = 2;
            this.headRadius < this.tailRadius && (this.headRadius = this.tailRadius);
            var g, h, i = a + c,
            j = i / 2,
            k = [],
            l = [],
            m = [],
            n = [];
            for (h = 0; f >= h; h++) {
                var o = [],
                p = [],
                q = h / f,
                r = q * d;
                for (g = 0; e >= g; g++) {
                    var s = g / e,
                    t = new Yb.Vec3;
                    t.x = r * Math.sin(s * Math.PI * 2),
                    t.y = -q * c + j,
                    t.z = r * Math.cos(s * Math.PI * 2),
                    this.vertices.push(t),
                    o.push(this.vertices.length - 1),
                    p.push(new Yb.Vec2(s, 1 - q))
                }
                k.push(o),
                m.push(p)
            }
            for (this.vertices.push(new Yb.Vec3(0, j - c, 0)), h = 0; f >= h; h++) {
                var o = [],
                p = [],
                q = h / f,
                r = b;
                for (g = 0; e >= g; g++) {
                    var s = g / e,
                    t = new Yb.Vec3;
                    t.x = r * Math.sin(s * Math.PI * 2),
                    t.y = -q * a + j - c,
                    t.z = r * Math.cos(s * Math.PI * 2),
                    this.vertices.push(t),
                    o.push(this.vertices.length - 1),
                    p.push(new Yb.Vec2(s, 1 - q))
                }
                l.push(o),
                n.push(p)
            }
            this.vertices.push(new Yb.Vec3(0, -j, 0));
            var u, v, w = this.headRadius / i;
            for (g = 0; e > g; g++) for (u = this.vertices[k[0][g]].clone(), v = this.vertices[k[0][g + 1]].clone(), u.setY(Math.sqrt(u.x * u.x + u.z * u.z) * w).normalize(), v.setY(Math.sqrt(v.x * v.x + v.z * v.z) * w).normalize(), h = 0; f > h; h++) {
                var x = k[h][g],
                y = k[h + 1][g],
                z = k[h + 1][g + 1],
                A = k[h][g + 1],
                B = u.clone(),
                C = u.clone(),
                D = v.clone(),
                E = v.clone(),
                F = m[h][g].clone(),
                G = m[h + 1][g].clone(),
                H = m[h + 1][g + 1].clone(),
                I = m[h][g + 1].clone();
                this.faces.push(new Yb.Face3(x, y, A, [B, C, E])),
                this.uvs.push([F, G, I]),
                this.faces.push(new Yb.Face3(y, z, A, [C, D, E])),
                this.uvs.push([G, H, I])
            }
            for (g = 0; e > g; g++) {
                var x = k[h][g + 1],
                y = k[h][g],
                z = k.length - 1,
                B = new Yb.Vec3(0, -1, 0),
                C = new Yb.Vec3(0, -1, 0),
                D = new Yb.Vec3(0, -1, 0),
                F = m[h][g + 1].clone(),
                G = m[h][g].clone(),
                H = new Yb.Vec2(G.u, 1);
                this.faces.push(new Yb.Face3(x, y, z, [B, C, D])),
                this.uvs.push([F, G, H])
            }
            var u, v, w = 0;
            for (g = 0; e > g; g++) for (u = this.vertices[l[1][g]].clone(), v = this.vertices[l[1][g + 1]].clone(), u.setY(Math.sqrt(u.x * u.x + u.z * u.z) * w).normalize(), v.setY(Math.sqrt(v.x * v.x + v.z * v.z) * w).normalize(), h = 0; f > h; h++) {
                var x = l[h][g],
                y = l[h + 1][g],
                z = l[h + 1][g + 1],
                A = l[h][g + 1],
                B = u.clone(),
                C = u.clone(),
                D = v.clone(),
                E = v.clone(),
                F = m[h][g].clone(),
                G = m[h + 1][g].clone(),
                H = m[h + 1][g + 1].clone(),
                I = m[h][g + 1].clone();
                this.faces.push(new Yb.Face3(x, y, A, [B, C, E])),
                this.uvs.push([F, G, I]),
                this.faces.push(new Yb.Face3(y, z, A, [C, D, E])),
                this.uvs.push([G, H, I])
            }
            for (g = 0; e > g; g++) {
                var x = l[h][g + 1],
                y = l[h][g],
                z = l.length - 1,
                B = new Yb.Vec3(0, -1, 0),
                C = new Yb.Vec3(0, -1, 0),
                D = new Yb.Vec3(0, -1, 0),
                F = n[h][g + 1].clone(),
                G = n[h][g].clone(),
                H = new Yb.Vec2(G.u, 1);
                this.faces.push(new Yb.Face3(x, y, z, [B, C, D])),
                this.uvs.push([F, G, H])
            }
            return this
        },
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.extend(Yb.Arrow, Yb.Entity, {}),
    Yb.BufferNode = function() {
        this.uuid = Yb.Math.generateUUID(),
        this.name = "",
        this.attributes = {},
        this.dynamic = !0,
        this.offsets = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.hasTangents = !1,
        this.morphTargets = [],
        this.materialSize = 1,
        this.createMaterial(),
        Yb.Node.call(this)
    },
    Yb.extend(Yb.BufferNode, Yb.Node, {
        constructor: Yb.BufferNode,
        compuateBufferData: function() {
            if (!this.computed) {
                var a = this.attributes.position;
                a && a.array && (a.itemSize = 3, a.numItems = a.array.length, this.verticesNeedUpdate = !0);
                var b = this.attributes.uv;
                b && b.array && (b.itemSize = 2, b.numItems = b.array.length, this.uvsNeedUpdate = !0);
                var c = this.attributes.index;
                c && c.array && (this.offsets = [{
                    index: 0,
                    start: 0,
                    count: c.array.length
                }]),
                this.computed = !0
            }
        },
        applyMatrix: function(a) {
            var b, c;
            if (this.attributes.position && (b = this.attributes.position.array), this.attributes.normal && (c = this.attributes.normal.array), b !== e && (a.multiplyVec3Array(b), this.verticesNeedUpdate = !0), c !== e) {
                var d = (new Yb.Matrix3).getNormalMatrix(a);
                d.multiplyVec3Array(c),
                this.normalizeNormals(),
                this.normalsNeedUpdate = !0
            }
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Yb.BoundingBox);
            var a = this.attributes.position.array;
            if (a) {
                var b, c, d, f = this.boundingBox;
                a.length >= 3 && (f.min.x = f.max.x = a[0], f.min.y = f.max.y = a[1], f.min.z = f.max.z = a[2]);
                for (var g = 3,
                h = a.length; h > g; g += 3) b = a[g],
                c = a[g + 1],
                d = a[g + 2],
                b < f.min.x ? f.min.x = b: b > f.max.x && (f.max.x = b),
                c < f.min.y ? f.min.y = c: c > f.max.y && (f.max.y = c),
                d < f.min.z ? f.min.z = d: d > f.max.z && (f.max.z = d)
            } (a === e || 0 === a.length) && (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0))
        },
        computeBoundingSphere: function() {
            var a = new Yb.BoundingBox,
            b = new Yb.Vec3;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Yb.BoundingSphere);
                var c = this.attributes.position.array;
                if (c) {
                    for (var d = this.boundingSphere.center,
                    e = [], f = 0, g = c.length; g > f; f += 3) b.set(c[f], c[f + 1], c[f + 2]),
                    e.push(b);
                    a.setFromPoints(e),
                    a.center(d);
                    for (var h = 0,
                    f = 0,
                    g = c.length; g > f; f += 3) b.set(c[f], c[f + 1], c[f + 2]),
                    h = Math.max(h, d.distanceToSquared(b));
                    this.boundingSphere.radius = Math.sqrt(h)
                }
            }
        } (),
        computeVertexNormals: function() {
            if (this.attributes.position) {
                var a, b, c, d, f = this.attributes.position.array.length;
                if (this.attributes.normal === e) this.attributes.normal = {
                    itemSize: 3,
                    array: new Float32Array(f)
                };
                else for (a = 0, b = this.attributes.normal.array.length; b > a; a++) this.attributes.normal.array[a] = 0;
                var g, h, i, j, k, l, m = this.attributes.position.array,
                n = this.attributes.normal.array,
                o = new Yb.Vec3,
                p = new Yb.Vec3,
                q = new Yb.Vec3,
                r = new Yb.Vec3,
                s = new Yb.Vec3;
                if (this.attributes.index) {
                    var t = this.attributes.index.array,
                    u = this.offsets;
                    for (c = 0, d = u.length; d > c; ++c) {
                        var v = u[c].start,
                        w = u[c].count,
                        x = u[c].index;
                        for (a = v, b = v + w; b > a; a += 3) g = x + t[a],
                        h = x + t[a + 1],
                        i = x + t[a + 2],
                        j = m[3 * g],
                        k = m[3 * g + 1],
                        l = m[3 * g + 2],
                        o.set(j, k, l),
                        j = m[3 * h],
                        k = m[3 * h + 1],
                        l = m[3 * h + 2],
                        p.set(j, k, l),
                        j = m[3 * i],
                        k = m[3 * i + 1],
                        l = m[3 * i + 2],
                        q.set(j, k, l),
                        r.subVectors(q, p),
                        s.subVectors(o, p),
                        r.cross(s),
                        n[3 * g] += r.x,
                        n[3 * g + 1] += r.y,
                        n[3 * g + 2] += r.z,
                        n[3 * h] += r.x,
                        n[3 * h + 1] += r.y,
                        n[3 * h + 2] += r.z,
                        n[3 * i] += r.x,
                        n[3 * i + 1] += r.y,
                        n[3 * i + 2] += r.z
                    }
                } else for (a = 0, b = m.length; b > a; a += 9) j = m[a],
                k = m[a + 1],
                l = m[a + 2],
                o.set(j, k, l),
                j = m[a + 3],
                k = m[a + 4],
                l = m[a + 5],
                p.set(j, k, l),
                j = m[a + 6],
                k = m[a + 7],
                l = m[a + 8],
                q.set(j, k, l),
                r.subVectors(q, p),
                s.subVectors(o, p),
                r.cross(s),
                n[a] = r.x,
                n[a + 1] = r.y,
                n[a + 2] = r.z,
                n[a + 3] = r.x,
                n[a + 4] = r.y,
                n[a + 5] = r.z,
                n[a + 6] = r.x,
                n[a + 7] = r.y,
                n[a + 8] = r.z;
                this.normalizeNormals(),
                this.normalsNeedUpdate = !0
            }
        },
        normalizeNormals: function() {
            for (var a, b, c, d, e = this.attributes.normal.array,
            f = 0,
            g = e.length; g > f; f += 3) a = e[f],
            b = e[f + 1],
            c = e[f + 2],
            d = 1 / Math.sqrt(a * a + b * b + c * c),
            e[f] *= d,
            e[f + 1] *= d,
            e[f + 2] *= d
        },
        computeTangents: function() {
            function a(a, b, c) {
                n = d[3 * a],
                o = d[3 * a + 1],
                p = d[3 * a + 2],
                q = d[3 * b],
                r = d[3 * b + 1],
                s = d[3 * b + 2],
                t = d[3 * c],
                u = d[3 * c + 1],
                v = d[3 * c + 2],
                w = g[2 * a],
                x = g[2 * a + 1],
                y = g[2 * b],
                z = g[2 * b + 1],
                A = g[2 * c],
                B = g[2 * c + 1],
                C = q - n,
                D = t - n,
                E = r - o,
                F = u - o,
                G = s - p,
                H = v - p,
                I = y - w,
                J = A - w,
                K = z - x,
                L = B - x,
                M = 1 / (I * L - J * K),
                U.set((L * C - K * D) * M, (L * E - K * F) * M, (L * G - K * H) * M),
                V.set((I * D - J * C) * M, (I * F - J * E) * M, (I * H - J * G) * M),
                k[a].add(U),
                k[b].add(U),
                k[c].add(U),
                l[a].add(V),
                l[b].add(V),
                l[c].add(V)
            }
            function b(a) {
                da.x = f[3 * a],
                da.y = f[3 * a + 1],
                da.z = f[3 * a + 2],
                ea.copy(da),
                _ = k[a],
                ba.copy(_),
                ba.sub(da.multiplyScalar(da.dot(_))).normalize(),
                ca.crossVectors(ea, _),
                aa = ca.dot(l[a]),
                $ = 0 > aa ? -1 : 1,
                j[4 * a] = ba.x,
                j[4 * a + 1] = ba.y,
                j[4 * a + 2] = ba.z,
                j[4 * a + 3] = $
            }
            if (this.attributes.index === e || this.attributes.position === e || this.attributes.normal === e || this.attributes.uv === e) return void console.warn("Missing required attributes (index, position, normal or uv) in BufferNode.computeTangents()");
            var c = this.attributes.index.array,
            d = this.attributes.position.array,
            f = this.attributes.normal.array,
            g = this.attributes.uv.array,
            h = d.length / 3;
            if (this.attributes.tangent === e) {
                var i = 4 * h;
                this.attributes.tangent = {
                    itemSize: 4,
                    array: new Float32Array(i)
                }
            }
            for (var j = this.attributes.tangent.array,
            k = [], l = [], m = 0; h > m; m++) k[m] = new Yb.Vec3,
            l[m] = new Yb.Vec3;
            var n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U = new Yb.Vec3,
            V = new Yb.Vec3,
            W = this.offsets;
            for (P = 0, Q = W.length; Q > P; ++P) {
                var X = W[P].start,
                Y = W[P].count,
                Z = W[P].index;
                for (N = X, O = X + Y; O > N; N += 3) R = Z + c[N],
                S = Z + c[N + 1],
                T = Z + c[N + 2],
                a(R, S, T)
            }
            var $, _, aa, ba = new Yb.Vec3,
            ca = new Yb.Vec3,
            da = new Yb.Vec3,
            ea = new Yb.Vec3;
            for (P = 0, Q = W.length; Q > P; ++P) {
                var X = W[P].start,
                Y = W[P].count,
                Z = W[P].index;
                for (N = X, O = X + Y; O > N; N += 3) R = Z + c[N],
                S = Z + c[N + 1],
                T = Z + c[N + 2],
                b(R),
                b(S),
                b(T)
            }
            this.hasTangents = !0,
            this.tangentsNeedUpdate = !0
        },
        clone: function() {
            var a = new Yb.BufferNode,
            b = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            for (var c in this.attributes) {
                for (var d = this.attributes[c], e = d.array, f = {
                    itemSize: d.itemSize,
                    numItems: d.numItems,
                    array: null
                },
                g = 0, h = b.length; h > g; g++) {
                    var i = b[g];
                    if (e instanceof i) {
                        f.array = new i(e);
                        break
                    }
                }
                a.attributes[c] = f
            }
            for (var g = 0,
            h = this.offsets.length; h > g; g++) {
                var j = this.offsets[g];
                a.offsets.push({
                    start: j.start,
                    index: j.index,
                    count: j.count
                })
            }
            return a
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Yb.Particle = function(a, b) {
        var c;
        1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0]) && (c = arguments[0], this._id = c.id),
        Yb.Node.call(this, this._id),
        this.material = new Yb.ParticleMaterial({
            color: 16777215 * Math.random()
        }),
        this.sortParticles = !1,
        this.frustumCulled = !1,
        this.vertices = (c ? c.vertices: a) || [],
        this.colors = (c ? c.colors: b) || []
    },
    Yb.extend(Yb.Particle, Yb.Node, {
        clone: function(a) {
            return a === e && (a = new Yb.Particle(this.material)),
            a.sortParticles = this.sortParticles,
            a.frustumCulled = this.frustumCulled,
            Yb.Element.prototype.clone.call(this, a),
            a
        },
        needUpdate: function() {
            return ! 1
        },
        setUpdateFlags: function(a) {
            this.verticesNeedUpdate = a
        },
        setMaterialStyle: function(a, b) {
            a = a.substr(a.indexOf(".") + 1),
            this._A97(this.material, a, b)
        }
    }),
    Yb.Line = function() {
        var a, b, c;
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var d = arguments[0];
            a = d.vertices,
            b = d.colors,
            c = d.type,
            this._id = d.id || this._id
        } else a = arguments[0],
        b = arguments[1],
        c = arguments[2];
        Yb.Node.call(this, this._id),
        this.material = new Yb.LineMaterial({
            color: 16777215
        }),
        this.type = c !== e ? c: Yb.LineStrip,
        this.vertices = a || [],
        this.colors = b || []
    },
    Yb.LineStrip = 0,
    Yb.LinePieces = 1,
    Yb.extend(Yb.Line, Yb.Node, {
        className: "TGL.Line",
        __accessor: ["vertices", "type"],
        __SizePropeties: ["vertices", "type"],
        clone: function(a) {
            return a === e && (a = new Yb.Line(this.material, this.type)),
            Yb.Element.prototype.clone.call(this, a, !0),
            a
        },
        onPropertyChange: function() {},
        setMaterialStyle: function(a, b) {
            a = a.substr(a.indexOf(".") + 1),
            this._A97(this.material, a, b)
        },
        setMaterialStyles: function(a) {
            Yb.Element.prototype.setMaterialStyles.call(this, a)
        }
    }),
    Yb.Line.createEllipse = function(a, b, c, d, e, f, g) {
        "number" == typeof a ? (g = f, f = e, e = d, d = c, c = b, b = a, a = new Yb.Line) : null == a && (a = new Yb.Line);
        for (var h = new Yb.EllipseCurve(0, 0, b, c, e, f, g), i = [], j = d || 50, k = 0; j >= k; k++) {
            var l = h.getPoint(k / j);
            i.push(l)
        }
        return a.setVertices(i),
        a
    },
    Yb.Line.createHelix = function(a, b, c, d, e, f) {
        "number" == typeof a ? (f = e, e = d, d = c, c = b, b = a, a = new Yb.Line) : null == a && (a = new Yb.Line);
        var g = [],
        h = f || 50;
        e = e || 1;
        for (var i, j, k, l, m = 0; h >= m; m++) i = (c * m + b * (h - m)) / h,
        k = e * Math.PI * 2 * m / h,
        j = d * (.5 - m / h),
        l = new $b(i * Math.sin(k), j, i * Math.cos(k)),
        g.push(l);
        return a.setVertices(g),
        a
    },
    Yb.Line.createRectangle = function(a, b, c, d) {
        "number" == typeof a ? (d = c, c = b, b = a, a = new Yb.Line) : null == a && (a = new Yb.Line);
        var e = d || 50,
        f = 2 * (b + c) / e,
        g = [];
        if (f > Math.min(b, c)) g.push(new $b( - b / 2, -c / 2, 0)),
        g.push(new $b( - b / 2, c / 2, 0)),
        g.push(new $b(b / 2, c / 2, 0)),
        g.push(new $b(b / 2, -c / 2, 0)),
        g.push(new $b( - b / 2, -c / 2, 0));
        else for (var h, i = -b / 2,
        j = -c / 2,
        k = 0; e >= k; k++) i == -b / 2 && c / 2 > j ? c / 2 >= j + f ? j += f: (g.push(new $b( - b / 2, c / 2, 0)), g.push(new $b( - b / 2, c / 2, 0)), i += j + f - c / 2, j = c / 2) : j == c / 2 && b / 2 >= i ? b / 2 >= i + f ? i += f: (g.push(new $b(b / 2, c / 2, 0)), g.push(new $b(b / 2, c / 2, 0)), j -= i + f - b / 2, i = b / 2) : i == b / 2 && j > -c / 2 ? j - f >= -c / 2 ? j -= f: (g.push(new $b(b / 2, -c / 2, 0)), g.push(new $b(b / 2, -c / 2, 0)), i -= -c / 2 - j + f, j = -c / 2) : j == -c / 2 && i >= -b / 2 && (i - f >= -b / 2 ? i -= f: (j += -b / 2 - i + f, i = -b / 2)),
        h = new $b(i, j, 0),
        g.push(h);
        return a.setVertices(g),
        a
    },
    Yb.PathLine = function() {
        var a, b, c;
        if (1 === arguments.length && arguments[0] instanceof Object && !(arguments[0] instanceof Yb.Path)) {
            var d = arguments[0];
            a = d.path,
            b = d.segments,
            c = d.type,
            this._id = d.id || this._id
        } else a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        this._id = arguments[3];
        Yb.Line.call(this, {
            vertices: [],
            colors: [],
            type: c,
            id: this._id
        }),
        this.segments = b || 20,
        this.setPath(a)
    },
    Yb.extend(Yb.PathLine, Yb.Line, {
        constructor: Yb.PathNode,
        className: "TGL.PathNode",
        __accessor: ["path", "segments"],
        __SizePropeties: ["path", "segments"],
        onPropertyChange: function() {
            this.computeNodeData()
        },
        computeNodeData: function() {
            this.computeData()
        },
        adjustPath: function(a) {
            return a
        },
        computeData: function() {
            var a = this.path;
            if (a) {
                a = this.adjustPath(a);
                var b, c, d, e, f = a.curves.length,
                g = a.curves,
                h = [],
                i = a.getLength(),
                j = 0,
                k = this.segments;
                for (p = 0; f > p; p++) {
                    if (c = g[p], d = c.getLength(), c instanceof Yb.LineCurve3) {
                        var l = j / i,
                        m = (d + j) / i;
                        h.push(l),
                        h.push(m)
                    } else for (e = p > 0 ? 1 : 0; k >= e; e++) {
                        var n = (d * e / k + j) / i;
                        h.push(n)
                    }
                    j += d
                }
                for (var o = [], p = 0; p < h.length; p++) b = h[p],
                pos = a.getPointAt(b),
                o.push(pos);
                return this.vertices = o,
                []
            }
        }
    }),
    Yb.Polyhedron = function() {
        function a(a) {
            var b = a.normalize().clone();
            b.index = k.vertices.push(b) - 1;
            var c = d(a) / 2 / Math.PI + .5,
            f = e(a) / Math.PI + .5;
            return b.uv = new Yb.Vec3(c, 1 - f),
            b
        }
        function b(a, b, c) {
            var e = new Yb.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]);
            e.centroid.add(a).add(b).add(c).divideScalar(3),
            k.faces.push(e);
            var g = d(e.centroid);
            k.uvs.push([f(a.uv, a, g), f(b.uv, b, g), f(c.uv, c, g)])
        }
        function c(c, d) {
            for (var e = Math.pow(2, d), f = (Math.pow(4, d), a(k.vertices[c.a])), g = a(k.vertices[c.b]), h = a(k.vertices[c.c]), i = [], j = 0; e >= j; j++) {
                i[j] = [];
                for (var l = a(f.clone().lerp(h, j / e)), m = a(g.clone().lerp(h, j / e)), n = e - j, o = 0; n >= o; o++) 0 == o && j == e ? i[j][o] = l: i[j][o] = a(l.clone().lerp(m, o / n))
            }
            for (var j = 0; e > j; j++) for (var o = 0; 2 * (e - j) - 1 > o; o++) {
                var p = Math.floor(o / 2);
                o % 2 == 0 ? b(i[j][p + 1], i[j + 1][p], i[j][p]) : b(i[j][p + 1], i[j + 1][p + 1], i[j + 1][p])
            }
        }
        function d(a) {
            return Math.atan2(a.z, -a.x)
        }
        function e(a) {
            return Math.atan2( - a.y, Math.sqrt(a.x * a.x + a.z * a.z))
        }
        function f(a, b, c) {
            return 0 > c && 1 === a.x && (a = new Yb.Vec3(a.x - 1, a.y)),
            0 === b.x && 0 === b.z && (a = new Yb.Vec3(c / 2 / Math.PI + .5, a.y)),
            a.clone()
        }
        var g, h, i, j;
        arguments[0] instanceof Yb.Material ? (this.material = arguments[0], g = arguments[1], h = arguments[2], i = arguments[3], j = arguments[4]) : (g = arguments[0], h = arguments[1], i = arguments[2], j = arguments[3]),
        this.materialSize = 1,
        Yb.Entity.call(this),
        i = i || 1,
        j = j || 0;
        for (var k = this,
        l = 0,
        m = g.length; m > l; l++) a(new Yb.Vec3(g[l][0], g[l][1], g[l][2]));
        for (var n = this.vertices,
        o = [], l = 0, m = h.length; m > l; l++) {
            var p = n[h[l][0]],
            q = n[h[l][1]],
            r = n[h[l][2]];
            o[l] = new Yb.Face3(p.index, q.index, r.index, [p.clone(), q.clone(), r.clone()])
        }
        for (var l = 0,
        m = o.length; m > l; l++) c(o[l], j);
        for (var l = 0,
        m = this.uvs.length; m > l; l++) {
            var s = this.uvs[l],
            t = s[0].x,
            u = s[1].x,
            v = s[2].x,
            w = Math.max(t, Math.max(u, v)),
            x = Math.min(t, Math.min(u, v));
            w > .9 && .1 > x && (.2 > t && (s[0].x += 1), .2 > u && (s[1].x += 1), .2 > v && (s[2].x += 1))
        }
        for (var l = 0,
        m = this.vertices.length; m > l; l++) this.vertices[l].multiplyScalar(i);
        this.mergeVertices(),
        this.computeCentroids(),
        this.computeFaceNormals(),
        this.boundingSphere = new Yb.BoundingSphere(new Yb.Vec3, i)
    },
    Yb.extend(Yb.Polyhedron, Yb.Entity, {}),
    Yb.Octahedron = function(a, b, c) {
        var d = [[1, 0, 0], [ - 1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]],
        e = [[0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2], [1, 2, 5], [1, 5, 3], [1, 3, 4], [1, 4, 2]];
        Yb.Polyhedron.call(this, a, d, e, b, c)
    },
    Yb.extend(Yb.Octahedron, Yb.Polyhedron, {
        clone: function() {
            return new Yb.Octahedron(this.material, this.radius, this.detail)
        }
    }),
    Yb.Axis = function(a) {
        a = a || 1;
        var b = [],
        c = [];
        b.push(new Yb.Vec3, new Yb.Vec3(a, 0, 0), new Yb.Vec3, new Yb.Vec3(0, a, 0), new Yb.Vec3, new Yb.Vec3(0, 0, a)),
        c.push(new Yb.Color(16711680), new Yb.Color(16711680), new Yb.Color(65280), new Yb.Color(65280), new Yb.Color(255), new Yb.Color(255));
        var d = new Yb.LineMaterial({
            vertexColors: Yb.VertexColors,
            depthTest: !1,
            depthMask: !1
        });
        Yb.Line.call(this, b, c, Yb.LinePieces),
        this.material = d,
        this.xAxisText = this.makeAxisText("X", 16711680),
        this.yAxisText = this.makeAxisText("Y", 65280),
        this.zAxisText = this.makeAxisText("Z", 255),
        this.xAxisText.setParent(this),
        this.yAxisText.setParent(this),
        this.zAxisText.setParent(this),
        this.setSize(a),
        this._sizeFixed = !0
    },
    Yb.extend(Yb.Axis, Yb.Line, {
        showAxisText: function(a) {
            this.xAxisText._visible = a,
            this.yAxisText._visible = a,
            this.zAxisText._visible = a
        },
        setSize: function(a) {
            this.vertices[1].x = a,
            this.vertices[3].y = a,
            this.vertices[5].z = a,
            this.xAxisText.setPosition(a, 0, 0),
            this.yAxisText.setPosition(0, a, 0),
            this.zAxisText.setPosition(0, 0, a)
        },
        fixSize: function(a) {
            Yb.Element.prototype.fixSize.call(this, a),
            this._scale.x,
            this._scale.y,
            this._scale.z,
            this.xAxisText.setScale(3, 3, 1),
            this.yAxisText.setScale(3, 3, 1),
            this.zAxisText.setScale(3, 3, 1)
        },
        makeAxisText: function(a, b) {
            var c = "Arial",
            d = 36,
            e = Yb.BillboardAlignment.topLeft,
            f = document.createElement("canvas"),
            g = f.getContext("2d");
            g.font = "Bold " + d + "px " + c,
            b instanceof Yb.Color || (b = new Yb.Color(b));
            var h = g.measureText(a),
            i = h.width;
            f.width = tc.nextPowerOfTwo(i),
            f.height = tc.nextPowerOfTwo(2 * g.measureText("e").width + 4),
            g.fillStyle = "rgba(" + 255 * b.r + ", " + 255 * b.g + ", " + 255 * b.b + ", 1.0)",
            g.fillText(a, 0, 10);
            var j = new Yb.Texture(f),
            k = new Yb.BillboardMaterial({
                map: j,
                useScreenCoordinates: !1,
                alignment: e,
                depthTest: !1,
                depthMask: !1
            }),
            l = new Yb.Billboard;
            return l.material = k,
            l
        }
    }),
    Yb.Curve = function() {},
    Yb.Curve.prototype.getPoint = function(a) {
        return console.log("Warning, getPoint() not implemented!"),
        null
    },
    Yb.Curve.prototype.getPointAt = function(a) {
        var b = this.getUtoTmapping(a);
        return this.getPoint(b)
    },
    Yb.Curve.prototype.getPoints = function(a) {
        a || (a = 5);
        var b, c = [];
        for (b = 0; a >= b; b++) c.push(this.getPoint(b / a));
        return c
    },
    Yb.Curve.prototype.getSpacedPoints = function(a) {
        a || (a = 5);
        var b, c = [];
        for (b = 0; a >= b; b++) c.push(this.getPointAt(b / a));
        return c
    },
    Yb.Curve.prototype.getLength = function() {
        var a = this.getLengths();
        return a[a.length - 1]
    },
    Yb.Curve.prototype.getLengths = function(a) {
        if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions: 200), this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var b, c, d = [],
        e = this.getPoint(0),
        f = 0;
        for (d.push(0), c = 1; a >= c; c++) b = this.getPoint(c / a),
        f += b.distanceTo(e),
        d.push(f),
        e = b;
        return this.cacheArcLengths = d,
        d
    },
    Yb.Curve.prototype.updateArcLengths = function() {
        this.needsUpdate = !0,
        this.getLengths()
    },
    Yb.Curve.prototype.getUtoTmapping = function(a, b) {
        var c, d = this.getLengths(),
        e = 0,
        f = d.length;
        c = b ? b: a * d[f - 1];
        for (var g, h = 0,
        i = f - 1; i >= h;) if (e = Math.floor(h + (i - h) / 2), g = d[e] - c, 0 > g) h = e + 1;
        else {
            if (! (g > 0)) {
                i = e;
                break
            }
            i = e - 1
        }
        if (e = i, d[e] == c) {
            var j = e / (f - 1);
            return j
        }
        var k = d[e],
        l = d[e + 1],
        m = l - k,
        n = (c - k) / m,
        j = (e + n) / (f - 1);
        return j
    },
    Yb.Curve.prototype.getTangent = function(a) {
        var b = 1e-4,
        c = a - b,
        d = a + b;
        0 > c && (c = 0),
        d > 1 && (d = 1);
        var e = this.getPoint(c),
        f = this.getPoint(d),
        g = f.clone().sub(e);
        return g.normalize()
    },
    Yb.Curve.prototype.getTangentAt = function(a) {
        var b = this.getUtoTmapping(a);
        return this.getTangent(b)
    },
    Yb.Curve.Utils = {
        tangentQuadraticBezier: function(a, b, c, d) {
            return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
        },
        tangentCubicBezier: function(a, b, c, d, e) {
            return - 3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
        },
        tangentSpline: function(a, b, c, d, e) {
            var f = 6 * a * a - 6 * a,
            g = 3 * a * a - 4 * a + 1,
            h = -6 * a * a + 6 * a,
            i = 3 * a * a - 2 * a;
            return f + g + h + i
        },
        interpolate: function(a, b, c, d, e) {
            var f = .5 * (c - a),
            g = .5 * (d - b),
            h = e * e,
            i = e * h;
            return (2 * b - 2 * c + f + g) * i + ( - 3 * b + 3 * c - 2 * f - g) * h + f * e + b
        }
    },
    Yb.Curve.create = function(a, b) {
        return a.prototype = Object.create(Yb.Curve.prototype),
        a.prototype.getPoint = b,
        a
    },
    Yb.LineCurve = function(a, b) {
        this.v1 = a,
        this.v2 = b
    },
    Yb.LineCurve.prototype = Object.create(Yb.Curve.prototype),
    Yb.LineCurve.prototype.getPoint = function(a) {
        var b = this.v2.clone().sub(this.v1);
        return b.multiplyScalar(a).add(this.v1),
        b
    },
    Yb.LineCurve.prototype.getPointAt = function(a) {
        return this.getPoint(a)
    },
    Yb.LineCurve.prototype.getTangent = function(a) {
        var b = this.v2.clone().sub(this.v1);
        return b.normalize()
    },
    Yb.LineCurve3 = function(a, b) {
        this.v1 = a,
        this.v2 = b,
        this.getPoint = function(a) {
            var b = new Yb.Vec3;
            return b.subVectors(this.v2, this.v1),
            b.multiplyScalar(a),
            b.add(this.v1),
            b
        }
    },
    Yb.extend(Yb.LineCurve3, Yb.Curve, {}),
    Yb.CurvePath = function() {
        this.curves = [],
        this.bends = [],
        this.autoClose = !1
    },
    Yb.CurvePath.prototype = Object.create(Yb.Curve.prototype),
    Yb.CurvePath.prototype.add = function(a) {
        this.curves.push(a)
    },
    Yb.CurvePath.prototype.checkConnection = function() {},
    Yb.CurvePath.prototype.closePath = function() {
        var a = this.curves[0].getPoint(0),
        b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.curves.push(new Yb.LineCurve3(b, a))
    },
    Yb.CurvePath.prototype.getPoint = function(a) {
        for (var b, c, d = a * this.getLength(), e = this.getCurveLengths(), f = 0; f < e.length;) {
            if (e[f] >= d) {
                b = e[f] - d,
                c = this.curves[f];
                var g = 1 - b / c.getLength();
                return c.getPointAt(g)
            }
            f++
        }
        return null
    },
    Yb.CurvePath.prototype.getLength = function() {
        var a = this.getCurveLengths();
        return a[a.length - 1]
    },
    Yb.CurvePath.prototype.getCurveLengths = function() {
        if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
        var a, b = [],
        c = 0,
        d = this.curves.length;
        for (a = 0; d > a; a++) c += this.curves[a].getLength(),
        b.push(c);
        return this.cacheLengths = b,
        b
    },
    Yb.CurvePath.prototype.getBoundingBox = function() {
        var a, b, c, d, e, f, g = this.getPoints();
        a = b = Number.NEGATIVE_INFINITY,
        d = e = Number.POSITIVE_INFINITY;
        var h, i, j, k, l = g[0] instanceof Yb.Vec3;
        for (k = l ? new Yb.Vec3: new Yb.Vec2, i = 0, j = g.length; j > i; i++) h = g[i],
        h.x > a ? a = h.x: h.x < d && (d = h.x),
        h.y > b ? b = h.y: h.y < e && (e = h.y),
        l && (h.z > c ? c = h.z: h.z < f && (f = h.z)),
        k.add(h);
        var m = {
            minX: d,
            minY: e,
            maxX: a,
            maxY: b,
            centroid: k.divideScalar(j)
        };
        return l && (m.maxZ = c, m.minZ = f),
        m
    },
    Yb.CurvePath.prototype.createPointsGeometry = function(a) {
        var b = this.getPoints(a, !0);
        return this.createGeometry(b)
    },
    Yb.CurvePath.prototype.createSpacedPointsGeometry = function(a) {
        var b = this.getSpacedPoints(a, !0);
        return this.createGeometry(b)
    },
    Yb.CurvePath.prototype.createGeometry = function(a) {
        for (var b = new Yb.Geometry,
        c = 0; c < a.length; c++) b.vertices.push(new Yb.Vec3(a[c].x, a[c].y, a[c].z || 0));
        return b
    },
    Yb.CurvePath.prototype.addWrapPath = function(a) {
        this.bends.push(a)
    },
    Yb.CurvePath.prototype.getTransformedPoints = function(a, b) {
        var c, d, e = this.getPoints(a);
        for (b || (b = this.bends), c = 0, d = b.length; d > c; c++) e = this.getWrapPoints(e, b[c]);
        return e
    },
    Yb.CurvePath.prototype.getTransformedSpacedPoints = function(a, b) {
        var c, d, e = this.getSpacedPoints(a);
        for (b || (b = this.bends), c = 0, d = b.length; d > c; c++) e = this.getWrapPoints(e, b[c]);
        return e
    },
    Yb.CurvePath.prototype.getWrapPoints = function(a, b) {
        var c, d, e, f, g, h, i = this.getBoundingBox();
        for (c = 0, d = a.length; d > c; c++) {
            e = a[c],
            f = e.x,
            g = e.y,
            h = f / i.maxX,
            h = b.getUtoTmapping(h, f);
            var j = b.getPoint(h),
            k = b.getTangent(h);
            k.set( - k.y, k.x).multiplyScalar(g),
            e.x = j.x + k.x,
            e.y = j.y + k.y
        }
        return a
    },
    Yb.EllipseCurve = function(a, b, c, d, e, f, g) {
        this.aX = a,
        this.aY = b,
        this.xRadius = c,
        this.yRadius = d,
        this.aStartAngle = e || 0,
        this.aEndAngle = f || 2 * Math.PI,
        this.aClockwise = g
    },
    Yb.EllipseCurve.prototype = Object.create(Yb.Curve.prototype),
    Yb.EllipseCurve.prototype.getPoint = function(a) {
        var b, c = this.aEndAngle - this.aStartAngle;
        0 > c && (c += 2 * Math.PI),
        c > 2 * Math.PI && (c -= 2 * Math.PI),
        b = this.aClockwise === !0 ? this.aEndAngle + (1 - a) * (2 * Math.PI - c) : this.aStartAngle + a * c;
        var d = this.aX + this.xRadius * Math.cos(b),
        e = this.aY + this.yRadius * Math.sin(b);
        return new Yb.Vec3(d, e, 0)
    },
    Yb.ArcCurve = function(a, b, c, d, e, f) {
        Yb.EllipseCurve.call(this, a, b, c, c, d, e, f)
    },
    Yb.ArcCurve.prototype = Object.create(Yb.EllipseCurve.prototype),
    Yb.Path = function(a) {
        Yb.CurvePath.call(this),
        this.actions = [],
        this.points = [],
        a && this.fromPoints(a)
    },
    Yb.extend(Yb.Path, Yb.CurvePath, {
        constructor: Yb.Path,
        className: "TGL.Path",
        serializeJsonValue: function() {
            return {
                actions: this.actions,
                "class": "TGL.Path"
            }
        },
        deserializeJsonValue: function(a) {
            var b, c, d, e;
            for (e = 0; e < a.actions.length; e++) c = a.actions[e],
            b = c.action,
            d = c.args,
            this[b].apply(this, d)
        }
    }),
    Yb.PathActions = {
        MOVE_TO: "moveTo",
        LINE_TO: "lineTo",
        QUADRATIC_CURVE_TO: "curveTo",
        BEZIER_CURVE_TO: "bCurveTo",
        CSPLINE_THRU: "splineThru",
        ARC: "arc",
        ELLIPSE: "ellipse"
    },
    Yb.Path.prototype.fromPoints = function(a) {
        this.moveTo(a[0].x, a[0].y, a[0].z);
        for (var b = 1,
        c = a.length; c > b; b++) this.lineTo(a[b].x, a[b].y, a[b].z)
    },
    Yb.Path.prototype.closePath = function() {
        var a = this.curves[0].getPoint(0),
        b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.lineTo(a.x, a.y, a.z)
    },
    Yb.Path.prototype.reverse = function() {
        var a, b, c, d, e, f = new Yb.Path,
        g = this.actions.length;
        for (a = g - 1; a >= 0; a--) {
            if (b = this.actions[a].args, c = b.length, a === g - 1 && f.moveTo(b[c - 3], b[c - 2], b[c - 1]), null != d) switch (e) {
            case Yb.PathActions.MOVE_TO:
                f.moveTo(b[c - 3], b[c - 2], b[c - 1]);
                break;
            case Yb.PathActions.LINE_TO:
                f.lineTo(b[c - 3], b[c - 2], b[c - 1]);
                break;
            case Yb.PathActions.QUADRATIC_CURVE_TO:
                f.quadraticCurveTo(d[0], d[1], d[2], b[c - 3], b[c - 2], b[c - 1]);
                break;
            case Yb.PathActions.BEZIER_CURVE_TO:
                f.bezierCurveTo(d[3], d[4], d[5], d[0], d[1], d[2], b[c - 3], b[c - 2], b[c - 1])
            }
            d = b,
            e = this.actions[a].action
        }
        return f
    },
    Yb.Path.prototype.moveTo = function(a, b, c) {
        a = a || 0,
        b = b || 0,
        c = c || 0;
        var d = Array.prototype.slice.call(arguments);
        this.actions.push({
            action: Yb.PathActions.MOVE_TO,
            args: d
        }),
        this.points.push(new $b(a, b, c))
    },
    Yb.Path.prototype.lineTo = function(a, b, c) {
        if (a = a || 0, b = b || 0, c = c || 0, this.actions && 1 === this.actions.length) {
            var d = this.actions[0].args;
            d[0] === a && d[1] === b && d[2] === c && (console.log("TGL.Path:lineTo the same point of moveTo"), a += .01)
        }
        var d = Array.prototype.slice.call(arguments),
        e = this.actions[this.actions.length - 1].args,
        f = e[e.length - 3],
        g = e[e.length - 2],
        h = e[e.length - 1],
        i = new Yb.LineCurve3(new Yb.Vec3(f, g, h), new Yb.Vec3(a, b, c));
        this.curves.push(i),
        this.actions.push({
            action: Yb.PathActions.LINE_TO,
            args: d
        }),
        this.points.push(new $b(a, b, c))
    },
    Yb.Path.prototype.quadraticCurveTo = function(a, b, c, d, e, f) {
        if (a = a || 0, b = b || 0, c = c || 0, d = d || 0, e = e || 0, f = f || 0, this.actions && 1 === this.actions.length) {
            var g = this.actions[0].args;
            g[0] === d && g[1] === e && g[2] === f && (console.log("TGL.Path:quadraticCurveTo the same point of moveTo"), d = .01)
        }
        var g = Array.prototype.slice.call(arguments),
        h = this.actions[this.actions.length - 1].args,
        i = h[h.length - 3],
        j = h[h.length - 2],
        k = h[h.length - 1],
        l = new Yb.QuadraticBezierCurve3(new Yb.Vec3(i, j, k), new Yb.Vec3(a, b, c), new Yb.Vec3(d, e, f));
        this.curves.push(l),
        this.actions.push({
            action: Yb.PathActions.QUADRATIC_CURVE_TO,
            args: g
        }),
        this.points.push(new $b(d, e, f))
    },
    Yb.Path.prototype.curveTo = Yb.Path.prototype.quadraticCurveTo,
    Yb.Path.prototype.bezierCurveTo = function(a, b, c, d, e, f, g, h, i) {
        var j = Array.prototype.slice.call(arguments),
        k = this.actions[this.actions.length - 1].args,
        l = k[k.length - 3],
        m = k[k.length - 2],
        n = k[k.length - 1],
        o = new Yb.CubicBezierCurve3(new Yb.Vec3(l, m, n), new Yb.Vec3(a, b, c), new Yb.Vec3(d, e, f), new Yb.Vec3(g, h, i));
        this.curves.push(o),
        this.actions.push({
            action: Yb.PathActions.BEZIER_CURVE_TO,
            args: j
        }),
        this.points.push(new $b(g, h, i))
    },
    Yb.Path.prototype.isClockwise = function() {
        if (this.points.length < 2) return e;
        if (this.points.length < 3) {
            var a = this.points[0],
            b = this.points[1];
            return b.x > a.x
        }
        return Yb.Math.isClockwise(this.points)
    },
    Yb.Path.prototype.bCurveTo = Yb.Path.prototype.bezierCurveTo,
    Yb.Path.prototype.splineThru = function(a) {
        var b = Array.prototype.slice.call(arguments),
        c = this.actions[this.actions.length - 1].args,
        d = c[c.length - 2],
        e = c[c.length - 1],
        f = [new Yb.Vec2(d, e)];
        Array.prototype.push.apply(f, a);
        var g = new Yb.SplineCurve(f);
        this.curves.push(g),
        this.actions.push({
            action: Yb.PathActions.CSPLINE_THRU,
            args: b
        })
    },
    Yb.Path.prototype.arc = function(a, b, c, d, e, f) {
        var g = this.actions[this.actions.length - 1].args,
        h = g[g.length - 2],
        i = g[g.length - 1];
        this.absarc(a + h, b + i, c, d, e, f)
    },
    Yb.Path.prototype.absarc = function(a, b, c, d, e, f) {
        this.absellipse(a, b, c, c, d, e, f)
    },
    Yb.Path.prototype.ellipse = function(a, b, c, d, e, f, g) {
        var h = this.actions[this.actions.length - 1].args,
        i = h[h.length - 2],
        j = h[h.length - 1];
        this.absellipse(a + i, b + j, c, d, e, f, g)
    },
    Yb.Path.prototype.absellipse = function(a, b, c, d, e, f, g) {
        var h = Array.prototype.slice.call(arguments),
        i = new Yb.EllipseCurve(a, b, c, d, e, f, g);
        this.curves.push(i);
        var j = i.getPoint(1);
        h.push(j.x),
        h.push(j.y),
        this.actions.push({
            action: Yb.PathActions.ELLIPSE,
            args: h
        })
    },
    Yb.Path.prototype.toArray = function() {
        var a, b = this.actions.length,
        c = [];
        for (a = 0; b > a; a++) {
            var d = this.actions[a];
            "moveTo" === d.action ? (c.push("m"), c.push(d.args[0]), c.push(d.args[1]), c.push(d.args[2])) : "lineTo" === d.action ? (c.push("l"), c.push(d.args[0]), c.push(d.args[1]), c.push(d.args[2])) : "curveTo" === d.action && (c.push("c"), c.push(d.args[0]), c.push(d.args[1]), c.push(d.args[2]), c.push(d.args[3]), c.push(d.args[4]), c.push(d.args[5]))
        }
        return c
    },
    Yb.Path.prototype.getSpacedPoints = function(a, b) {
        a || (a = 40);
        for (var c = [], d = 0; a > d; d++) c.push(this.getPoint(d / a));
        return c
    },
    Yb.Path.prototype.getPoints = function(a, b) {
        if (this.useSpacedPoints) return console.log("tata"),
        this.getSpacedPoints(a, b);
        a = a || 12;
        var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = [];
        for (c = 0, d = this.actions.length; d > c; c++) switch (e = this.actions[c], f = e.action, g = e.args, f) {
        case Yb.PathActions.MOVE_TO:
            y.push(new Yb.Vec3(g[0], g[1], g[2]));
            break;
        case Yb.PathActions.LINE_TO:
            y.push(new Yb.Vec3(g[0], g[1], g[2]));
            break;
        case Yb.PathActions.QUADRATIC_CURVE_TO:
            for (h = g[3], i = g[4], j = g[5], n = g[0], o = g[1], p = g[2], y.length > 0 ? (t = y[y.length - 1], q = t.x, r = t.y, s = t.z) : (t = this.actions[c - 1].args, q = t[t.length - 3], r = t[t.length - 2], s = t[t.length - 1]), u = 1; a >= u; u++) v = u / a,
            w = Yb.Shape.Utils.b2(v, q, n, h),
            x = Yb.Shape.Utils.b2(v, r, o, i),
            tz = Yb.Shape.Utils.b2(v, s, p, j),
            y.push(new Yb.Vec3(w, x, tz));
            break;
        case Yb.PathActions.BEZIER_CURVE_TO:
            for (h = g[6], i = g[7], j = g[8], n = g[0], o = g[1], p = g[2], k = g[3], l = g[4], m = g[5], y.length > 0 ? (t = y[y.length - 1], q = t.x, r = t.y, s = t.z) : (t = this.actions[c - 1].args, q = t[t.length - 3], r = t[t.length - 2], s = t[t.length - 1]), u = 1; a >= u; u++) v = u / a,
            w = Yb.Shape.Utils.b3(v, q, n, k, h),
            x = Yb.Shape.Utils.b3(v, r, o, l, i),
            tz = Yb.Shape.Utils.b3(v, s, p, m, j),
            y.push(new Yb.Vec3(w, x, tz));
            break;
        case Yb.PathActions.CSPLINE_THRU:
            t = this.actions[c - 1].args;
            var z = new Yb.Vec2(t[t.length - 2], t[t.length - 1]),
            A = [z],
            B = a * g[0].length;
            A = A.concat(g[0]);
            var C = new Yb.SplineCurve(A);
            for (u = 1; B >= u; u++) y.push(C.getPointAt(u / B));
            break;
        case Yb.PathActions.ARC:
            var D, E = g[0],
            F = g[1],
            G = g[2],
            H = g[3],
            I = g[4],
            J = !!g[5],
            K = I - H,
            L = 2 * a;
            for (u = 1; L >= u; u++) v = u / L,
            J || (v = 1 - v),
            D = H + v * K,
            w = E + G * Math.cos(D),
            x = F + G * Math.sin(D),
            y.push(new Yb.Vec3(w, x));
            break;
        case Yb.PathActions.ELLIPSE:
            var D, E = g[0],
            F = g[1],
            M = g[2],
            N = g[3],
            H = g[4],
            I = g[5],
            J = !!g[6],
            K = I - H,
            L = 2 * a;
            for (u = 1; L >= u; u++) v = u / L,
            J || (v = 1 - v),
            D = H + v * K,
            w = E + M * Math.cos(D),
            x = F + N * Math.sin(D),
            y.push(new Yb.Vec3(w, x))
        }
        var O = y[y.length - 1],
        P = 1e-10;
        return Math.abs(O.x - y[0].x) < P && Math.abs(O.y - y[0].y) < P && y.splice(y.length - 1, 1),
        b && y.push(y[0]),
        y
    },
    Yb.Path.prototype.toShapes = function(a) {
        var b, c, d, f, g, h = [],
        i = new Yb.Path;
        for (b = 0, c = this.actions.length; c > b; b++) d = this.actions[b],
        g = d.args,
        f = d.action,
        f == Yb.PathActions.MOVE_TO && 0 != i.actions.length && (h.push(i), i = new Yb.Path),
        i[f].apply(i, g);
        if (0 != i.actions.length && h.push(i), 0 == h.length) return [];
        var j, k, l, m = [];
        if (1 == h.length) return k = h[0],
        l = new Yb.Shape,
        l.actions = k.actions,
        l.curves = k.curves,
        m.push(l),
        m;
        var n = !Yb.Shape.Utils.isClockWise(h[0].getPoints());
        if (n = a ? !n: n) for (l = new Yb.Shape, b = 0, c = h.length; c > b; b++) k = h[b],
        j = Yb.Shape.Utils.isClockWise(k.getPoints()),
        j = a ? !j: j,
        j ? (l.actions = k.actions, l.curves = k.curves, m.push(l), l = new Yb.Shape) : l.holes.push(k);
        else {
            for (l = e, b = 0, c = h.length; c > b; b++) k = h[b],
            j = Yb.Shape.Utils.isClockWise(k.getPoints()),
            j = a ? !j: j,
            j ? (l && m.push(l), l = new Yb.Shape, l.actions = k.actions, l.curves = k.curves) : l.holes.push(k);
            m.push(l)
        }
        return m
    },
    Yb.Shape = function() {
        Yb.Path.apply(this, arguments),
        this.holes = []
    },
    Yb.Shape.prototype = Object.create(Yb.Path.prototype),
    Yb.Shape.prototype.extrude = function(a) {
        var b = new Yb.ShapeNode(this, a);
        return b
    },
    Yb.Shape.prototype.makeGeometry = function(a) {
        var b = new Yb.ShapeGeometry(this, a);
        return b
    },
    Yb.Shape.prototype.getPointsHoles = function(a) {
        var b, c = this.holes.length,
        d = [];
        for (b = 0; c > b; b++) d[b] = this.holes[b].getTransformedPoints(a, this.bends);
        return d
    },
    Yb.Shape.prototype.getSpacedPointsHoles = function(a) {
        var b, c = this.holes.length,
        d = [];
        for (b = 0; c > b; b++) d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
        return d
    },
    Yb.Shape.prototype.extractAllPoints = function(a) {
        return {
            shape: this.getTransformedPoints(a),
            holes: this.getPointsHoles(a)
        }
    },
    Yb.Shape.prototype.extractPoints = function(a) {
        return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a)
    },
    Yb.Shape.prototype.extractAllSpacedPoints = function(a) {
        return {
            shape: this.getTransformedSpacedPoints(a),
            holes: this.getSpacedPointsHoles(a)
        }
    },
    Yb.Shape.Utils = {
        removeHoles: function(a, b) {
            var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = a.concat(),
            t = s.concat(),
            u = [];
            for (g = 0; g < b.length; g++) {
                for (i = b[g], Array.prototype.push.apply(t, i), j = Number.POSITIVE_INFINITY, h = 0; h < i.length; h++) {
                    m = i[h];
                    var v = [];
                    for (l = 0; l < s.length; l++) n = s[l],
                    k = m.distanceToSquared(n),
                    v.push(k),
                    j > k && (j = k, e = h, f = l)
                }
                c = f - 1 >= 0 ? f - 1 : s.length - 1,
                d = e - 1 >= 0 ? e - 1 : i.length - 1;
                var w = [i[e], s[f], s[c]],
                x = Yb.FontUtils.Triangulate.area(w),
                y = [i[e], i[d], s[f]],
                z = Yb.FontUtils.Triangulate.area(y),
                A = 1,
                B = -1,
                C = f,
                D = e;
                f += A,
                e += B,
                0 > f && (f += s.length),
                f %= s.length,
                0 > e && (e += i.length),
                e %= i.length,
                c = f - 1 >= 0 ? f - 1 : s.length - 1,
                d = e - 1 >= 0 ? e - 1 : i.length - 1,
                w = [i[e], s[f], s[c]];
                var E = Yb.FontUtils.Triangulate.area(w);
                y = [i[e], i[d], s[f]];
                var F = Yb.FontUtils.Triangulate.area(y);
                x + z > E + F && (f = C, e = D, 0 > f && (f += s.length), f %= s.length, 0 > e && (e += i.length), e %= i.length, c = f - 1 >= 0 ? f - 1 : s.length - 1, d = e - 1 >= 0 ? e - 1 : i.length - 1),
                o = s.slice(0, f),
                p = s.slice(f),
                q = i.slice(e),
                r = i.slice(0, e);
                var G = [i[e], s[f], s[c]],
                H = [i[e], i[d], s[f]];
                u.push(G),
                u.push(H),
                s = o.concat(q).concat(r).concat(p)
            }
            return {
                shape: s,
                isolatedPts: u,
                allpoints: t
            }
        },
        triangulateShape: function(a, b) {
            var c, d, f, g, h, i, j = Yb.Shape.Utils.removeHoles(a, b),
            k = j.shape,
            l = j.allpoints,
            m = j.isolatedPts,
            n = Yb.FontUtils.Triangulate(k, !1),
            o = {};
            for (c = 0, d = l.length; d > c; c++) h = l[c].x + ":" + l[c].y,
            o[h] !== e && console.log("Duplicate point", h),
            o[h] = c;
            for (c = 0, d = n.length; d > c; c++) for (g = n[c], f = 0; 3 > f; f++) h = g[f].x + ":" + g[f].y,
            i = o[h],
            i !== e && (g[f] = i);
            for (c = 0, d = m.length; d > c; c++) for (g = m[c], f = 0; 3 > f; f++) h = g[f].x + ":" + g[f].y,
            i = o[h],
            i !== e && (g[f] = i);
            return n.concat(m)
        },
        isClockWise: function(a) {
            return Yb.FontUtils.Triangulate.area(a) < 0
        },
        b2p0: function(a, b) {
            var c = 1 - a;
            return c * c * b
        },
        b2p1: function(a, b) {
            return 2 * (1 - a) * a * b
        },
        b2p2: function(a, b) {
            return a * a * b
        },
        b2: function(a, b, c, d) {
            return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d)
        },
        b3p0: function(a, b) {
            var c = 1 - a;
            return c * c * c * b
        },
        b3p1: function(a, b) {
            var c = 1 - a;
            return 3 * c * c * a * b
        },
        b3p2: function(a, b) {
            var c = 1 - a;
            return 3 * c * a * a * b
        },
        b3p3: function(a, b) {
            return a * a * a * b
        },
        b3: function(a, b, c, d, e) {
            return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e)
        }
    },
    Yb.CubicBezierCurve3 = Yb.Curve.create(function(a, b, c, d) {
        this.v0 = a,
        this.v1 = b,
        this.v2 = c,
        this.v3 = d
    },
    function(a) {
        var b, c, d;
        return b = Yb.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x),
        c = Yb.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y),
        d = Yb.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z),
        new Yb.Vec3(b, c, d)
    }),
    Yb.QuadraticBezierCurve3 = Yb.Curve.create(function(a, b, c) {
        this.v0 = a,
        this.v1 = b,
        this.v2 = c
    },
    function(a) {
        var b, c, d;
        return b = Yb.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x),
        c = Yb.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y),
        d = Yb.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z),
        new Yb.Vec3(b, c, d)
    }),
    Yb.PathNode = function(a, b, c, d, f, g, h, i, j, k) {
        this.materialSize = 1,
        this.closed = !1;
        var l;
        1 === arguments.length && arguments[0] instanceof Object && !(arguments[0] instanceof Yb.Path) ? (l = arguments[0], this.path = l.path, this.segments = l.segments || 20, this.radius = l.radius || 1, this.segmentsR = l.segmentsR || 8, this.shape = l.shape, this.startCap = l.startCap || "plain", this.endCap = l.endCap || "plain", this.arc = l.arc != e ? l.arc: 2 * Math.PI, this.arcStart = l.arcStart != e ? l.arcStart: 0, this.cutSurface = l.cutSurface || "none", this.startCapR = l.startCapR, this.endCapR = l.endCapR, this.startCapSize = l.startCapSize, this.endCapSize = l.endCapSize, this.startCapExtend = l.startCapExtend === e ? 1 : l.startCapExtend, this.endCapExtend = l.endCapExtend === e ? 1 : l.endCapExtend, this._id = l.id) : (this.path = a, this.segments = b || 20, this.radius = c || 1, this.segmentsR = d || 8, this.shape = h, this.startCap = f || "plain", this.endCap = g || "plain", this.arc = i != e ? i: 2 * Math.PI, this.arcStart = j != e ? j: 0, this.cutSurface = k || "none"),
        this.shape instanceof Array && (this.segmentsR = this.shape.length),
        this.startCapSize = this.startCapSize || 1,
        this.endCapSize = this.endCapSize || 1,
        this.segmentsCap = 20,
        this.arc === 2 * Math.PI && (this.cutSurface = "none"),
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.extend(Yb.PathNode, Yb.Entity, {
        constructor: Yb.PathNode,
        className: "TGL.PathNode",
        __accessor: ["path", "segments", "radius", "segmentsR", "startCap", "endCap", "shape", "startCapSize", "endCapSize", "segmentsCap", "arc", "arcStart", "cutSurface", "startCapR", "endCapR", "startCapExtend", "endCapExtend"],
        __SizePropeties: ["path", "segments", "radius", "segmentsR", "startCap", "endCap", "shape", "startCapSize", "endCapSize", "segmentsCap", "arc", "arcStart", "cutSurface", "startCapR", "endCapR", "startCapExtend", "endCapExtend"],
        getCrossSectionPoint: function() {},
        needComputeVertexNormal: function() {
            return ! 0
        },
        adjustPath: function(a, b, c) {
            b = b || this.radius,
            c = c || 1;
            var d, e, f, g, h, i, j, k, l, m, n, o, p = new Yb.Path,
            q = new $b,
            r = new $b,
            s = new $b,
            t = new $b,
            u = a.actions.length;
            for (o = 0; u > o; o++) f = a.actions[o],
            h = o + 1 === u ? null: a.actions[o + 1],
            g = f.args,
            "moveTo" === f.action ? p.moveTo(g[0], g[1], g[2]) : "lineTo" === f.action ? h && "lineTo" === h.action ? (d = a.actions[o - 1], e = d.args, i = h.args, j = new $b(e[0], e[1], e[2]), k = new $b(g[0], g[1], g[2]), l = new $b(i[0], i[1], i[2]), q.subVectors(k, j), r.subVectors(k, l), m = q.angleTo(r), n = Math.min(q.length() / 2, r.length() / 2), n = Math.min(b * c, n), s.addVectors(k, q.normalize().multiplyScalar( - n)), t.addVectors(k, r.normalize().multiplyScalar( - n)), p.lineTo(s.x, s.y, s.z), p.curveTo(k.x, k.y, k.z, t.x, t.y, t.z)) : p.lineTo(g[0], g[1], g[2]) : "quadraticCurveTo" === f.action && p.curveTo(g[0], g[1], g[2], g[3], g[4], g[5]);
            return p
        },
        _resetPath: function() {
            return this.path
        },
        getPointAt: function(a) {
            return this._realPath ? this._realPath.getPoint(a) : null
        },
        getTangentAt: function(a) {
            if (this._realPath) {
                var b = this._realPath.getPoint(a),
                c = this._realPath.getPoint(a - .001);
                return b.sub(c).normalize()
            }
            return null
        },
        computeData: function() {
            function a(a, b, c, d) {
                return d.vertices.push(new Yb.Vec3(a, b, c)) - 1
            }
            this.grid = [],
            this.startGrid = [],
            this.endGrid = [];
            var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v = this.segmentsCap,
            w = new Yb.Vec3,
            x = {};
            if (x.faces = [], x.uvs = [], x.vertices = [], null == this.path) return x;
            var y = this._resetPath(),
            z = this.startCap,
            A = this.endCap,
            B = this.cutSurface;
            this._realPath = y,
            1 == this._autoAjust && (y = this.adjustPath(y));
            var p, C, k, D = y.curves.length,
            E = y.curves,
            F = [],
            G = y.getLength(),
            H = 0,
            I = this.segments;
            for (j = 0; D > j; j++) {
                if (p = E[j], C = p.getLength(), p instanceof Yb.LineCurve3) {
                    var J = (.001 * C + H) / G,
                    K = (.999 * C + H) / G;
                    F.push(J),
                    F.push(K)
                } else {
                    var L = .998 * C;
                    for (k = 0; I >= k; k++) {
                        var M = (.001 * C + L * k / I + H) / G;
                        F.push(M)
                    }
                }
                H += C
            }
            var N = this.frenetFrames(y, F, this.closed),
            O = N.tangents,
            P = N.normals,
            Q = N.binormals;
            this.tangents = O,
            this.normals = P,
            this.binormals = Q;
            var R, S = 0,
            T = F.length - 1,
            U = T + 1,
            V = 0,
            W = 0;
            for (j = 0; U > j; j++) {
                if (this.grid[j] = [], e = F[j], i = y.getPointAt(e), b = O[j], c = P[j], d = Q[j], "none" !== z && 0 === j) if ("round" === z || "arrow" === z) {
                    var X, Y;
                    V += this.radius * this.startCapSize;
                    for (var Z = i.clone().add(b.clone().multiplyScalar( - this.radius * this.startCapSize)), $ = 0; v >= $; $++) {
                        this.startGrid[$] = [];
                        var _ = $ / v * Math.PI / 2;
                        X = "round" === z ? Z.clone().add(b.clone().multiplyScalar(this.radius * this.startCapSize * (1 - Math.cos(_)))) : Z.clone().add(b.clone().multiplyScalar(this.radius * this.startCapSize * $ / v));
                        for (var k = 0; k < this.segmentsR; k++) f = k / this.segmentsR * this.arc + this.arcStart,
                        "round" === z ? (g = -this.radius * Math.cos(f) * Math.sin(_), h = this.radius * Math.sin(f) * Math.sin(_)) : (g = -this.radius * Math.cos(f) * $ / v, h = this.radius * Math.sin(f) * $ / v, g *= this.startCapR || 1.3, h *= this.startCapR || 1.3),
                        Y = X.clone(),
                        Y.x += g * c.x + h * d.x,
                        Y.y += g * c.y + h * d.y,
                        Y.z += g * c.z + h * d.z,
                        this.startGrid[$][k] = x.vertices.push(Y) - 1;
                        "center" === B && (this.startGrid[$][this.segmentsR] = x.vertices.push(X.clone()) - 1)
                    }
                } else S = x.vertices.push(i);
                for (k = 0; k < this.segmentsR; k++) {
                    if (R = k / (this.segmentsR - 1), this.shape instanceof Array) g = -this.shape[k].x,
                    h = this.shape[k].y;
                    else if (this.shape instanceof Yb.Path) {
                        var aa = this.shape.getPointAt(R);
                        g = -aa.x,
                        h = -aa.y
                    } else f = k / this.segmentsR * this.arc + this.arcStart,
                    g = -this.radius * Math.cos(f),
                    h = this.radius * Math.sin(f);
                    w.copy(i),
                    w.x += g * c.x + h * d.x,
                    w.y += g * c.y + h * d.y,
                    w.z += g * c.z + h * d.z,
                    this.grid[j][k] = a(w.x, w.y, w.z, x)
                }
                if ("center" === B && (this.grid[j][this.segmentsR] = x.vertices.push(i.clone()) - 1), "none" !== A && j === U - 1) if ("round" === A || "arrow" === A) {
                    W += this.radius * this.endCapSize;
                    for (var X, Y, Z = i.clone().add(b.clone().multiplyScalar(this.radius * this.endCapSize)), $ = 0; v >= $; $++) {
                        this.endGrid[$] = [];
                        var _ = (1 - $ / v) * Math.PI / 2;
                        X = "round" === A ? Z.clone().add(b.clone().multiplyScalar( - this.radius * this.endCapSize * (1 - Math.cos(_)))) : Z.clone().add(b.clone().multiplyScalar( - this.radius * this.endCapSize * (1 - $ / v)));
                        for (var k = 0; k < this.segmentsR; k++) f = k / this.segmentsR * this.arc + this.arcStart,
                        "round" === A ? (g = -this.radius * Math.cos(f) * Math.sin(_), h = this.radius * Math.sin(f) * Math.sin(_)) : (g = -this.radius * Math.cos(f) * (1 - $ / v), h = this.radius * Math.sin(f) * (1 - $ / v), g *= this.endCapR || 1.3, h *= this.endCapR || 1.3),
                        Y = X.clone(),
                        Y.x += g * c.x + h * d.x,
                        Y.y += g * c.y + h * d.y,
                        Y.z += g * c.z + h * d.z,
                        this.endGrid[$][k] = x.vertices.push(Y) - 1;
                        "center" === B && (this.endGrid[$][this.segmentsR] = x.vertices.push(X) - 1)
                    }
                } else x.vertices.push(i)
            }
            var ba = this.segmentsR,
            ca = this.segmentsR;
            this.arc !== 2 * Math.PI && ("center" === B ? (ba++, ca++) : "none" === B && ba--);
            var da = this.arc / Math.PI / 2,
            ea = y.getLength(),
            fa = ea + V + W,
            ga = 0,
            ha = V / fa,
            ia = ha,
            ja = ea / fa,
            ka = ha + ja,
            la = W / fa;
            if ("none" !== z) if ("plain" === z) for (n = 0, k = 0; k < this.segmentsR; k++) {
                m = (k + 1) % this.segmentsR,
                o = this.grid[0][k],
                p = this.grid[0][m],
                x.faces.push(new Yb.Face3(n, o, p)),
                f = k / this.segmentsR * 2 * Math.PI,
                g = -this.radius * Math.cos(f),
                h = this.radius * Math.sin(f);
                var r = new Zb(.5, .5);
                f = k / this.segmentsR * 2 * Math.PI,
                g = -this.radius * Math.cos(f),
                h = this.radius * Math.sin(f);
                var s = new Zb((g / this.radius + 1) / 2, (h / this.radius + 1) / 2);
                f = m / this.segmentsR * 2 * Math.PI,
                g = -this.radius * Math.cos(f),
                h = this.radius * Math.sin(f);
                var t = new Zb((g / this.radius + 1) / 2, (h / this.radius + 1) / 2);
                x.uvs.push([r, s, t])
            } else for (j = 0; v >= j; j++) for (k = 0; ba > k; k++) {
                if (l = j + 1, m = (k + 1) % ca, n = this.startGrid[j][k], l === v + 1 ? (o = this.grid[0][k], p = this.grid[0][m]) : (o = this.startGrid[l][k], p = this.startGrid[l][m]), q = this.startGrid[j][m], k >= this.segmentsR - 1) {
                    var $ = this.segmentsR - 1,
                    e = $ / this.segmentsR * da;
                    ba === this.segmentsR ? (r = new Yb.Vec2(j / v * ha + ga, e), s = new Yb.Vec2((j + 1) / v * ha + ga, e), t = new Yb.Vec2((j + 1) / v * ha + ga, 1), u = new Yb.Vec2(j / v * ha + ga, 1)) : k > this.segmentsR - 1 ? (r = new Yb.Vec2(j / v * ha + ga, (1 + e) / 2), s = new Yb.Vec2((j + 1) / v * ha + ga, (1 + e) / 2), t = new Yb.Vec2((j + 1) / v * ha + ga, 1), u = new Yb.Vec2(j / v * ha + ga, 1)) : (r = new Yb.Vec2(j / v * ha + ga, e), s = new Yb.Vec2((j + 1) / v * ha + ga, e), t = new Yb.Vec2((j + 1) / v * ha + ga, (1 + e) / 2), u = new Yb.Vec2(j / v * ha + ga, (1 + e) / 2))
                } else r = new Yb.Vec2(j / v * ha + ga, k / this.segmentsR * da),
                s = new Yb.Vec2((j + 1) / v * ha + ga, k / this.segmentsR * da),
                t = new Yb.Vec2((j + 1) / v * ha + ga, (k + 1) / this.segmentsR * da),
                u = new Yb.Vec2(j / v * ha + ga, (k + 1) / this.segmentsR * da);
                0 !== j && (x.faces.push(new Yb.Face3(n, o, q, S - 1)), x.uvs.push([r, s, u])),
                x.faces.push(new Yb.Face3(o, p, q, S - 1)),
                x.uvs.push([s.clone(), t, u.clone()])
            }
            for (j = 0; T > j; j++) for (k = 0; ba > k; k++) {
                if (l = this.closed ? (j + 1) % T: j + 1, m = (k + 1) % ca, n = this.grid[j][k], o = this.grid[l][k], p = this.grid[l][m], q = this.grid[j][m], k >= this.segmentsR - 1) {
                    var $ = this.segmentsR - 1,
                    e = $ / this.segmentsR * da;
                    ba === this.segmentsR ? (r = new Yb.Vec2(F[j] * ja + ia, e), s = new Yb.Vec2(F[j + 1] * ja + ia, e), t = new Yb.Vec2(F[j + 1] * ja + ia, 1), u = new Yb.Vec2(F[j] * ja + ia, 1)) : k > this.segmentsR - 1 ? (r = new Yb.Vec2(F[j] * ja + ia, (e + 1) / 2), s = new Yb.Vec2(F[j + 1] * ja + ia, (e + 1) / 2), t = new Yb.Vec2(F[j + 1] * ja + ia, 1), u = new Yb.Vec2(F[j] * ja + ia, 1)) : (r = new Yb.Vec2(F[j] * ja + ia, e), s = new Yb.Vec2(F[j + 1] * ja + ia, e), t = new Yb.Vec2(F[j + 1] * ja + ia, (e + 1) / 2), u = new Yb.Vec2(F[j] * ja + ia, (e + 1) / 2))
                } else r = new Yb.Vec2(F[j] * ja + ia, k / this.segmentsR * da),
                s = new Yb.Vec2(F[j + 1] * ja + ia, k / this.segmentsR * da),
                t = new Yb.Vec2(F[j + 1] * ja + ia, (k + 1) / this.segmentsR * da),
                u = new Yb.Vec2(F[j] * ja + ia, (k + 1) / this.segmentsR * da);
                x.faces.push(new Yb.Face3(n, o, q)),
                x.uvs.push([r, s, u]),
                x.faces.push(new Yb.Face3(o, p, q)),
                x.uvs.push([s.clone(), t, u.clone()])
            }
            if ("none" !== A) {
                n = x.vertices.length - 1;
                var D = this.grid.length;
                if ("plain" === A) for (k = 0; k < this.segmentsR; k++) {
                    m = (k + 1) % this.segmentsR,
                    o = this.grid[D - 1][k],
                    p = this.grid[D - 1][m],
                    x.faces.push(new Yb.Face3(n, p, o)),
                    f = k / this.segmentsR * 2 * Math.PI,
                    g = -this.radius * Math.cos(f),
                    h = this.radius * Math.sin(f);
                    var r = new Zb(.5, .5);
                    f = k / this.segmentsR * 2 * Math.PI,
                    g = -this.radius * Math.cos(f),
                    h = this.radius * Math.sin(f);
                    var s = new Zb((g / this.radius + 1) / 2, (h / this.radius + 1) / 2);
                    f = m / this.segmentsR * 2 * Math.PI,
                    g = -this.radius * Math.cos(f),
                    h = this.radius * Math.sin(f);
                    var t = new Zb((g / this.radius + 1) / 2, (h / this.radius + 1) / 2);
                    x.uvs.push([r, t, s])
                } else for (j = -1; v > j; j++) for (k = 0; ba > k; k++) {
                    if (l = j + 1, m = (k + 1) % ca, -1 === j ? (n = this.grid[D - 1][k], q = this.grid[D - 1][m]) : (n = this.endGrid[j][k], q = this.endGrid[j][m]), o = this.endGrid[l][k], p = this.endGrid[l][m], k >= this.segmentsR - 1) {
                        var $ = this.segmentsR - 1,
                        e = $ / this.segmentsR * da;
                        ba === this.segmentsR ? (r = new Yb.Vec2(j / v * la + ka, e), s = new Yb.Vec2((j + 1) / v * la + ka, e), t = new Yb.Vec2((j + 1) / v * la + ka, 1), u = new Yb.Vec2(j / v * la + ka, 1)) : k > this.segmentsR - 1 ? (r = new Yb.Vec2(j / v * la + ka, (1 + e) / 2), s = new Yb.Vec2((j + 1) / v * la + ka, (1 + e) / 2), t = new Yb.Vec2((j + 1) / v * la + ka, 1), u = new Yb.Vec2(j / v * la + ka, 1)) : (r = new Yb.Vec2(j / v * la + ka, e), s = new Yb.Vec2((j + 1) / v * la + ka, e), t = new Yb.Vec2((j + 1) / v * la + ka, (1 + e) / 2), u = new Yb.Vec2(j / v * la + ka, (1 + e) / 2))
                    } else r = new Yb.Vec2(j / v * la + ka, k / this.segmentsR * da),
                    s = new Yb.Vec2((j + 1) / v * la + ka, k / this.segmentsR * da),
                    t = new Yb.Vec2((j + 1) / v * la + ka, (k + 1) / this.segmentsR * da),
                    u = new Yb.Vec2(j / v * la + ka, (k + 1) / this.segmentsR * da);
                    x.faces.push(new Yb.Face3(n, o, q)),
                    x.uvs.push([r, s, u]),
                    x.faces.push(new Yb.Face3(o, p, q)),
                    x.uvs.push([s.clone(), t, u.clone()])
                }
            }
            return x
        },
        frenetFrames: function(a, b, c) {
            function d() {
                o[0] = new Yb.Vec3,
                p[0] = new Yb.Vec3,
                f = Number.MAX_VALUE,
                g = Math.abs(n[0].x),
                h = Math.abs(n[0].y),
                i = Math.abs(n[0].z),
                f >= h && (f = h, m.set(0, 1, 0)),
                f >= g && (f = g, m.set(1, 0, 0)),
                f >= i && m.set(0, 0, 1),
                q.crossVectors(n[0], m).normalize(),
                o[0].crossVectors(n[0], q),
                p[0].crossVectors(n[0], o[0])
            }
            var e, f, g, h, i, j, k, l, m = (new Yb.Vec3, new Yb.Vec3),
            n = (new Yb.Vec3, []),
            o = [],
            p = [],
            q = new Yb.Vec3,
            r = new Yb.Mat4,
            s = b.length - 1,
            t = s + 1,
            u = 1e-4,
            v = [];
            for (v.tangents = n, v.normals = o, v.binormals = p, j = 0; t > j; j++) {
                k = b[j];
                var l = a.getTangentAt(k);
                n[j] = new Yb.Vec3(l.x, l.y, l.z ? l.z: 0),
                n[j].normalize()
            }
            for (d(), j = 1; t > j; j++) o[j] = o[j - 1].clone(),
            p[j] = p[j - 1].clone(),
            q.crossVectors(n[j - 1], n[j]),
            q.length() > u && (q.normalize(), e = Math.acos(Yb.Math.clamp(n[j - 1].dot(n[j]), -1, 1)), o[j].applyMatrix4(r.makeRotationAxis(q, e))),
            p[j].crossVectors(n[j], o[j]);
            if (c) for (e = Math.acos(Yb.Math.clamp(o[0].dot(o[t - 1]), -1, 1)), e /= t - 1, n[0].dot(q.crossVectors(o[0], o[t - 1])) > 0 && (e = -e), j = 1; t > j; j++) o[j].applyMatrix4(r.makeRotationAxis(n[j], e * j)),
            p[j].crossVectors(n[j], o[j]);
            return v
        }
    }),
    Yb.PathCube = function(a, b, c, d, e) {
        var f;
        1 === arguments.length && arguments[0] instanceof Object && !(arguments[0] instanceof Yb.Path) ? (f = arguments[0], this.path = f.path, this.width = f.width || 50, this.height = f.height || 100, this.curveSegements = f.curveSegements || 32, this.repeat = f.repeat || 20, this._id = f.id) : (this.path = a, this.width = b || 50, this.height = c || 100, this.curveSegements = d || 32, this.repeat = e || 20),
        this.materialSize = 6,
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.PathCube.SideIndexMapping = {
        bottom: 0,
        outside: 1,
        inside: 2,
        top: 3,
        aside: 4,
        zside: 5
    },
    Yb.extend(Yb.PathCube, Yb.Entity, {
        __accessor: ["path", "width", "height", "curveSegements", "repeat"],
        __SizePropeties: ["path", "width", "height", "curveSegements", "repeat"],
        constructor: Yb.PathCube,
        className: "TGL.PathCube",
        getSideIndexMapping: function() {
            return Yb.PathCube.SideIndexMapping
        },
        computeData: function() {
            var a = {};
            if (a.vertices = [], a.faces = [], a.uvs = [], a.uv2s = [], null == this.path) return a;
            var b, c = this.computePoints(this.path, this.width, this.curveSegements),
            d = c[0],
            e = c[1],
            f = d.length,
            g = c[2],
            h = this.height,
            i = this.repeat,
            j = [],
            k = [],
            l = [],
            m = [],
            n = this.path.isClockwise();
            for (this.innerPoints = this.clonePoints(d), this.outerPoints = this.clonePoints(e), b = 0; f > b; b++) this.exchangeYZ(d[b]),
            this.exchangeYZ(e[b]),
            j[b] = a.vertices.push(d[b]) - 1,
            k[b] = a.vertices.push(e[b]) - 1,
            l[b] = a.vertices.push(d[b].clone().setY(h)) - 1,
            m[b] = a.vertices.push(e[b].clone().setY(h)) - 1;
            var o = g ? f: f - 1;
            for (b = 0; o > b; b++) this.generateTop(a, b, f, l, m, !0, i),
            this.generateBottom(a, b, f, j, k, i),
            this.generateSideWall(a, b, f, m, k, !0, i, n),
            this.generateSideWall(a, b, f, l, j, !1, i, n);
            return g || (this.generateEnd(a, l, j, k, m, i, !0), this.generateEnd(a, l, j, k, m, i, !1)),
            this.clockwise = n,
            a
        },
        clonePoints: function(a) {
            for (var b = [], c = 0; c < a.length; c++) b.push(a[c].clone());
            return b
        },
        getInsidePoints: function() {
            var a = [];
            return a = this.clockwise ? this.innerPoints: this.outerPoints
        },
        generateEnd: function(a, b, c, d, e, f, g) {
            var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, t, w, x, y, z, A = g ? 0 : c.length - 1;
            h = b[A],
            i = c[A],
            j = d[A],
            k = e[A],
            w = a.vertices[h],
            x = a.vertices[i],
            y = a.vertices[j],
            z = a.vertices[k],
            l = w.x,
            m = w.y,
            n = w.z,
            o = x.x,
            p = x.y,
            q = x.z,
            r = y.x,
            s = y.y,
            t = y.z,
            u = z.x,
            v = z.y,
            dz = z.z;
            var B = Math.abs(n - t),
            C = Math.abs(l - r);
            g ? (a.faces.push(new Yb.Face3(h, i, k, null, null, 4)), C > B ? a.uvs.push([new Yb.Vec2(l / f, m / f), new Yb.Vec2(o / f, p / f), new Yb.Vec2(u / f, v / f)]) : a.uvs.push([new Yb.Vec2(n / f, m / f), new Yb.Vec2(q / f, p / f), new Yb.Vec2(dz / f, v / f)]), a.uv2s.push([new Zb(0, 1), new Zb(0, 0), new Zb(1, 1)]), a.faces.push(new Yb.Face3(i, j, k, null, null, 4)), C > B ? a.uvs.push([new Yb.Vec2(o / f, p / f), new Yb.Vec2(r / f, s / f), new Yb.Vec2(u / f, v / f)]) : a.uvs.push([new Yb.Vec2(q / f, p / f), new Yb.Vec2(t / f, s / f), new Yb.Vec2(dz / f, v / f)]), a.uv2s.push([new Zb(0, 0), new Zb(1, 0), new Zb(1, 1)])) : (a.faces.push(new Yb.Face3(i, h, k, null, null, 5)), C > B ? a.uvs.push([new Yb.Vec2(o / f, p / f), new Yb.Vec2(l / f, m / f), new Yb.Vec2(u / f, v / f)]) : a.uvs.push([new Yb.Vec2(q / f, p / f), new Yb.Vec2(n / f, m / f), new Yb.Vec2(dz / f, v / f)]), a.uv2s.push([new Zb(0, 0), new Zb(0, 1), new Zb(1, 1)]), a.faces.push(new Yb.Face3(j, i, k, null, null, 5)), C > B ? a.uvs.push([new Yb.Vec2(r / f, s / f), new Yb.Vec2(o / f, p / f), new Yb.Vec2(u / f, v / f)]) : a.uvs.push([new Yb.Vec2(t / f, s / f), new Yb.Vec2(q / f, p / f), new Yb.Vec2(dz / f, v / f)]), a.uv2s.push([new Zb(1, 0), new Zb(0, 0), new Zb(1, 1)]))
        },
        generateSideWall: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, u, x, y, z, A, B;
            x = (b + 1) % c,
            i = d[b],
            j = e[b],
            k = e[x],
            l = d[x],
            y = a.vertices[i],
            z = a.vertices[j],
            A = a.vertices[k],
            B = a.vertices[l],
            m = y.x,
            n = y.y,
            o = y.z,
            p = z.x,
            q = z.y,
            r = z.z,
            s = A.x,
            t = A.y,
            u = A.z,
            v = B.x,
            w = B.y,
            dz = B.z;
            var C, D = Math.abs(o - u),
            E = Math.abs(m - s);
            f ? (C = h ? 1 : 2, a.faces.push(new Yb.Face3(i, j, l, null, null, C)), E > D ? a.uvs.push([new Yb.Vec2(m / g, n / g), new Yb.Vec2(p / g, q / g), new Yb.Vec2(v / g, w / g)]) : a.uvs.push([new Yb.Vec2(o / g, n / g), new Yb.Vec2(r / g, q / g), new Yb.Vec2(dz / g, w / g)]), a.uv2s.push([new Zb(0, 1), new Zb(0, 0), new Zb(1, 1)]), a.faces.push(new Yb.Face3(j, k, l, null, null, C)), E > D ? a.uvs.push([new Yb.Vec2(p / g, q / g), new Yb.Vec2(s / g, t / g), new Yb.Vec2(v / g, w / g)]) : a.uvs.push([new Yb.Vec2(r / g, q / g), new Yb.Vec2(u / g, t / g), new Yb.Vec2(dz / g, w / g)]), a.uv2s.push([new Zb(0, 0), new Zb(1, 0), new Zb(1, 1)])) : (C = h ? 2 : 1, a.faces.push(new Yb.Face3(j, i, l, null, null, C)), E > D ? a.uvs.push([new Yb.Vec2(p / g, q / g), new Yb.Vec2(m / g, n / g), new Yb.Vec2(v / g, w / g)]) : a.uvs.push([new Yb.Vec2(r / g, q / g), new Yb.Vec2(o / g, n / g), new Yb.Vec2(dz / g, w / g)]), a.uv2s.push([new Zb(0, 0), new Zb(0, 1), new Zb(1, 1)]), a.faces.push(new Yb.Face3(k, j, l, null, null, C)), E > D ? a.uvs.push([new Yb.Vec2(s / g, t / g), new Yb.Vec2(p / g, q / g), new Yb.Vec2(v / g, w / g)]) : a.uvs.push([new Yb.Vec2(u / g, t / g), new Yb.Vec2(r / g, q / g), new Yb.Vec2(dz / g, w / g)]), a.uv2s.push([new Zb(1, 0), new Zb(0, 0), new Zb(1, 1)]))
        },
        generateBottom: function(a, b, c, d, e, f) {
            this.generateTop(a, b, c, d, e, !1, f)
        },
        generateTop: function(a, b, c, d, e, f, g) {
            var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, t, w, x, y, z, A;
            w = (b + 1) % c,
            h = d[b],
            i = e[b],
            j = e[w],
            k = d[w],
            x = a.vertices[h],
            y = a.vertices[i],
            z = a.vertices[j],
            A = a.vertices[k],
            l = x.x,
            m = x.y,
            n = x.z,
            o = y.x,
            p = y.y,
            q = y.z,
            r = z.x,
            s = z.y,
            t = z.z,
            u = A.x,
            v = A.y,
            dz = A.z,
            f ? (a.faces.push(new Yb.Face3(h, i, k, null, null, 3)), a.uvs.push([new Yb.Vec2(l / g, n / g), new Yb.Vec2(o / g, q / g), new Yb.Vec2(u / g, dz / g)]), a.uv2s.push([new Zb(0, 1), new Zb(0, 0), new Zb(1, 1)]), a.faces.push(new Yb.Face3(i, j, k, null, null, 3)), a.uvs.push([new Yb.Vec2(o / g, q / g), new Yb.Vec2(r / g, t / g), new Yb.Vec2(u / g, dz / g)]), a.uv2s.push([new Zb(0, 0), new Zb(1, 0), new Zb(1, 1)])) : (a.faces.push(new Yb.Face3(i, h, k, null, null, 0)), a.uvs.push([new Yb.Vec2(o / g, q / g), new Yb.Vec2(l / g, n / g), new Yb.Vec2(u / g, dz / g)]), a.uv2s.push([new Zb(0, 0), new Zb(0, 1), new Zb(1, 1)]), a.faces.push(new Yb.Face3(j, i, k, null, null, 0)), a.uvs.push([new Yb.Vec2(r / g, t / g), new Yb.Vec2(o / g, q / g), new Yb.Vec2(u / g, dz / g)]), a.uv2s.push([new Zb(1, 0), new Zb(0, 0), new Zb(1, 1)]))
        },
        exchangeYZ: function(a) {
            var b = a.y;
            a.y = a.z,
            a.z = -b
        },
        addPoints: function(a, b, c, d, e) {
            b.multiplyScalar(.5),
            c.push((new Yb.Vec3).subVectors(a, b)),
            d.push((new Yb.Vec3).addVectors(a, b))
        },
        computeCurvePoint: function(a, b, c, d, e, f, g, h, i) {
            var k, l, m, n, o = d ? 0 : 1,
            p = new Yb.Vec3,
            q = h;
            if (a) {
                l = a.getTangentAt(1),
                m = b.getTangentAt(0),
                concave = Yb.Math.isConcave(l, m, !1),
                m.multiplyScalar( - 1),
                angle = l.angleTo(m),
                n = Math.sin(angle / 2),
                k = b.getPoint(0),
                n = 0 == n ? .1 : n;
                var r = concave ? c / n: -c / n;
                1 == n ? p.crossVectors(m, new $b(0, 0, 1)).normalize().multiplyScalar(r) : p.addVectors(l, m).normalize().multiplyScalar(r),
                this.addPoints(k, p, f, g, i)
            } else m = b.getTangentAt(o),
            k = b.getPoint(o),
            p.crossVectors(m, new Yb.Vec3(0, 0, 1)).normalize().multiplyScalar(c),
            this.addPoints(k, p, f, g, i);
            if (! (b instanceof Yb.LineCurve3) && e) {
                var s = q + 1;
                for (j = 0; j < s - 2; j++) u = j / (s - 1),
                m = b.getTangentAt(u),
                k = b.getPointAt(u),
                p.crossVectors(m, new Yb.Vec3(0, 0, 1)).normalize().multiplyScalar(c),
                j * b.getLength() / q > c / Math.abs(n) && this.addPoints(k, p, f, g, i)
            }
        },
        computePoints: function(a, b, c) {
            var d, e, f, g = (new Yb.Vec3, a.isClockwise()),
            h = a.curves[0].getPoint(0),
            i = a.curves[a.curves.length - 1].getPoint(1);
            f = h.equals(i),
            e = a.curves.length;
            var j = [],
            k = [];
            for (new Yb.Path, a.getLength(), d = 0; e > d; d++) {
                var l = d - 1;
                f && -1 === l && (l = e - 1);
                var m = a.curves[l],
                n = a.curves[d];
                this.computeCurvePoint(m, n, b, !0, !0, j, k, c, g),
                d === e - 1 && !f && this.computeCurvePoint(null, n, b, !1, !1, j, k, c, g)
            }
            return [j, k, f]
        }
    }),
    Yb.ShapeNode = function(a, b, c, d, e) {
        if (null == a) return a = [],
        this.materialSize = 3,
        void Yb.Entity.call(this);
        var f;
        if (! (1 === arguments.length && arguments[0] instanceof Object) || arguments[0] instanceof Yb.Shape || arguments[0] instanceof Yb.Path && !Array.isArray(arguments[0])) this.options = {
            curveSegments: b,
            amount: c,
            vertical: d,
            zMinusHalfAmount: this.zMinusHalfAmount,
            repeat: e || 20
        };
        else {
            if (f = arguments[0], a = f.path, null == a) return a = [],
            this.materialSize = 3,
            void Yb.Entity.call(this);
            b = f.curveSegments,
            c = f.amount,
            d = f.vertical,
            e = f.repeat,
            this.options = {
                curveSegments: f.curveSegments,
                amount: f.amount,
                vertical: f.vertical,
                zMinusHalfAmount: this.zMinusHalfAmount,
                repeat: f.repeat || 20
            },
            this._id = f.id
        }
        var g = [];
        a instanceof Yb.Path ? (g = a.toShapes(), this.path = a) : g = a,
        this.curveSegments = b,
        this.amount = c,
        this.vertical = d,
        this.repeat = e || 20,
        g = g instanceof Array ? g: [g],
        this.shapes = g,
        this.shapebb = g[g.length - 1].getBoundingBox(),
        this.materialSize = 3,
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.ShapeNode.SideIndexMapping = {
        bottom: 0,
        side: 1,
        top: 2
    },
    Yb.extend(Yb.ShapeNode, Yb.Entity, {
        constructor: Yb.ShapeNode,
        className: "TGL.ShapeNode",
        __accessor: ["path", "curveSegments", "amount", "vertical", "repeat"],
        __bool: ["vertical"],
        __SizePropeties: ["path", "curveSegments", "amount", "vertical", "repeat"],
        computeData: function() {
            return this.options = {
                curveSegments: this.curveSegments,
                amount: this.amount,
                vertical: this.vertical,
                zMinusHalfAmount: this.zMinusHalfAmount,
                repeat: this.repeat || 20
            },
            this.addShapes(this.path, this.options)
        },
        getSideIndexMapping: function() {
            return Yb.ShapeNode.SideIndexMapping
        },
        addShapes: function(a, b) {
            var c = [];
            c = a instanceof Yb.Path ? a.toShapes() : a;
            var d = {};
            if (d.vertices = [], d.uvs = [], d.faces = [], !c) return d;
            for (var e = c.length,
            f = 0; e > f; f++) {
                var g = c[f];
                this.addShape(g, b, d)
            }
            var h = new Yb.BoundingBox;
            h.setFromPoints(d.vertices);
            var i = (h.max.y - h.min.y) / 2;
            if (b.zMinusHalfAmount) for (var j = 0; j < d.vertices.length; j++) d.vertices[j].y -= i;
            if (b.vertical) for (var j = 0; j < d.vertices.length; j++) {
                var k = d.vertices[j].y;
                d.vertices[j].y = d.vertices[j].z,
                d.vertices[j].z = -k
            }
            return d
        }
    }),
    Yb.ShapeNode.prototype.addShape = function(a, b, c) {
        function d(a, b, c) {
            return b || console.log("die"),
            b.clone().multiplyScalar(c).add(a)
        }
        function f(a, b, c) {
            return h(a, b, c)
        }
        function g(a, b, c) {
            var d = Math.atan2(b.y - a.y, b.x - a.x),
            e = Math.atan2(c.y - a.y, c.x - a.x);
            d > e && (e += 2 * Math.PI);
            var f = (d + e) / 2,
            g = -Math.cos(f),
            h = -Math.sin(f),
            i = new Yb.Vec2(g, h);
            return i
        }
        function h(a, b, c) {
            var d, e, f, h, i, j, k = Yb.ShapeNode.__v1,
            l = Yb.ShapeNode.__v2,
            m = Yb.ShapeNode.__v3,
            n = Yb.ShapeNode.__v4,
            o = Yb.ShapeNode.__v5,
            p = Yb.ShapeNode.__v6;
            return k.set(a.x - b.x, a.y - b.y),
            l.set(a.x - c.x, a.y - c.y),
            d = k.normalize(),
            e = l.normalize(),
            m.set( - d.y, d.x),
            n.set(e.y, -e.x),
            o.copy(a).add(m),
            p.copy(a).add(n),
            o.equals(p) ? n.clone() : (o.copy(b).add(m), p.copy(c).add(n), f = d.dot(n), h = p.sub(o).dot(n), 0 === f && (console.log("Either infinite or no solutions!"), 0 === h ? console.log("Its finite solutions.") : console.log("Too bad, no solutions.")), i = h / f, 0 > i ? g(a, b, c) : (j = d.multiplyScalar(i).add(o), j.sub(a).clone()))
        }
        function i() {
            if (u) {
                var a = 0,
                b = V * a;
                for (Y = 0; W > Y; Y++) U = N[Y],
                m(U[2] + b, U[1] + b, U[0] + b, !0);
                for (a = w + 2 * t, b = V * a, Y = 0; W > Y; Y++) U = N[Y],
                m(U[0] + b, U[1] + b, U[2] + b, !1)
            } else {
                for (Y = 0; W > Y; Y++) U = N[Y],
                m(U[2], U[1], U[0], !0);
                for (Y = 0; W > Y; Y++) U = N[Y],
                m(U[0] + V * w, U[1] + V * w, U[2] + V * w, !1)
            }
        }
        function j() {
            var a = 0;
            for (k(O, a), a += O.length, G = 0, H = L.length; H > G; G++) F = L[G],
            k(F, a),
            a += F.length
        }
        function k(a, b) {
            var c, d;
            for (Y = a.length; --Y >= 0;) {
                c = Y,
                d = Y - 1,
                0 > d && (d = a.length - 1);
                var e = 0,
                f = w + 2 * t;
                for (e = 0; f > e; e++) {
                    var g = V * e,
                    h = V * (e + 1),
                    i = b + c + g,
                    j = b + d + g,
                    k = b + d + h,
                    l = b + c + h;
                    n(i, j, k, l, a, e, f, c, d)
                }
            }
        }
        function l(a, b, d) {
            c.vertices.push(new Yb.Vec3(a, b, d - (q ? p / 2 : 0)))
        }
        function m(d, e, f, g) {
            d += I,
            e += I,
            f += I;
            var h = g ? 0 : 2;
            if (Yb.Math.isClockwise([c.vertices[d], c.vertices[e], c.vertices[f]]), "z") {
                c.faces.push(new Yb.Face3(d, e, f, null, null, h));
                var i = g ? A.generateBottomUV(c, a, b, d, e, f) : A.generateTopUV(c, a, b, d, e, f);
                c.uvs.push(i)
            } else {
                c.faces.push(new Yb.Face3(d, f, e, null, null, h));
                var i = g ? A.generateBottomUV(c, a, b, d, f, e) : A.generateTopUV(c, a, b, d, f, e);
                c.uvs.push(i)
            }
        }
        function n(d, e, f, g, h, i, j, k, l) {
            if (d += I, e += I, f += I, g += I, Yb.Math.isClockwise([c.vertices[d], c.vertices[e], c.vertices[g]]), "z") {
                c.faces.push(new Yb.Face3(d, e, g, null, null, z)),
                c.faces.push(new Yb.Face3(e, f, g, null, null, z));
                var m = A.generateSideWallUV(c, a, h, b, d, e, f, g, i, j, k, l);
                c.uvs.push([m[0], m[1], m[3]]),
                c.uvs.push([m[1], m[2], m[3]])
            } else {
                c.faces.push(new Yb.Face3(d, g, e, null, null, z)),
                c.faces.push(new Yb.Face3(e, g, f, null, null, z));
                var m = A.generateSideWallUV(c, a, h, b, d, e, f, g, i, j, k, l);
                c.uvs.push([m[0], m[3], m[1]]),
                c.uvs.push([m[1], m[3], m[2]])
            }
        }
        var o, p = b.amount !== e ? b.amount: 100,
        q = b.zMinusHalfAmount !== e ? b.zMinusHalfAmount: !1,
        r = b.bevelThickness !== e ? b.bevelThickness: 6,
        s = b.bevelSize !== e ? b.bevelSize: r - 2,
        t = b.bevelSegments !== e ? b.bevelSegments: 3,
        u = b.bevelEnabled !== e ? b.bevelEnabled: !1,
        v = b.curveSegments !== e ? b.curveSegments: 12,
        w = b.steps !== e ? b.steps: 1,
        x = b.extrudePath,
        y = !1,
        z = (b.material || 0, b.extrudeMaterial || 1),
        A = b.UVGenerator !== e ? b.UVGenerator: Yb.ShapeNode.WorldUVGenerator;
        A.repeat = b.repeat;
        var B, C, D, E;
        this.shapebb,
        x && (o = x.getSpacedPoints(w), y = !0, u = !1, B = b.frames !== e ? b.frames: Yb.PathNode.prototype.frenetFrames(x, w, !1), C = new Yb.Vec3, D = new Yb.Vec3, E = new Yb.Vec3),
        u || (t = 0, r = 0, s = 0);
        var F, G, H, I = c.vertices.length,
        J = a.extractPoints(v),
        K = J.shape,
        L = J.holes,
        M = !Yb.Shape.Utils.isClockWise(K);
        if (M) {
            for (K = K.reverse(), G = 0, H = L.length; H > G; G++) F = L[G],
            Yb.Shape.Utils.isClockWise(F) && (L[G] = F.reverse());
            M = !1
        }
        var N = Yb.Shape.Utils.triangulateShape(K, L),
        O = K;
        for (G = 0, H = L.length; H > G; G++) F = L[G],
        K = K.concat(F);
        for (var P, Q, R, S, T, U, V = K.length,
        W = N.length,
        X = (O.length, 180 / Math.PI, []), Y = 0, Z = O.length, $ = Z - 1, _ = Y + 1; Z > Y; Y++, $++, _++) $ === Z && ($ = 0),
        _ === Z && (_ = 0),
        O[Y],
        O[$],
        O[_],
        X[Y] = f(O[Y], O[$], O[_]);
        var aa, ba = [],
        ca = X.concat();
        for (G = 0, H = L.length; H > G; G++) {
            for (F = L[G], aa = [], Y = 0, Z = F.length, $ = Z - 1, _ = Y + 1; Z > Y; Y++, $++, _++) $ === Z && ($ = 0),
            _ === Z && (_ = 0),
            aa[Y] = f(F[Y], F[$], F[_]);
            ba.push(aa),
            ca = ca.concat(aa)
        }
        for (P = 0; t > P; P++) {
            for (R = P / t, S = r * (1 - R), Q = s * Math.sin(R * Math.PI / 2), Y = 0, Z = O.length; Z > Y; Y++) T = d(O[Y], X[Y], Q),
            l(T.x, T.y, -S);
            for (G = 0, H = L.length; H > G; G++) for (F = L[G], aa = ba[G], Y = 0, Z = F.length; Z > Y; Y++) T = d(F[Y], aa[Y], Q),
            l(T.x, T.y, -S)
        }
        for (Q = s, Y = 0; V > Y; Y++) T = u ? d(K[Y], ca[Y], Q) : K[Y],
        y ? (D.copy(B.normals[0]).multiplyScalar(T.x), C.copy(B.binormals[0]).multiplyScalar(T.y), E.copy(o[0]).add(D).add(C), l(E.x, E.y, E.z)) : l(T.x, T.y, 0);
        var da;
        for (da = 1; w >= da; da++) for (Y = 0; V > Y; Y++) T = u ? d(K[Y], ca[Y], Q) : K[Y],
        y ? (D.copy(B.normals[da]).multiplyScalar(T.x), C.copy(B.binormals[da]).multiplyScalar(T.y), E.copy(o[da]).add(D).add(C), l(E.x, E.y, E.z)) : l(T.x, T.y, p / w * da);
        for (P = t - 1; P >= 0; P--) {
            for (R = P / t, S = r * (1 - R), Q = s * Math.sin(R * Math.PI / 2), Y = 0, Z = O.length; Z > Y; Y++) T = d(O[Y], X[Y], Q),
            l(T.x, T.y, p + S);
            for (G = 0, H = L.length; H > G; G++) for (F = L[G], aa = ba[G], Y = 0, Z = F.length; Z > Y; Y++) T = d(F[Y], aa[Y], Q),
            y ? l(T.x, T.y + o[w - 1].y, o[w - 1].x + S) : l(T.x, T.y, p + S)
        }
        i(),
        j()
    },
    Yb.ShapeNode.WorldUVGenerator = {
        generateTopUV: function(a, b, c, d, e, f) {
            var g = a.vertices[d].x,
            h = a.vertices[d].y,
            i = a.vertices[e].x,
            j = a.vertices[e].y,
            k = a.vertices[f].x,
            l = a.vertices[f].y;
            return [new Yb.Vec2(g / this.repeat, h / this.repeat), new Yb.Vec2(i / this.repeat, j / this.repeat), new Yb.Vec2(k / this.repeat, l / this.repeat)]
        },
        generateBottomUV: function(a, b, c, d, e, f) {
            return this.generateTopUV(a, b, c, d, e, f)
        },
        uv: function(a, b, c) {
            return new Zb(Math.sqrt(a * a + b * b) / this.repeat, (1 - c) / this.repeat)
        },
        generateSideWallUV: function(a, b, c, d, e, f, g, h, i, j, k, l) {
            var m = a.vertices[e].x,
            n = a.vertices[e].y,
            o = a.vertices[e].z,
            p = a.vertices[f].x,
            q = a.vertices[f].y,
            r = a.vertices[f].z,
            s = a.vertices[g].x,
            t = a.vertices[g].y,
            u = a.vertices[g].z,
            v = a.vertices[h].x,
            w = a.vertices[h].y,
            x = a.vertices[h].z,
            y = Math.abs(n - q),
            z = Math.abs(m - p);
            return z > y ? [new Yb.Vec2(m / this.repeat, (1 - o) / this.repeat), new Yb.Vec2(p / this.repeat, (1 - r) / this.repeat), new Yb.Vec2(s / this.repeat, (1 - u) / this.repeat), new Yb.Vec2(v / this.repeat, (1 - x) / this.repeat)] : [new Yb.Vec2(n / this.repeat, (1 - o) / this.repeat), new Yb.Vec2(q / this.repeat, (1 - r) / this.repeat), new Yb.Vec2(t / this.repeat, (1 - u) / this.repeat), new Yb.Vec2(w / this.repeat, (1 - x) / this.repeat)]
        }
    },
    Yb.ShapeNode.__v1 = new Yb.Vec2,
    Yb.ShapeNode.__v2 = new Yb.Vec2,
    Yb.ShapeNode.__v3 = new Yb.Vec2,
    Yb.ShapeNode.__v4 = new Yb.Vec2,
    Yb.ShapeNode.__v5 = new Yb.Vec2,
    Yb.ShapeNode.__v6 = new Yb.Vec2,
    Yb.TextNode = function(a, b, c, d, f, g, h) {
        var i;
        1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0]) ? (i = arguments[0], a = i.text, this.font = i.font || "helvetiker", this.size = i.size || 150, this.weight = i.weight || "normal", this.fontStyle = i.fontStyle || "normal", this.height = i.height || 50, this._id = i.id, this.curveSegments = i.curveSegments) : (this.font = d || "helvetiker", this.size = b || 150, this.weight = f || "normal", this.fontStyle = g || "normal", this.height = c || 50, this.curveSegments = h);
        var j = {
            size: this.size,
            height: this.height,
            font: this.font,
            weight: this.weight,
            style: this.fontStyle,
            curveSegments: this.curveSegments || 30,
            bevelEnabled: !1,
            zMinusHalfAmount: !0
        };
        this.text = a;
        var k = Yb.FontUtils.generateShapes(a, j);
        j.amount = j.height !== e ? j.height: 50,
        j.bevelThickness === e && (j.bevelThickness = 10),
        j.bevelSize === e && (j.bevelSize = 8),
        j.bevelEnabled === e && (j.bevelEnabled = !1),
        Yb.ShapeNode.call(this, k, j.curveSegments, this.height, !1, 50, !0)
    },
    Yb.extend(Yb.TextNode, Yb.ShapeNode, {
        constructor: Yb.TextNode,
        className: "TGL.TextNode",
        __accessor: ["text", "size", "height", "font", "weight", "fontStyle"],
        __SizePropeties: ["text", "size", "height", "font", "weight", "fontStyle"],
        computeData: function() {
            var a = {
                size: this.size,
                height: this.height,
                font: this.font,
                weight: this.weight,
                style: this.fontStyle,
                curveSegments: this.curveSegments || 30,
                bevelEnabled: !1,
                zMinusHalfAmount: !0
            },
            b = {
                curveSegments: this.curveSegments,
                amount: this.height,
                vertical: !1,
                zMinusHalfAmount: !0,
                repeat: 20
            },
            c = Yb.FontUtils.generateShapes(this.text, a);
            return Yb.ShapeNode.prototype.addShapes.call(this, c, b)
        }
    }),
    Yb.LatheNode = function(a, b, c, d, f, g) {
        this.materialSize = 3;
        var h;
        1 === arguments.length && arguments[0] instanceof Object && !(arguments[0] instanceof Yb.Path) ? (h = arguments[0], this.path = h.path, this.segmentsH = h.segmentsH || 64, this.segmentsR = h.segmentsR || 20, this.arc = h.arc != e ? h.arc: 2 * Math.PI, this.startClosed = h.startClosed, this.endClosed = h.endClosed, this._id = h.id) : (this.path = a, this.segmentsH = b || 64, this.segmentsR = c || 20, this.arc = d != e ? d: 2 * Math.PI, this.startClosed = f, this.endClosed = g),
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.extend(Yb.LatheNode, Yb.Entity, {
        constructor: Yb.LatheNode,
        className: "TGL.LatheNode",
        __accessor: ["path", "segmentsH", "segmentsR", "arc", "startClosed", "endClosed"],
        __SizePropeties: ["path", "segmentsH", "segmentsR", "arc", "startClosed", "endClosed"],
        computeData: function() {
            function d(a) {
                var b = a.x,
                c = a.z,
                d = ((0 === c ? b / Math.abs(b) : b / Math.abs(c)) + 1) / 2;
                d = Yb.Math.clamp(d, 0, 1);
                var e = ((0 === b ? c / Math.abs(c) : c / Math.abs(b)) + 1) / 2;
                return e = Yb.Math.clamp(e, 0, 1),
                new Yb.Vec2(d, e)
            }
            var e = {},
            e = {};
            if (e.faces = [], e.uvs = [], e.vertices = [], null == this.path) return e;
            var f, g, h, i, j, k, l, m = [],
            n = this.path,
            o = this.segmentsH,
            p = this.segmentsR;
            for (Yb.Shape.Utils.isClockWise(n.getPoints()) || (n = n.reverse()), g = 0; o >= g; g++) {
                for (f = n.getPoint(g / o), m[g] = [], i = Math.abs(f.x), j = f.y, this.startClosed && 0 === g && e.vertices.push(new Yb.Vec3(0, j, 0)), h = 0; p > h; h++) l = h / p * this.arc,
                k = new Yb.Vec3(i * Math.cos(l), j, i * Math.sin(l)),
                m[g][h] = e.vertices.push(k) - 1;
                this.endClosed && g === o && e.vertices.push(new Yb.Vec3(0, j, 0))
            }
            var q = this.arc == 2 * Math.PI;
            if (this.startClosed) for (a = 0, h = 0; (q ? p: p - 1) > h; h++) jp = (h + 1) % p,
            b = m[0][h],
            c = m[0][jp],
            uva = new Yb.Vec2(.5, .5),
            uvb = d(e.vertices[b]),
            uvc = d(e.vertices[c]),
            e.faces.push(new Yb.Face3(a, b, c)),
            e.uvs.push([uva, uvb, uvc]);
            for (g = 0; o > g; g++) for (h = 0; (q ? p: p - 1) > h; h++) ip = g + 1,
            jp = (h + 1) % p,
            a = m[g][h],
            b = m[ip][h],
            c = m[ip][jp],
            Vc = m[g][jp],
            uva = new Yb.Vec2(g / o, h / p),
            uvb = new Yb.Vec2((g + 1) / o, h / p),
            uvc = new Yb.Vec2((g + 1) / o, (h + 1) / p),
            uvd = new Yb.Vec2(g / o, (h + 1) / p),
            e.faces.push(new Yb.Face3(a, b, Vc)),
            e.uvs.push([uva, uvb, uvd]),
            e.faces.push(new Yb.Face3(b, c, Vc)),
            e.uvs.push([uvb.clone(), uvc, uvd.clone()]);
            if (this.endClosed) for (a = e.vertices.length - 1, h = 0; (q ? p: p - 1) > h; h++) jp = (h + 1) % p,
            b = m[m.length - 1][h],
            c = m[m.length - 1][jp],
            uva = new Yb.Vec2(0, 0),
            uvb = new Yb.Vec2(1, h / p),
            uvc = new Yb.Vec2(1, (h + 1) / p),
            e.faces.push(new Yb.Face3(a, b, c)),
            e.uvs.push([uva, uvb, uvc]);
            return e
        }
    }),
    Yb.CurvePlane = function(a, b, c, d) {
        this.pathH = a,
        this.pathV = b,
        this.segmentsH = c || 20,
        this.segmentsV = d || 20,
        Yb.Entity.call(this)
    },
    Yb.extend(Yb.CurvePlane, Yb.Entity, {
        constructor: Yb.CurvePlane,
        className: "TGL.CurvePlane",
        computeData: function() {
            var a = {};
            if (a.faces = [], a.uvs = [], a.vertices = [], null == this.pathV || null == this.pathH) return a;
            var b, c, d, e, f, g, h, i, j, k = this.pathV,
            l = this.pathH,
            m = this.segmentsV,
            n = this.segmentsH,
            o = m + 1,
            p = n + 1;
            for (this.grid = [], b = 0; p > b; b++) {
                this.grid[b] = [];
                var q = l.getPointAt(b / p);
                for (c = 0; o > c; c++) {
                    var r = k.getPointAt(c / o);
                    this.grid[b][c] = a.vertices.push(new $b(q.x, r.y, q.z + r.z)) - 1
                }
            }
            for (b = 0; n > b; b++) for (c = 0; m > c; c++) d = this.grid[b][c],
            e = this.grid[b][c + 1],
            f = this.grid[b + 1][c + 1],
            g = this.grid[b + 1][c],
            h = new Zb(b / p, c / o),
            i = new Zb(b / p, (c + 1) / o),
            uvc = new Zb((b + 1) / p, (c + 1) / o),
            j = new Zb((b + 1) / p, c / o),
            a.faces.push(new pc(d, f, e)),
            a.uvs.push([h, uvc, i]),
            a.faces.push(new pc(d, g, f)),
            a.uvs.push([h.clone(), j.clone(), uvc]);
            return a
        }
    }),
    Yb.ComboNode = function(a, b, c, d, e) {
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var f = a;
            this.combos = f.combos || [],
            this.operators = f.operators,
            this.centralized = c,
            this.names = e,
            this._id = f.id
        } else this.combos = a || [],
        this.operators = b,
        this.centralized = c,
        this._id = d,
        this.names = e;
        this.csgs = [],
        Yb.Entity.call(this)
    },
    Yb.extend(Yb.ComboNode, Yb.Entity, {
        constructor: Yb.ComboNode,
        className: "TGL.ComboNode",
        __accessor: ["combos", "operators", "centralized", "names"],
        __SizePropeties: ["combos", "operators", "centralized"],
        getOffsetPosition: function() {
            return this._offsetPosition
        },
        getSideIndexMapping: function() {
            var a, b, c, d, e = this.combos,
            f = this.names || [],
            g = {},
            h = 0;
            if (e && e.length) for (c = 0; c < e.length; c++) {
                a = e[c],
                b = f[c],
                b || (d = a.getClassName(), d && d.indexOf(".") > 0 && (d = d.substr(d.lastIndexOf(".") + 1)), b = d + "" + c, b = b.toLowerCase());
                var i = a.getSideIndexMapping();
                if (i) for (var j in i) g[b + "-" + j] = h++;
                else g[b] = h++
            }
            return g
        },
        computeData: function() {
            this.csgs = [];
            var a = {
                vertices: [],
                faces: [],
                uvs: [],
                uv2s: []
            };
            if (!this.combos) return a;
            if (null == this.operators || 0 == this.operators.length) {
                var b = tc.mergeElements(this.combos);
                if (this.materialSize = b.material.materials.length, this.material = b.material, this.orgMaterial = b.material, a = {
                    vertices: b.vertices,
                    faces: b.faces,
                    uvs: b.uvs,
                    uv2s: b.uv2s || []
                },
                this.centralized && a.vertices) {
                    var c = new Yb.BoundingBox;
                    c.setFromPoints(a.vertices);
                    var d = c.center();
                    for (g = 0; g < a.vertices.length; g++) {
                        var f = a.vertices[g];
                        f.sub(d)
                    }
                    this._offsetPosition = d
                }
                return a
            }
            this.operators = this.operators || [];
            var g, h, i, j, k = this.combos.length;
            for (g = 0; k > g; g++) this.csgs.push(new Yb.CSG(this.combos[g]));
            for (g = 0; k > g; g++) null == h ? h = this.csgs[g] : (i = this.operators[g - 1], "+" === i || i == e ? h = h.union(this.csgs[g]) : "-" === i ? h = h.substract(this.csgs[g]) : "^" === i && (h = h.intersect(this.csgs[g])));
            if (!h) return a;
            if (j = h.toMesh(), ("centralized" != this.changeProperty || null == this.material) && (this.materialSize = j.material.materials.length, this.material = j.material, this.orgMaterial = j.material), a = {
                vertices: j.vertices,
                faces: j.faces,
                uvs: j.uvs,
                uv2s: j.uv2s
            },
            this.centralized && a.vertices) {
                var c = new Yb.BoundingBox;
                c.setFromPoints(a.vertices);
                var d = c.center();
                for (g = 0; g < a.vertices.length; g++) {
                    var f = a.vertices[g];
                    f.sub(d)
                }
                this._offsetPosition = d
            }
            return j = e,
            a
        },
        computeNodeMaterial: function(a) {
            this.material = a.material,
            this.materialSize = a.materialSize
        },
        cacheNodeMaterial: function(a) {
            a.material = this.material,
            a.materialSize = this.materialSize
        },
        needComputeVertexNormal: function() {
            return ! 0
        },
        generatePrimitiveKey: function() {
            return null
        },
        changeMapping: function(a) {
            var b = this.getMaterialMapping();
            Yb.Utils.isSame(a, b) || (this.batch ? this.materialMappingChanges = [a, b] : (this.onMaterialMapping(), this.firePropertyChange("materialMapping", a, b)))
        },
        isStyleEquals: function(a, b, c) {
            return ! 1
        },
        getSelectStyle: function() {
            var a = this.getStyle("select.style");
            return ("outline.normal" == a || "outline" == a) && (a = "outline.wireframe"),
            a
        },
        onMaterialMapping: function() {
            this.groups = e,
            this.primitive.groups = e
        }
    }),
    Yb.Terrain = function(a) {
        if (a = a || {},
        this._id = a.id, this.width = a.width, this.depth = a.depth, this.segmentsW = a.segmentsW || 30, this.segmentsD = a.segmentsD || 30, this.heightMap = a.heightMap, this.heightUnit = a.heightUnit || 1, this.maxHeight = a.maxHeight || 255, this.minHeight = a.minHeight || 0, this.baseLayerHeight = a.baseLayerHeight || 0, "string" == typeof this.heightMap ? (this.image = new Image, this.image.src = this.heightMap) : bc.isCanvas(this.heightMap) ? this.canvas = this.heightMap: bc.isImage(this.heightMap) && (this.image = this.heightMap), this.image) {
            var b = this;
            this.image.onload = function(a) {
                var c = document.createElement("canvas");
                c.width = b.image.width,
                c.height = b.image.height;
                var d = c.getContext("2d");
                d.drawImage(b.image, 0, 0),
                b.canvas = c,
                b.computed = !1,
                b.computeNodeData(),
                b.firePropertyChange("width", 0, 1)
            }
        }
        this.materialSize = 2,
        Yb.Entity.call(this),
        this.computeCentroids(),
        this.computeFaceNormals()
    },
    Yb.extend(Yb.Terrain, Yb.Entity, {
        constructor: Yb.Terrain,
        className: "TGL.Terrain",
        __accessor: ["width", "heightUnit", "depth", "segmentsW", "segmentsD", "heightMap", "heightUnit", "maxHeight", "minHeight", "baseLayerHeight", "smooth"],
        __SizePropeties: ["width", "heightUnit", "depth", "segmentsW", "segmentsD", "heightMap", "heightUnit", "maxHeight", "minHeight", "baseLayerHeight", "smooth"],
        __bool: ["smooth"],
        computeLayerData: function(a, b, c) {
            var d, e, f = this.width / 2,
            g = this.depth / 2,
            h = c ? this.segmentsW: 1,
            i = c ? this.segmentsD: 1,
            j = h + 1,
            k = i + 1,
            l = this.width / h,
            m = this.depth / i,
            n = new Yb.Vec3(0, 0, 1),
            o = a.vertices.length;
            for (e = 0; k > e; e++) for (d = 0; j > d; d++) {
                var p = d * l - f,
                q = e * m - g,
                r = 0;
                r = c ? c.call(this, d / j, e / k) : this.baseLayerHeight * this.heightUnit,
                a.vertices.push(new Yb.Vec3(p, r, q))
            }
            for (e = 0; i > e; e++) for (d = 0; h > d; d++) {
                var s = d + j * e + o,
                t = d + j * (e + 1) + o,
                u = d + 1 + j * (e + 1) + o,
                v = d + 1 + j * e + o,
                w = new Yb.Vec2(d / h, 1 - e / i),
                x = new Yb.Vec2(d / h, 1 - (e + 1) / i),
                y = new Yb.Vec2((d + 1) / h, 1 - (e + 1) / i),
                z = new Yb.Vec2((d + 1) / h, 1 - e / i);
                if (c) {
                    var A = new Yb.Face3(s, t, v);
                    A.materialIndex = b,
                    a.faces.push(A),
                    a.uvs.push([w, x, z]),
                    A = new Yb.Face3(t, u, v),
                    A.materialIndex = b,
                    a.faces.push(A),
                    a.uvs.push([x.clone(), y, z.clone()])
                } else {
                    var A = new Yb.Face4(s, t, u, v);
                    A.normal.copy(n),
                    A.vertexNormals.push(n.clone(), n.clone(), n.clone(), n.clone()),
                    A.materialIndex = b,
                    a.faces.push(A),
                    a.uvs.push([w, x, y, z])
                }
            }
        },
        computeData: function() {
            var a = {};
            return a.vertices = [],
            a.faces = [],
            a.uvs = [],
            this.computeLayerData(a, 0),
            this.computeLayerData(a, 1, this.getHeight),
            a
        },
        getFaceNormal: function(a, b) {
            this.computeFaceNormals();
            var c = this.segmentsW * a,
            d = this.segmentsD * b,
            e = Math.floor(c),
            f = Math.floor(d),
            g = f * this.segmentsW + e;
            g = 2 * g + 1,
            e != Math.round(c) && f != Math.round(d) && g++;
            var h = this.faces[g];
            return this.vertices[h.a],
            this.vertices[h.b],
            this.vertices[h.c],
            h.normal.clone()
        },
        setHeightMap: function(a) {
            if (this.heightMap = a, "string" == typeof this.heightMap ? (this.image = new Image, this.image.src = this.heightMap) : bc.isCanvas(this.heightMap) ? this.canvas = this.heightMap: bc.isImage(this.heightMap) && (this.image = this.heightMap), this.image) {
                var b = this;
                if (this.image.width) {
                    var c = document.createElement("canvas");
                    c.width = b.image.width,
                    c.height = b.image.height;
                    var d = c.getContext("2d");
                    d.drawImage(b.image, 0, 0),
                    b.canvas = c,
                    b.computed = !1,
                    b.computeNodeData(),
                    b.firePropertyChange("width", 0, 1)
                } else this.image.onload = function(a) {
                    var c = document.createElement("canvas");
                    c.width = b.image.width,
                    c.height = b.image.height;
                    var d = c.getContext("2d");
                    d.drawImage(b.image, 0, 0),
                    b.canvas = c,
                    b.computed = !1,
                    b.computeNodeData(),
                    b.firePropertyChange("width", 0, 1)
                }
            }
        },
        getHeight: function(a, b) {
            if (null == this.canvas) return 0;
            var c = this.canvas;
            if (null == this.heightData) {
                for (var d = c.width * c.height,
                e = new Float32Array(d), f = 0; d > f; f++) e[f] = 0;
                for (var g = c.getContext("2d"), h = g.getImageData(0, 0, c.width, c.height), i = h.data, j = 0, f = 0, k = i.length; k > f; f += 4) {
                    var l = i[f] + i[f + 1] + i[f + 2];
                    e[j++] = l / 3
                }
                this.heightData = e
            }
            var m = a * c.width,
            n = b * c.height,
            o = Math.floor(m),
            p = Math.floor(n),
            q = [],
            r = [];
            q.push(o),
            m != o && q.push(o + 1),
            r.push(p),
            n != p && r.push(p + 1);
            var f, j, s, t = q.length * r.length,
            u = 0;
            for (f = 0; f < q.length; f++) for (j = 0; j < r.length; j++) s = r[j] * c.width + q[f],
            u += this.heightData[s];
            return u /= t,
            u = Yb.Math.clamp(u, this.minHeight, this.maxHeight),
            u *= this.heightUnit
        },
        getSideIndexMapping: function() {
            return Yb.Terrain.SideIndexMapping
        },
        refreshUniforms: function(a) {
            a.heightUnit && (a.heightUnit.value = this.heightUnit)
        }
    }),
    Yb.Terrain.SideIndexMapping = {
        layer0: 0,
        layer1: 1
    },
    Yb.Link = function(a, b, c) {
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var d = arguments[0];
            a = d.fromNode,
            b = d.toNode,
            this._id = d.id
        } else this._id = c;
        Yb.Line.call(this),
        this.setFromNode(a),
        this.setToNode(b),
        this._editable = !1
    },
    Yb.extend(Yb.Link, Yb.Line, {
        className: "TGL.Link",
        ___accessor: ["linkType", "extend", "controls"],
        __SizePropeties: ["fromNode", "toNode", "linkType", "extend", "controls"],
        setFromNode: function(a) {
            if (this._fromNode != a) {
                var b = this._fromNode;
                this._fromNode = a,
                this.onPropertyChange(),
                this.firePropertyChange("fromNode", b, a),
                this._fromNode = a,
                b && (b._removeFromLink(this), b.removePropertyChangeListener(this.handleNodePropertyChange)),
                this._fromNode && (this._fromNode._addFromLink(this), this._fromNode.addPropertyChangeListener(this.handleNodePropertyChange, this))
            }
        },
        getFromNode: function() {
            return this._fromNode
        },
        setToNode: function(a) {
            if (this._toNode != a) {
                var b = this._toNode;
                this._toNode = a,
                this.onPropertyChange(),
                this.firePropertyChange("toNode", b, a),
                b && (b.removePropertyChangeListener(this.handleNodePropertyChange), b._removeToLink(this)),
                this._toNode && (this._toNode._addToLink(this), this._toNode.addPropertyChangeListener(this.handleNodePropertyChange, this))
            }
        },
        getToNode: function() {
            return this._toNode
        },
        isLooped: function() {
            return this._fromNode === this._toNode && null != this._fromNode && null != this._toNode
        },
        handleNodePropertyChange: function(a) {
            if (a.property.startsWith("position") || "worldMatrix" == a.property) {
                var b = this.vertices;
                this.onPropertyChange(),
                this.firePropertyChange("vertices", b, this.vertices)
            }
        },
        computeNodeData: function() {
            this.computeData()
        },
        updateMatrix: function() {},
        updateWorldMatrix: function() {},
        computeData: function() {
            if (null != this._fromNode && null != this._toNode) {
                null == this._extend && (this._extend = 0);
                var a = this._fromNode.worldMatrix.getPosition(),
                b = this._toNode.worldMatrix.getPosition(),
                c = [];
                if (c.push(a.clone()), "orthogonal.x" == this._linkType) {
                    var d = Math.max(a.x, b.x),
                    e = new $b(d + this._extend, a.y, a.z);
                    c.push(e),
                    e = new $b(d + this._extend, b.y, b.z),
                    c.push(e)
                } else if ("orthogonal.x.n" == this._linkType) {
                    var f = Math.min(a.x, b.x),
                    e = new $b(f - this._extend, a.y, a.z);
                    c.push(e),
                    e = new $b(f - this._extend, b.y, b.z),
                    c.push(e)
                } else if ("orthogonal.y" == this._linkType) {
                    var g = Math.max(a.y, b.y),
                    e = new $b(a.x, g + this._extend, a.z);
                    c.push(e),
                    e = new $b(b.x, g + this._extend, b.z),
                    c.push(e)
                } else if ("orthogonal.y.n" == this._linkType) {
                    var h = Math.min(a.y, b.y),
                    e = new $b(a.x, h - this._extend, a.z);
                    c.push(e),
                    e = new $b(b.x, h - this._extend, b.z),
                    c.push(e)
                } else if ("orthogonal.z" == this._linkType) {
                    var i = Math.max(a.z, b.z),
                    e = new $b(a.x, a.y, i + this._extend);
                    c.push(e),
                    e = new $b(b.x, b.y, i + this._extend),
                    c.push(e)
                } else if ("orthogonal.z.n" == this._linkType) {
                    var j = Math.min(a.z, b.z),
                    e = new $b(a.x, a.y, j - this._extend);
                    c.push(e),
                    e = new $b(b.x, b.y, j - this._extend),
                    c.push(e)
                } else if ("control" == this._linkType) {
                    var k = this._controls;
                    if (k && k.length > 0) for (var l = 0; l < k.length; l++) k[l] instanceof $b && c.push(k[l].clone())
                }
                c.push(b.clone()),
                this.vertices = c
            }
        },
        onPropertyChange: function() {
            this.vertices = this.vertices || [],
            this.computeData(),
            this.computeBoundingBox(),
            this.selectionData = null,
            this.boundingSphere = null
        }
    }),
    Yb.PathLink = function(a, b, c) {
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var d = arguments[0];
            a = d.fromNode,
            b = d.toNode,
            this._id = d.id
        } else this._id = c;
        Yb.PathNode.call(this),
        this._autoAjust = !0,
        this.setFromNode(a),
        this.setToNode(b)
    },
    Yb.PathLink.allLinkTypes = ["extend.x", "extend.y", "extend.z", "extend.x.n", "extend.y.n", "extend.z.n", "orthogonal.x", "orthogonal.y", "orthogonal.z", "orthogonal.x.n", "orthogonal.y.n", "orthogonal.z.n", "flex.x", "flex.y", "flex.z", "flex.yz", "flex.xz", "flex.xy"],
    Yb.extend(Yb.PathLink, Yb.PathNode, {
        className: "TGL.PathLink",
        ___accessor: ["linkType", "extend", "controls", "fromOffset", "toOffset"],
        __SizePropeties: ["fromOffset", "toOffset", "path", "segments", "radius", "segmentsR", "startCap", "endCap", "shape", "startCapSize", "endCapSize", "segmentsCap", "arc", "arcStart", "cutSurface", "startCapR", "endCapR", "startCapExtend", "endCapExtend", "fromNode", "toNode", "linkType", "extend", "controls"],
        setFromNode: function(a) {
            if (this._fromNode != a) {
                var b = this._fromNode;
                this._fromNode = a,
                this._dirtyPath = !0,
                this.onPropertyChange("fromNode", b, a),
                this.firePropertyChange("fromNode", b, a),
                this._fromNode = a,
                b && (b._removeFromLink(this), b.removePropertyChangeListener(this.handleNodePropertyChange)),
                this._fromNode && (this._fromNode._addFromLink(this), this._fromNode.addPropertyChangeListener(this.handleNodePropertyChange, this))
            }
        },
        getFromNode: function() {
            return this._fromNode
        },
        setToNode: function(a) {
            if (this._toNode != a) {
                var b = this._toNode;
                this._toNode = a,
                this.onPropertyChange("toNode", b, a),
                this.firePropertyChange("toNode", b, a),
                b && (b.removePropertyChangeListener(this.handleNodePropertyChange), b._removeToLink(this)),
                this._toNode && (this._toNode._addToLink(this), this._toNode.addPropertyChangeListener(this.handleNodePropertyChange, this))
            }
        },
        getToNode: function() {
            return this._toNode
        },
        isLooped: function() {
            return this._fromNode === this._toNode && null != this._fromNode && null != this._toNode
        },
        handleNodePropertyChange: function(a) {
            var b = a.source,
            c = a.property;
            if (c.startsWith("position") || c.startsWith("rotation") || c.startsWith("scale") || "worldMatrix" == c || "linkAgent" === c || b.isSizeChangedProperty(c) || "parent" === c) {
                this.vertices,
                this._dirtyPath = !0;
                var d = this;
                sc.PATH_LINK_COMPUTE_DELAY ? setTimeout(function() {
                    d._computePath()
                },
                10) : d._computePath()
            }
        },
        _resetPath: function() {
            if (this.path) {
                var a = !1;
                if ("arrow" !== this.endCap) return this.path;
                if (this.endCapExtend * this.endCapR > 1) return this.path;
                a = !0;
                var b, c, d, e = this.path,
                f = new Yb.Path,
                g = e.actions.length,
                h = null;
                for (c = 0; g - 1 > c; c++) b = e.actions[c],
                d = b.args,
                h = new Yb.Vec3(d[0], d[1], d[2]),
                "moveTo" === b.action ? f.moveTo(d[0], d[1], d[2]) : "lineTo" === b.action ? f.lineTo(d[0], d[1], d[2]) : "quadraticCurveTo" === b.action && (f.curveTo(d[0], d[1], d[2], d[3], d[4], d[5]), h = new Yb.Vec3(d[3], d[4], d[5]));
                if (c = g - 1, b = e.actions[c], d = b.args, "lineTo" === b.action) {
                    var i = new Yb.Vec3(d[0], d[1], d[2]),
                    j = (new $b).subVectors(i, h).normalize(),
                    g = this.radius * this.endCapSize,
                    k = null;
                    k = (new $b).subVectors(i, h).length() < g ? h.add(j.multiplyScalar(.1)) : i.clone().sub(j.multiplyScalar(g)),
                    f.lineTo(k.x, k.y, k.z)
                }
                return f
            }
        },
        _getNodeOffset: function(a, b, c) {
            b = a.worldToLocal(b.clone()),
            c = a.worldToLocal(c.clone());
            var d = (new $b).subVectors(c, b),
            e = d.length(),
            f = a.getLinkOffset(d);
            return f && f.length() > e && f.normalize().multiplyScalar(e - .1),
            f || new $b(0, 0, 0)
        },
        updateMatrix: function() {},
        updateWorldMatrix: function(a, b) {},
        onPropertyChange: function(a, b, c) { ("fromNode" === a || "toNode" === a || "linkType" === a || "extend" === a || "controls" === a || "fromOffset" === a || "toOffset" === a) && (this._dirtyPath = !0),
            Yb.Node.prototype.onPropertyChange.call(this, a, b, c)
        },
        computeData: function() {
            return this._computePath(),
            Yb.PathNode.prototype.computeData.call(this)
        },
        _clearFromNodeExtend: function(a, b, c) {},
        _flex: function(a, b, c, d, e) {
            a = a.substr(a.indexOf(".") + 1);
            for (var f, g = ["x", "y", "z"], h = new $b, i = new $b, j = 0; 3 > j; j++) f = g[j],
            h[f] = f === a ? d[f] : b[f],
            i[f] = f === a ? d[f] : c[f];
            e.push(h, i)
        },
        _flex2: function(a, b, c, d) {
            a = a.substr(a.indexOf(".") + 1);
            var e = ["x", "y", "z"],
            f = a[0],
            g = a[1];
            if (b[f] != c[f]) {
                for (var h = new mono.Vec3,
                i = 0; i < e.length; i++) h[e[i]] = e[i] == f ? c[e[i]] : b[e[i]];
                d.push(h)
            }
            if (b[g] != c[g]) {
                for (var j = new mono.Vec3,
                i = 0; i < e.length; i++) j[e[i]] = e[i] == f || e[i] == g ? c[e[i]] : b[e[i]];
                d.push(j)
            }
        },
        _orthogonal: function(a, b, c, d) {
            a = a.substr(a.indexOf(".") + 1);
            var e, f = !1,
            g = ["x", "y", "z"],
            h = new $b,
            i = 0;
            a.endsWith(".n") && (f = !0, a = a[0]);
            for (var j = f ? b[a] : c[a], k = 0; k < g.length; k++) e = g[k],
            e !== a && b[e] == c[e] && i++;
            if (2 !== i) {
                for (var k = 0; k < g.length; k++) e = g[k],
                e !== a ? h[e] = j: h[e] = f ? c[e] : b[e];
                d.push(h)
            }
        },
        _removeSamePoint: function(a) {},
        _computePath: function() {
            if (this._dirtyPath && (this._dirtyPath = !1, null != this._fromNode && null != this._toNode)) {
                null == this._extend && (this._extend = 0);
                var a = this._fromNode.getLinkAgent() || this._fromNode,
                b = this._toNode.getLinkAgent() || this._toNode,
                c = a.localToWorld2(new $b(0, 0, 0)),
                d = b.localToWorld2(new $b(0, 0, 0));
                if (a == b) {
                    var e = new mono.Path;
                    return e.moveTo(c.x, c.y, c.z),
                    e.lineTo(c.x, c.y + 200, c.z),
                    e.lineTo(c.x + 200, c.y + 200, c.z),
                    e.lineTo(c.x + 200, c.y, c.z),
                    e.lineTo(c.x, c.y, c.z),
                    this.setPath(e),
                    e
                }
                if (c.equals(d)) return void this.setPath(null);
                var e, f, g = [],
                h = this.radius * this.endCapSize;
                if (this._linkType && this._linkType.startsWith("extend")) {
                    var c, d, i, j, k, l, m;
                    if ("extend.x" === this._linkType) {
                        i = new $b(1, 0, 0);
                        var c = a.localToWorld2(a.getLinkExtend(i.clone())),
                        d = b.localToWorld2(b.getLinkExtend(i));
                        m = Math.max(c.x, d.x),
                        l = m + this._extend + h + .1,
                        j = new $b(l, c.y, c.z),
                        k = new $b(l, d.y, d.z)
                    } else if ("extend.y" === this._linkType) {
                        i = new $b(0, 1, 0);
                        var c = a.localToWorld2(a.getLinkExtend(i.clone())),
                        d = b.localToWorld2(b.getLinkExtend(i));
                        m = Math.max(c.y, d.y),
                        l = m + this._extend + h + .1,
                        j = new $b(c.x, l, c.z),
                        k = new $b(d.x, l, d.z)
                    } else if ("extend.z" === this._linkType) {
                        i = new $b(0, 0, 1);
                        var c = a.localToWorld2(a.getLinkExtend(i.clone())),
                        d = b.localToWorld2(b.getLinkExtend(i));
                        m = Math.max(c.z, d.z),
                        l = m + this._extend + h + .1,
                        j = new $b(c.x, c.y, l),
                        k = new $b(d.x, d.y, l)
                    } else if ("extend.x.n" === this._linkType) {
                        i = new $b( - 1, 0, 0);
                        var c = a.localToWorld2(a.getLinkExtend(i.clone())),
                        d = b.localToWorld2(b.getLinkExtend(i));
                        m = Math.min(c.x, d.x),
                        l = m - this._extend - h - .1,
                        j = new $b(l, c.y, c.z),
                        k = new $b(l, d.y, d.z)
                    } else if ("extend.y.n" === this._linkType) {
                        i = new $b(0, -1, 0);
                        var c = a.localToWorld2(a.getLinkExtend(i.clone())),
                        d = b.localToWorld2(b.getLinkExtend(i));
                        m = Math.min(c.y, d.y),
                        l = m - this._extend - h - .1,
                        j = new $b(c.x, l, c.z),
                        k = new $b(d.x, l, d.z)
                    } else if ("extend.z.n" === this._linkType) {
                        i = new $b(0, 0, -1);
                        var c = a.localToWorld2(a.getLinkExtend(i.clone())),
                        d = b.localToWorld2(b.getLinkExtend(i));
                        m = Math.min(c.z, d.z),
                        l = m - this._extend - h - .1,
                        j = new $b(c.x, c.y, l),
                        k = new $b(d.x, d.y, l)
                    }
                    j ? g.push(c, j, k, d) : g.push(c, d)
                } else {
                    if (g.push(c), "orthogonal.x" === this._linkType) {
                        if (c.y != d.y || c.z != d.z) {
                            var n = d.x,
                            o = new $b(n, c.y, c.z);
                            g.push(o)
                        }
                    } else if ("orthogonal.x.n" === this._linkType) {
                        var n = c.x,
                        o = new $b(n, d.y, d.z);
                        g.push(o)
                    } else if ("orthogonal.y" === this._linkType) {
                        var p = d.y,
                        o = new $b(c.x, p, c.z);
                        g.push(o)
                    } else if ("orthogonal.y.n" === this._linkType) {
                        var p = c.y,
                        o = new $b(d.x, p, d.z);
                        g.push(o)
                    } else if ("orthogonal.z" === this._linkType) {
                        var o = new $b(c.x, c.y, d.z);
                        g.push(o)
                    } else if ("orthogonal.z.n" === this._linkType) {
                        var o = new $b(d.x, d.y, c.z);
                        g.push(o)
                    }
                    var q = new $b(c.x + d.x, c.y + d.y, c.z + d.z).multiplyScalar(.5);
                    if (("flex.x" === this._linkType || "flex.y" === this._linkType || "flex.z" === this._linkType) && this._flex(this._linkType, c, d, q, g), ("flex.yz" === this._linkType || "flex.zy" === this._linkType || "flex.xy" === this._linkType || "flex.yx" === this._linkType || "flex.xz" === this._linkType || "flex.zx" === this._linkType) && this._flex2(this._linkType, c, d, g), "control" === this._linkType) {
                        var r = this.getControls();
                        tc.isArray(r) && (g = g.concat(r))
                    }
                    g.push(d),
                    f = g.length;
                    var s = this._getNodeOffset(a, g[0].clone(), g[1].clone()),
                    t = this._getNodeOffset(b, g[f - 1].clone(), g[f - 2].clone());
                    c = a.localToWorld2(s),
                    d = b.localToWorld2(t),
                    g[0] = c,
                    g[f - 1] = d
                }
                var f = g.length,
                u = this.getFromOffset(),
                v = this.getToOffset();
                u && g[0].add(u),
                v && g[f - 1].add(v);
                for (var w, e = new Yb.Path,
                x = 0; f > x; x++) w = g[x],
                0 === x ? e.moveTo(w.x, w.y, w.z) : e.lineTo(w.x, w.y, w.z);
                return this.setPath(e),
                e
            }
        }
    }),
    mono.LoadingManager = function(a, b, c) {
        var d = this,
        f = 0,
        g = 0;
        this.onLoad = a,
        this.onProgress = b,
        this.onError = c,
        this.itemStart = function(a) {
            g++
        },
        this.itemEnd = function(a) {
            f++,
            d.onProgress !== e && d.onProgress(a, f, g),
            f === g && d.onLoad !== e && d.onLoad()
        }
    },
    mono.DefaultLoadingManager = new mono.LoadingManager,
    mono.ImageLoader = function(a) {
        this.manager = a !== e ? a: mono.DefaultLoadingManager
    },
    mono.ImageLoader.prototype = {
        constructor: mono.ImageLoader,
        load: function(a, b, c, d) {
            var f = this,
            g = document.createElement("img");
            return b !== e && g.addEventListener("load",
            function(c) {
                f.manager.itemEnd(a),
                b(this)
            },
            !1),
            c !== e && g.addEventListener("progress",
            function(a) {
                c(a)
            },
            !1),
            d !== e && g.addEventListener("error",
            function(a) {
                d(a)
            },
            !1),
            this.crossOrigin !== e && (g.crossOrigin = this.crossOrigin),
            g.src = a,
            f.manager.itemStart(a),
            g
        },
        loadFile: function(a, b, c, d) {
            var f = this,
            g = new FileReader;
            b !== e && (g.onload = function() {
                b(g.result),
                f.manager.itemEnd(a.name)
            }),
            c !== e && g.addEventListener("progress",
            function(a) {
                c(a)
            },
            !1),
            d !== e && g.addEventListener("error",
            function(a) {
                d(a)
            },
            !1),
            g.readAsDataURL(a),
            f.manager.itemStart(a.name)
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        }
    },
    mono.XHRLoader = function(a) {
        this.manager = a !== e ? a: mono.DefaultLoadingManager
    },
    mono.XHRLoader.prototype = {
        constructor: mono.XHRLoader,
        load: function(a, b, c, d) {
            var f = this,
            g = new XMLHttpRequest;
            b !== e && g.addEventListener("load",
            function(c) {
                b(c.target.responseText),
                f.manager.itemEnd(a)
            },
            !1),
            c !== e && g.addEventListener("progress",
            function(a) {
                c(a)
            },
            !1),
            d !== e && g.addEventListener("error",
            function(a) {
                d(a)
            },
            !1),
            this.crossOrigin !== e && (g.crossOrigin = this.crossOrigin),
            g.open("GET", a, !0),
            g.send(null),
            f.manager.itemStart(a)
        },
        loadFile: function(a, b, c, d) {
            if (a) {
                var f = this,
                g = new FileReader;
                b !== e && (g.onload = function() {
                    b(g.result),
                    f.manager.itemEnd(a.name)
                }),
                c !== e && g.addEventListener("progress",
                function(a) {
                    c(a)
                },
                !1),
                d !== e && g.addEventListener("error",
                function(a) {
                    d(a)
                },
                !1),
                g.readAsText(a),
                f.manager.itemStart(a.name)
            }
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        }
    },
    mono.MTLLoader = function(a, b, c) {
        this.baseUrl = a,
        this.options = b,
        this.crossOrigin = c
    },
    mono.extend(mono.MTLLoader, null, {
        constructor: mono.MTLLoader,
        load: function(a, b, c, d) {
            var e = this,
            f = new mono.XHRLoader;
            f.setCrossOrigin(this.crossOrigin),
            f.load(a,
            function(a) {
                b(e.parse(a))
            })
        },
        loadFile: function(a, b, c, d) {
            var e = this,
            f = new mono.XHRLoader;
            f.loadFile(a,
            function(a) {
                b(e.parse(a))
            })
        },
        loadText: function(a, b) {
            b(this.parse(a))
        },
        parse: function(a) {
            var b = a.split("\n"),
            c = {},
            d = /\s+/,
            e = {};
            this.baseUrl || (this.baseUrl = {});
            for (var f = 0; f < b.length; f++) {
                var g = b[f];
                if (g = g.trim(), 0 !== g.length && "#" !== g.charAt(0)) {
                    var h = g.indexOf(" "),
                    i = h >= 0 ? g.substring(0, h) : g;
                    i = i.toLowerCase();
                    var j = h >= 0 ? g.substring(h + 1) : "";
                    if (j = j.trim(), "newmtl" === i) c = {
                        name: j
                    },
                    e[j] = c;
                    else if (c) if ("ka" === i || "kd" === i || "ks" === i) {
                        var k = j.split(d, 3);
                        c[i] = [parseFloat(k[0]), parseFloat(k[1]), parseFloat(k[2])]
                    } else if ("map_kd" === i || "map_ka" === i) {
                        var l = j;
                        if (j.indexOf(".") > 0) {
                            j = j.substring(0, j.lastIndexOf(".")).toLowerCase();
                            var m = {};
                            if (/\-s/.test(j)) {
                                var n = /\-s( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
                                m = n.exec(j);
                                var o = j.split(m[0]);
                                j = o[o.length - 1].trim();
                                var p = l.split(m[0]);
                                l = p[p.length - 1].trim()
                            }
                            if (/\-t/.test(j)) {
                                var n = /\-t( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
                                m = n.exec(j);
                                var o = j.split(m[0]);
                                j = o[o.length - 1].trim();
                                var p = l.split(m[0]);
                                l = p[p.length - 1].trim()
                            }
                        }
                        this.baseUrl[j] = l,
                        c[i] = l
                    } else c[i] = j
                }
            }
            var q = new mono.MTLLoader.MaterialCreator(this.baseUrl, this.options);
            return q.setMaterials(e),
            q
        }
    }),
    mono.MTLLoader.MaterialCreator = function(a, b) {
        this.baseUrl = a,
        this.options = b,
        this.materialsInfo = {},
        this.materials = {},
        this.materialsArray = [],
        this.nameLookup = {},
        this.side = this.options && this.options.side ? this.options.side: mono.FrontSide,
        this.wrap = this.options && this.options.wrap ? this.options.wrap: mono.RepeatWrapping
    },
    mono.extend(mono.MTLLoader.MaterialCreator, mono.EventDispatcher, {
        constructor: mono.MTLLoader.MaterialCreator,
        setMaterials: function(a) {
            this.materialsInfo = this.convert(a),
            this.materials = {},
            this.materialsArray = [],
            this.nameLookup = {}
        },
        convert: function(a) {
            if (!this.options) return a;
            var b = {};
            for (var c in a) {
                var d = a[c],
                e = {};
                b[c] = e;
                for (var f in d) {
                    var g = !0,
                    h = d[f],
                    i = f.toLowerCase();
                    switch (i) {
                    case "kd":
                    case "ka":
                    case "ks":
                        this.options && this.options.normalizeRGB && (h = [h[0] / 255, h[1] / 255, h[2] / 255]),
                        this.options && this.options.ignoreZeroRGBs && 0 === h[0] && 0 === h[1] && 0 === h[1] && (g = !1);
                        break;
                    case "d":
                        this.options && this.options.invertTransparency && (h = 1 - h)
                    }
                    g && (e[i] = h)
                }
            }
            return b
        },
        preload: function() {
            for (var a in this.materialsInfo) this.create(a)
        },
        getIndex: function(a) {
            return this.nameLookup[a]
        },
        getAsArray: function() {
            var a = 0;
            for (var b in this.materialsInfo) this.materialsArray[a] = this.create(b),
            this.nameLookup[b] = a,
            a++;
            return this.materialsArray
        },
        create: function(a) {
            return this.materials[a] === e && this.createMaterial_(a),
            this.materials[a]
        },
        createMaterial_: function(a) {
            var b = this,
            c = this.materialsInfo[a],
            d = {
                name: a,
                side: this.side
            };
            for (var e in c) {
                var f = c[e];
                switch (e.toLowerCase()) {
                case "kd":
                    d.diffuse = (new mono.Color).setRGB(f[0], f[1], f[2]);
                    break;
                case "ka":
                    d.ambient = (new mono.Color).setRGB(f[0], f[1], f[2]);
                    break;
                case "ks":
                    d.specular = (new mono.Color).setRGB(f[0], f[1], f[2]);
                    break;
                case "map_kd":
                    if ("string" == typeof this.baseUrl) d.map = {},
                    d.map.img = this.baseUrl + f,
                    d.map.wrapS = this.wrap,
                    d.map.wrapT = this.wrap;
                    else if ("object" == typeof this.baseUrl && f.indexOf(".") > 0) {
                        f = f.substring(0, f.lastIndexOf(".")).toLowerCase();
                        var g = {};
                        if (/\-s/.test(f)) {
                            var h = /\-s( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
                            g = h.exec(f);
                            var i = f.split(g[0]);
                            f = i[i.length - 1].trim(),
                            g.repeatR = parseInt(g[1]),
                            g.repeatC = parseInt(g[2])
                        }
                        if (/\-t/.test(f)) {
                            var h = /\-t( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
                            g = h.exec(f);
                            var i = f.split(g[0]);
                            f = i[i.length - 1].trim(),
                            g.repeatR = parseInt(g[1]),
                            g.repeatC = parseInt(g[2])
                        }
                        this.baseUrl[f] && (d.map = {},
                        d.map.img = this.baseUrl[f], d.map.wrapS = b.wrap, d.map.wrapT = b.wrap, d.map.repeatR = g.repeatR || 1, d.map.repeatC = g.repeatC || 1)
                    }
                    break;
                case "ns":
                    d.shininess = f;
                    break;
                case "d":
                    1 > f && (d.transparent = !0, d.opacity = f)
                }
            }
            return d.diffuse && (d.ambient || (d.ambient = d.diffuse), d.color = d.diffuse),
            this.materials[a] = d,
            this.materials[a]
        },
        loadTexture: function(a, b, c, d) {
            var e = /\.dds$/i.test(a);
            if (e) var f = mono.ImageUtils.loadCompressedTexture(a, b, c, d);
            else {
                var g = new Image,
                f = new mono.Texture(g, b),
                h = new mono.ImageLoader;
                h.crossOrigin = this.crossOrigin,
                h.load(a,
                function(a) {
                    f.image = mono.MTLLoader.ensurePowerOfTwo_(a),
                    f.needsUpdate = !0,
                    c && c(f)
                })
            }
            return f
        }
    }),
    mono.MTLLoader.ensurePowerOfTwo_ = function(a) {
        if (!mono.MTLLoader.isPowerOfTwo_(a.width) || !mono.MTLLoader.isPowerOfTwo_(a.height)) {
            var b = document.createElement("canvas");
            b.width = mono.MTLLoader.nextHighestPowerOfTwo_(a.width),
            b.height = mono.MTLLoader.nextHighestPowerOfTwo_(a.height);
            var c = b.getContext("2d");
            return c.drawImage(a, 0, 0, a.width, a.height, 0, 0, b.width, b.height),
            b
        }
        return a
    },
    mono.MTLLoader.isPowerOfTwo_ = function(a) {
        return 0 === (a & a - 1)
    },
    mono.MTLLoader.nextHighestPowerOfTwo_ = function(a) {--a;
        for (var b = 1; 32 > b; b <<= 1) a |= a >> b;
        return a + 1
    },
    mono.OBJLoader = function(a) {
        this.manager = a !== e ? a: mono.DefaultLoadingManager
    },
    mono.extend(mono.OBJLoader, Object, {
        constructor: mono.ObJLoader,
        load: function(a, b, c, d) {
            var e = this,
            f = new mono.XHRLoader(e.manager);
            f.setCrossOrigin(this.crossOrigin),
            f.load(a,
            function(a) {
                b(e.parse(a))
            })
        },
        parse: function(a) {
            function b(a, b, c) {
                return new mono.Vec3(a, b, c)
            }
            function c(a, b) {
                return new mono.Vec2(a, b)
            }
            function d(a, b, c, d) {
                return new mono.Face3(a, b, c, d)
            }
            function f(a, b, c, f) {
                f === e ? i.faces.push(d(parseInt(a) - (l + 1), parseInt(b) - (l + 1), parseInt(c) - (l + 1))) : i.faces.push(d(parseInt(a) - (l + 1), parseInt(b) - (l + 1), parseInt(c) - (l + 1), [n[parseInt(f[0]) - 1].clone(), n[parseInt(f[1]) - 1].clone(), n[parseInt(f[2]) - 1].clone()]))
            }
            function g(a, b, c) {
                i.uvs.push([o[parseInt(a) - 1].clone(), o[parseInt(b) - 1].clone(), o[parseInt(c) - 1].clone()])
            }
            function h(a, b, c) {
                a[3] === e ? (f(a[0], a[1], a[2], c), b !== e && b.length > 0 && g(b[0], b[1], b[2])) : (c !== e && c.length > 0 ? (f(a[0], a[1], a[3], [c[0], c[1], c[3]]), f(a[1], a[2], a[3], [c[1], c[2], c[3]])) : (f(a[0], a[1], a[3]), f(a[1], a[2], a[3])), b !== e && b.length > 0 && (g(b[0], b[1], b[3]), g(b[1], b[2], b[3])))
            }
            var i, j, k = new mono.Element,
            l = 0;
            /^o /gm.test(a) === !1 && (i = new mono.Entity, j = new mono.BasicMaterial, i.setStyle("m.type", "phong"), k.addChild(i));
            for (var m = 0,
            n = [], o = [], p = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, q = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, r = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, s = /f( +\d+)( +\d+)( +\d+)( +\d+)?/, t = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, u = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, v = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, w = a.split("\n"), x = 0; x < w.length; x++) {
                var y = w[x];
                y = y.trim();
                var z;
                0 !== y.length && "#" !== y.charAt(0) && (null !== (z = p.exec(y)) ? i.vertices.push(b(parseFloat(z[1]), parseFloat(z[2]), parseFloat(z[3]))) : null !== (z = q.exec(y)) ? n.push(b(parseFloat(z[1]), parseFloat(z[2]), parseFloat(z[3]))) : null !== (z = r.exec(y)) ? o.push(c(parseFloat(z[1]), parseFloat(z[2]))) : null !== (z = s.exec(y)) ? h([z[1], z[2], z[3], z[4]]) : null !== (z = t.exec(y)) ? h([z[2], z[5], z[8], z[11]], [z[3], z[6], z[9], z[12]]) : null !== (z = u.exec(y)) ? h([z[2], z[6], z[10], z[14]], [z[3], z[7], z[11], z[15]], [z[4], z[8], z[12], z[16]]) : null !== (z = v.exec(y)) ? h([z[2], z[5], z[8], z[11]], [], [z[3], z[6], z[9], z[12]]) : /^o /.test(y) ? (i !== e && (l += i.vertices.length), i = new mono.Entity, j = new mono.BasicMaterial, i.setStyle("m.type", "phong"), i._name = y.substring(2).trim(), k.addChild(i), m = 0) : /^g /.test(y) || (/^usemtl /.test(y) ? y.substring(7).trim() : /^mtllib /.test(y) || /^s /.test(y)))
            }
            for (var x = 0,
            A = k._childList._as.length; A > x; x++) {
                var i = k._childList._as[x];
                i.computed = !1,
                i.computeNodeData(),
                i.computeCentroids(),
                i.computeFaceNormals(),
                i.computeBoundingSphere()
            }
            return k
        }
    }),
    mono.OBJMTLLoader = function() {},
    mono.extend(mono.OBJMTLLoader, mono.MTLLoader, {
        constructor: mono.OBJMTLLoader,
        load: function(a, b, c, d, e, f) {
            var g = this,
            h = new mono.MTLLoader(c);
            h.load(b,
            function(b) {
                var e = b;
                e.preload();
                var f = new mono.XHRLoader(g.manager);
                f.setCrossOrigin(this.crossOrigin),
                f.load(a,
                function(b) {
                    var f = g.parse(b),
                    h = ""; ! c && a.lastIndexOf("/") > 0 && (h = a.substring(0, a.lastIndexOf("/") + 1));
                    for (var i = 0; i < f._childList._as.length; i++) {
                        var j = f._childList._as[i];
                        if (j.mname) {
                            var k = e.create(j.mname);
                            g.setGeometryStyle(j, k, h)
                        }
                        for (var l = 0; l < j._childList._as.length; l++) {
                            var m = j._childList._as[l];
                            if (m.mname) {
                                var n = e.create(m.mname);
                                g.setGeometryStyle(m, n, h)
                            }
                        }
                    }
                    d(f)
                })
            })
        },
        setGeometryStyle: function(a, b, c) {
            if (b.map) {
                this.loadTexture(a, c + b.map.img);
                var d = b.map.repeatR,
                e = b.map.repeatC;
                d && e && a.setStyle("m.texture.repeat", new mono.Vec2(d, e))
            }
            a.setStyle("m.ambient", b.ambient),
            a.setStyle("m.specular", b.specular),
            a.setStyle("m.color", b.color),
            b.transparent && (a.setStyle("m.transparent", !0), a.setStyle("m.opacity", b.opacity))
        },
        loadBase64: function(a, b, c, d, e, f) {
            var g = this,
            h = mono.base64decode(b),
            i = mono.base64decode(a),
            j = new mono.MTLLoader(c);
            j.loadText(h,
            function(a) {
                var b = a;
                b.preload();
                var e = g.parse(i),
                f = ""; ! c && url.lastIndexOf("/") > 0 && (f = url.substring(0, url.lastIndexOf("/") + 1));
                for (var h = 0; h < e._childList._as.length; h++) {
                    var j = e._childList._as[h];
                    if (j.mname) {
                        var k = b.create(j.mname);
                        g.setGeometryStyle(j, k, f)
                    }
                    for (var l = 0; l < j._childList._as.length; l++) {
                        var m = j._childList._as[l];
                        if (m.mname) {
                            var n = b.create(m.mname);
                            g.setGeometryStyle(m, n, f)
                        }
                    }
                }
                d(e)
            })
        },
        loadFiles: function(a, b, c, d, e, f) {
            var g = this,
            h = new mono.MTLLoader(c);
            h.loadFile(b,
            function(b) {
                var c = b;
                c.preload();
                var e = new mono.XHRLoader(g.manager);
                e.loadFile(a,
                function(a) {
                    for (var b = g.parse(a), e = 0; e < b._childList._as.length; e++) {
                        var f = b._childList._as[e];
                        if (f.mname) {
                            var h = c.create(f.mname);
                            g.setGeometryStyle(f, h)
                        }
                        for (var i = 0; i < f._childList._as.length; i++) {
                            var j = f._childList._as[i];
                            if (j.mname) {
                                var k = c.create(j.mname);
                                g.setGeometryStyle(j, k)
                            }
                        }
                    }
                    d(b)
                })
            })
        },
        loadTexture: function(a, b) {
            if ("string" == typeof b) a.setStyle("m.texture.image", b);
            else if (a && b) {
                var c = new mono.ImageLoader;
                c.loadFile(b,
                function(b) {
                    a.setStyle("m.texture.image", b)
                })
            }
        },
        parse: function(a, b) {
            function c(a, b, c) {
                return new mono.Vec3(a, b, c)
            }
            function d(a, b) {
                return new mono.Vec2(a, b)
            }
            function f(a, b, c, d) {
                return new mono.Face3(a, b, c, d)
            }
            function g(a, b) {
                if (o.length > 0 && (n.vertices = o, n.computed = !1, n.computeCentroids(), n.computeFaceNormals(), n.computeBoundingSphere(), n.faces.length > 0)) {
                    var c = n._name;
                    m.addChild(n),
                    n = new mono.Entity,
                    n._name = c,
                    n.setStyle("m.type", "phong"),
                    p = 0
                }
                a !== e && (n._name = a),
                b !== e && (n.mname = b)
            }
            function h(a, b, c, d) {
                d === e ? n.faces.push(f(parseInt(a) - (k + 1), parseInt(b) - (k + 1), parseInt(c) - (k + 1))) : n.faces.push(f(parseInt(a) - (k + 1), parseInt(b) - (k + 1), parseInt(c) - (k + 1), [q[parseInt(d[0]) - 1].clone(), q[parseInt(d[1]) - 1].clone(), q[parseInt(d[2]) - 1].clone()]))
            }
            function i(a, b, c) {
                n.uvs.push([r[parseInt(a) - 1].clone(), r[parseInt(b) - 1].clone(), r[parseInt(c) - 1].clone()])
            }
            function j(a, b, c) {
                a[3] === e ? (h(a[0], a[1], a[2], c), b !== e && b.length > 0 && i(b[0], b[1], b[2])) : (c !== e && c.length > 0 ? (h(a[0], a[1], a[3], [c[0], c[1], c[3]]), h(a[1], a[2], a[3], [c[1], c[2], c[3]])) : (h(a[0], a[1], a[3]), h(a[1], a[2], a[3])), b !== e && b.length > 0 && (i(b[0], b[1], b[3]), i(b[1], b[2], b[3])))
            }
            var k = 0,
            l = new mono.Entity,
            m = l,
            n = new mono.Entity;
            n.setStyle("m.type", "phong");
            for (var o = [], p = 0, q = [], r = [], s = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, t = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, u = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, v = /f( +\d+)( +\d+)( +\d+)( +\d+)?/, w = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, x = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, y = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, z = a.split("\n"), A = 0; A < z.length; A++) {
                var B = z[A];
                B = B.trim();
                var C;
                if (0 !== B.length && ("#" !== B.charAt(0) || "o" == B.charAt(2))) if (null !== (C = s.exec(B))) o.push(c(parseFloat(C[1]), parseFloat(C[2]), parseFloat(C[3])));
                else if (null !== (C = t.exec(B))) q.push(c(parseFloat(C[1]), parseFloat(C[2]), parseFloat(C[3])));
                else if (null !== (C = u.exec(B))) r.push(d(parseFloat(C[1]), parseFloat(C[2])));
                else if (null !== (C = v.exec(B))) j([C[1], C[2], C[3], C[4]]);
                else if (null !== (C = w.exec(B))) j([C[2], C[5], C[8], C[11]], [C[3], C[6], C[9], C[12]]);
                else if (null !== (C = x.exec(B))) j([C[2], C[6], C[10], C[14]], [C[3], C[7], C[11], C[15]], [C[4], C[8], C[12], C[16]]);
                else if (null !== (C = y.exec(B))) j([C[2], C[5], C[8], C[11]], [], [C[3], C[6], C[9], C[12]]);
                else if ("#" === B.charAt(0) && "o" === B.charAt(2)) g(),
                k += o.length,
                o = [],
                m = new mono.Entity,
                m._name = B.substring(2).trim(),
                l.addChild(m);
                else if (/^g /.test(B)) g(B.substring(2).trim(), e);
                else if (/^usemtl /.test(B)) g(e, B.substring(7).trim());
                else if (/^mtllib /.test(B)) {
                    if (b) {
                        var D = B.substring(7);
                        D = D.trim(),
                        b(D)
                    }
                } else / ^s / .test(B)
            }
            return g(e, e),
            l
        }
    }),
    DaeAdapter = mono.DaeAdapter = function() {
        function a(a, c, d) {
            var f = 0;
            if (a !== e) {
                var g = a.split("/");
                g.pop(),
                Y = (g.length < 1 ? ".": g.join("/")) + "/"
            }
            var h = new XMLHttpRequest;
            h.onreadystatechange = function() {
                if (4 == h.readyState) {
                    if (0 == h.status || 200 == h.status) if (h.responseXML) b(h.responseXML, c, a);
                    else if (h.responseText) {
                        var e = new DOMParser,
                        g = e.parseFromString(h.responseText, "application/xml");
                        b(g, c, a)
                    } else console.error("ColladaLoader: Empty or non-existing file (" + a + ")")
                } else 3 == h.readyState && d && (0 == f && (f = h.getResponseHeader("Content-Length")), d({
                    total: f,
                    loaded: h.responseText.length
                }))
            },
            h.open("GET", a, !0),
            h.send(null)
        }
        function b(a, b, e) {
            Q = a,
            C(),
            V = m(),
            T = new h,
            T.parse();
            var f = O();
            if (X = E(), W = G(), $ = d(), T) for (var g = 0; g < T.nodes.length; g++) c(T.nodes[g]);
            var i = {
                lights: f,
                visualScenes: T,
                images: X,
                materials: $,
                geometries: V,
                entityies: Z
            };
            b && b(i)
        }
        function c(a, b) {
            if (a) {
                for (var d = {},
                e = 0; e < a.geometries.length; e++) {
                    var f, g = a.geometries[e],
                    h = g.instance_material,
                    i = V[g.url],
                    j = {},
                    k = [],
                    l = 0;
                    if (i) {
                        if (!i.mesh || !i.mesh.primitives) continue;
                        if (h) for (var m = 0; m < h.length; m++) {
                            var n = h[m],
                            o = $[n.target],
                            p = o.instance_effect.url,
                            q = W[p].shader,
                            r = q.material;
                            if (i.doubleSided) {
                                if (! (n.symbol in d)) {
                                    var s = r.clone();
                                    s.side = mono.DoubleSide,
                                    d[n.symbol] = s
                                }
                                r = d[n.symbol]
                            }
                            r.opacity = r.opacity ? r.opacity: 1,
                            j[n.symbol] = l,
                            k.push(r),
                            f = r,
                            f.name = null == o.name || "" === o.name ? o.id: o.name,
                            l++
                        }
                        var t = f || new mono.LambertMaterial({
                            color: 14540253,
                            shading: mono.FlatShading,
                            side: i.doubleSided ? mono.DoubleSide: mono.FrontSide
                        }),
                        u = i.mesh.node3D;
                        if (l > 1) for (t = new mono.ArrayMaterial(k), m = 0; m < u.faces.length; m++) {
                            var v = u.faces[m];
                            v.materialIndex = j[v.daeMaterial]
                        }
                        t instanceof mono.ArrayMaterial && u.setMaterialSize(t.materials.length),
                        u.createMaterial(t),
                        u.matrix = a.matrix,
                        u.matrix.decompose(u._position, u.quaternion, u.scale);
                        var w = u.quaternion;
                        if (w) {
                            var x = w.x * w.x,
                            y = w.y * w.y,
                            z = w.z * w.z,
                            A = w.w * w.w;
                            u._rotation.x = Math.atan2(2 * (w.x * w.w - w.y * w.z), A - x - y + z),
                            u._rotation.y = Math.asin(mono.Math.clamp(2 * (w.x * w.z + w.y * w.w), -1, 1)),
                            u._rotation.z = Math.atan2(2 * (w.z * w.w - w.x * w.y), A + x - y - z)
                        }
                        Z.push(u)
                    }
                }
                for (var m = 0; m < a.nodes.length; m++) c(a.nodes[m], a)
            }
        }
        function d() {
            var a = Q.querySelectorAll("library_materials material"),
            b = {};
            if (a && a.length > 0) for (var c = 0; c < a.length; c++) {
                var d = a[c];
                if (d) {
                    var e = (new f).parse(d);
                    e && (b[e.id] = e)
                }
            }
            return b
        }
        function f() {
            this.id = "",
            this.name = "",
            this.instance_effect = null
        }
        function g() {
            this.url = ""
        }
        function h() {
            this.nodes = [],
            this.id = "",
            this.name = ""
        }
        function i() {
            this.nodes = [],
            this.id = "",
            this.name = "",
            this.sid = "",
            this.type = "",
            this.controllers = [],
            this.geometries = [],
            this.type = "",
            this.layer = "",
            this.matrix = new mono.Mat4,
            this.transforms = []
        }
        function j() {
            this.sid = "",
            this.type = "",
            this.data = []
        }
        function k() {
            this.url = "",
            this.instance_material = []
        }
        function l() {
            this.symbol = "",
            this.target = ""
        }
        function m() {
            var a = {};
            a.entity = [];
            var b = Q.querySelectorAll("library_geometries geometry");
            if (b && b.length > 0) for (var c = 0; c < b.length; c++) {
                var d = (new n).parse(b[c]);
                d && (a[d.id] = d, a.entity.push(d))
            }
            return a
        }
        function n() {
            this.id = "",
            this.mesh = null
        }
        function o() {
            this.sources = {},
            this.primitives = [],
            this.vertices = null,
            this.node3D = null
        }
        function p(a, b) {
            var c = [a[b], a[b + 1], a[b + 2]];
            return q(c, -1),
            new mono.Vec3(c[0], c[1], c[2])
        }
        function q(a, b) {
            if (_.convertUpAxis === !0 && R !== _.upAxis) switch (S) {
            case "XtoY":
                var c = a[0];
                a[0] = b * a[1],
                a[1] = c;
                break;
            case "XtoZ":
                var c = a[2];
                a[2] = a[1],
                a[1] = a[0],
                a[0] = c;
                break;
            case "YtoX":
                var c = a[0];
                a[0] = a[1],
                a[1] = b * c;
                break;
            case "YtoZ":
                var c = a[1];
                a[1] = b * a[2],
                a[2] = c;
                break;
            case "ZtoX":
                var c = a[0];
                a[0] = a[1],
                a[1] = a[2],
                a[2] = c;
                break;
            case "ZtoY":
                var c = a[1];
                a[1] = a[2],
                a[2] = b * c
            }
        }
        function r() {
            this.id = "",
            this.input = {}
        }
        function s() {
            this.semantic = "",
            this.offset = 0,
            this.source = "",
            this.set = 0
        }
        function t() {
            this.inputs = [],
            this.count = 0,
            this.p = [],
            this.material = ""
        }
        function u() {
            t.call(this),
            this.vcount = 3
        }
        function v() {
            this.id,
            this.dataType,
            this.technique_common = {},
            this.accessor = null,
            this.data = []
        }
        function w() {
            this.source = "",
            this.count = 0,
            this.stride = 0,
            this.params = []
        }
        function x(a) {
            return a ? parseInt(a, 10) : 0
        }
        function y(a) {
            return a.replace(/^\s+/, "").replace(/\s+$/, "")
        }
        function z(a) {
            var b = [];
            if (!a) return a;
            if (a = y(a), a.length > 0) for (var c = a.split(/\s+/), d = 0; d < c.length; d++) {
                var f = c[d];
                f != e && null != f && null != parseFloat(f) && b.push(parseFloat(f))
            }
            return b
        }
        function A(a) {
            var b = [];
            if (!a) return [];
            if (a = y(a), a.length > 0) for (var c = a.split(/\s+/), d = 0; d < c.length; d++) {
                var f = c[d];
                f != e && null != f && null != parseInt(f) && b.push(parseInt(f))
            }
            return b
        }
        function B(a) {
            var b = [];
            if (!a) return [];
            if (a = y(a), a.length > 0) for (var c = a.split(/\s+/), d = 0; d < c.length; d++) b.push("true" == c[d] || "1" == c[d] ? !0 : !1);
            return b
        }
        function C() {
            if (_.convertUpAxis !== !0 || R === _.upAxis) S = null;
            else switch (R) {
            case "X":
                S = "Y" === _.upAxis ? "XtoY": "XtoZ";
                break;
            case "Y":
                S = "X" === _.upAxis ? "YtoX": "YtoZ";
                break;
            case "Z":
                S = "X" === _.upAxis ? "ZtoX": "ZtoY"
            }
        }
        function D(a) {
            if (_.convertUpAxis) {
                var b = [a[0], a[4], a[8]];
                q(b, -1),
                a[0] = b[0],
                a[4] = b[1],
                a[8] = b[2],
                b = [a[1], a[5], a[9]],
                q(b, -1),
                a[1] = b[0],
                a[5] = b[1],
                a[9] = b[2],
                b = [a[2], a[6], a[10]],
                q(b, -1),
                a[2] = b[0],
                a[6] = b[1],
                a[10] = b[2],
                b = [a[0], a[1], a[2]],
                q(b, -1),
                a[0] = b[0],
                a[1] = b[1],
                a[2] = b[2],
                b = [a[4], a[5], a[6]],
                q(b, -1),
                a[4] = b[0],
                a[5] = b[1],
                a[6] = b[2],
                b = [a[8], a[9], a[10]],
                q(b, -1),
                a[8] = b[0],
                a[9] = b[1],
                a[10] = b[2],
                b = [a[3], a[7], a[11]],
                q(b, -1),
                a[3] = b[0],
                a[7] = b[1],
                a[11] = b[2]
            }
            return new mono.Mat4(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15])
        }
        function E() {
            var a = Q.querySelectorAll("library_images image"),
            b = {};
            if (a && a.length > 0) for (var c = 0; c < a.length; c++) {
                var d = a[c];
                if (d) {
                    var e = (new F).parse(d);
                    b[e.id] = e
                }
            }
            return b
        }
        function F() {
            this.id = "",
            this.init_from = ""
        }
        function G() {
            var a = Q.querySelectorAll("library_effects effect"),
            b = {};
            if (a && a.length > 0) for (var c = 0; c < a.length; c++) {
                var d = a[c];
                if (d) {
                    var e = (new H).parse(d);
                    b[e.id] = e
                }
            }
            return b
        }
        function H() {
            this.id = "",
            this.name = "",
            this.shader = null,
            this.surface = {},
            this.sampler = {}
        }
        function I(a, b) {
            this.type = a,
            this.effect = b,
            this.material = null
        }
        function J() {
            this.color = new mono.Color,
            this.color.setRGB(Math.random(), Math.random(), Math.random()),
            this.color.a = 1,
            this.texture = null,
            this.texcoord = null,
            this.texOpts = null
        }
        function K(a) {
            this.effect = a,
            this.init_from = null,
            this.format = null
        }
        function L(a) {
            this.effect = a,
            this.source = null,
            this.wrap_s = null,
            this.wrap_t = null,
            this.minfilter = null,
            this.magfilter = null,
            this.mipfilter = null
        }
        function M(a) {
            for (var b = Q.querySelectorAll("library_nodes node"), c = 0; c < b.length; c++) {
                var d = b[c].attributes.getNamedItem("id");
                if (d && d.value === a) return b[c]
            }
            return e
        }
        function N(a, b) {
            a.doubleSided = !1;
            var c = b.querySelectorAll("extra double_sided")[0];
            c && c && 1 === parseInt(c.textContent, 10) && (a.doubleSided = !0)
        }
        function O() {
            var a = [],
            b = Q.querySelectorAll("library_lights light");
            if (b && b.length > 0) for (var c = 0; c < b.length; c++) {
                var d = (b[c], (new P).parse(b));
                a.push(d)
            }
            return a
        }
        function P() {
            this.id = "",
            this.name = "",
            this.technique = ""
        }
        this.id = "",
        this.name = "",
        this.type = "";
        var Q = null,
        R = "Y",
        S = null,
        T = null,
        U = {},
        V = {},
        W = {},
        X = {},
        Y = "",
        Z = [],
        $ = {},
        _ = {};
        return f.prototype.parse = function(a) {
            this.id = a.getAttribute("id"),
            this.name = a.getAttribute("name");
            for (var b = 0; b < a.childNodes.length; b++) if ("instance_effect" == a.childNodes[b].nodeName) {
                this.instance_effect = (new g).parse(a.childNodes[b]);
                break
            }
            return this
        },
        g.prototype.parse = function(a) {
            return this.url = a.getAttribute("url").replace(/^#/, ""),
            this
        },
        h.prototype.parse = function() {
            var a = Q.querySelectorAll("library_visual_scenes visual_scene");
            if (!a || a.length < 0) return this;
            this.id = "",
            this.name = "";
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                if (c && c.childNodes && c.childNodes.length > 0) for (var d = 0; d < c.childNodes.length; d++) {
                    var e = c.childNodes[d];
                    if (e && e.nodeName) switch (e.nodeName) {
                    case "node":
                        this.nodes.push((new i).parse(e))
                    }
                }
            }
            return this
        },
        i.prototype.parse = function(a) {
            if (!a) return this;
            if (this.id = a.getAttribute("id"), this.sid = a.getAttribute("sid"), this.name = a.getAttribute("name"), this.type = a.getAttribute("type"), this.layer = a.getAttribute("layer"), this.type = "JOINT" == this.type ? this.type: "NODE", a.childNodes.length > 0) for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (c && c.nodeName) switch (c.nodeName) {
                case "node":
                    this.nodes.push((new i).parse(c));
                    break;
                case "instance_camera":
                    break;
                case "instance_controller":
                    break;
                case "instance_geometry":
                    this.geometries.push((new k).parse(c));
                    break;
                case "instance_light":
                    break;
                case "instance_node":
                    var d = c.getAttribute("url").replace(/^#/, ""),
                    e = M(d);
                    e && this.nodes.push((new i).parse(e));
                    break;
                case "rotate":
                case "translate":
                case "scale":
                case "matrix":
                case "lookat":
                case "skew":
                    this.transforms.push((new j).parse(c));
                    break;
                case "extra":
                    break;
                default:
                    console.log(c.nodeName)
                }
            }
            return this.updateMatrix(),
            this
        },
        i.prototype.updateMatrix = function() {
            this.matrix.identity();
            for (var a = 0; a < this.transforms.length; a++) this.transforms[a].apply(this.matrix)
        },
        j.prototype.parse = function(a) {
            return this.sid = a.getAttribute("sid"),
            this.type = a.nodeName,
            this.data = z(a.textContent),
            this.convert(),
            this
        },
        j.prototype.convert = function() {
            switch (this.type) {
            case "matrix":
                this.obj = D(this.data);
                break;
            case "rotate":
                this.angle = mono.Math.degToRad(this.data[3]);
            case "translate":
                q(this.data, -1),
                this.obj = new mono.Vec3(this.data[0], this.data[1], this.data[2]);
                break;
            case "scale":
                q(this.data, 1),
                this.obj = new mono.Vec3(this.data[0], this.data[1], this.data[2]);
                break;
            default:
                console.log("Can not convert Transform of type " + this.type)
            }
        },
        j.prototype.apply = function() {
            var a = new mono.Mat4;
            return function(b) {
                switch (this.type) {
                case "matrix":
                    b.multiply(this.obj);
                    break;
                case "translate":
                    b.multiply(a.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
                    break;
                case "rotate":
                    b.multiply(a.makeRotationAxis(this.obj, this.angle));
                    break;
                case "scale":
                    b.scale(this.obj)
                }
            }
        } (),
        j.prototype.update = function(a, b) {
            var c = ["X", "Y", "Z", "ANGLE"];
            switch (this.type) {
            case "matrix":
                if (b) if (1 === b.length) switch (b[0]) {
                case 0:
                    this.obj.n11 = a[0],
                    this.obj.n21 = a[1],
                    this.obj.n31 = a[2],
                    this.obj.n41 = a[3];
                    break;
                case 1:
                    this.obj.n12 = a[0],
                    this.obj.n22 = a[1],
                    this.obj.n32 = a[2],
                    this.obj.n42 = a[3];
                    break;
                case 2:
                    this.obj.n13 = a[0],
                    this.obj.n23 = a[1],
                    this.obj.n33 = a[2],
                    this.obj.n43 = a[3];
                    break;
                case 3:
                    this.obj.n14 = a[0],
                    this.obj.n24 = a[1],
                    this.obj.n34 = a[2],
                    this.obj.n44 = a[3]
                } else if (2 === b.length) {
                    var d = "n" + (b[0] + 1) + (b[1] + 1);
                    this.obj[d] = a
                } else console.log("Incorrect addressing of matrix in transform.");
                else this.obj.copy(a);
                break;
            case "translate":
            case "scale":
                switch ("[object Array]" === Object.prototype.toString.call(b) && (b = c[b[0]]), b) {
                case "X":
                    this.obj.x = a;
                    break;
                case "Y":
                    this.obj.y = a;
                    break;
                case "Z":
                    this.obj.z = a;
                    break;
                default:
                    this.obj.x = a[0],
                    this.obj.y = a[1],
                    this.obj.z = a[2]
                }
                break;
            case "rotate":
                switch ("[object Array]" === Object.prototype.toString.call(b) && (b = c[b[0]]), b) {
                case "X":
                    this.obj.x = a;
                    break;
                case "Y":
                    this.obj.y = a;
                    break;
                case "Z":
                    this.obj.z = a;
                    break;
                case "ANGLE":
                    this.angle = mono.Math.degToRad(a);
                    break;
                default:
                    this.obj.x = a[0],
                    this.obj.y = a[1],
                    this.obj.z = a[2],
                    this.angle = mono.Math.degToRad(a[3])
                }
            }
        },
        k.prototype.parse = function(a) {
            this.url = a.getAttribute("url").replace(/^#/, ""),
            this.instance_material = [];
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType && "bind_material" == c.nodeName) {
                    for (var d = c.querySelectorAll("instance_material"), e = 0; e < d.length; e++) {
                        var f = d[e];
                        this.instance_material.push((new l).parse(f))
                    }
                    break
                }
            }
            return this
        },
        l.prototype.parse = function(a) {
            return this.symbol = a.getAttribute("symbol"),
            this.target = a.getAttribute("target").replace(/^#/, ""),
            this
        },
        n.prototype.parse = function(a) {
            this.id = a.getAttribute("id");
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (c && "mesh" == c.nodeName) {
                    var d = new o,
                    e = d.parse(c);
                    e && (this.mesh = e)
                }
            }
            return this
        },
        o.prototype.parse = function(a) {
            if (a && a.childNodes && a.childNodes.length > 0) for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                switch (c.nodeName) {
                case "source":
                    var d = c.getAttribute("id");
                    this.sources[d] = (new v).parse(c);
                    break;
                case "vertices":
                    var e = new r;
                    this.vertices = e.parse(c);
                    break;
                case "polygons":
                    var f = (new t).parse(c);
                    f && this.primitives.push(f);
                    break;
                case "triangles":
                    var g = (new u).parse(c);
                    g && this.primitives.push(g);
                    break;
                case "polylist":
                    var h = null;
                    this.primitives.push(h)
                }
            }
            this.node3D = new mono.Entity;
            var i = null;
            for (this.vertices && this.vertices.input && this.vertices.input.POSITION && (i = this.sources[this.vertices.input.POSITION.source].data), b = 0; b < this.primitives.length; b++) {
                var j = this.primitives[b];
                j.setVertices(this.vertices),
                this.handlePrimitive(j, this.node3D)
            }
            for (b = 0; b < i.length; b += 3) this.node3D.vertices.push(p(i, b).clone());
            return this.node3D.computeFaceNormals(),
            this
        },
        o.prototype.handlePrimitive = function(a, b) {
            var c, d, f, g, h, i, j, k = a.p,
            l = a.inputs,
            m = 0,
            n = 3,
            o = 0,
            q = [];
            for (c = 0; c < l.length; c++) {
                f = l[c];
                var r = f.offset + 1;
                switch (o = r > o ? r: o, f.semantic) {
                case "TEXCOORD":
                    q.push(f.set)
                }
            }
            for (var s = 0; s < k.length; ++s) for (var t = k[s], u = 0; u < t.length;) {
                var v = [],
                w = [],
                x = null,
                y = [];
                for (n = a.vcount ? a.vcount.length ? a.vcount[m++] : a.vcount: t.length / o, c = 0; n > c; c++) for (d = 0; d < l.length; d++) switch (f = l[d], i = this.sources[f.source], g = t[u + c * o + f.offset], j = i.accessor.params.length, h = g * j, f.semantic) {
                case "VERTEX":
                    v.push(g);
                    break;
                case "NORMAL":
                    w.push(p(i.data, h));
                    break;
                case "TEXCOORD":
                    x = x || {},
                    x[f.set] === e && (x[f.set] = []),
                    x[f.set].push(new mono.Vec2(i.data[h], i.data[h + 1]));
                    break;
                case "COLOR":
                    y.push((new mono.Color).setRGB(i.data[h], i.data[h + 1], i.data[h + 2]))
                }
                if (0 == w.length) if (f = this.vertices.input.NORMAL) {
                    i = i[f.source],
                    j = i.accessor.params.length;
                    for (var z = 0,
                    A = v.length; A > z; z++) w.push(p(i.data, v[z] * j))
                } else b.calcNormals = !0;
                if (!x && (x = {},
                f = this.vertices.input.TEXCOORD)) {
                    q.push(f.set),
                    i = sources[f.source],
                    j = i.accessor.params.length;
                    for (var z = 0,
                    A = v.length; A > z; z++) h = v[z] * j,
                    x[f.set] === e && (x[f.set] = []),
                    x[f.set].push(new mono.Vec2(i.data[h], 1 - i.data[h + 1]))
                }
                if (0 == y.length && (f = this.vertices.input.COLOR)) {
                    i = sources[f.source],
                    j = i.accessor.params.length;
                    for (var z = 0,
                    A = v.length; A > z; z++) h = v[z] * j,
                    y.push((new mono.Color).setRGB(i.data[h], i.data[h + 1], i.data[h + 2]))
                }
                var B, C, D = null,
                E = [];
                if (3 === n) E.push(new mono.Face3(v[0], v[1], v[2], w, y.length ? y: new mono.Color(16711680)));
                else if (4 === n) E.push(new mono.Face3(v[0], v[1], v[3], [w[0], w[1], w[3]], y.length ? [y[0], y[1], y[3]] : new mono.Color(16711680))),
                E.push(new mono.Face3(v[1], v[2], v[3], [w[1], w[2], w[3]], y.length ? [y[1], y[2], y[3]] : new mono.Color(16711680)));
                else if (n > 4 && _.subdivideFaces) {
                    var F = y.length ? y: new mono.Color;
                    for (d = 1; n - 1 > d;) E.push(new mono.Face3(v[0], v[d], v[d + 1], [w[0], w[d++], w[d]], F))
                }
                if (E.length) for (var z = 0,
                A = E.length; A > z; z++) for (D = E[z], D.daeMaterial = a.material, b.faces.push(D), d = 0; d < q.length; d++) B = x[q[d]],
                C = n > 4 ? [B[0], B[z + 1], B[z + 2]] : 4 === n ? 0 === z ? [B[0], B[1], B[3]] : [B[1].clone(), B[2], B[3].clone()] : [B[0], B[1], B[2]],
                b.uvs === e && (b.uvs = []),
                b.uvs.push(C);
                else console.log("dropped face with vcount " + n + " for geometry with id: " + b.id);
                u += o * n
            }
        },
        r.prototype.parse = function(a) {
            if (a && (this.id = a.getAttribute("id"), a.childNodes.length > 0)) for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (c && c.nodeName) switch (c.nodeName) {
                case "input":
                    var d = (new s).parse(c);
                    this.input[d.semantic] = d
                }
            }
            return this
        },
        s.prototype.parse = function(a) {
            return a && (this.semantic = a.getAttribute("semantic"), this.offset = x(a.getAttribute("offset")), this.set = x(a.getAttribute("set")), this.source = a.getAttribute("source").replace(/^#/, ""), "TEXCOORD" == this.semantic && this.set < 0 && (this.set = 0)),
            this
        },
        t.prototype.parse = function(a) {
            if (a && (this.count = a.getAttribute("count"), this.material = a.getAttribute("material"), a.childNodes.length > 0)) for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (c && c.nodeName) switch (c.nodeName) {
                case "input":
                    var d = (new s).parse(c);
                    d && this.inputs.push(d);
                    break;
                case "p":
                    this.p.push(A(c.textContent))
                }
            }
            return this
        },
        t.prototype.setVertices = function(a) {
            for (var b = 0; b < this.inputs.length; b++) this.inputs[b].source == a.id && (this.inputs[b].source = a.input.POSITION.source)
        },
        u.prototype = Object.create(t.prototype),
        v.prototype.parse = function(a) {
            if (!a) return this;
            if (this.id = a.getAttribute("id"), a.childNodes.length > 0) for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (c && c.nodeName) switch (c.nodeName) {
                case "float_array":
                    this.dataType = c.nodeName,
                    this.data = z(c.textContent);
                    break;
                case "bool_array":
                    this.dataType = c.nodeName,
                    this.data = B(c.textContent);
                    break;
                case "int_array":
                    this.data = A(c.textContent),
                    this.dataType = c.nodeName;
                    break;
                case "technique_common":
                    if (c.childNodes && c.childNodes.length > 0) for (var d = 0; d < c.childNodes.length; d++) {
                        var e = c.childNodes[d];
                        if (e && e.nodeName) switch (e.nodeName) {
                        case "accessor":
                            var f = (new w).parse(e);
                            f.source && (this.technique_common[f.source] = f, this.accessor = f)
                        }
                    }
                }
            }
            return this
        },
        v.prototype.read = function() {
            var a = [],
            b = this.accessor.params[0];
            switch (b.type) {
            case "IDREF":
            case "Name":
            case "name":
            case "float":
                return this.data;
            case "float4x4":
                for (var c = 0; c < this.data.length; c += 16) {
                    var d = this.data.slice(c, c + 16),
                    e = D(d);
                    a.push(e)
                }
                break;
            default:
                console.log("ColladaLoader: Source: Read dont know how to read " + b.type + ".")
            }
            return a
        },
        w.prototype.parse = function(a) {
            if (!a) return this;
            if (this.source = a.getAttribute("source"), this.count = x(a.getAttribute("count")), this.stride = x(a.getAttribute("stride")), a.childNodes.length > 0) for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (c && c.nodeName) switch (c.nodeName) {
                case "param":
                    var d = {};
                    d.name = c.getAttribute("name"),
                    d.type = c.getAttribute("type"),
                    this.params.push(d)
                }
            }
            return this
        },
        F.prototype.parse = function(a) {
            this.id = a.getAttribute("id");
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                "init_from" == c.nodeName && (this.init_from = c.textContent)
            }
            return this
        },
        H.prototype.create = function() {
            return null == this.shader ? null: void 0
        },
        H.prototype.parse = function(a) {
            this.id = a.getAttribute("id"),
            this.name = a.getAttribute("name"),
            N(this, a),
            this.shader = null;
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "profile_COMMON":
                    this.parseTechnique(this.parseProfileCOMMON(c))
                }
            }
            return this
        },
        H.prototype.parseNewparam = function(a) {
            for (var b = a.getAttribute("sid"), c = 0; c < a.childNodes.length; c++) {
                var d = a.childNodes[c];
                if (1 == d.nodeType) switch (d.nodeName) {
                case "surface":
                    this.surface[b] = new K(this).parse(d);
                    break;
                case "sampler2D":
                    this.sampler[b] = new L(this).parse(d);
                    break;
                case "extra":
                    break;
                default:
                    console.log(d.nodeName)
                }
            }
        },
        H.prototype.parseProfileCOMMON = function(a) {
            for (var b, c = 0; c < a.childNodes.length; c++) {
                var d = a.childNodes[c];
                if (1 == d.nodeType) switch (d.nodeName) {
                case "profile_COMMON":
                    this.parseProfileCOMMON(d);
                    break;
                case "technique":
                    b = d;
                    break;
                case "newparam":
                    this.parseNewparam(d);
                    break;
                case "image":
                    var e = (new F).parse(d);
                    X[e.id] = e;
                    break;
                case "extra":
                    break;
                default:
                    console.log(d.nodeName)
                }
            }
            return b
        },
        H.prototype.parseTechnique = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "constant":
                case "lambert":
                case "blinn":
                case "phong":
                    this.shader = new I(c.nodeName, this).parse(c);
                    break;
                case "extra":
                    this.parseExtra(c)
                }
            }
        },
        H.prototype.parseExtra = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "technique":
                    this.parseExtraTechnique(c)
                }
            }
        },
        H.prototype.parseExtraTechnique = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "bump":
                    this.shader.parse(c)
                }
            }
        },
        I.prototype.parse = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "ambient":
                case "emission":
                case "diffuse":
                case "specular":
                case "transparent":
                    this[c.nodeName] = (new J).parse(c);
                    break;
                case "bump":
                    var d = c.getAttribute("bumptype");
                    d ? "heightfield" === d.toLowerCase() ? this.bump = (new J).parse(c) : "normalmap" === d.toLowerCase() ? this.normal = (new J).parse(c) : (console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + d + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'"), this.bump = (new J).parse(c)) : (console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'"), this.bump = (new J).parse(c));
                    break;
                case "shininess":
                case "reflectivity":
                case "index_of_refraction":
                case "transparency":
                    var e = c.querySelectorAll("float");
                    e.length > 0 && (this[c.nodeName] = parseFloat(e[0].textContent))
                }
            }
            return this.create(),
            this
        },
        I.prototype.create = function() {
            var a = {},
            b = !1;
            if (this.transparency !== e && this.transparent !== e) {
                var c = (this.transparent, (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency);
                c > 0 && (b = !0, a.transparent = !0, a.opacity = 1 - c)
            }
            var d = {
                diffuse: "map",
                ambient: "lightMap",
                specular: "specularMap",
                emission: "emissionMap",
                bump: "bumpMap",
                normal: "normalMap"
            };
            for (var f in this) switch (f) {
            case "ambient":
            case "emission":
            case "diffuse":
            case "specular":
            case "bump":
            case "normal":
                var g = this[f];
                if (g instanceof J) if (g.isTexture()) {
                    var h = g.texture,
                    i = this.effect.sampler[h],
                    j = null;
                    if (i !== e && i.source !== e) {
                        var k = this.effect.surface[i.source];
                        j = X[k.init_from]
                    } else j = X[h];
                    if (j) {
                        var l = Y + j.init_from,
                        m = new Image;
                        m.loaded = !1;
                        var n = new mono.Texture;
                        n._imageSrc = l,
                        n._image = m,
                        n.setImage(l),
                        n.wrapS = g.texOpts.wrapU ? mono.RepeatWrapping: mono.ClampToEdgeWrapping,
                        n.wrapT = g.texOpts.wrapV ? mono.RepeatWrapping: mono.ClampToEdgeWrapping,
                        n.offsetX = g.texOpts.offsetU,
                        n.offsetY = g.texOpts.offsetV,
                        n.repeatX = g.texOpts.repeatU,
                        n.repeatY = g.texOpts.repeatV,
                        a[d[f]] = n,
                        "emission" === f && (a.emissive = 16777215)
                    }
                } else "diffuse" !== f && b || ("emission" === f ? a.emissive = g.color.getHex() : a[f] = g.color.getHex());
                break;
            case "shininess":
                a[f] = this[f];
                break;
            case "reflectivity":
                a[f] = this[f],
                a[f] > 0 && (a.envMap = _.defaultEnvMap),
                a.combine = mono.MixOperation;
                break;
            case "index_of_refraction":
                a.refractionRatio = this[f],
                1 !== this[f] && (a.envMap = _.defaultEnvMap);
                break;
            case "transparency":
            }
            switch (a.shading = mono.SmoothShading, a.side = this.effect.doubleSided ? mono.DoubleSide: mono.FrontSide, this.type) {
            case "constant":
                a.emissive != e && (a.color = a.emissive),
                this.material = new mono.EntityMaterial(a);
                break;
            case "phong":
            case "blinn":
                a.diffuse != e && (a.color = a.diffuse),
                this.material = new mono.EntityMaterial(a);
                break;
            case "lambert":
            default:
                a.diffuse != e && (a.color = a.diffuse),
                this.material = new mono.LambertMaterial(a)
            }
            return this.material
        },
        J.prototype.isColor = function() {
            return null == this.texture
        },
        J.prototype.isTexture = function() {
            return null != this.texture
        },
        J.prototype.parse = function(a) {
            "transparent" == a.nodeName && (this.opaque = a.getAttribute("opaque"));
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "color":
                    var d = z(c.textContent);
                    this.color = new mono.Color,
                    this.color.setRGB(d[0], d[1], d[2]),
                    this.color.a = d[3];
                    break;
                case "texture":
                    this.texture = c.getAttribute("texture"),
                    this.texcoord = c.getAttribute("texcoord"),
                    this.texOpts = {
                        offsetU: 0,
                        offsetV: 0,
                        repeatU: 1,
                        repeatV: 1,
                        wrapU: 1,
                        wrapV: 1
                    },
                    this.parseTexture(c)
                }
            }
            return this
        },
        J.prototype.parseTexture = function(a) {
            if (!a.childNodes) return this;
            a.childNodes[1] && "extra" === a.childNodes[1].nodeName && (a = a.childNodes[1], a.childNodes[1] && "technique" === a.childNodes[1].nodeName && (a = a.childNodes[1]));
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                switch (c.nodeName) {
                case "offsetU":
                case "offsetV":
                case "repeatU":
                case "repeatV":
                    this.texOpts[c.nodeName] = parseFloat(c.textContent);
                    break;
                case "wrapU":
                case "wrapV":
                    "TRUE" === c.textContent.toUpperCase() ? this.texOpts[c.nodeName] = 1 : this.texOpts[c.nodeName] = parseInt(c.textContent);
                    break;
                default:
                    this.texOpts[c.nodeName] = c.textContent
                }
            }
            return this
        },
        K.prototype.parse = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "init_from":
                    this.init_from = c.textContent;
                    break;
                case "format":
                    this.format = c.textContent;
                    break;
                default:
                    console.log("unhandled Surface prop: " + c.nodeName)
                }
            }
            return this
        },
        L.prototype.parse = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "source":
                    this.source = c.textContent;
                    break;
                case "minfilter":
                    this.minfilter = c.textContent;
                    break;
                case "magfilter":
                    this.magfilter = c.textContent;
                    break;
                case "mipfilter":
                    this.mipfilter = c.textContent;
                    break;
                case "wrap_s":
                    this.wrap_s = c.textContent;
                    break;
                case "wrap_t":
                    this.wrap_t = c.textContent;
                    break;
                default:
                    console.log("unhandled Sampler2D prop: " + c.nodeName)
                }
            }
            return this
        },
        P.prototype.parse = function(a) {
            this.id = a.getAttribute("id"),
            this.name = a.getAttribute("name");
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if (1 == c.nodeType) switch (c.nodeName) {
                case "technique_common":
                    this.parseCommon(c);
                    break;
                case "technique":
                    this.parseTechnique(c)
                }
            }
            return this
        },
        P.prototype.parseCommon = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) switch (a.childNodes[b].nodeName) {
            case "directional":
            case "point":
            case "spot":
            case "ambient":
                this.technique = a.childNodes[b].nodeName;
                for (var c = a.childNodes[b], d = 0; d < c.childNodes.length; d++) {
                    var e = c.childNodes[d];
                    switch (e.nodeName) {
                    case "color":
                        var f = z(e.textContent);
                        this.color = new mono.Color(0),
                        this.color.setRGB(f[0], f[1], f[2]),
                        this.color.a = f[3];
                        break;
                    case "falloff_angle":
                        this.falloff_angle = parseFloat(e.textContent);
                        break;
                    case "quadratic_attenuation":
                        var g = parseFloat(e.textContent);
                        this.distance = g ? Math.sqrt(1 / g) : 0
                    }
                }
            }
            return this
        },
        P.prototype.parseTechnique = function(a) {
            this.profile = a.getAttribute("profile");
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                switch (c.nodeName) {
                case "intensity":
                    this.intensity = parseFloat(c.textContent)
                }
            }
            return this
        },
        {
            load: a,
            parse: b,
            geometries: U,
            options: _
        }
    },
    Yb.DataBox = function(a) {
        Yb.DataBox.superClass.constructor.apply(this, arguments),
        1 === arguments.length && (this._name = a),
        this._dataList = new kc,
        this._dataMap = {},
        this._rootList = new kc,
        this._rootMap = {},
        this._clientMap = {},
        this._lightList = new kc,
        this._billboardList = new kc,
        this._nodeList = new kc,
        this._annotationList = new kc,
        this._particleList = new kc,
        this.nodes = [],
        this.particles = [],
        this.billboards = [],
        this._dataBoxChangeDispatcher = new Yb.EventDispatcher,
        this._dataPropertyChangeDispatcher = new Yb.EventDispatcher,
        this._groupLists = {},
        this.selection = new kc,
        this instanceof Yb.AlarmBox || (this._selectionModel = new Yb.SelectionModel(this), this._alarmBox = new Yb.AlarmBox(this), this._alarmStatePropagator = new Yb.AlarmStatePropagator(this), this._alarmStatePropagator.setEnable(!0)),
        this.batch = !1,
        this._clientMap = {}
    },
    Yb.extend(Yb.DataBox, Yb.PropertyChangeDispatcher, {
        constructor: Yb.DataBox,
        className: "TGL.DataBox",
        ___accessor: ["name"],
        add: function(a, b) {
            if (a) {
                1 === arguments.length && (b = -1);
                var c = a.getId();
                if (this._dataMap.hasOwnProperty(c)) throw "Data with ID '" + c + "' already exists";
                this._dataMap[c] = a,
                this._dataList.add(a),
                a.getParent() || (this._rootMap[c] = a, b >= 0 ? this._rootList.add(a, b) : this._rootList.add(a)),
                a instanceof Yb.Billboard ? this._billboardList.add(a) : a instanceof Yb.Node ? this._nodeList.add(a) : a instanceof Yb.Particle ? this._particleList.add(a) : a instanceof Yb.Annotation ? this._annotationList.add(a) : a instanceof Yb.Light && this._lightList.add(a),
                this._dataBoxChangeDispatcher.fire({
                    kind: "add",
                    data: a,
                    source: this
                }),
                a.getGroupId() && this.groupElements(a, null, a.getGroupId()),
                a.addPropertyChangeListener(this.handleDataPropertyChange, this),
                a._selected = !1
            }
        },
        onPropertyChange: function() {},
        firePropertyChange: function() {},
        addByDescendant: function(a, b) {
            b && 0 == b(a) || a && (this.add(a), a.getChildren().size() > 0 && a.getChildren().forEach(function(a) {
                this.addByDescendant(a, b)
            },
            this))
        },
        getAlarmBox: function() {
            return this._alarmBox
        },
        removeById: function(a, b) {
            var c = this.getDataById(a);
            this.remove(c, b)
        },
        remove: function(a, b) {
            if (a) {
                a instanceof Yb.Link && (a.setFromNode(null), a.setToNode(null)),
                a instanceof Yb.Node && a.getLinks() && a.getLinks().toList().forEach(function(a) {
                    this.remove(a)
                },
                this),
                b && (a.getChildren().forEach(function(b) {
                    a.removeChild(b)
                },
                this), a.getParent() && a.getParent().removeChild(a)),
                this._dataList.remove(a);
                var c = a._id;
                delete this._dataMap[c],
                this._rootMap[c] && (delete this._rootMap[c], this._rootList.remove(a)),
                a instanceof Yb.Billboard ? this._billboardList.remove(a) : a instanceof Yb.Node ? this._nodeList.remove(a) : a instanceof Yb.Particle ? this._particleList.remove(a) : a instanceof Yb.Annotation ? this._annotationList.remove(a) : a instanceof Yb.Light && this._lightList.remove(a),
                a.getGroupId() && this.groupElements(a, a.getGroupId(), null),
                a.removePropertyChangeListener(this.handleDataPropertyChange, this),
                this._dataBoxChangeDispatcher.fire({
                    kind: "remove",
                    data: a,
                    source: this
                }),
                this._selectionModel && this._selectionModel.removeSelection(a)
            }
        },
        removeByDescendant: function(a, b) {
            if (a) {
                var c = this;
                a.hasChildren() && a.getChildren().forEachReverse(function(a) {
                    c.removeByDescendant(a, b)
                }),
                this.remove(a, b)
            }
        },
        containsById: function(a) {
            return this._dataMap.hasOwnProperty(a)
        },
        contains: function(a) {
            return a ? this._dataMap[a._id] === a: !1
        },
        lightsSize: function() {
            return this._lightList.size()
        },
        getLights: function() {
            return this._lightList
        },
        getLightsArray: function() {
            return this._lightList.toArray()
        },
        getAnnotations: function() {
            return this._annotationList
        },
        clear: function(a) {
            if (this._dataList.size() > 0) {
                var b = this._dataList.toList(function(b) {
                    return ! this._lightList.contains(b) || a
                },
                this);
                if (b.forEach(function(a) {
                    a.removePropertyChangeListener(this.handleDataPropertyChange, this)
                },
                this), this._dataList.clear(), this._dataMap = {},
                this._rootList.clear(), this._rootMap = {},
                this._nodeList.clear(), this._billboardList.clear(), a) this._lightList.clear();
                else {
                    var c = this;
                    this._lightList.forEach(function(a) {
                        c._dataList.add(a);
                        var b = a.getId();
                        c._dataMap[b] = a,
                        null == a.getParent() && (c._rootList.add(a), c._rootMap[b] = a)
                    })
                }
                this._dataBoxChangeDispatcher.fire({
                    kind: "clear",
                    datas: b
                }),
                this.clearSelection()
            }
        },
        startBatch: function() {
            this.batch = !0
        },
        endBatch: function() {
            this.batch = !1,
            this._dataBoxChangeDispatcher.fire({
                kind: "batchEnd"
            })
        },
        removeSelection: function() {
            var a = this._selectionModel.toSelection();
            a.forEach(function(a) {
                this.remove(a)
            },
            this)
        },
        clearSelection: function() {
            this._selectionModel && this._selectionModel.clearSelection()
        },
        clearEditing: function() {
            this._nodeList.forEach(function(a) {
                a.editing = !1
            }),
            this._billboardList.forEach(function(a) {
                a.editing = !1
            })
        },
        getDataById: function(a) {
            return this._dataMap[a]
        },
        groupElements: function(a, b, c) {
            var d;
            b && (d = this._groupLists[b], d && (d.remove(a), d.isEmpty() && delete this._groupLists[b])),
            c && (d = this._groupLists[c], null == d && (d = new kc, this._groupLists[c] = d), d.contains(a) || d.add(a))
        },
        synchronizeGroup: function(a, b, c, d) {
            if (!this.isAdjustingGroup) {
                this.isAdjustingGroup = !0;
                var e = a.getGroupId(),
                f = new Yb.Vec3;
                if (e) {
                    var g = this._groupLists[e];
                    g && g.size() > 1 && g.forEach(function(e) {
                        e !== a && !e.isDescendantOf(a) && !a.isDescendantOf(e) && (f.subVectors(c, b), e[Yb.setter(d)](e[Yb.getter(d)]().clone().add(f)))
                    })
                }
                this.isAdjustingGroup = !1
            }
        },
        handleDataPropertyChange: function(a) {
            var b = a.source;
            if ("parent" === a.property) {
                var c = b.getId();
                b.getParent() ? this._rootMap[c] && (delete this._rootMap[c], this._rootList.remove(b)) : this._rootMap[c] || (this._rootMap[c] = b, this._rootList.add(b))
            } else if ("groupId" === a.property) {
                var d = a.oldValue,
                e = a.newValue;
                this.groupElements(b, d, e)
            } else "position" === a.property || "scale" === a.property || "rotation" === a.property ? this.synchronizeGroup(b, a.oldValue, a.newValue, a.property) : "selected" === a.property && (b._selected ? this._selectionModel.appendSelection(b) : this._selectionModel.removeSelection(b));
            this.onDataPropertyChanged(b, a),
            this._dataPropertyChangeDispatcher.fire(a)
        },
        onDataPropertyChanged: function(a, b) {},
        addDataBoxChangeListener: function(a, b, c) {
            this._dataBoxChangeDispatcher.add(a, b, c)
        },
        removeDataBoxChangeListener: function(a, b) {
            this._dataBoxChangeDispatcher.remove(a, b)
        },
        addDataPropertyChangeListener: function(a, b, c) {
            this._dataPropertyChangeDispatcher.add(a, b, c)
        },
        removeDataPropertyChangeListener: function(a, b) {
            this._dataPropertyChangeDispatcher.remove(a, b)
        },
        allocateLights: function() {
            var a, b, c, d, e, f, g, c;
            d = e = f = g = 0;
            var h = this._lightList;
            for (a = 0, b = h.size(); b > a; a++) c = h.get(a),
            c.onlyShadow || (c instanceof Yb.DirectionalLight && d++, c instanceof Yb.PointLight && e++, c instanceof Yb.SpotLight && f++);
            return {
                directional: d,
                point: e,
                spot: f,
                hemi: g
            }
        },
        allocateShadows: function() {
            var a, b, c, d = 0,
            e = this._lightList;
            for (a = 0, b = e.size(); b > a; a++) c = e.get(a),
            c.castShadow && (c instanceof Yb.SpotLight && d++, c instanceof Yb.DirectionalLight && !c.shadowCascade && d++);
            return d
        },
        allocatePointShadows: function() {
            var a, b, c, d = 0,
            e = this._lightList;
            for (a = 0, b = e.size(); b > a; a++) c = e.get(a),
            c.castShadow && c instanceof Yb.PointLight && d++;
            return d
        },
        getSelectionModel: function() {
            return this._selectionModel
        },
        size: function() {
            return this._dataList.size()
        },
        isEmpty: function() {
            return this._dataList.isEmpty()
        },
        getLimit: function() {
            return this._limit
        },
        setLimit: function(a) {
            var b = this._limit;
            this._limit = a,
            this.firePropertyChange("limit", b, a),
            this._checkLimit()
        },
        _checkLimit: function() {
            this._limit >= 0 && this.size() > this._limit && this.removeFirst(this.size() - this._limit);
        },
        removeFirst: function(a) {
            for (0 === arguments.length && (a = 1); a > 0 && this._dataList.size() > 0;) {
                var b = this._dataList.get(0);
                this.remove(b),
                a--
            }
        },
        getSiblings: function(a) {
            if (!this.contains(a)) throw a + " dosen't belong to this dataBox";
            var b = a.getParent();
            return b ? b.getChildren() : this._rootList
        },
        getRoots: function() {
            return this._rootList
        },
        getSiblingIndex: function(a) {
            return a.getParent() ? a.getParent().getChildren().indexOf(a) : this._rootList.indexOf(a)
        },
        getNodes: function() {
            return this._nodeList
        },
        getBillboards: function() {
            return this._billboardList
        },
        getDatas: function() {
            return this._dataList
        },
        getDataAt: function(a) {
            return this._dataList.get(a)
        },
        toDatas: function(a, b) {
            return this._dataList.toList(a, b)
        },
        forEach: function(a, b) {
            this._dataList.forEach(a, b)
        },
        forEachReverse: function(a, b) {
            this._dataList.forEachReverse(a, b)
        },
        forEachByDepthFirst: function(a, b, c) {
            if (b) this._depthFirst(a, b, c);
            else for (var d = this._rootList.size(), e = 0; d > e; e++) {
                var f = this._rootList.get(e);
                if (this._depthFirst(a, f, c) === !1) return
            }
        },
        _depthFirst: function(a, b, c) {
            for (var d = b.getChildrenSize(), e = 0; d > e; e++) {
                var f = b.getChildAt(e);
                if (this._depthFirst(a, f, c) === !1) return ! 1
            }
            if (c) {
                if (a.call(c, b) === !1) return ! 1
            } else if (a(b) === !1) return ! 1
        },
        forEachByBreadthFirst: function(a, b, c) {
            var d = new kc;
            for (b ? d.add(b) : this._rootList.forEach(d.add, d); d.size() > 0;) if (b = d.removeAt(0), b.getChildren().forEach(d.add, d), c) {
                if (a.call(c, b) === !1) return
            } else if (a(b) === !1) return
        },
        getAlarmStatePropagator: function() {
            return this._alarmStatePropagator
        },
        setAlarmStatePropagator: function(a) {
            this._alarmStatePropagator != a && (this._alarmStatePropagator && this._alarmStatePropagator.setEnable(!1), this._alarmStatePropagator = a, this._alarmStatePropagator.setEnable(!0))
        },
        setClient: function(a, b) {
            if (null == a) return this;
            null == this._clientMap && (this._clientMap = new Object);
            var c = this._clientMap[a];
            return c !== b ? (null == b ? delete this._clientMap[a] : this._clientMap[a] = b, this._clientMap[a] = b, this.firePropertyChange("C:" + a, c, b), this) : void 0
        },
        getClient: function(a) {
            return this._clientMap[a]
        }
    }),
    Yb.QuickFinder = function(a, b, c, d, e) {
        if (this._map = {},
        !a) throw "dataBox can not be null";
        if (!b) throw "propertyName can not be null";
        this._dataBox = a,
        this._propertyName = b,
        this._propertyType = c || "accessor",
        "accessor" === this._propertyType && (this._getter = Yb.getter(b)),
        this._valueFunction = d || this.getValue,
        this._filterFunction = e || this.isInterested,
        this._dataBox.forEach(this._addData, this),
        this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this, !0),
        this._dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this, !0)
    },
    Yb.extend(Yb.QuickFinder, Object, {
        _NULL_: "mono-null-key",
        getValueFunction: function() {
            return this._valueFunction
        },
        getFilterFunction: function() {
            return this._filterFunction
        },
        handleDataBoxChange: function(a) {
            "add" === a.kind ? this._addData(a.data) : "remove" === a.kind ? this._removeData(a.data) : "clear" === a.kind && (this._map = {})
        },
        handleDataPropertyChange: function(a) {
            if (this._filterFunction.call(this, a.source) && ("accessor" === this._propertyType && this._propertyName === a.property || "style" === this._propertyType && a.source.IStyle && "S:" + this._propertyName === a.property || "client" === this._propertyType && "C:" + this._propertyName === a.property)) {
                var b = this._getMap(a.oldValue);
                b && b.remove(a.source),
                this._addData(a.source)
            }
        },
        _getMap: function(a) {
            return a = null == a ? this._NULL_: a,
            this._map[a]
        },
        find: function(a) {
            var b = this._getMap(a);
            return b ? b.toList() : new kc
        },
        findFirst: function(a) {
            var b = this._getMap(a);
            return ! b || b.isEmpty() ? null: b.get(0)
        },
        _addData: function(a) {
            if (this._filterFunction.call(this, a)) {
                var b = this._valueFunction.call(this, a),
                c = this._getMap(b);
                c || (c = new kc, b = null == b ? this._NULL_: b, this._map[b] = c),
                c.add(a)
            }
        },
        _removeData: function(a) {
            if (this._filterFunction.call(this, a)) {
                var b = this._valueFunction.call(this, a),
                c = this._getMap(b);
                c && (c.remove(a), c.isEmpty() && (b = null == b ? this._NULL_: b, delete this._map[b]))
            }
        },
        dispose: function() {
            this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this),
            this._dataBox.removeDataPropertyChangeListener(this.handleDataPropertyChange, this),
            delete this._dataBox
        },
        getDataBox: function() {
            return this._dataBox
        },
        getPropertyType: function() {
            return this._propertyType
        },
        getPropertyName: function() {
            return this._propertyName
        },
        isInterested: function(a) {
            return "style" === this._propertyType && !a.IStyle || "accessor" === this._propertyType && this._valueFunction === this.getValue && !a[this._getter] ? !1 : !0
        },
        getValue: function(a) {
            return "accessor" === this._propertyType ? a[this._getter]() : "style" === this._propertyType && a.getStyle ? a.getStyle(this._propertyName) : "client" === this._propertyType && a.getClient ? a.getClient(this._propertyName) : null
        }
    }),
    Yb.SelectionModel = function(a) {
        Yb.SelectionModel.superClass.constructor.apply(this, arguments),
        this._selectionMode = "multipleSelection",
        this._selectionList = new kc,
        this._selectionChangeDispatcher = new Yb.EventDispatcher,
        this._selectionMap = {},
        this._setDataBox(a)
    },
    Yb.extend(Yb.SelectionModel, Yb.PropertyChangeDispatcher, {
        getSelectionMode: function() {
            return this._selectionMode
        },
        setSelectionMode: function(a) {
            if (this._selectionMode !== a && ("noneSelection" === a || "singleSelection" === a || "multipleSelection" === a)) {
                this.clearSelection();
                var b = this._selectionMode;
                this._selectionMode = a,
                this.firePropertyChange("selectionMode", b, this._selectionMode)
            }
        },
        getDataBox: function() {
            return this._dataBox
        },
        _setDataBox: function(a) {
            if (!a) throw "dataBox can not be null";
            if (this._dataBox !== a) {
                this._dataBox && (this.clearSelection(), this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this));
                var b = this._dataBox;
                this._dataBox = a,
                this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this, !0),
                this.firePropertyChange("dataBox", b, this._dataBox)
            }
        },
        dispose: function() {
            this.clearSelection(),
            this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this)
        },
        handleDataBoxChange: function(a) {
            if ("remove" === a.kind) {
                var b = a.data;
                this.contains(b) && (this._selectionList.remove(b), delete this._selectionMap[b.getId()], this.fireSelectionChange("remove", new kc(b))),
                b._selected = !1
            } else "clear" === a.kind && this.clearSelection()
        },
        getFilterFunction: function() {
            return this._filterFunction
        },
        setFilterFunction: function(a) {
            if (this._filterFunction !== a) {
                this.clearSelection();
                var b = this._filterFunction;
                this._filterFunction = a,
                this.firePropertyChange("filterFunction", b, this._filterFunction)
            }
        },
        fireSelectionChange: function(a, b, c) {
            c && (this._selectionList.forEach(function(a) {
                c.contains(a) ? c.remove(a) : c.add(a)
            }), b = c.toList()),
            this._selectionChangeDispatcher.fire({
                kind: a,
                datas: new kc(b)
            })
        },
        addSelectionChangeListener: function(a, b, c) {
            this._selectionChangeDispatcher.add(a, b, c)
        },
        removeSelectionChangeListener: function(a, b) {
            this._selectionChangeDispatcher.remove(a, b)
        },
        _filterList: function(a, b) {
            for (var c = new kc(a), d = 0; d < c.size(); d++) {
                var e = c.get(d); (this._filterFunction && !this._filterFunction(e) || b && this.contains(e) || !b && !this.contains(e) || !this._dataBox.contains(e)) && (c.removeAt(d), d--)
            }
            return c
        },
        appendSelection: function(a) {
            if ("noneSelection" !== this._selectionMode) {
                var b = this._filterList(a, !0);
                if (!b.isEmpty()) {
                    var c = null;
                    "singleSelection" === this._selectionMode && (c = new kc(this._selectionList), this._selectionList.forEach(function(a) {
                        a._selected = !1
                    }), this._selectionList.clear(), this._selectionMap = {},
                    b = new kc(b.get(b.size() - 1)));
                    for (var d = 0; d < b.size(); d++) {
                        var e = b.get(d);
                        e._selected = !0,
                        this._selectionList.add(e),
                        this._selectionMap[e._id] = e
                    }
                    this.fireSelectionChange("append", b, c)
                }
            }
        },
        removeSelection: function(a) {
            var b = this._filterList(a);
            if (0 !== b.size()) {
                for (var c = 0; c < b.size(); c++) {
                    var d = b.get(c);
                    d._selected = !1,
                    this._selectionList.remove(d),
                    delete this._selectionMap[d.getId()]
                }
                this.fireSelectionChange("remove", b)
            }
        },
        toSelection: function(a, b) {
            return this._selectionList.toList(a, b)
        },
        getSelection: function() {
            return this._selectionList
        },
        setSelection: function(a) {
            if ("noneSelection" !== this._selectionMode && (0 !== this._selectionList.size() || null != a)) {
                var b = new kc(this._selectionList);
                this._selectionList.clear(),
                this._selectionMap = {};
                var c = this._filterList(a, !0);
                "singleSelection" === this._selectionMode && c.size() > 1 && (c = new kc(c.get(c.size() - 1)));
                for (var d = 0; d < c.size(); d++) {
                    var e = c.get(d);
                    e._selected = !0,
                    this._selectionList.add(e),
                    this._selectionMap[e.getId()] = e
                }
                this.fireSelectionChange("set", null, b)
            }
        },
        clearSelection: function() {
            if (this._selectionList.size() > 0) {
                var a = this._selectionList.toList();
                this._selectionList.forEach(function(a) {
                    a._selected = !1
                }),
                this._selectionList.clear(),
                this._selectionMap = {},
                this.fireSelectionChange("clear", a)
            }
        },
        selectAll: function() {
            if ("noneSelection" !== this._selectionMode) {
                var a = this._dataBox.toDatas(),
                b = 0,
                c = null;
                if (this._filterFunction) for (b = 0; b < a.size(); b++) c = a.get(b),
                this._filterFunction(c) || (a.removeAt(b), b--);
                var d = new kc(this._selectionList);
                for (this._selectionList.clear(), this._selectionMap = {},
                "singleSelection" === this._selectionMode && a.size() > 1 && (a = new kc(a.get(a.size() - 1))), b = 0; b < a.size(); b++) c = a.get(b),
                this._selectionList.add(c),
                this._selectionMap[c.getId()] = c;
                this.fireSelectionChange("all", null, d)
            }
        },
        size: function() {
            return this._selectionList.size()
        },
        contains: function(a) {
            return a ? null != this._selectionMap[a._id] : !1
        },
        getLastData: function() {
            return this._selectionList.size() > 0 ? this._selectionList.get(this._selectionList.size() - 1) : null
        },
        getFirstData: function() {
            return this._selectionList.size() > 0 ? this._selectionList.get(0) : null
        },
        isSelectable: function(a) {
            return a ? "noneSelection" === this._selectionMode ? !1 : this._filterFunction && !this._filterFunction(a) ? !1 : !0 : !1
        }
    }),
    Yb.AlarmSeverity = function(a, b, c, d, e) {
        this.value = a,
        this.name = b,
        this.nickName = c,
        this.color = d,
        this.displayName = e
    },
    Yb.extend(Yb.AlarmSeverity, Object, {
        toString: function() {
            return this.displayName ? this.displayName: this.name
        }
    }),
    function() {
        var a = Yb.AlarmSeverity;
        a.severities = new kc,
        a._vm = {},
        a._nm = {},
        a._cp = function(a, b) {
            if (a && b) {
                var c = a.value - b.value;
                return c > 0 ? 1 : 0 > c ? -1 : 0
            }
            return a && !b ? 1 : !a && b ? -1 : 0
        },
        a.forEach = function(b, c) {
            a.severities.forEach(b, c)
        },
        a.getSortFunction = function() {
            return a._cp
        },
        a.setSortFunction = function(b) {
            a._cp = b,
            a.severities.sort(b)
        },
        a.add = function(b, c, d, e, f) {
            var g = new a(b, c, d, e, f);
            return a._vm[b] = g,
            a._nm[c] = g,
            a.severities.add(g),
            a.severities.sort(a._cp),
            g
        },
        a.remove = function(b) {
            var c = a._nm[b];
            return c && (delete a._nm[b], delete a._vm[c.value], a.severities.remove(c)),
            c
        },
        a.CRITICAL = a.add(500, "Critical", "C", "#FF0000"),
        a.MAJOR = a.add(400, "Major", "M", "#FFA000"),
        a.MINOR = a.add(300, "Minor", "m", "#FFFF00"),
        a.WARNING = a.add(200, "Warning", "W", "#00FFFF"),
        a.INDETERMINATE = a.add(100, "Indeterminate", "N", "#C800FF"),
        a.CLEARED = a.add(0, "Cleared", "R", "#00FF00"),
        a.isClearedAlarmSeverity = function(a) {
            return a ? 0 === a.value: !1
        },
        a.getByName = function(b) {
            return a._nm[b]
        },
        a.getByValue = function(b) {
            return a._vm[b]
        },
        a.clear = function() {
            a.severities.clear(),
            a._vm = {},
            a._nm = {}
        },
        a.compare = function(b, c) {
            return a._cp(b, c)
        }
    } (),
    Yb.AlarmState = function(a) {
        this._e = a,
        this._nm = {},
        this._am = {},
        this._ps = null,
        this._haa = null,
        this._hna = null,
        this._hoa = null,
        this._hta = null,
        this._hls = !1,
        this._aac = 0,
        this._nac = 0
    },
    Yb.extend(Yb.AlarmState, Object, {
        _ep: !0,
        _f: function() {
            this._c1(),
            this._c2(),
            this._c3(),
            this._c4(),
            this._c5(),
            this._c6(),
            this._c7(),
            this._e.firePropertyChange("alarmState", null, this)
        },
        getHighestAcknowledgedAlarmSeverity: function() {
            return this._haa
        },
        getHighestNewAlarmSeverity: function() {
            return this._hna
        },
        getHighestOverallAlarmSeverity: function() {
            return this._hoa
        },
        getHighestNativeAlarmSeverity: function() {
            return this._hta
        },
        hasLessSevereNewAlarms: function() {
            return this._hls
        },
        _c1: function() {
            var a = null;
            for (var b in this._am) b = Yb.AlarmSeverity.getByName(b),
            Yb.AlarmSeverity.isClearedAlarmSeverity(b) || 0 !== this.getAcknowledgedAlarmCount(b) && (a = a && Yb.AlarmSeverity.compare(a, b) > 0 ? a: b);
            this._haa = a
        },
        _c2: function() {
            var a = null;
            for (var b in this._nm) b = Yb.AlarmSeverity.getByName(b),
            Yb.AlarmSeverity.isClearedAlarmSeverity(b) || 0 !== this.getNewAlarmCount(b) && (a = a && Yb.AlarmSeverity.compare(a, b) > 0 ? a: b);
            this._hna = a
        },
        _c3: function() {
            if (!this._hna) return void(this._hls = !1);
            for (var a in this._nm) if (a = Yb.AlarmSeverity.getByName(a), !Yb.AlarmSeverity.isClearedAlarmSeverity(a) && 0 !== this.getNewAlarmCount(a) && Yb.AlarmSeverity.compare(this._hna, a) > 0) return void(this._hls = !0);
            this._hls = !1
        },
        _c4: function() {
            var a = this._haa,
            b = this._hna,
            c = this._ps;
            this._hoa = a,
            Yb.AlarmSeverity.compare(b, this._hoa) > 0 && (this._hoa = b),
            Yb.AlarmSeverity.compare(c, this._hoa) > 0 && (this._hoa = c)
        },
        _c5: function() {
            var a = this._haa,
            b = this._hna;
            this._hta = a,
            Yb.AlarmSeverity.compare(b, this._hta) > 0 && (this._hta = b)
        },
        increaseAcknowledgedAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._am[a.name];
                null == c && (c = 0),
                c += b,
                this._am[a.name] = c,
                this._f(),
                this._e.onAlarmChange()
            }
        },
        increaseNewAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._nm[a.name];
                null == c && (c = 0),
                c += b,
                this._nm[a.name] = c,
                this._f(),
                this._e.onAlarmChange()
            }
        },
        decreaseAcknowledgedAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._am[a.name];
                if (null == c && (c = 0), c -= b, 0 > c) throw "Alarm count can not be negative";
                this._am[a.name] = c,
                this._f(),
                this._e.onAlarmChange()
            }
        },
        decreaseNewAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._nm[a.name];
                if (null == c && (c = 0), c -= b, 0 > c) throw "Alarm count can not be negative";
                this._nm[a.name] = c,
                this._f(),
                this._e.onAlarmChange()
            }
        },
        acknowledgeAlarm: function(a) {
            this.decreaseNewAlarm(a, 1),
            this.increaseAcknowledgedAlarm(a, 1)
        },
        acknowledgeAllAlarms: function(a) {
            if (a) {
                var b = this.getNewAlarmCount(a);
                this.decreaseNewAlarm(a, b),
                this.increaseAcknowledgedAlarm(a, b)
            } else for (var c in this._nm) this.acknowledgeAllAlarms(Yb.AlarmSeverity.getByName(c))
        },
        _c6: function() {
            this._aac = 0;
            for (var a in this._am) a = Yb.AlarmSeverity.getByName(a),
            this._aac += this.getAcknowledgedAlarmCount(a)
        },
        getAcknowledgedAlarmCount: function(a) {
            if (a) {
                var b = this._am[a.name];
                return null == b ? 0 : b
            }
            return this._aac
        },
        getAlarmCount: function(a) {
            return this.getAcknowledgedAlarmCount(a) + this.getNewAlarmCount(a)
        },
        _c7: function() {
            this._nac = 0;
            for (var a in this._nm) a = Yb.AlarmSeverity.getByName(a),
            this._nac += this.getNewAlarmCount(a)
        },
        getNewAlarmCount: function(a) {
            if (a) {
                var b = this._nm[a.name];
                return null == b ? 0 : b
            }
            return this._nac
        },
        setNewAlarmCount: function(a, b) {
            this._nm[a.name] = b,
            this._f()
        },
        removeAllNewAlarms: function(a) {
            a ? delete this._nm[a] : this._nm = {},
            this._f()
        },
        setAcknowledgedAlarmCount: function(a, b) {
            this._am[a.name] = b,
            this._f()
        },
        removeAllAcknowledgedAlarms: function(a) {
            a ? delete this._am[a.name] : this._am = {},
            this._f()
        },
        isEmpty: function() {
            return null == this._hoa
        },
        clear: function() {
            this._am = {},
            this._nm = {},
            this._f()
        },
        getPropagateSeverity: function() {
            return this._ps
        },
        setPropagateSeverity: function(a) {
            if (this._ep || (a = null), this._ps !== a) {
                var b = this._ps;
                this._ps = a,
                this._f(),
                this._e.onAlarmChange(),
                this._e.firePropertyChange("propagateSeverity", b, a)
            }
        },
        isEnablePropagation: function() {
            return this._ep
        },
        setEnablePropagation: function(a) {
            var b = this._ep;
            this._ep = a,
            this._e.firePropertyChange("enablePropagation", b, a) && (a || this.setPropagateSeverity(null))
        }
    }),
    Yb.Alarm = function(a, b, c, d, e) {
        Yb.Data.call(this, a),
        this._id = null != a ? a: Yb.id("A"),
        this._elementId = b,
        this._alarmSeverity = c,
        this._acked = d || !1,
        this._cleared = e || !1
    },
    Yb.extend(Yb.Alarm, Yb.Data, {
        IAlarm: !0,
        getElementId: function() {
            return this._elementId
        },
        ___accessor: ["acked", "cleared", "alarmSeverity"]
    }),
    Yb.AlarmBox = function(a) {
        if (!a) throw "elementBox can not be null.";
        Yb.AlarmBox.superClass.constructor.call(this),
        this._elementBox = a,
        this._alarmElementMapping = new Yb.AlarmElementMapping(this, a),
        this._elementBox.addDataBoxChangeListener(this.handleElementBoxChange, this, !0),
        this.addDataBoxChangeListener(this.handleAlarmBoxChange, this, !0),
        this.addDataPropertyChangeListener(this.handleAlarmPropertyChange, this, !0)
    },
    Yb.extend(Yb.AlarmBox, Yb.DataBox, {
        __accessor: ["removeAlarmWhenElementIsRemoved"],
        _name: "AlarmBox",
        _removeAlarmWhenAlarmIsCleared: !1,
        _removeAlarmWhenElementIsRemoved: !0,
        getElementBox: function() {
            return this._elementBox
        },
        isRemoveAlarmWhenAlarmIsCleared: function() {
            return this._removeAlarmWhenAlarmIsCleared
        },
        setRemoveAlarmWhenAlarmIsCleared: function(a) {
            var b = this._removeAlarmWhenAlarmIsCleared;
            if (this._removeAlarmWhenAlarmIsCleared = a, this.firePropertyChange("removeAlarmWhenAlarmIsCleared", b, a), a) for (var c in this.datas) {
                var d = this.datas[c];
                d.isCleard() && this.remove(d)
            }
        },
        getAlarmElementMapping: function() {
            return this._alarmElementMapping
        },
        setAlarmElementMapping: function(a) {
            if (!a) throw "alarmElementMapping can not be null";
            if (this._alarmElementMapping !== a) {
                var b = this._alarmElementMapping;
                this.getDatas().forEach(this._decreaseAlarmState, this),
                this._alarmElementMapping = a,
                this.getDatas().forEach(this._increaseAlarmState, this),
                this.firePropertyChange("alarmElementMapping", b, a)
            }
        },
        handleElementBoxChange: function(a) {
            "add" === a.kind ? this.handleElementAdded(a.data) : "remove" === a.kind ? (this.handleElementRemoved(a.data), this._removeAlarmWhenElementIsRemoved && this.removeAlarmsByElement(a.data)) : "clear" === a.kind && (a.datas.forEach(this.handleElementRemoved, this), this._removeAlarmWhenElementIsRemoved && this.clear())
        },
        handleAlarmBoxChange: function(a) {
            "add" === a.kind ? this._increaseAlarmState(a.data) : "remove" === a.kind ? this._decreaseAlarmState(a.data) : "clear" === a.kind && a.datas.forEach(this._decreaseAlarmState, this)
        },
        handleAlarmPropertyChange: function(a) {
            var b = a.source;
            b.isCleared() || ("alarmSeverity" === a.property ? this.handleAlarmSeverityChange(b, a) : "acked" === a.property && this.handleAckedChange(b, a)),
            "cleared" === a.property && (b.isCleared() ? (this._decreaseAlarmState(b, !0), this._removeAlarmWhenAlarmIsCleared && this.remove(b)) : this._increaseAlarmState(b, !0))
        },
        handleAckedChange: function(a, b) {
            if (a.getAlarmSeverity()) {
                var c = this.getCorrespondingElements(a);
                if (c) for (var d = 0; d < c.size(); d++) {
                    var e = c.get(d);
                    b.oldValue ? e.getAlarmState().decreaseAcknowledgedAlarm(a.getAlarmSeverity()) : e.getAlarmState().decreaseNewAlarm(a.getAlarmSeverity()),
                    b.newValue ? e.getAlarmState().increaseAcknowledgedAlarm(a.getAlarmSeverity()) : e.getAlarmState().increaseNewAlarm(a.getAlarmSeverity())
                }
            }
        },
        handleAlarmSeverityChange: function(a, b) {
            var c = b.oldValue,
            d = b.newValue,
            e = this.getCorrespondingElements(a);
            if (e) for (var f = 0; f < e.size(); f++) {
                var g = e.get(f);
                c && (a.isAcked() ? g.getAlarmState().decreaseAcknowledgedAlarm(c) : g.getAlarmState().decreaseNewAlarm(c)),
                d && (a.isAcked() ? g.getAlarmState().increaseAcknowledgedAlarm(d) : g.getAlarmState().increaseNewAlarm(d))
            }
        },
        getCorrespondingAlarms: function(a) {
            return this._alarmElementMapping.getCorrespondingAlarms(a)
        },
        getCorrespondingElements: function(a) {
            return this._alarmElementMapping.getCorrespondingElements(a)
        },
        handleElementAdded: function(a) {
            var b = this.getCorrespondingAlarms(a);
            if (b) for (var c = 0; c < b.size(); c++) {
                var d = b.get(c);
                if (!d.isCleared()) {
                    var e = d.getAlarmSeverity();
                    e && (d.isAcked() ? a.getAlarmState().increaseAcknowledgedAlarm(e) : a.getAlarmState().increaseNewAlarm(e))
                }
            }
        },
        _increaseAlarmState: function(a, b) {
            if (!a.isCleared() || b) {
                var c = a.getAlarmSeverity();
                if (c) {
                    var d = this.getCorrespondingElements(a);
                    if (d) for (var e = 0; e < d.size(); e++) {
                        var f = d.get(e);
                        a.isAcked() ? f.getAlarmState().increaseAcknowledgedAlarm(c) : f.getAlarmState().increaseNewAlarm(c)
                    }
                }
            }
        },
        _decreaseAlarmState: function(a, b) {
            if (a.isCleared || console.log(), !a.isCleared() || b) {
                var c = a.getAlarmSeverity();
                if (c) {
                    var d = this.getCorrespondingElements(a);
                    if (d) for (var e = 0; e < d.size(); e++) {
                        var f = d.get(e);
                        a.isAcked() ? f.getAlarmState().decreaseAcknowledgedAlarm(c) : f.getAlarmState().decreaseNewAlarm(c)
                    }
                }
            }
        },
        handleElementRemoved: function(a) {
            var b = this.getCorrespondingAlarms(a);
            b && b.forEach(function(b) { ! b.isCleared() && b.getAlarmSeverity() && (b.isAcked() ? a.getAlarmState().decreaseAcknowledgedAlarm(b.getAlarmSeverity()) : a.getAlarmState().decreaseNewAlarm(b.getAlarmSeverity()))
            })
        },
        removeAlarmsByElement: function(a) {
            var b = this.getCorrespondingAlarms(a);
            b && b.forEach(this.remove, this)
        },
        add: function(a, b) {
            if (!a.IAlarm) throw "Only IAlarm can be added into AlarmBox";
            this._removeAlarmWhenAlarmIsCleared && a.isCleared() || Yb.AlarmBox.superClass.add.apply(this, arguments)
        }
    }),
    Yb.AlarmElementMapping = function(a, b) {
        if (!b) throw "ElementBox can not be null";
        if (!a) throw "AlarmBox can not be null";
        this._elementBox = b,
        this._alarmBox = a,
        this._alarmsFinder = new Yb.QuickFinder(a, "elementId")
    },
    Yb.extend(Yb.AlarmElementMapping, Object, {
        getCorrespondingAlarms: function(a) {
            return this._alarmsFinder.find(a.getId())
        },
        getCorrespondingElements: function(a) {
            var b = this._elementBox.getDataById(a.getElementId());
            return new kc(b)
        },
        dispose: function() {
            delete this._elementBox,
            delete this._alarmBox,
            delete this._alarmsFinder
        }
    }),
    Yb.PropertyPropagator = function(a, b, c) {
        if (!a) throw "dataBox can not be null";
        if (!b) throw "propertyName can not be null";
        this._dataBox = a,
        this._propertyName = b,
        this._propertyType = c || "accessor",
        "accessor" === this._propertyType && (this._getter = Yb.getter(b), this._setter = Yb.setter(b)),
        this._enable = !1,
        this._isPropagating = !1
    },
    Yb.extend(Yb.PropertyPropagator, Object, {
        getDataBox: function() {
            return this._dataBox
        },
        getPropertyType: function() {
            return this._propertyType
        },
        getPropertyName: function() {
            return this._propertyName
        },
        isEnable: function() {
            return this._enable
        },
        setEnable: function(a) {
            if (this._enable !== a) if (this._enable = a, this._enable) {
                this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this),
                this._dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this);
                for (var b in this._dataBox.datas) this.propagate(this._dataBox.datas[b])
            } else this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this),
            this._dataBox.removeDataPropertyChangeListener(this.handleDataPropertyChange, this)
        },
        handleDataBoxChange: function(a) {
            a.data && this.propagate(a.data)
        },
        handleDataPropertyChange: function(a) {
            if (this.isInterestedProperty(a)) this.propagate(a.source);
            else if ("parent" === a.property) {
                var b = a.oldValue;
                b && this.propagate(b),
                this.propagate(a.source)
            }
        },
        isInterestedProperty: function(a) {
            return "accessor" === this._propertyType && this._propertyName === a.property ? !0 : "style" === this._propertyType && a.IElement && "S:" + this._propertyName === a.property ? !0 : "client" === this._propertyType && "C:" + this._propertyName === a.property ? !0 : !1
        },
        propagate: function(a) {
            a && !this._isPropagating && (this._isPropagating = !0, this.propagateToTop(a), this._isPropagating = !1)
        },
        propagateToTop: function(a) {
            for (this.propagateToParent(null, a); a && a.getParent();) this.propagateToParent(a, a.getParent()),
            a = a.getParent()
        },
        propagateToParent: function(a, b) {}
    }),
    Yb.AlarmStatePropagator = function(a) {
        Yb.AlarmStatePropagator.superClass.constructor.call(this, a, "alarmState")
    },
    Yb.extend(Yb.AlarmStatePropagator, Yb.PropertyPropagator, {
        handleDataPropertyChange: function(a) {
            "enablePropagation" === a.property ? this.propagate(a.source) : Yb.AlarmStatePropagator.superClass.handleDataPropertyChange.call(this, a)
        },
        propagateToParent: function(a, b) {
            var c = null;
            b.getChildren().forEach(function(a) {
                var b = a.getAlarmState().getHighestOverallAlarmSeverity();
                Yb.AlarmSeverity.compare(b, c) > 0 && (c = b)
            }),
            b.getAlarmState && b.getAlarmState().setPropagateSeverity(c)
        }
    });
    var sc = {
        KEEP_DEFAULT_FUNCTION: function(a) {
            return a.target.keepDefault || a.target.getAttribute("keepDefault") ? !0 : a.target.parentNode && (a.target.parentNode.keepDefault || a.target.parentNode.getAttribute("keepDefault")) ? !0 : a.shiftKey ? !0 : !1
        }
    };
    sc.paintSortFunction = function(a, b) {
        return a.z !== b.z ? a.z - b.z: 0
    },
    sc.doubleClickToLookAtFunction = function(a) {
        return ! 0
    },
    sc.needSmoothNormalFunction = function(a) {
        var b = a instanceof rc || a instanceof Yb.TextNode || a instanceof Yb.PathCube || a instanceof Yb.ShapeNode || a instanceof Yb.ComboNode || "TGL.Entity" == a.getClassName();
        return ! b
    },
    sc.PATH_LINK_COMPUTE_DELAY = !1,
    Yb.Defaults = sc,
    Yb.BasicShader = {
        vertex_shader: "",
        fragment_shader: ""
    },
    Yb.ShaderUtil = {},
    Yb.ShaderUtil.getShader = function(a) {},
    Yb.ShaderChunk = {
        gradient_parts_fragment: ["#ifdef MAX_GRADIENT", "uniform vec3 gradientColor[MAX_GRADIENT];", "uniform float gradientStop[MAX_GRADIENT];", "uniform int gradientType;", "#endif"].join("\n"),
        gradient_basic_fragment: ["#ifdef MAX_GRADIENT", "float gradientUV = 1.0;", "float PI = 3.14;", "if(gradientType == 1){", "gradientUV = oUv.x;", "} else if(gradientType == 2){", "gradientUV = oUv.y;", "} else if(gradientType == 3){", "gradientUV = (oUv.x + oUv.y)/2.0;", "} else if(gradientType == 4){", "gradientUV = (oUv.x + 1.0 - oUv.y)/2.0;", "} else if(gradientType == 5){", "gradientUV = 1.414 * sqrt((oUv.x - 0.5) * (oUv.x - 0.5) + (oUv.y - 0.5) * (oUv.y - 0.5));", "} else if(gradientType == 6){", "gradientUV = (atan(oUv.y - 0.5,oUv.x - 0.5)) / (2.0 * PI);", "if(gradientUV < 0.0){", "gradientUV = 1.0 + gradientUV;", "}", "}", "for( int i = 1; i < MAX_GRADIENT; i ++ ){", "if(gradientStop[i - 1] <= gradientUV){", "if((gradientStop[i] >= gradientUV)){", "vec3 color1 = gradientColor[i-1];", "vec3 color2 = gradientColor[i];", "float stop1 = gradientStop[i-1];", "float stop2 =gradientStop[i]; ", "gl_FragColor = vec4( (color1 * (stop2 - gradientUV )  + color2 * (gradientUV - stop1))/(stop2 - stop1),opacity);", "break;", "}", "}", "}", "#endif"].join("\n"),
        gradient_phong_fragment: ["#ifdef MAX_GRADIENT", "float gradientUV = 1.0;", "float PI = 3.14;", "if(gradientType == 1){", "gradientUV = oUv.x;", "} else if(gradientType == 2){", "gradientUV = oUv.y;", "} else if(gradientType == 3){", "gradientUV = (oUv.x + oUv.y)/2.0;", "} else if(gradientType == 4){", "gradientUV = (oUv.x + 1.0 - oUv.y)/2.0;", "} else if(gradientType == 5){", "gradientUV = 1.414 * sqrt((oUv.x - 0.5) * (oUv.x - 0.5) + (oUv.y - 0.5) * (oUv.y - 0.5));", "} else if(gradientType == 6){", "gradientUV = (atan(oUv.y - 0.5,oUv.x - 0.5)) / (2.0 * PI);", "if(gradientUV < 0.0){", "gradientUV = 1.0 + gradientUV;", "}", "}", "for( int i = 1; i < MAX_GRADIENT; i ++ ){", "if(gradientStop[i - 1] < gradientUV){", "if((gradientStop[i] > gradientUV)){", "vec3 color1 = gradientColor[i-1];", "vec3 color2 = gradientColor[i];", "float stop1 = gradientStop[i-1];", "float stop2 = gradientStop[i]; ", "tempDiffuse = (color1 * (stop2 - gradientUV )  + color2 * (gradientUV - stop1))/(stop2 - stop1);", "break;", "}", "}", "}", "#endif"].join("\n"),
        fog_pars_fragment: ["#ifdef USE_FOG", "uniform vec3 fogColor;", "#ifdef FOG_EXP2", "uniform float fogDensity;", "#else", "uniform float fogNear;", "uniform float fogFar;", "#endif", "#endif"].join("\n"),
        fog_fragment: ["#ifdef USE_FOG", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "#ifdef FOG_EXP2", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "#else", "float fogFactor = smoothstep( fogNear, fogFar, depth );", "#endif", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "#endif"].join("\n"),
        envmap_pars_fragment: ["#ifdef USE_ENVMAP", "uniform float reflectivity;", "uniform samplerCube envMap;", "uniform float flipEnvMap;", "uniform int combine;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "uniform bool useRefract;", "uniform float refractionRatio;", "#else", "varying vec3 vReflect;", "#endif", "#endif"].join("\n"),
        envmap_fragment: ["#ifdef USE_ENVMAP", "vec3 reflectVec;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "if ( useRefract ) {", "reflectVec = refract( cameraToVertex, normal, refractionRatio );", "} else { ", "reflectVec = reflect( cameraToVertex, normal );", "}", "#else", "reflectVec = vReflect;", "#endif", "#ifdef DOUBLE_SIDED", "float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "vec4 cubeColor = textureCube( envMap, flipNormal * vec3( reflectVec.x*flipEnvMap,  reflectVec.y,reflectVec.z) );", "#else", "vec4 cubeColor = textureCube( envMap, vec3(reflectVec.x*flipEnvMap,  reflectVec.y,reflectVec.z) );", "#endif", "#ifdef GAMMA_INPUT", "cubeColor.xyz *= cubeColor.xyz;", "#endif", "#ifdef PHONG", "#else", "float specularStrength = 1.0;", "#endif", "if ( combine == 1 ) {", "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );", "} else if ( combine == 2 ) {", "gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;", "} else {", "gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );", "}", "#endif"].join("\n"),
        envmap_pars_vertex: ["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )", "varying vec3 vReflect;", "uniform float refractionRatio;", "uniform bool useRefract;", "#endif"].join("\n"),
        worldpos_vertex: ["#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP ) ", "#ifdef USE_SKINNING", "vec4 worldPosition = modelMatrix * skinned;", "#endif", "#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )", "vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );", "#endif", "#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "#endif", "#endif"].join("\n"),
        envmap_vertex: ["#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )", "vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;", "worldNormal = normalize( worldNormal );", "vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );", "if ( useRefract ) {", "vReflect = refract( cameraToVertex, worldNormal, refractionRatio );", "} else {", "vReflect = reflect( cameraToVertex, worldNormal );", "}", "#endif"].join("\n"),
        map_particle_pars_fragment: ["#ifdef USE_MAP", "uniform sampler2D map;", "#endif"].join("\n"),
        map_particle_fragment: ["#ifdef USE_MAP", "gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );", "#endif"].join("\n"),
        map_pars_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined(MAX_GRADIENT)", "varying vec2 vUv;", "varying vec2 oUv;", "uniform vec4 offsetRepeat;", "uniform bool flipX; ", "#endif"].join("\n"),
        map_pars_fragment: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined(MAX_GRADIENT)", "varying vec2 vUv;", "varying vec2 oUv;", "#endif", "#ifdef USE_MAP", "uniform bool mapLoaded;", "uniform sampler2D map;", "#endif"].join("\n"),
        map_vertex: ["#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined(MAX_GRADIENT)", "if(flipX){", "vUv.x = uv.x * offsetRepeat.z * (-1.0) + offsetRepeat.x + offsetRepeat.z;", "vUv.y = uv.y * offsetRepeat.w  + offsetRepeat.y;", "}else{", "vUv = uv * offsetRepeat.zw  + offsetRepeat.xy;", "}", "oUv = uv;", "#endif"].join("\n"),
        map_fragment: ["#ifdef USE_MAP", "if(mapLoaded){", "vec4 texelColor = texture2D( map, vUv );", "#ifdef GAMMA_INPUT", "texelColor.xyz *= texelColor.xyz;", "#endif", "gl_FragColor = texelColor * gl_FragColor;", "}", "#endif"].join("\n"),
        lightmap_pars_fragment: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "uniform sampler2D lightMap;", "#endif"].join("\n"),
        lightmap_pars_vertex: ["#ifdef USE_LIGHTMAP", "varying vec2 vUv2;", "#endif"].join("\n"),
        lightmap_fragment: ["#ifdef USE_LIGHTMAP", "gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );", "#endif"].join("\n"),
        lightmap_vertex: ["#ifdef USE_LIGHTMAP", "vUv2 = uv2;", "#endif"].join("\n"),
        bumpmap_pars_fragment: ["#ifdef USE_BUMPMAP", "uniform sampler2D bumpMap;", "uniform float bumpScale;", "vec2 dHdxy_fwd() {", "vec2 dSTdx = dFdx( vUv );", "vec2 dSTdy = dFdy( vUv );", "float Hll = bumpScale * texture2D( bumpMap, vUv ).x;", "float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;", "float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;", "return vec2( dBx, dBy );", "}", "vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {", "vec3 vSigmaX = dFdx( surf_pos );", "vec3 vSigmaY = dFdy( surf_pos );", "vec3 vN = surf_norm;", "vec3 R1 = cross( vSigmaY, vN );", "vec3 R2 = cross( vN, vSigmaX );", "float fDet = dot( vSigmaX, R1 );", "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );", "return normalize( abs( fDet ) * surf_norm - vGrad );", "}", "#endif"].join("\n"),
        normalmap_pars_fragment: ["#ifdef USE_NORMALMAP", "uniform sampler2D normalMap;", "uniform vec2 normalScale;", "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {", "vec3 q0 = dFdx( eye_pos.xyz );", "vec3 q1 = dFdy( eye_pos.xyz );", "vec2 st0 = dFdx( vUv.st );", "vec2 st1 = dFdy( vUv.st );", "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );", "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );", "vec3 N = normalize( surf_norm );", "vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;", "mapN.xy = normalScale * mapN.xy;", "mat3 tsn = mat3( S, T, N );", "return normalize( tsn * mapN );", "}", "#endif"].join("\n"),
        specularmap_pars_fragment: ["#ifdef USE_SPECULARMAP", "uniform sampler2D specularMap;", "#endif"].join("\n"),
        specularmap_fragment: ["float specularStrength;", "#ifdef USE_SPECULARMAP", "vec4 texelSpecular = texture2D( specularMap, vUv );", "specularStrength = texelSpecular.r;", "#else", "specularStrength = uspecularStrength;", "#endif"].join("\n"),
        lights_lambert_pars_vertex: ["uniform vec3 ambient;", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "#endif", "#ifdef WRAP_AROUND", "uniform vec3 wrapRGB;", "#endif"].join("\n"),
        lights_lambert_vertex: ["vLightFront = vec3( 0.0 );", "#ifdef DOUBLE_SIDED", "vLightBack = vec3( 0.0 );", "#endif", "transformedNormal = normalize( transformedNormal );", "#if MAX_DIR_LIGHTS > 0", "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "float dotProduct = dot( transformedNormal, dirVector );", "vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );", "#ifdef DOUBLE_SIDED", "vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );", "#ifdef WRAP_AROUND", "vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );", "#endif", "#endif", "#ifdef WRAP_AROUND", "vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );", "directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );", "#ifdef DOUBLE_SIDED", "directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );", "#endif", "#endif", "vLightFront += directionalLightColor[ i ] * directionalLightWeighting;", "#ifdef DOUBLE_SIDED", "vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;", "#endif", "}", "#endif", "#if MAX_POINT_LIGHTS > 0 ", "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "float dotProduct = dot( transformedNormal, lVector );", "vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );", "#ifdef DOUBLE_SIDED", "vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );", "#ifdef WRAP_AROUND", "vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );", "#endif", "#endif", "#ifdef WRAP_AROUND", "vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );", "pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );", "#ifdef DOUBLE_SIDED", "pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );", "#endif", "#endif", "vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;", "#ifdef DOUBLE_SIDED", "vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;", "#endif", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );", "if ( spotEffect > spotLightAngleCos[ i ] ) {", "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );", "float lDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "float dotProduct = dot( transformedNormal, lVector );", "vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );", "#ifdef DOUBLE_SIDED", "vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );", "#ifdef WRAP_AROUND", "vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );", "#endif", "#endif", "#ifdef WRAP_AROUND", "vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );", "spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );", "#ifdef DOUBLE_SIDED", "spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );", "#endif", "#endif", "vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;", "#ifdef DOUBLE_SIDED", "vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;", "#endif", "}", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( transformedNormal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;", "vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "#ifdef DOUBLE_SIDED", "vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );", "#endif", "}", "#endif", "vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;", "#ifdef DOUBLE_SIDED", "vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;", "#endif"].join("\n"),
        lights_phong_pars_vertex: ["#ifndef PHONG_PER_PIXEL", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "varying vec3 vWorldPosition;", "#endif"].join("\n"),
        lights_phong_vertex: ["#ifndef PHONG_PER_PIXEL", "#if MAX_POINT_LIGHTS > 0", "for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "vPointLight[ i ] = vec4( lVector, lDistance );", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz - mvPosition.xyz;", "float lDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );", "vSpotLight[ i ] = vec4( lVector, lDistance );", "}", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ", "vWorldPosition = worldPosition.xyz;", "#endif"].join("\n"),
        lights_phong_pars_fragment: ["uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "#ifdef PHONG_PER_PIXEL", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#else", "varying vec4 vPointLight[ MAX_POINT_LIGHTS ];", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "#ifdef PHONG_PER_PIXEL", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "#else", "varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];", "#endif", "#endif", "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "varying vec3 vWorldPosition;", "#endif", "#ifdef WRAP_AROUND", "uniform vec3 wrapRGB;", "#endif", "varying vec3 vViewPosition;", "varying vec3 vNormal;"].join("\n"),
        lights_phong_fragment: ["vec3 normal = normalize( vNormal );", "vec3 viewPosition = normalize( vViewPosition );", "#ifdef DOUBLE_SIDED", "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "#endif", "#ifdef USE_NORMALMAP", "normal = perturbNormal2Arb( -viewPosition, normal );", "#elif defined( USE_BUMPMAP )", "normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );", "#endif", "#if MAX_POINT_LIGHTS > 0", "vec3 pointDiffuse  = vec3( 0.0 );", "vec3 pointSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "#ifdef PHONG_PER_PIXEL", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz + vViewPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "#else", "vec3 lVector = normalize( vPointLight[ i ].xyz );", "float lDistance = vPointLight[ i ].w;", "#endif", "float dotProduct = dot( normal, lVector );", "#ifdef WRAP_AROUND", "float pointDiffuseWeightFull = max( dotProduct, 0.0 );", "float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );", "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );", "#else", "float pointDiffuseWeight = max( dotProduct, 0.0 );", "#endif", "pointDiffuse  += tempDiffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;", "vec3 pointHalfVector = normalize( lVector + viewPosition );", "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );", "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;", "#else", "pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;", "#endif", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "vec3 spotDiffuse  = vec3( 0.0 );", "vec3 spotSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "#ifdef PHONG_PER_PIXEL", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz + vViewPosition.xyz;", "float lDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "#else", "vec3 lVector = normalize( vSpotLight[ i ].xyz );", "float lDistance = vSpotLight[ i ].w;", "#endif", "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );", "if ( spotEffect > spotLightAngleCos[ i ]) {", "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );", "float dotProduct = dot( normal, lVector );", "#ifdef WRAP_AROUND", "float spotDiffuseWeightFull = max( dotProduct, 0.0 );", "float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );", "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );", "#else", "float spotDiffuseWeight = max( dotProduct, 0.0 );", "#endif", "spotDiffuse += tempDiffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;", "vec3 spotHalfVector = normalize( lVector + viewPosition );", "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );", "float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );", "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;", "#else", "spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;", "#endif", "}", "}", "#endif", "#if MAX_DIR_LIGHTS > 0", "vec3 dirDiffuse  = vec3( 0.0 );", "vec3 dirSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, dirVector );", "#ifdef WRAP_AROUND", "float dirDiffuseWeightFull = max( dotProduct, 0.0 );", "float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );", "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );", "#else", "float dirDiffuseWeight = max( dotProduct, 0.0 );", "#endif", "dirDiffuse  += tempDiffuse * directionalLightColor[ i ] * dirDiffuseWeight;", "vec3 dirHalfVector = normalize( dirVector + viewPosition );", "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );", "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;", "#else", "dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;", "#endif", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "vec3 hemiDiffuse  = vec3( 0.0 );", "vec3 hemiSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "hemiDiffuse += tempDiffuse * hemiColor;", "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );", "vec3 lVectorGround = -lVector;", "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float dotProductGround = dot( normal, lVectorGround );", "float specularNormalization = ( shininess + 2.0001 ) / 8.0;", "vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );", "vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );", "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );", "#else", "hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;", "#endif", "}", "#endif", "vec3 totalDiffuse = vec3( 0.0 );", "vec3 totalSpecular = vec3( 0.0 );", "#if MAX_DIR_LIGHTS > 0", "totalDiffuse += dirDiffuse;", "totalSpecular += dirSpecular;", "#endif", "#if MAX_HEMI_LIGHTS > 0", "totalDiffuse += hemiDiffuse;", "totalSpecular += hemiSpecular;", "#endif", "#if MAX_POINT_LIGHTS > 0", "totalDiffuse += pointDiffuse;", "totalSpecular += pointSpecular;", "#endif", "#if MAX_SPOT_LIGHTS > 0", "totalDiffuse += spotDiffuse;", "totalSpecular += spotSpecular;", "#endif", "float ssao = 1.0;", "#ifdef USE_SSAO", "ssao = clamp(1.0 - texture2D(mapSSAO, (finalPosition.xy / finalPosition.w / 2.0 + vec2(0.5,0.5))).x,0.0,1.0);", "#endif", "#ifdef METAL", "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + (ambientLightColor * ambient * ssao) + totalSpecular );", "#else", "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + (ambientLightColor * ambient) * ssao ) + totalSpecular;", "#endif"].join("\n"),
        color_pars_fragment: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"),
        color_fragment: ["#ifdef USE_COLOR", "gl_FragColor = gl_FragColor * vec4( vColor, opacity );", "#endif"].join("\n"),
        color_pars_vertex: ["#ifdef USE_COLOR", "varying vec3 vColor;", "#endif"].join("\n"),
        color_vertex: ["#ifdef USE_COLOR", "#ifdef GAMMA_INPUT", "vColor = color * color;", "#else", "vColor = color;", "#endif", "#endif"].join("\n"),
        skinning_pars_vertex: ["#ifdef USE_SKINNING", "#ifdef BONE_TEXTURE", "uniform sampler2D boneTexture;", "mat4 getBoneMatrix( const in float i ) {", "float j = i * 4.0;", "float x = mod( j, N_BONE_PIXEL_X );", "float y = floor( j / N_BONE_PIXEL_X );", "const float dx = 1.0 / N_BONE_PIXEL_X;", "const float dy = 1.0 / N_BONE_PIXEL_Y;", "y = dy * ( y + 0.5 );", "vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );", "vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );", "vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );", "vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );", "mat4 bone = mat4( v1, v2, v3, v4 );", "return bone;", "}", "#else", "uniform mat4 boneGlobalMatrices[ MAX_BONES ];", "mat4 getBoneMatrix( const in float i ) {", "mat4 bone = boneGlobalMatrices[ int(i) ];", "return bone;", "}", "#endif", "#endif"].join("\n"),
        skinbase_vertex: ["#ifdef USE_SKINNING", "mat4 boneMatX = getBoneMatrix( skinIndex.x );", "mat4 boneMatY = getBoneMatrix( skinIndex.y );", "#endif"].join("\n"),
        skinning_vertex: ["#ifdef USE_SKINNING", "#ifdef USE_MORPHTARGETS", "vec4 skinVertex = vec4( morphed, 1.0 );", "#else", "vec4 skinVertex = vec4( position, 1.0 );", "#endif", "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;", "skinned 	  += boneMatY * skinVertex * skinWeight.y;", "#endif"].join("\n"),
        morphtarget_pars_vertex: ["#ifdef USE_MORPHTARGETS", "#ifndef USE_MORPHNORMALS", "uniform float morphTargetInfluences[ 8 ];", "#else", "uniform float morphTargetInfluences[ 4 ];", "#endif", "#endif"].join("\n"),
        morphtarget_vertex: ["#ifdef USE_MORPHTARGETS", "vec3 morphed = vec3( 0.0 );", "morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];", "morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];", "morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];", "morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];", "#ifndef USE_MORPHNORMALS", "morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];", "morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];", "morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];", "morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];", "#endif", "morphed += position;", "#endif"].join("\n"),
        default_vertex: ["vec4 mvPosition;", "#ifdef USE_SKINNING", "mvPosition = modelViewMatrix * skinned;", "#endif", "#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )", "mvPosition = modelViewMatrix * vec4( morphed, 1.0 );", "#endif", "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )", "mvPosition = modelViewMatrix * vec4( position, 1.0 );", "#endif", "gl_Position = projectionMatrix * mvPosition;"].join("\n"),
        morphnormal_vertex: ["#ifdef USE_MORPHNORMALS", "vec3 morphedNormal = vec3( 0.0 );", "morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];", "morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];", "morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];", "morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];", "morphedNormal += normal;", "#endif"].join("\n"),
        skinnormal_vertex: ["#ifdef USE_SKINNING", "mat4 skinMatrix = skinWeight.x * boneMatX;", "skinMatrix 	+= skinWeight.y * boneMatY;", "#ifdef USE_MORPHNORMALS", "vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );", "#else", "vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );", "#endif", "#endif"].join("\n"),
        defaultnormal_vertex: ["vec3 objectNormal;", "#ifdef USE_SKINNING", "objectNormal = skinnedNormal.xyz;", "#endif", "#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )", "objectNormal = morphedNormal;", "#endif", "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )", "objectNormal = normal;", "#endif", "#ifdef FLIP_SIDED", "objectNormal = -objectNormal;", "#endif", "vec3 transformedNormal = normalMatrix * objectNormal;"].join("\n"),
        shadowmap_pars_fragment: ["#ifdef USE_SHADOWMAP", "uniform sampler2D shadowMap[ MAX_SHADOWS ];", "uniform vec2 shadowMapSize[ MAX_SHADOWS ];", "uniform float shadowDarkness[ MAX_SHADOWS ];", "uniform float shadowBias[ MAX_SHADOWS ];", "varying vec4 vShadowCoord[ MAX_SHADOWS ];", "#endif", "#ifdef USE_POINT_SHADOWMAP", "uniform samplerCube pShadowMap[MAX_POINT_SHADOWS];", "uniform float pShadowDarkness[MAX_POINT_SHADOWS];", "uniform vec3 pPosition[MAX_POINT_SHADOWS];", "varying vec4 pWorldPosition;", "#endif", "#if defined(USE_SHADOWMAP) || defined(USE_POINT_SHADOWMAP)", "float unpackDepth( const in vec4 rgba_depth ) {", "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "float depth = dot( rgba_depth, bit_shift );", "return depth;", "}", "float unpack (vec4 colour){", "const vec4 bitShifts = vec4(1.0,1.0 / 255.0,1.0 / (255.0 * 255.0),1.0 / (255.0 * 255.0 * 255.0));", "return dot(colour, bitShifts) * 100000.0;", "}", "#endif"].join("\n"),
        shadowmap_fragment: ["#ifdef USE_SHADOWMAP", "#ifdef SHADOWMAP_DEBUG", "vec3 frustumColors[3];", "frustumColors[0] = vec3( 1.0, 0.5, 0.0 );", "frustumColors[1] = vec3( 0.0, 1.0, 0.8 );", "frustumColors[2] = vec3( 0.0, 0.5, 1.0 );", "#endif", "#ifdef SHADOWMAP_CASCADE", "int inFrustumCount = 0;", "#endif", "float fDepth;", "vec3 shadowColor = vec3( 1.0 );", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;", "bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );", "bool inFrustum = all( inFrustumVec );", "#ifdef SHADOWMAP_CASCADE", "inFrustumCount += int( inFrustum );", "bvec3 frustumTestVec = bvec3(inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );", "#else", "bvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0 );", "#endif", "bool frustumTest = all( frustumTestVec );", "if ( frustumTest) {", "shadowCoord.z += shadowBias[ i ];", "#if defined( SHADOWMAP_TYPE_PCF )", "float shadow = 0.0;", "const float shadowDelta = 1.0 / 9.0;", "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;", "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;", "float dx0 = -1.25 * xPixelOffset;", "float dy0 = -1.25 * yPixelOffset;", "float dx1 = 1.25 * xPixelOffset;", "float dy1 = 1.25 * yPixelOffset;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );", "if ( fDepth < shadowCoord.z ) shadow += shadowDelta;", "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );", "#elif defined( SHADOWMAP_TYPE_PCF_SOFT )", "float shadow = 0.0;", "float xPixelOffset = 1.0 / shadowMapSize[ i ].x;", "float yPixelOffset = 1.0 / shadowMapSize[ i ].y;", "float dx0 = -1.0 * xPixelOffset;", "float dy0 = -1.0 * yPixelOffset;", "float dx1 = 1.0 * xPixelOffset;", "float dy1 = 1.0 * yPixelOffset;", "mat3 shadowKernel;", "mat3 depthKernel;", "depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );", "if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;", "else shadowKernel[0][0] = 0.0;", "depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );", "if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;", "else shadowKernel[0][1] = 0.0;", "depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );", "if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;", "else shadowKernel[0][2] = 0.0;", "depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );", "if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;", "else shadowKernel[1][0] = 0.0;", "depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );", "if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;", "else shadowKernel[1][1] = 0.0;", "depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );", "if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;", "else shadowKernel[1][2] = 0.0;", "depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );", "if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;", "else shadowKernel[2][0] = 0.0;", "depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );", "if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;", "else shadowKernel[2][1] = 0.0;", "depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );", "if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;", "else shadowKernel[2][2] = 0.0;", "vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );", "shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );", "shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );", "vec4 shadowValues;", "shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );", "shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );", "shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );", "shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );", "shadow = dot( shadowValues, vec4( 1.0 ) );", "shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );", "#else", "vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );", "float fDepth = unpackDepth( rgbaDepth );", "if ( fDepth < shadowCoord.z )", "shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );", "#endif", "}", "#ifdef SHADOWMAP_DEBUG", "#ifdef SHADOWMAP_CASCADE", "if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];", "#else", "if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];", "#endif", "#endif", "}", "#ifdef GAMMA_OUTPUT", "shadowColor *= shadowColor;", "#endif", "gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;", "#endif", "#ifdef USE_POINT_SHADOWMAP", "for( int i = 0; i < MAX_POINT_SHADOWS; i ++ ) {", "vec3 lightVec = normalize(pWorldPosition.xyz - pPosition[i]);", "float depth = length(pWorldPosition.xyz - pPosition[i]);", "float shadowDepth = unpack (textureCube(pShadowMap[i], lightVec));", "depth = depth * 0.95;", "if ( depth > shadowDepth){", "gl_FragColor.xyz *= 0.8;", "}", "}", "#endif"].join("\n"),
        shadowmap_pars_vertex: ["#ifdef USE_SHADOWMAP", "varying vec4 vShadowCoord[ MAX_SHADOWS ];", "uniform mat4 shadowMatrix[ MAX_SHADOWS ];", "#endif", "#ifdef USE_POINT_SHADOWMAP", "varying vec4 pWorldPosition;", "#endif"].join("\n"),
        shadowmap_vertex: ["#ifdef USE_SHADOWMAP", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "}", "#endif", "#ifdef USE_POINT_SHADOWMAP", "pWorldPosition = modelMatrix * vec4(position,1.0);", "#endif"].join("\n"),
        alphatest_fragment: ["#ifdef ALPHATEST", "if ( gl_FragColor.a < ALPHATEST ) discard;", "#endif"].join("\n"),
        linear_to_gamma_fragment: ["#ifdef GAMMA_OUTPUT", "gl_FragColor.xyz = sqrt( gl_FragColor.xyz );", "#endif"].join("\n")
    },
    Yb.UniformsUtils = {
        merge: function(a) {
            var b, c, d, e = {};
            for (b = 0; b < a.length; b++) {
                d = this.clone(a[b]);
                for (c in d) e[c] = d[c]
            }
            return e
        },
        clone: function(a) {
            var b, c, d, e = {};
            for (b in a) {
                e[b] = {};
                for (c in a[b]) d = a[b][c],
                d instanceof Yb.Color || d instanceof Yb.Vec2 || d instanceof Yb.Vec3 || d instanceof Yb.Vec4 || d instanceof Yb.Mat4 || d instanceof Yb.Texture ? e[b][c] = d.clone() : d instanceof Array ? e[b][c] = d.slice() : e[b][c] = d
            }
            return e
        }
    },
    Yb.UniformsLib = {
        outline: {
            diffuse: {
                type: "c",
                value: new Yb.Color(15658734)
            },
            outline_offset: {
                type: "f",
                value: 0
            }
        },
        glow: {
            map: {
                type: "t",
                value: null
            }
        },
        blur: {
            orientation: {
                type: "i",
                value: 0
            },
            texelSize: {
                type: "v2",
                value: new Yb.Vec2(512, 512)
            },
            blurAmount: {
                type: "i",
                value: 10
            },
            blurScale: {
                type: "f",
                value: 1
            },
            blurStrength: {
                type: "f",
                value: .2
            },
            map: {
                type: "t",
                value: null
            },
            useBlur: {
                type: "i",
                value: 1
            },
            blurGlobalAlpha: {
                type: "f",
                value: 1
            }
        },
        deferred: {
            linearDepth: {
                type: "f",
                value: 9e3
            },
            isNormal: {
                type: "i",
                value: 1
            }
        },
        ssao: {
            map0: {
                type: "t",
                value: null
            },
            map1: {
                type: "t",
                value: null
            },
            map2: {
                type: "t",
                value: null
            },
            occluderBias: {
                type: "f",
                value: .05
            },
            samplingRadius: {
                type: "f",
                value: 20
            },
            attenuation: {
                type: "v2",
                value: new Zb(1, 0)
            },
            texelSize: {
                type: "v2",
                value: new Zb(1 / 512, 1 / 512)
            }
        },
        common: {
            diffuse: {
                type: "c",
                value: new Yb.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            mapLoaded: {
                type: "i",
                value: 0
            },
            offsetRepeat: {
                type: "v4",
                value: new Yb.Vec4(0, 0, 1, 1)
            },
            flipX: {
                type: "i",
                value: 0
            },
            lightMap: {
                type: "t",
                value: null
            },
            specularMap: {
                type: "t",
                value: null
            },
            envMap: {
                type: "t",
                value: null
            },
            flipEnvMap: {
                type: "f",
                value: -1
            },
            useRefract: {
                type: "i",
                value: 0
            },
            reflectivity: {
                type: "f",
                value: 1
            },
            refractionRatio: {
                type: "f",
                value: .98
            },
            combine: {
                type: "i",
                value: 0
            },
            morphTargetInfluences: {
                type: "f",
                value: 0
            }
        },
        gradient: {
            gradientColor: {
                type: "v3v",
                value: []
            },
            gradientStop: {
                type: "fv1",
                value: []
            },
            gradientType: {
                type: "i",
                value: 0
            }
        },
        bump: {
            bumpMap: {
                type: "t",
                value: null
            },
            bumpScale: {
                type: "f",
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                type: "t",
                value: null
            },
            normalScale: {
                type: "v2",
                value: new Yb.Vec2(1, 1)
            }
        },
        fog: {
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new Yb.Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                type: "fv",
                value: []
            },
            directionalLightDirection: {
                type: "fv",
                value: []
            },
            directionalLightColor: {
                type: "fv",
                value: []
            },
            hemisphereLightDirection: {
                type: "fv",
                value: []
            },
            hemisphereLightSkyColor: {
                type: "fv",
                value: []
            },
            hemisphereLightGroundColor: {
                type: "fv",
                value: []
            },
            pointLightColor: {
                type: "fv",
                value: []
            },
            pointLightPosition: {
                type: "fv",
                value: []
            },
            pointLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightColor: {
                type: "fv",
                value: []
            },
            spotLightPosition: {
                type: "fv",
                value: []
            },
            spotLightDirection: {
                type: "fv",
                value: []
            },
            spotLightDistance: {
                type: "fv1",
                value: []
            },
            spotLightAngleCos: {
                type: "fv1",
                value: []
            },
            spotLightExponent: {
                type: "fv1",
                value: []
            }
        },
        particle: {
            psColor: {
                type: "c",
                value: new Yb.Color(15658734)
            },
            opacity: {
                type: "f",
                value: 1
            },
            size: {
                type: "f",
                value: 1
            },
            scale: {
                type: "f",
                value: 1
            },
            map: {
                type: "t",
                value: null
            },
            fogDensity: {
                type: "f",
                value: 25e-5
            },
            fogNear: {
                type: "f",
                value: 1
            },
            fogFar: {
                type: "f",
                value: 2e3
            },
            fogColor: {
                type: "c",
                value: new Yb.Color(16777215)
            }
        },
        shadowmap: {
            shadowMap: {
                type: "tv",
                value: []
            },
            shadowMapSize: {
                type: "v2v",
                value: []
            },
            shadowBias: {
                type: "fv1",
                value: []
            },
            shadowDarkness: {
                type: "fv1",
                value: []
            },
            shadowMatrix: {
                type: "m4v",
                value: []
            },
            pShadowMap: {
                type: "tv",
                value: []
            },
            pShadowMapSize: {
                type: "v2v",
                value: []
            },
            pShadowDarkness: {
                type: "fv1",
                value: []
            },
            pPosition: {
                type: "v3v",
                value: []
            }
        }
    },
    Yb.ShaderLib = {
        outline: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.outline]),
            vertexShader: ["uniform float outline_offset;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4( position + normalize(position)  * outline_offset, 1.0 );", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "void main() {", "gl_FragColor = vec4(diffuse, 1.0 );", "}"].join("\n")
        },
        blur: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.blur]),
            vertexShader: ["varying vec2 vUv;", "void main (){", "gl_Position = vec4(position, 1.0);", "vUv = uv;", "}"].join("\n"),
            fragmentShader: ["uniform vec2 texelSize;", "uniform sampler2D map;", "uniform int orientation;", "uniform int blurAmount;", "uniform float blurScale;", "uniform float blurStrength;", "uniform int useBlur;", "uniform float blurGlobalAlpha;", "uniform sampler2D depthMap;", "varying vec2 vUv;", "float Gaussian (float x, float deviation){", "return (1.0 / sqrt(2.0 * 3.141592 * deviation)) * exp(-((x * x) / (2.0 * deviation)));", "}", "void main (){", "float halfBlur = float(blurAmount) * 0.5;", "vec4 colour = vec4(0.0);", "if(useBlur == 0){", "colour = texture2D(map,vUv);", "}else {", "vec4 texColour = vec4(0.0);", "float deviation = halfBlur * 0.35;", "deviation *= deviation;", "float strength = 1.0 - blurStrength;", "if ( orientation == 0 ){", "for (int i = 0; i < 20; ++i){", "if ( i >= blurAmount ){", "break;", "}", "float offset = float(i) - halfBlur;", "texColour = texture2D(map, vUv + vec2(offset / texelSize.x * blurScale, 0.0)) * Gaussian(offset * strength, deviation);", "colour += texColour;", "}", "}else{", "for (int i = 0; i < 20; ++i){", "if ( i >= blurAmount )", "break;", "float offset = float(i) - halfBlur;", "texColour = texture2D(map, vUv + vec2(0.0, offset / texelSize.y * blurScale)) * Gaussian(offset * strength, deviation);", "colour += texColour;", "}", "}", "}", "gl_FragColor = clamp(colour, 0.0, 1.0);", "if(useBlur == 0){", "gl_FragColor.w *=  gl_FragColor.w * gl_FragColor.w * gl_FragColor.w * blurGlobalAlpha;", "}", "}"].join("\n")
        },
        deferred: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.deferred]),
            vertexShader: ["varying vec4 vPosition;", "varying vec3 vNormal;", "void main (){", "vNormal = mat3(modelViewMatrix) * normal;", "vPosition = modelViewMatrix * vec4(position, 1.0);", "gl_Position = projectionMatrix * vPosition;", "}"].join("\n"),
            fragmentShader: ["uniform float linearDepth;", "uniform int isNormal;", "varying vec4 vPosition;", "varying vec3 vNormal;", "void main (){", "float linear_depth = length(vPosition) / linearDepth;", "if(isNormal == 1){", "vec3 normal = normalize(vNormal);", "gl_FragColor = vec4(normal.x, normal.y, normal.z, 1.0);", "}else{", "gl_FragColor = vec4(vPosition.x, vPosition.y, vPosition.z, linear_depth);", "}", "}"].join("\n")
        },
        ssao: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.ssao]),
            vertexShader: ["varying vec2 vUv;", "void main (){", "gl_Position = vec4(position, 1.0);", "vUv = uv;", "}"].join("\n"),
            fragmentShader: ["uniform sampler2D map0;", "uniform sampler2D map1;", "uniform sampler2D map2;", "uniform vec2 texelSize;", "uniform float occluderBias;", "uniform float samplingRadius;", "uniform vec2 attenuation;", "varying vec2 vUv;", "float samplePixels (vec3 srcPosition, vec3 srcNormal, vec2 uv){", "vec3 dstPosition = texture2D(map0, uv).xyz;", "vec3 positionVec = dstPosition - srcPosition;", "float intensity = max(dot(normalize(positionVec), srcNormal) - occluderBias, 0.0);", "float dist = length(positionVec);", "float attenuationValue = 1.0 / (attenuation.x + (attenuation.y * dist));", "return intensity * attenuationValue;", "}", "void main (){", "vec3 srcPosition = texture2D(map0, vUv).xyz;", "vec3 srcNormal = texture2D(map1, vUv).xyz;", "vec2 randVec = normalize(texture2D(map2, vUv).xy * 2.0 - 1.0);", "float srcDepth = texture2D(map0, vUv).w;", "float kernelRadius = samplingRadius * (1.0 - srcDepth);", "vec2 kernel[4];", "kernel[0] = vec2(0.0, 1.0);", "kernel[1] = vec2(1.0, 0.0);", "kernel[2] = vec2(0.0, -1.0);", "kernel[3] = vec2(-1.0, 0.0);", "const float sin45 = 0.707107;", "float occlusion = 0.0;", "for (int i = 0; i < 4; ++i){", "vec2 k1 = reflect(kernel[i], randVec);", "vec2 k2 = vec2(k1.x * sin45 - k1.y * sin45,k1.x * sin45 + k1.y * sin45);", "k1 *= texelSize;", "k2 *= texelSize;", "occlusion += samplePixels(srcPosition, srcNormal, vUv + k1 * kernelRadius);", "occlusion += samplePixels(srcPosition, srcNormal, vUv + k2 * kernelRadius * 0.75);", "occlusion += samplePixels(srcPosition, srcNormal, vUv + k1 * kernelRadius * 0.5);", "occlusion += samplePixels(srcPosition, srcNormal, vUv + k2 * kernelRadius * 0.25);", "}", "occlusion /= 16.0;", "occlusion = clamp(occlusion, 0.0, 1.0);", "gl_FragColor =  vec4(occlusion,0.0,0.0,1.0);", "}"].join("\n")
        },
        basic: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.common, Yb.UniformsLib.gradient, Yb.UniformsLib.fog]),
            vertexShader: [Yb.ShaderChunk.map_pars_vertex, Yb.ShaderChunk.lightmap_pars_vertex, Yb.ShaderChunk.envmap_pars_vertex, Yb.ShaderChunk.color_pars_vertex, Yb.ShaderChunk.morphtarget_pars_vertex, Yb.ShaderChunk.skinning_pars_vertex, "void main() {", Yb.ShaderChunk.map_vertex, Yb.ShaderChunk.lightmap_vertex, Yb.ShaderChunk.color_vertex, Yb.ShaderChunk.skinbase_vertex, "#ifdef USE_ENVMAP", Yb.ShaderChunk.morphnormal_vertex, Yb.ShaderChunk.skinnormal_vertex, Yb.ShaderChunk.defaultnormal_vertex, "#endif", Yb.ShaderChunk.morphtarget_vertex, Yb.ShaderChunk.skinning_vertex, Yb.ShaderChunk.default_vertex, Yb.ShaderChunk.worldpos_vertex, Yb.ShaderChunk.envmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", Yb.ShaderChunk.color_pars_fragment, Yb.ShaderChunk.map_pars_fragment, Yb.ShaderChunk.gradient_parts_fragment, Yb.ShaderChunk.lightmap_pars_fragment, Yb.ShaderChunk.envmap_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, Yb.ShaderChunk.specularmap_pars_fragment, "void main() {", "gl_FragColor = vec4( diffuse, opacity );", Yb.ShaderChunk.gradient_basic_fragment, Yb.ShaderChunk.map_fragment, Yb.ShaderChunk.alphatest_fragment, Yb.ShaderChunk.lightmap_fragment, Yb.ShaderChunk.color_fragment, Yb.ShaderChunk.envmap_fragment, Yb.ShaderChunk.linear_to_gamma_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        lambert: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.common, Yb.UniformsLib.fog, Yb.UniformsLib.lights, Yb.UniformsLib.shadowmap, {
                ambient: {
                    type: "c",
                    value: new Yb.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new Yb.Color(0)
                },
                wrapRGB: {
                    type: "v3",
                    value: new Yb.Vec3(1, 1, 1)
                }
            }]),
            vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "varying vec3 vLightBack;", "#endif", Yb.ShaderChunk.map_pars_vertex, Yb.ShaderChunk.lightmap_pars_vertex, Yb.ShaderChunk.envmap_pars_vertex, Yb.ShaderChunk.lights_lambert_pars_vertex, Yb.ShaderChunk.color_pars_vertex, Yb.ShaderChunk.morphtarget_pars_vertex, Yb.ShaderChunk.skinning_pars_vertex, Yb.ShaderChunk.shadowmap_pars_vertex, "void main() {", Yb.ShaderChunk.map_vertex, Yb.ShaderChunk.lightmap_vertex, Yb.ShaderChunk.color_vertex, Yb.ShaderChunk.morphnormal_vertex, Yb.ShaderChunk.skinbase_vertex, Yb.ShaderChunk.skinnormal_vertex, Yb.ShaderChunk.defaultnormal_vertex, Yb.ShaderChunk.morphtarget_vertex, Yb.ShaderChunk.skinning_vertex, Yb.ShaderChunk.default_vertex, Yb.ShaderChunk.worldpos_vertex, Yb.ShaderChunk.envmap_vertex, Yb.ShaderChunk.lights_lambert_vertex, Yb.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "varying vec3 vLightBack;", "#endif", Yb.ShaderChunk.color_pars_fragment, Yb.ShaderChunk.map_pars_fragment, Yb.ShaderChunk.lightmap_pars_fragment, Yb.ShaderChunk.envmap_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, Yb.ShaderChunk.shadowmap_pars_fragment, Yb.ShaderChunk.specularmap_pars_fragment, "void main() {", "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );", Yb.ShaderChunk.map_fragment, Yb.ShaderChunk.alphatest_fragment, Yb.ShaderChunk.specularmap_fragment, "#ifdef DOUBLE_SIDED", "if ( gl_FrontFacing )", "gl_FragColor.xyz *= vLightFront;", "else", "gl_FragColor.xyz *= vLightBack;", "#else", "gl_FragColor.xyz *= vLightFront;", "#endif", Yb.ShaderChunk.lightmap_fragment, Yb.ShaderChunk.color_fragment, Yb.ShaderChunk.envmap_fragment, Yb.ShaderChunk.shadowmap_fragment, Yb.ShaderChunk.linear_to_gamma_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        phong: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.common, Yb.UniformsLib.gradient, Yb.UniformsLib.bump, Yb.UniformsLib.normalmap, Yb.UniformsLib.fog, Yb.UniformsLib.lights, Yb.UniformsLib.shadowmap, {
                ambient: {
                    type: "c",
                    value: new Yb.Color(16777215)
                },
                emissive: {
                    type: "c",
                    value: new Yb.Color(0)
                },
                specular: {
                    type: "c",
                    value: new Yb.Color(1118481)
                },
                uspecularStrength: {
                    type: "f",
                    value: 1
                },
                shininess: {
                    type: "f",
                    value: 30
                },
                wrapRGB: {
                    type: "v3",
                    value: new Yb.Vec3(1, 1, 1)
                },
                mapSSAO: {
                    type: "t",
                    value: null
                }
            }]),
            vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "varying vec4 finalPosition;", Yb.ShaderChunk.map_pars_vertex, Yb.ShaderChunk.lightmap_pars_vertex, Yb.ShaderChunk.envmap_pars_vertex, Yb.ShaderChunk.lights_phong_pars_vertex, Yb.ShaderChunk.color_pars_vertex, Yb.ShaderChunk.morphtarget_pars_vertex, Yb.ShaderChunk.skinning_pars_vertex, Yb.ShaderChunk.shadowmap_pars_vertex, "void main() {", Yb.ShaderChunk.map_vertex, Yb.ShaderChunk.lightmap_vertex, Yb.ShaderChunk.color_vertex, Yb.ShaderChunk.morphnormal_vertex, Yb.ShaderChunk.skinbase_vertex, Yb.ShaderChunk.skinnormal_vertex, Yb.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", Yb.ShaderChunk.morphtarget_vertex, Yb.ShaderChunk.skinning_vertex, Yb.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", Yb.ShaderChunk.worldpos_vertex, Yb.ShaderChunk.envmap_vertex, Yb.ShaderChunk.lights_phong_vertex, Yb.ShaderChunk.shadowmap_vertex, "finalPosition = gl_Position;", "}"].join("\n"),
            fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform float opacity;", "uniform vec3 ambient;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float uspecularStrength;", "uniform float shininess;", "varying vec4 finalPosition;", Yb.ShaderChunk.color_pars_fragment, Yb.ShaderChunk.gradient_parts_fragment, Yb.ShaderChunk.map_pars_fragment, Yb.ShaderChunk.lightmap_pars_fragment, Yb.ShaderChunk.envmap_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, Yb.ShaderChunk.lights_phong_pars_fragment, Yb.ShaderChunk.shadowmap_pars_fragment, Yb.ShaderChunk.bumpmap_pars_fragment, Yb.ShaderChunk.normalmap_pars_fragment, Yb.ShaderChunk.specularmap_pars_fragment, "#ifdef USE_SSAO", "uniform sampler2D mapSSAO;", "#endif", "void main() {", "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );", "vec3 tempDiffuse = diffuse;", Yb.ShaderChunk.gradient_phong_fragment, Yb.ShaderChunk.map_fragment, Yb.ShaderChunk.alphatest_fragment, Yb.ShaderChunk.specularmap_fragment, Yb.ShaderChunk.lights_phong_fragment, Yb.ShaderChunk.lightmap_fragment, Yb.ShaderChunk.color_fragment, Yb.ShaderChunk.envmap_fragment, Yb.ShaderChunk.shadowmap_fragment, Yb.ShaderChunk.linear_to_gamma_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        particle_basic: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.particle, Yb.UniformsLib.shadowmap]),
            vertexShader: ["uniform float size;", "uniform float scale;", Yb.ShaderChunk.color_pars_vertex, Yb.ShaderChunk.shadowmap_pars_vertex, "void main() {", Yb.ShaderChunk.color_vertex, "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "#ifdef USE_SIZEATTENUATION", "gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "#else", "gl_PointSize = size;", "#endif", "gl_Position = projectionMatrix * mvPosition;", Yb.ShaderChunk.worldpos_vertex, Yb.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", Yb.ShaderChunk.color_pars_fragment, Yb.ShaderChunk.map_particle_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, Yb.ShaderChunk.shadowmap_pars_fragment, "void main() {", "gl_FragColor = vec4( psColor, opacity );", Yb.ShaderChunk.map_particle_fragment, Yb.ShaderChunk.alphatest_fragment, Yb.ShaderChunk.color_fragment, Yb.ShaderChunk.shadowmap_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        billboard: {
            vertexShader: ["uniform int useScreenCoordinates;", "uniform int sizeAttenuation;", "uniform vec3 screenPosition;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 alignment;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position + alignment;", "vec2 rotatedPosition;", "rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;", "rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;", "vec4 finalPosition;", "if( useScreenCoordinates != 0 ) {", "finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );", "} else {", "finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );", "}", "gl_Position = finalPosition;", "}"].join("\n"),
            fragmentShader: ["uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")
        },
        dashed: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.common, Yb.UniformsLib.fog, {
                scale: {
                    type: "f",
                    value: 1
                },
                dashSize: {
                    type: "f",
                    value: 1
                },
                totalSize: {
                    type: "f",
                    value: 2
                }
            }]),
            vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", Yb.ShaderChunk.color_pars_vertex, "void main() {", Yb.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", Yb.ShaderChunk.color_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, "void main() {", "if ( mod( vLineDistance, totalSize ) > dashSize ) {", "discard;", "}", "gl_FragColor = vec4( diffuse, opacity );", Yb.ShaderChunk.color_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n")
        },
        depth: {
            uniforms: {
                mNear: {
                    type: "f",
                    value: 1
                },
                mFar: {
                    type: "f",
                    value: 2e3
                },
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", "void main() {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float color = 1.0 - smoothstep( mNear, mFar, depth );", "gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
        },
        normal: {
            uniforms: {
                opacity: {
                    type: "f",
                    value: 1
                }
            },
            vertexShader: ["varying vec3 vNormal;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vNormal = normalize( normalMatrix * normal );", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
            fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", "void main() {", "gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", "}"].join("\n")
        },
        normalmap: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.fog, Yb.UniformsLib.lights, Yb.UniformsLib.shadowmap, {
                enableAO: {
                    type: "i",
                    value: 0
                },
                enableDiffuse: {
                    type: "i",
                    value: 0
                },
                enableSpecular: {
                    type: "i",
                    value: 0
                },
                enableReflection: {
                    type: "i",
                    value: 0
                },
                enableDisplacement: {
                    type: "i",
                    value: 0
                },
                tDisplacement: {
                    type: "t",
                    value: null
                },
                tDiffuse: {
                    type: "t",
                    value: null
                },
                tCube: {
                    type: "t",
                    value: null
                },
                tNormal: {
                    type: "t",
                    value: null
                },
                tSpecular: {
                    type: "t",
                    value: null
                },
                tAO: {
                    type: "t",
                    value: null
                },
                uNormalScale: {
                    type: "v2",
                    value: new Yb.Vec2(1, 1)
                },
                uDisplacementBias: {
                    type: "f",
                    value: 0
                },
                uDisplacementScale: {
                    type: "f",
                    value: 1
                },
                uDiffuseColor: {
                    type: "c",
                    value: new Yb.Color(16777215)
                },
                uSpecularColor: {
                    type: "c",
                    value: new Yb.Color(1118481)
                },
                uSpecualarStrength: {
                    type: "f",
                    value: 1
                },
                uAmbientColor: {
                    type: "c",
                    value: new Yb.Color(16777215)
                },
                uShininess: {
                    type: "f",
                    value: 30
                },
                uOpacity: {
                    type: "f",
                    value: 1
                },
                useRefract: {
                    type: "i",
                    value: 0
                },
                uRefractionRatio: {
                    type: "f",
                    value: .98
                },
                uReflectivity: {
                    type: "f",
                    value: .5
                },
                uOffset: {
                    type: "v2",
                    value: new Yb.Vec2(0, 0)
                },
                uRepeat: {
                    type: "v2",
                    value: new Yb.Vec2(1, 1)
                },
                wrapRGB: {
                    type: "v3",
                    value: new Yb.Vec3(1, 1, 1)
                }
            }]),
            fragmentShader: ["uniform vec3 uAmbientColor;", "uniform vec3 uDiffuseColor;", "uniform vec3 uSpecularColor;", "uniform vec3 uSpecularStrength;", "uniform float uShininess;", "uniform float uOpacity;", "uniform bool enableDiffuse;", "uniform bool enableSpecular;", "uniform bool enableAO;", "uniform bool enableReflection;", "uniform sampler2D tDiffuse;", "uniform sampler2D tNormal;", "uniform sampler2D tSpecular;", "uniform sampler2D tAO;", "uniform samplerCube tCube;", "uniform vec2 uNormalScale;", "uniform bool useRefract;", "uniform float uRefractionRatio;", "uniform float uReflectivity;", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#endif", "#if MAX_SPOT_LIGHTS > 0", "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];", "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];", "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];", "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];", "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];", "#endif", "#ifdef WRAP_AROUND", "uniform vec3 wrapRGB;", "#endif", "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", Yb.ShaderChunk.shadowmap_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, "void main() {", "gl_FragColor = vec4( vec3( 1.0 ), uOpacity );", "vec3 specularTex = vec3( 1.0 );", "vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;", "normalTex.xy *= uNormalScale;", "normalTex = normalize( normalTex );", "if( enableDiffuse ) {", "#ifdef GAMMA_INPUT", "vec4 texelColor = texture2D( tDiffuse, vUv );", "texelColor.xyz *= texelColor.xyz;", "gl_FragColor = gl_FragColor * texelColor;", "#else", "gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );", "#endif", "}", "if( enableAO ) {", "#ifdef GAMMA_INPUT", "vec4 aoColor = texture2D( tAO, vUv );", "aoColor.xyz *= aoColor.xyz;", "gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;", "#else", "gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;", "#endif", "}", "if( enableSpecular )", "specularTex = texture2D( tSpecular, vUv ).xyz;", "mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );", "vec3 finalNormal = tsb * normalTex;", "#ifdef FLIP_SIDED", "finalNormal = -finalNormal;", "#endif", "vec3 normal = normalize( finalNormal );", "vec3 viewPosition = normalize( vViewPosition );", "#if MAX_POINT_LIGHTS > 0", "vec3 pointDiffuse = vec3( 0.0 );", "vec3 pointSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 pointVector = lPosition.xyz + vViewPosition.xyz;", "float pointDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );", "pointVector = normalize( pointVector );", "#ifdef WRAP_AROUND", "float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );", "float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );", "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );", "#else", "float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );", "#endif", "pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;", "vec3 pointHalfVector = normalize( pointVector + viewPosition );", "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );", "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;", "#else", "pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;", "#endif", "}", "#endif", "#if MAX_SPOT_LIGHTS > 0", "vec3 spotDiffuse = vec3( 0.0 );", "vec3 spotSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );", "vec3 spotVector = lPosition.xyz + vViewPosition.xyz;", "float spotDistance = 1.0;", "if ( spotLightDistance[ i ] > 0.0 )", "spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );", "spotVector = normalize( spotVector );", "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );", "if ( spotEffect > spotLightAngleCos[ i ] ) {", "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );", "#ifdef WRAP_AROUND", "float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );", "float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );", "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );", "#else", "float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );", "#endif", "spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;", "vec3 spotHalfVector = normalize( spotVector + viewPosition );", "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );", "float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );", "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;", "#else", "spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;", "#endif", "}", "}", "#endif", "#if MAX_DIR_LIGHTS > 0", "vec3 dirDiffuse = vec3( 0.0 );", "vec3 dirSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "#ifdef WRAP_AROUND", "float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );", "float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );", "vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );", "#else", "float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );", "#endif", "dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;", "vec3 dirHalfVector = normalize( dirVector + viewPosition );", "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );", "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;", "#else", "dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;", "#endif", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "vec3 hemiDiffuse  = vec3( 0.0 );", "vec3 hemiSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "hemiDiffuse += uDiffuseColor * hemiColor;", "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );", "vec3 lVectorGround = -lVector;", "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );", "#ifdef PHYSICALLY_BASED_SHADING", "float dotProductGround = dot( normal, lVectorGround );", "float specularNormalization = ( uShininess + 2.0001 ) / 8.0;", "vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );", "vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );", "hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );", "#else", "hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;", "#endif", "}", "#endif", "vec3 totalDiffuse = vec3( 0.0 );", "vec3 totalSpecular = vec3( 0.0 );", "#if MAX_DIR_LIGHTS > 0", "totalDiffuse += dirDiffuse;", "totalSpecular += dirSpecular;", "#endif", "#if MAX_HEMI_LIGHTS > 0", "totalDiffuse += hemiDiffuse;", "totalSpecular += hemiSpecular;", "#endif", "#if MAX_POINT_LIGHTS > 0", "totalDiffuse += pointDiffuse;", "totalSpecular += pointSpecular;", "#endif", "#if MAX_SPOT_LIGHTS > 0", "totalDiffuse += spotDiffuse;", "totalSpecular += spotSpecular;", "#endif", "#ifdef METAL", "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );", "#else", "gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;", "#endif", "if ( enableReflection ) {", "vec3 vReflect;", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "if ( useRefract ) {", "vReflect = refract( cameraToVertex, normal, uRefractionRatio );", "} else {", "vReflect = reflect( cameraToVertex, normal );", "}", "vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "#ifdef GAMMA_INPUT", "cubeColor.xyz *= cubeColor.xyz;", "#endif", "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );", "}", Yb.ShaderChunk.shadowmap_fragment, Yb.ShaderChunk.linear_to_gamma_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n"),
            vertexShader: ["attribute vec4 tangent;", "uniform vec2 uOffset;", "uniform vec2 uRepeat;", "uniform bool enableDisplacement;", "#ifdef VERTEX_TEXTURES", "uniform sampler2D tDisplacement;", "uniform float uDisplacementScale;", "uniform float uDisplacementBias;", "#endif", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", Yb.ShaderChunk.skinning_pars_vertex, Yb.ShaderChunk.shadowmap_pars_vertex, "void main() {", Yb.ShaderChunk.skinbase_vertex, Yb.ShaderChunk.skinnormal_vertex, "#ifdef USE_SKINNING", "vNormal = normalize( normalMatrix * skinnedNormal.xyz );", "vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );", "vTangent = normalize( normalMatrix * skinnedTangent.xyz );", "#else", "vNormal = normalize( normalMatrix * normal );", "vTangent = normalize( normalMatrix * tangent.xyz );", "#endif", "vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );", "vUv = uv * uRepeat + uOffset;", "vec3 displacedPosition;", "#ifdef VERTEX_TEXTURES", "if ( enableDisplacement ) {", "vec3 dv = texture2D( tDisplacement, uv ).xyz;", "float df = uDisplacementScale * dv.x + uDisplacementBias;", "displacedPosition = position + normalize( normal ) * df;", "} else {", "#ifdef USE_SKINNING", "vec4 skinVertex = vec4( position, 1.0 );", "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;", "skinned 	  += boneMatY * skinVertex * skinWeight.y;", "displacedPosition  = skinned.xyz;", "#else", "displacedPosition = position;", "#endif", "}", "#else", "#ifdef USE_SKINNING", "vec4 skinVertex = vec4( position, 1.0 );", "vec4 skinned  = boneMatX * skinVertex * skinWeight.x;", "skinned 	  += boneMatY * skinVertex * skinWeight.y;", "displacedPosition  = skinned.xyz;", "#else", "displacedPosition = position;", "#endif", "#endif", "vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );", "vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );", "gl_Position = projectionMatrix * mvPosition;", "vWorldPosition = worldPosition.xyz;", "vViewPosition = -mvPosition.xyz;", "#ifdef USE_SHADOWMAP", "for( int i = 0; i < MAX_SHADOWS; i ++ ) {", "vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;", "}", "#endif", "}"].join("\n")
        },
        cube: {
            uniforms: {
                tCube: {
                    type: "t",
                    value: null
                },
                tFlip: {
                    type: "f",
                    value: -1
                }
            },
            vertexShader: ["varying vec3 vWorldPosition;", "void main() {", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vWorldPosition = worldPosition.xyz;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", "void main() {", "gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", "}"].join("\n")
        },
        depthRGBA: {
            uniforms: {
                isCube: {
                    type: "i",
                    value: 0
                }
            },
            vertexShader: [Yb.ShaderChunk.morphtarget_pars_vertex, Yb.ShaderChunk.skinning_pars_vertex, "varying vec4 vPosition1;", "void main() {", Yb.ShaderChunk.skinbase_vertex, Yb.ShaderChunk.morphtarget_vertex, Yb.ShaderChunk.skinning_vertex, Yb.ShaderChunk.default_vertex, "vPosition1 = modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform int isCube;", "varying vec4 vPosition1;", "varying vec3 vPosition2;", "vec4 pack_depth( const in float depth ) {", "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "vec4 res = fract( depth * bit_shift );", "res -= res.xxyz * bit_mask;", "return res;", "}", "vec4 pack (float depth){", "const vec4 bias = vec4(1.0 / 255.0,1.0 / 255.0,1.0 / 255.0, 0.0);", "float r = depth;", "float g = fract(r * 255.0);", "float b = fract(g * 255.0);", "float a = fract(b * 255.0);", "vec4 colour = vec4(r, g, b, a);", "return colour - (colour.yzww * bias);", "}", "void main() {", "if(isCube == 1){", "gl_FragData[ 0 ] = pack(length(vPosition1) / 100000.0);", "}else{", "gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "}", "}"].join("\n")
        }
    },
    Yb.ShaderTerrain = {
        terrain: {
            uniforms: Yb.UniformsUtils.merge([Yb.UniformsLib.fog, Yb.UniformsLib.lights, Yb.UniformsLib.shadowmap, {
                enableDiffuse1: {
                    type: "i",
                    value: 0
                },
                enableDiffuse2: {
                    type: "i",
                    value: 0
                },
                enableDiffuse3: {
                    type: "i",
                    value: 0
                },
                enableDisplacement: {
                    type: "i",
                    value: 0
                },
                enableSpecular: {
                    type: "i",
                    value: 0
                },
                enableReflection: {
                    type: "i",
                    value: 0
                },
                tDiffuse1: {
                    type: "t",
                    value: null
                },
                tDiffuse2: {
                    type: "t",
                    value: null
                },
                tDiffuse3: {
                    type: "t",
                    value: null
                },
                tDetail: {
                    type: "t",
                    value: null
                },
                tNormal: {
                    type: "t",
                    value: null
                },
                tSpecular: {
                    type: "t",
                    value: null
                },
                tDisplacement: {
                    type: "t",
                    value: null
                },
                heightUnit: {
                    type: "f",
                    value: 1
                },
                blendRange: {
                    type: "fv1",
                    value: null
                },
                uNormalScale: {
                    type: "f",
                    value: 1
                },
                uDisplacementBias: {
                    type: "f",
                    value: 0
                },
                uDisplacementScale: {
                    type: "f",
                    value: 1
                },
                uDiffuseColor: {
                    type: "c",
                    value: new Yb.Color(15658734)
                },
                uSpecularColor: {
                    type: "c",
                    value: new Yb.Color(1118481)
                },
                uAmbientColor: {
                    type: "c",
                    value: new Yb.Color(328965)
                },
                uShininess: {
                    type: "f",
                    value: 30
                },
                uOpacity: {
                    type: "f",
                    value: 1
                },
                uRepeatBase: {
                    type: "v2",
                    value: new Yb.Vec2(1, 1)
                },
                uRepeatOverlay: {
                    type: "v2",
                    value: new Yb.Vec2(1, 1)
                },
                uOffset: {
                    type: "v2",
                    value: new Yb.Vec2(0, 0)
                }
            }]),
            fragmentShader: ["uniform vec3 uAmbientColor;", "uniform vec3 uDiffuseColor;", "uniform vec3 uSpecularColor;", "uniform float uShininess;", "uniform float uOpacity;", "uniform bool enableDiffuse1;", "uniform bool enableDiffuse2;", "uniform bool enableDiffuse3;", "uniform bool enableSpecular;", "uniform bool enableDisplacement;", "uniform float blendRange[2];", "uniform float heightUnit;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "uniform sampler2D tDiffuse3;", "uniform sampler2D tDetail;", "uniform sampler2D tNormal;", "uniform sampler2D tSpecular;", "uniform sampler2D tDisplacement;", "uniform float uNormalScale;", "uniform vec2 uRepeatOverlay;", "uniform vec2 uRepeatBase;", "uniform vec2 uOffset;", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec4 vPosition;", "uniform vec3 ambientLightColor;", "#if MAX_DIR_LIGHTS > 0", "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];", "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];", "#endif", "#if MAX_HEMI_LIGHTS > 0", "uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];", "uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];", "#endif", "#if MAX_POINT_LIGHTS > 0", "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];", "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];", "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];", "#endif", "varying vec3 vViewPosition;", Yb.ShaderChunk.shadowmap_pars_fragment, Yb.ShaderChunk.fog_pars_fragment, "void main() {", "gl_FragColor = vec4( vec3( 1.0 ), uOpacity );", "vec3 specularTex = vec3( 1.0 );", "vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;", "vec2 uvBase = uRepeatBase * vUv;", "vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;", "normalTex.xy *= uNormalScale;", "normalTex = normalize( normalTex );", "if( (enableDiffuse1 && enableDiffuse2)  || (enableDiffuse1 && enableDiffuse3) || (enableDiffuse2 && enableDiffuse3) ){", "vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );", "vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );", "vec4 colDiffuse3 = texture2D( tDiffuse3, uvOverlay );", "vec4 allDefiuuses[3];", "allDefiuuses[0] = colDiffuse1;", "allDefiuuses[1] = colDiffuse2;", "allDefiuuses[2] = colDiffuse3;", "#ifdef GAMMA_INPUT", "colDiffuse1.xyz *= colDiffuse1.xyz;", "colDiffuse2.xyz *= colDiffuse2.xyz;", "colDiffuse3.xyz *= colDiffuse3.xyz;", "#endif", "vec4 mixColor;", "if(enableDisplacement){", "vec4 dis = texture2D( tDisplacement, uvBase );", "if(enableDiffuse1 && enableDiffuse2 && enableDiffuse3){", "float total = dis.r + dis.g + dis.b;", "if(total == 0.0){", "mixColor = colDiffuse1 * 1.0/3.0 + colDiffuse2 * 1.0/3.0 + colDiffuse3 * 1.0/3.0;", "}else{", "mixColor = colDiffuse1 * dis.r/total + colDiffuse2 * dis.g/total + colDiffuse3 * dis.b/total;", "}", "}", "}else {", "mixColor = colDiffuse2;", "float y = vPosition.y;", "float blend2Bottom = blendRange[1] * heightUnit * 255.0;", "float percent = 0.0;", "if(y < blendRange[0] * heightUnit * 255.0){", "mixColor = colDiffuse1;", "percent = y / (blendRange[0] * heightUnit * 255.0);", "if(percent >=0.8){", "mixColor = mix(colDiffuse1,colDiffuse2,(percent - 0.8) / 0.2);", "}", "} else if(y > blend2Bottom){", "mixColor = colDiffuse3;", "percent = (y - blend2Bottom) / (heightUnit * 255.0 - blend2Bottom);", "if(percent <= 0.2){", "mixColor = mix(colDiffuse2,colDiffuse3,percent/0.2);", "}", "}", "}", "gl_FragColor = gl_FragColor * mixColor;", " } else if( enableDiffuse1 ) {", "gl_FragColor = gl_FragColor * texture2D( tDiffuse1, uvOverlay );", "} else if( enableDiffuse2 ) {", "gl_FragColor = gl_FragColor * texture2D( tDiffuse2, uvOverlay );", "}", "if( enableSpecular )", "specularTex = texture2D( tSpecular, uvOverlay ).xyz;", "mat3 tsb = mat3( vTangent, vBinormal, vNormal );", "vec3 finalNormal = tsb * normalTex;", "vec3 normal = normalize( finalNormal );", "vec3 viewPosition = normalize( vViewPosition );", "#if MAX_POINT_LIGHTS > 0", "vec3 pointDiffuse = vec3( 0.0 );", "vec3 pointSpecular = vec3( 0.0 );", "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {", "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );", "vec3 lVector = lPosition.xyz + vViewPosition.xyz;", "float lDistance = 1.0;", "if ( pointLightDistance[ i ] > 0.0 )", "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );", "lVector = normalize( lVector );", "vec3 pointHalfVector = normalize( lVector + viewPosition );", "float pointDistance = lDistance;", "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );", "float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );", "pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;", "pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;", "}", "#endif", "#if MAX_DIR_LIGHTS > 0", "vec3 dirDiffuse = vec3( 0.0 );", "vec3 dirSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {", "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );", "vec3 dirVector = normalize( lDirection.xyz );", "vec3 dirHalfVector = normalize( dirVector + viewPosition );", "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );", "float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );", "dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;", "dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;", "}", "#endif", "#if MAX_HEMI_LIGHTS > 0", "vec3 hemiDiffuse  = vec3( 0.0 );", "vec3 hemiSpecular = vec3( 0.0 );", "for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {", "vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", "float dotProduct = dot( normal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "hemiDiffuse += uDiffuseColor * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );", "float hemiSpecularWeight = 0.0;", "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );", "vec3 lVectorGround = -lVector;", "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );", "hemiSpecular += uSpecularColor * mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;", "}", "#endif", "vec3 totalDiffuse = vec3( 0.0 );", "vec3 totalSpecular = vec3( 0.0 );", "#if MAX_DIR_LIGHTS > 0", "totalDiffuse += dirDiffuse;", "totalSpecular += dirSpecular;", "#endif", "#if MAX_HEMI_LIGHTS > 0", "totalDiffuse += hemiDiffuse;", "totalSpecular += hemiSpecular;", "#endif", "#if MAX_POINT_LIGHTS > 0", "totalDiffuse += pointDiffuse;", "totalSpecular += pointSpecular;", "#endif", Yb.ShaderChunk.shadowmap_fragment, Yb.ShaderChunk.linear_to_gamma_fragment, Yb.ShaderChunk.fog_fragment, "}"].join("\n"),
            vertexShader: ["attribute vec4 tangent;", "uniform vec2 uRepeatBase;", "uniform sampler2D tNormal;", "#ifdef VERTEX_TEXTURES", "uniform sampler2D tDisplacement;", "uniform float uDisplacementScale;", "uniform float uDisplacementBias;", "#endif", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec4 vPosition;", "varying vec3 vViewPosition;", Yb.ShaderChunk.shadowmap_pars_vertex, "void main() {", "vNormal = normalize( normalMatrix * normal );", "vTangent = normalize( normalMatrix * tangent.xyz );", "vBinormal = cross( vNormal, vTangent ) * tangent.w;", "vBinormal = normalize( vBinormal );", "vUv = uv;", "vec2 uvBase = uv * uRepeatBase;", "#ifdef VERTEX_TEXTURES", "vec3 dv = texture2D( tDisplacement, uvBase ).xyz;", "float df = uDisplacementScale * dv.x + uDisplacementBias;", "vec3 displacedPosition = normal * df + position;", "vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );", "vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );", "#else", "vPosition = vec4(position,1.0);", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "#endif", "gl_Position = projectionMatrix * mvPosition;", "vViewPosition = -mvPosition.xyz;", "vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;", "vNormal = normalMatrix * normalTex;", Yb.ShaderChunk.shadowmap_vertex, "}"].join("\n")
        }
    },
    Yb.ShaderLib.terrain = Yb.ShaderTerrain.terrain,
    Yb.Fog = function(a, b, c) {
        this.name = "",
        this.color = new Yb.Color(a),
        this.near = b !== e ? b: 1,
        this.far = c !== e ? c: 1e3
    },
    Yb.Fog.prototype = {
        constructor: Yb.Fog,
        clone: function() {
            return new Yb.Flog(this.color.getHex(), this.near, this.far)
        },
        refreshUniforms: function(a) {
            a.fogNear.value = this.near,
            a.fogFar.value = this.far,
            a.fogColor.value = this.color
        }
    },
    Yb.FogExp2 = function(a, b) {
        this.name = "",
        this.color = new Yb.Color(a),
        this.density = b !== e ? b: 1
    },
    Yb.FogExp2.prototype = {
        DensityFactor: 25e-5,
        constructor: Yb.FogExp2,
        clone: function() {
            return new Yb.FogExp2(this.color.getHex(), this.density)
        },
        refreshUniforms: function(a) {
            a.fogDensity.value = this.density * this.DensityFactor,
            a.fogColor.value = this.color
        }
    };
    var tc = {},
    uc = tc.RADIANS_TO_DEGREES = 180 / Math.PI,
    vc = tc.DEGREES_TO_RADIANS = Math.PI / 180;
    tc.isPowerOfTwo = function(a) {
        return 0 === (a & a - 1)
    },
    tc.clone = function(a, b) {
        b == e && (b = new a.prototype.constructor);
        for (var c in a) if ("id" !== c) {
            var d = a[c];
            if (d.copy && "function" == typeof d.copy) b[c].copy(d);
            else if (d instanceof Array) {
                var f = d,
                g = b[c];
                null == g && (g = []);
                for (var h = 0; h < f.length; h++) {
                    var i = f[h];
                    g.push(i.clone())
                }
            } else cloneObjet[c] = d
        }
    },
    tc.paramToGL = function(a, b) {
        if (!b) return void console.error("No webgl context");
        switch (a) {
        case Yb.RepeatWrapping:
            return b.REPEAT;
        case Yb.ClampToEdgeWrapping:
            return b.CLAMP_TO_EDGE;
        case Yb.MirroredRepeatWrapping:
            return b.MIRRORED_REPEAT;
        case Yb.NearestFilter:
            return b.NEAREST;
        case Yb.NearestMipMapNearestFilter:
            return b.NEAREST_MIPMAP_NEAREST;
        case Yb.NearestMipMapLinearFilter:
            return b.NEAREST_MIPMAP_LINEAR;
        case Yb.LinearFilter:
            return b.LINEAR;
        case Yb.LinearMipMapNearestFilter:
            return b.LINEAR_MIPMAP_NEAREST;
        case Yb.LinearMipMapLinearFilter:
            return b.LINEAR_MIPMAP_LINEAR;
        case Yb.ByteType:
            return b.BYTE;
        case Yb.UnsignedByteType:
            return b.UNSIGNED_BYTE;
        case Yb.ShortType:
            return b.SHORT;
        case Yb.UnsignedShortType:
            return b.UNSIGNED_SHORT;
        case Yb.IntType:
            return b.INT;
        case Yb.UnsignedIntType:
            return b.UNSIGNED_INT;
        case Yb.FloatType:
            return b.FLOAT;
        case Yb.AlphaFormat:
            return b.ALPHA;
        case Yb.RGBFormat:
            return b.RGB;
        case Yb.RGBAFormat:
            return b.RGBA;
        case Yb.LuminanceFormat:
            return b.LUMINANCE;
        case Yb.LuminanceAlphaFormat:
            return b.LUMINANCE_ALPHA;
        case Yb.AddEquation:
            return b.FUNC_ADD;
        case Yb.SubtractEquation:
            return b.FUNC_SUBTRACT;
        case Yb.ReverseSubtractEquation:
            return b.FUNC_REVERSE_SUBTRACT;
        case Yb.ZeroFactor:
            return b.ZERO;
        case Yb.OneFactor:
            return b.ONE;
        case Yb.SrcColorFactor:
            return b.SRC_COLOR;
        case Yb.OneMinusSrcColorFactor:
            return b.ONE_MINUS_SRC_COLOR;
        case Yb.SrcAlphaFactor:
            return b.SRC_ALPHA;
        case Yb.OneMinusSrcAlphaFactor:
            return b.ONE_MINUS_SRC_ALPHA;
        case Yb.DstAlphaFactor:
            return b.DST_ALPHA;
        case Yb.OneMinusDstAlphaFactor:
            return b.ONE_MINUS_DST_ALPHA;
        case Yb.DstColorFactor:
            return b.DST_COLOR;
        case Yb.OneMinusDstColorFactor:
            return b.ONE_MINUS_DST_COLOR;
        case Yb.SrcAlphaSaturateFactor:
            return b.SRC_ALPHA_SATURATE
        }
        return 0
    },
    tc.createElement = function(a, b, c, d) {
        var f, g, h, i, j = a.vertices.length,
        k = (a.uvs.length, a.vertices),
        l = b.vertices,
        m = a.faces,
        n = b.faces,
        o = a.uvs,
        p = b.uvs,
        q = [],
        r = [],
        s = [];
        d === e && (d = 0),
        a instanceof Yb.Element && (a.matrixAutoUpdate && a.updateMatrix(), f = a.matrix, g = (new _b).getNormalMatrix(f)),
        b instanceof Yb.Element && (b.matrixAutoUpdate && b.updateMatrix(), h = b.matrix, i = (new _b).getNormalMatrix(h));
        for (var t = 0,
        u = k.length; u > t; t++) {
            var v = k[t],
            w = v.clone();
            f && w.applyMatrix4(f),
            r.push(w)
        }
        for (var t = 0,
        u = l.length; u > t; t++) {
            var v = l[t],
            w = v.clone();
            h && w.applyMatrix4(h),
            r.push(w)
        }
        for (t = 0, u = m.length; u > t; t++) {
            var x, y, z, A = m[t],
            B = A.vertexNormals,
            C = A.vertexColors;
            x = A instanceof pc ? new pc(A.a, A.b, A.c) : new qc(A.a, A.b, A.c, A.d),
            x.normal.copy(A.normal),
            g && x.normal.applyMatrix3(g).normalize();
            for (var D = 0,
            E = B.length; E > D; D++) y = B[D].clone(),
            g && y.applyMatrix3(g).normalize(),
            x.vertexNormals.push(y);
            x.color.copy(A.color);
            for (var D = 0,
            E = C.length; E > D; D++) z = C[D],
            x.vertexColors.push(z.clone());
            x.materialIndex = A.materialIndex,
            x.centroid.copy(A.centroid),
            f && x.centroid.applyMatrix4(f),
            q.push(x)
        }
        for (t = 0, u = n.length; u > t; t++) {
            var x, y, z, A = n[t],
            B = A.vertexNormals,
            C = A.vertexColors;
            x = A instanceof pc ? new pc(A.a + j, A.b + j, A.c + j) : new qc(A.a + j, A.b + j, A.c + j, A.d + j),
            x.normal.copy(A.normal),
            i && x.normal.applyMatrix3(i).normalize();
            for (var D = 0,
            E = B.length; E > D; D++) y = B[D].clone(),
            i && y.applyMatrix3(i).normalize(),
            x.vertexNormals.push(y);
            x.color.copy(A.color);
            for (var D = 0,
            E = C.length; E > D; D++) z = C[D],
            x.vertexColors.push(z.clone());
            x.materialIndex = A.materialIndex + d,
            x.centroid.copy(A.centroid),
            h && x.centroid.applyMatrix4(h),
            q.push(x)
        }
        for (t = 0, u = o.length; u > t; t++) {
            for (var F = o[t], G = [], D = 0, E = F.length; E > D; D++) G.push(new Zb(F[D].x, F[D].y));
            s.push(G)
        }
        for (t = 0, u = p.length; u > t; t++) {
            for (var F = p[t], G = [], D = 0, E = F.length; E > D; D++) G.push(new Zb(F[D].x, F[D].y));
            s.push(G)
        }
        var H = new Yb.Entity;
        return H.vertices = r,
        H.faces = q,
        H.uvs = s,
        H.material = c === e ? a.material: c,
        H
    },
    tc.transformElement = function(a, b) {
        var c, d, e = a.vertices,
        f = a.faces,
        g = a.uvs,
        h = [],
        i = [],
        j = [];
        a instanceof Yb.Element && (a.matrixAutoUpdate && a.updateMatrix(), c = a.matrix, d = (new _b).getNormalMatrix(c));
        for (var k = 0,
        l = e.length; l > k; k++) {
            var m = e[k],
            n = m.clone();
            c && n.applyMatrix4(c),
            i.push(n)
        }
        for (k = 0, l = f.length; l > k; k++) {
            var o, p, q, r = f[k],
            s = r.vertexNormals,
            t = r.vertexColors;
            o = r instanceof pc ? new pc(r.a, r.b, r.c) : new qc(r.a, r.b, r.c, r.d),
            o.normal.copy(r.normal),
            d && o.normal.applyMatrix3(d).normalize();
            for (var u = 0,
            v = s.length; v > u; u++) p = s[u].clone(),
            d && p.applyMatrix3(d).normalize(),
            o.vertexNormals.push(p);
            o.color.copy(r.color);
            for (var u = 0,
            v = t.length; v > u; u++) q = t[u],
            o.vertexColors.push(q.clone());
            o.materialIndex = r.materialIndex,
            o.centroid.copy(r.centroid),
            c && o.centroid.applyMatrix4(c),
            h.push(o)
        }
        for (k = 0, l = g.length; l > k; k++) {
            for (var w = g[k], x = [], u = 0, v = w.length; v > u; u++) x.push(new Zb(w[u].x, w[u].y));
            j.push(x)
        }
        if (b) {
            var y = new Yb.Entity(a.material);
            y.vertices = i,
            y.faces = h,
            y.uvs = j,
            y.setPosition(0, 0, 0),
            y.setRotation(0, 0, 0),
            y.setScale(1, 1, 1);
            var z = {};
            return z.vertices = i,
            z.faces = h,
            z.uvs = j,
            y.primitive = new Yb.Primitive(z),
            y
        }
        a.vertices = i,
        a.faces = h,
        a.uvs = j,
        a.setPosition(0, 0, 0),
        a.setRotation(0, 0, 0),
        a.setScale(1, 1, 1);
        var z = {};
        z.vertices = i,
        z.faces = h,
        z.uvs = j,
        a.primitive = new Yb.Primitive(z);
        for (var k in c.elements) a._attachId += c.elements[k];
        return a
    },
    tc.mergeElements = function(a) {
        var b, c, d, e, f, g, h = 0,
        i = 0,
        j = 0;
        for (b = 0; b < a.length; b++) d = a[b],
        h += d.materialSize;
        var k = new Yb.Entity(h),
        l = {},
        m = {},
        n = (new $b(0, 0, 0), []),
        o = [],
        p = [],
        q = [],
        r = new Yb.ArrayMaterial;
        for (b = 0; b < a.length; b++) {
            for (d = a[b], d.matrixAutoUpdate && d.updateWorldMatrix(), e = d.worldMatrix.clone(), f = (new _b).getNormalMatrix(e), c = 0; c < d.vertices.length; c++) g = d.vertices[c],
            n.push(g.clone().applyMatrix4(e));
            for (c = 0; c < d.faces.length; c++) {
                var s, t = d.faces[c];
                t.vertexNormals,
                t.vertexColors,
                s = t instanceof pc ? new pc(t.a + i, t.b + i, t.c + i) : new qc(t.a + i, t.b + i, t.c + i, t.d + i),
                s.normal.copy(t.normal),
                f && s.normal.applyMatrix3(f).normalize(),
                s.materialIndex = t.materialIndex + j,
                s.centroid.copy(t.centroid),
                e && s.centroid.applyMatrix4(e),
                o.push(s)
            }
            for (c = 0, len = d.uvs.length; c < len; c++) {
                for (var u = d.uvs[c], v = [], w = 0, x = u.length; x > w; w++) v.push(new Zb(u[w].x, u[w].y));
                p.push(v)
            }
            if (d.uv2s && d.uv2s.length > 0) for (c = 0, len = d.uv2s.length; c < len; c++) {
                for (var y = d.uv2s[c], z = [], w = 0, x = y.length; x > w; w++) z.push(new Zb(y[w].x, y[w].y));
                q.push(z)
            }
            r.materials = r.materials.concat(d.material.materials),
            i += d.vertices.length,
            j += d.materialSize;
            for (var A in d.styleMap) {
                var B = l[A];
                null == B && (B = []);
                var C = d.styleMap[A],
                D = !0;
                if (tc.isArray(C)) for (var w = 0; w < C.length; w++) B.push(C[b]),
                w > 0 && C[w] != C[w - 1] && (D = !1);
                else for (var w = 0; w < d.materialSize; w++) B.push(C); (1 == m[A] || null == m[A]) && (m[A] = D),
                l[A] = B
            }
        }
        for (var A in m) 1 == m[A] && (l[A] = l[A][0]);
        return k.styleMap = l,
        k.material = r,
        k.vertices = n,
        k.faces = o,
        k.setUvs(p),
        k.uv2s = q,
        k.setUpdateFlags(!0),
        k
    },
    tc.mergeElement = function(a, b, c) {
        var d, f, g, h, i = a.vertices.length,
        j = (a.uvs.length, a.vertices),
        k = b.vertices,
        l = a.faces,
        m = b.faces,
        n = a.uvs,
        o = b.uvs,
        p = [],
        q = [],
        r = [];
        c === e && (c = 0),
        a instanceof Yb.Element && (a.matrixAutoUpdate && a.updateMatrix(), d = a.matrix, f = (new _b).getNormalMatrix(d)),
        b instanceof Yb.Element && (b.matrixAutoUpdate && b.updateMatrix(), g = b.matrix, h = (new _b).getNormalMatrix(g));
        for (var s = 0,
        t = j.length; t > s; s++) {
            var u = j[s],
            v = u.clone();
            d && v.applyMatrix4(d),
            q.push(v)
        }
        for (var s = 0,
        t = k.length; t > s; s++) {
            var u = k[s],
            v = u.clone();
            g && v.applyMatrix4(g),
            q.push(v)
        }
        for (s = 0, t = l.length; t > s; s++) {
            var w, x, y, z = l[s],
            A = z.vertexNormals,
            B = z.vertexColors;
            w = z instanceof pc ? new pc(z.a, z.b, z.c) : new qc(z.a, z.b, z.c, z.d),
            w.normal.copy(z.normal),
            f && w.normal.applyMatrix3(f).normalize();
            for (var C = 0,
            D = A.length; D > C; C++) x = A[C].clone(),
            f && x.applyMatrix3(f).normalize(),
            w.vertexNormals.push(x);
            w.color.copy(z.color);
            for (var C = 0,
            D = B.length; D > C; C++) y = B[C],
            w.vertexColors.push(y.clone());
            w.materialIndex = z.materialIndex,
            w.centroid.copy(z.centroid),
            d && w.centroid.applyMatrix4(d),
            p.push(w)
        }
        for (s = 0, t = m.length; t > s; s++) {
            var w, x, y, z = m[s],
            A = z.vertexNormals,
            B = z.vertexColors;
            w = z instanceof pc ? new pc(z.a + i, z.b + i, z.c + i) : new qc(z.a + i, z.b + i, z.c + i, z.d + i),
            w.normal.copy(z.normal),
            h && w.normal.applyMatrix3(h).normalize();
            for (var C = 0,
            D = A.length; D > C; C++) x = A[C].clone(),
            h && x.applyMatrix3(h).normalize(),
            w.vertexNormals.push(x);
            w.color.copy(z.color);
            for (var C = 0,
            D = B.length; D > C; C++) y = B[C],
            w.vertexColors.push(y.clone());
            w.materialIndex = z.materialIndex + c,
            w.centroid.copy(z.centroid),
            g && w.centroid.applyMatrix4(g),
            p.push(w)
        }
        for (s = 0, t = n.length; t > s; s++) {
            for (var E = n[s], F = [], C = 0, D = E.length; D > C; C++) F.push(new Zb(E[C].x, E[C].y));
            r.push(F)
        }
        for (s = 0, t = o.length; t > s; s++) {
            for (var E = o[s], F = [], C = 0, D = E.length; D > C; C++) F.push(new Zb(E[C].x, E[C].y));
            r.push(F)
        }
        return a.vertices = q,
        a.faces = p,
        a.uvs = r,
        a._position.set(0, 0, 0),
        a._rotation.set(0, 0, 0),
        a._scale.set(1, 1, 1),
        a
    },
    tc.autoAdjustNetworkBounds = function(a, b, c, e, f, g) {
        f = f || 0,
        g = g || 0,
        a.adjustBounds(b[c] - f, b[e] - g),
        d.addEventListener ? d.addEventListener("resize",
        function() {
            a.adjustBounds(b[c] - f, b[e] - g, g, f)
        },
        !0) : d.attachEvent ? d.attachEvent("onresize",
        function() {
            a.adjustBounds(b[c] - f, b[e] - g, g, f)
        }) : d.onresize = function() {
            a.adjustBounds(b[c] - f, b[e] - g, g, f)
        }
    },
    tc.isEmptyObject = function(a) {
        for (var b in a) return ! 1;
        return ! 0
    },
    tc.isArray = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a)
    },
    tc.isSame = function(a, b) {
        if (a === b) return ! 0;
        if (null == a && null != b) return ! 1;
        if (null != a && null == b) return ! 1;
        if (typeof a != typeof b) return ! 1;
        for (var c in a) if (a[c] != b[c]) return ! 1;
        for (var c in b) if (a[c] != b[c]) return ! 1;
        return ! 0
    },
    tc.toString = function(a) {
        if (a) {
            var b = "";
            for (var c in a) b += c + ":" + a[c];
            return b
        }
    },
    tc.validateLicense = function(a) {
        Bc = a,
        Rc()
    },
    tc.getLicense = function() {
        return Bc
    },
    tc.getObjectCount = function(a) {
        if (!a) return 0;
        var b = 0;
        for (var c in a) b++;
        return b
    },
    tc.isNaN = function(a) {
        return "" === a || null === a || isNaN(a)
    },
    tc.getTransformVertices = function(a, b, c) {
        null == c && (c = []);
        var d, e;
        if (a instanceof Yb.Node || a instanceof Yb.Billboard) {
            for (d = 0; d < a.vertices.length; d++) e = a.vertices[d].clone(),
            a instanceof Yb.Billboard ? (e.x *= a.rotation3d.x, e.y *= a.rotation3d.y, e.add(a.getPosition())) : e.applyMatrix4(a.worldMatrix),
            c.push(e);
            for (var d = 0; d < (a._childList ? a._childList.size() : 0); d++) {
                var f = a._childList.get(d);
                tc.getTransformVertices(f, b, c)
            }
        }
        return c
    },
    tc.getBoundingBox = function(a, b) {
        var c, d, e;
        if (null == a) return null;
        c = a instanceof kc ? a._as: tc.isArray(a) ? a: [a];
        var f = [];
        for (d = 0; d < c.length; d++) e = c[d],
        tc.getTransformVertices(e, b, f);
        var g = new Yb.BoundingBox;
        return g.setFromPoints(f),
        g
    },
    tc.mergeWrapMap = function(a) {
        if (a instanceof rc && !a.getWrapMap()) {
            for (var b, c = [], d = (a.getMaterialMapping(), a.material.materials), e = 0; e < d.length; e++) b = d[e],
            b.map && -1 == c.indexOf(b.map._image) && c.push(b.map._image);
            a.setWrapMap(!0)
        }
    },
    tc.setWrapMap = function(a, b, c, d) {
        tc.loadImages(b,
        function(e) {
            var f = mono.Utils.createWrapMapFromImages(e, c, d);
            f.__uniqueCode = "";
            for (var g = 0; g < b.length; g++) f.__uniqueCode += b[g].src;
            for (var g in c) f.__uniqueCode += g + ":" + c[g];
            if (tc.isArray(a)) for (var g = 0; g < a.length; g++) a[g].setStyle("m.texture.image", f),
            a[g].setClient("_originalImage", b),
            a[g].setClient("_wrapMapping", c);
            else a.setStyle("m.texture.image", f),
            a.setClient("_wrapMapping", c)
        })
    },
    tc.loadImages = function(a, b) {
        function c(a) {
            a.onload = function() {
                a.loaded = !0,
                d(),
                a.onload = null
            }
        }
        function d() {
            for (var c = 0; c < a.length; c++) if (!a[c].loaded) return;
            b(a)
        }
        if (null != a && 0 != a.length && null != b) for (var e = 0; e < a.length; e++) {
            var f = a[e];
            "string" == typeof f && (a[e] = new Image, a[e].crossOrigin = "", a[e].src = f),
            f = a[e],
            c(f)
        }
    },
    tc.createWrapMapFromImages = function(a, b, c, d, e) {
        if (null == a || 0 == a.length) return null;
        c = (c || "six-each").toLowerCase();
        var f = "six-each" == c || "front-other" == c || "back-other" == c || "left-other" == c || "right-other" == c || "top-other" == c || "bottom-other" == c;
        if (f) {
            null == b && (b = {
                0 : "bottom",
                1 : "top",
                2 : "back",
                3 : "left",
                4 : "front",
                5 : "right"
            });
            var g = document.createElement("canvas"),
            h = g.getContext("2d"),
            i = 0,
            j = 0;
            if ("six-each" == c) {
                var k = {
                    bottom: [0, 0],
                    top: [1 / 3, 0],
                    back: [2 / 3, 0],
                    left: [0, .5],
                    front: [1 / 3, .5],
                    right: [2 / 3, .5]
                };
                if (null == d || null == e) for (var l = 0; l < a.length; l++) i = Math.max(a[l].width, i),
                j = Math.max(a[l].height, j);
                i *= 3,
                j *= 2,
                i > 1024 && (i = 1024),
                j > 1024 && (j = 1024);
                var m, n = ["front", "back", "right", "left", "top", "bottom"],
                o = [];
                for (var l in b) {
                    var p = b[l];
                    "other" !== p ? (o.push(p), n.splice(n.indexOf(p), 1)) : m = l
                }
                null != m && (b[m] = n),
                d = d || i,
                e = e || j,
                g.setAttribute("width", d),
                g.setAttribute("height", e);
                for (var l = (Math.min(a.length, 6), 0); 6 > l; l++) {
                    var q = b[l];
                    if (q) {
                        var r = q;
                        r = tc.isArray(q) ? q: -1 != q.indexOf(",") ? q.split(",") : [q];
                        for (var s = 0; s < r.length; s++) {
                            var p = r[s],
                            t = k[p][0],
                            u = k[p][1];
                            h.drawImage(a[l], t * d, u * e, d / 3, e / 2)
                        }
                    }
                }
            } else {
                var v = c.split("-")[0];
                if (null == d || null == e) for (var l = 0; l < a.length; l++) i += a[l].width,
                j = Math.max(a[l].height, j);
                d = d || i,
                e = e || j,
                g.setAttribute("width", d),
                g.setAttribute("height", e);
                for (var l = (b[v], Math.min(a.length, 2), 0); 2 > l; l++) {
                    var q = b[l];
                    q && (q == v ? h.drawImage(a[l], 0, 0, d / 2, e) : h.drawImage(a[l], d / 2, 0, d / 2, e))
                }
            }
            return g
        }
    },
    tc.getVectorAngles = function(a, b) {
        var c = a;
        b && (c = b.clone().sub(a)),
        c = c.normalize();
        var d = Math.asin(c.y) * uc,
        e = Math.atan2(c.x, c.z) * uc;
        return [e, d]
    },
    tc.getPixelFromImage = function(a, b, c) {
        var d;
        bc.isCanvas(a) ? d = a: (d = document.createElement("canvas"), d.width = a.width, d.height = a.height, d.getContext("2d").drawImage(a, 0, 0, a.width, a.height)),
        b -= Math.floor(b),
        c -= Math.floor(c),
        c = 1 - c;
        var e = d.getContext("2d").getImageData(a.width * b, a.height * c, 1, 1).data;
        return e
    },
    tc.nextPowerOfTwo = function(a) {
        return a--,
        a |= a >> 1,
        a |= a >> 2,
        a |= a >> 4,
        a |= a >> 8,
        a |= a >> 16,
        a++,
        a
    },
    tc.createTextBillboard = function(a, b) {
        var c = new mono.Billboard;
        a = a || "",
        b = b || {};
        var d = tc.createTextImage(a, b);
        return c.setStyle("m.texture.image", d),
        c.setScale(d.width, d.height, 1),
        c
    },
    tc.createTextImage = function(a, b) {
        a = a || "";
        var c = b.font,
        d = b.color,
        f = b.background,
        g = b.powerOfTwo,
        h = b.canvas,
        i = b.drawFunction;
        h = h || document.createElement("canvas"),
        c = c || '20px "Dialog"',
        d = d || "white",
        f = f === e ? "#0F90C4": f,
        g = g || !1;
        var j, k = b.textAlign || "center";
        j = tc.isArray(a) ? a: a.split("\n");
        var l = mono.Utils.getMaxTextSize(j, c),
        m = b.ratio || l.width / l.height,
        n = h.realSize = {
            width: l.width,
            height: l.height
        };
        g && (l.width = mono.Utils.nextPowerOfTwo(l.width), l.height = mono.Utils.nextPowerOfTwo(l.height));
        var o = h.drawRect = {
            width: n.width / n.height > m ? n.width: n.height * m,
            height: n.width / n.height > m ? n.width / m: n.height
        };
        Number.isNaN(o.width) && console.log("debug -- b", n.width, n.height, m),
        o.width = Math.min(o.width, l.width),
        o.height = Math.min(o.height, l.height),
        h.width = l.width,
        h.height = l.height,
        Number.isNaN(o.width) && console.log("debug -- a");
        var p = h.getContext("2d");
        if (f && (p.fillStyle = f), i) i(p, h.width, h.height);
        else {
            f && p.fillRect(0, 0, h.width, h.height),
            p.font = c,
            p.fillStyle = d,
            p.strokeStyle = "gray",
            p.textBaseline = "middle",
            p.textAlign = k;
            for (var q, r = j.length,
            s = n.height / r,
            t = 0; r > t; t++) {
                tc.isArray(d) && (q = d[t], q && (p.fillStyle = q));
                var u = mono.Utils.getTextSize(c, j[t]),
                v = (u.width, u.height, h.height, (o.width - n.width) / 2);
                "center" === k ? v = o.width / 2 : "right" === k && (v = o.width);
                var w = (o.height - n.height) / 2 + s / 2 + t * s + (h.height - o.height);
                p.strokeText(j[t], v, w),
                p.fillText(j[t], v, w)
            }
        }
        return h
    },
    tc.createTextImage2 = function(a, b) {
        a = a || "",
        a = String(a);
        var c = b.font,
        d = b.color,
        g = b.background,
        h = b.powerOfTwo,
        i = b.canvas,
        j = b.drawFunction;
        i = i || document.createElement("canvas"),
        c = c || '20px "Dialog"',
        d = d || "white",
        g = g === e ? "#0F90C4": g,
        h = h || !1;
        var k = (b.align || "center", b.sizeScale || 1),
        l = tc.getMaxTextSize(a.split("\n"), c);
        i.realSize = {
            width: l.width,
            height: l.height
        },
        l.width *= k,
        l.height *= k,
        h && (l.width = tc.nextPowerOfTwo(l.width), l.height = tc.nextPowerOfTwo(l.height)),
        i.width = l.width,
        i.height = l.height;
        var m = i.getContext("2d");
        return g && (m.fillStyle = g),
        j ? j(m, i.width, i.height) : (g && m.fillRect(0, 0, i.width, i.height), f(m, a, c, d, i, "center")),
        i
    },
    tc.getMaxTextSize = function(a, b) {
        if (a && a.length > 0) {
            for (var c = a.length,
            d = fc.getTextSize(b, a[0]), e = d.width, f = d.height * c, g = 0; c > g; g++) {
                var h = fc.getTextSize(b, a[g]).width;
                h > e && (e = h)
            }
            return {
                width: e,
                height: f
            }
        }
        return null
    },
    tc.getTextSize = function(a, b) {
        return fc.getTextSize(a, b)
    },
    tc.playCameraAnimation = function(a, b, c, d, e) {
        b = b || a.p(),
        c = c || a.getTarget(),
        d = d || 2e3;
        var f = mono.Utils.getVectorAngles(a.getTarget(), a.p()),
        g = mono.Utils.getVectorAngles(c, b),
        h = a.getTarget(),
        i = c,
        j = a.getDistance(),
        k = (new mono.Vec3).subVectors(b, c).length();
        new mono.Animate({
            from: 0,
            to: 1,
            repeat: 1,
            dur: d,
            onPlay: function() {},
            onUpdate: function(b) {
                var c = f[0] + (g[0] - f[0]) * b,
                d = f[1] + (g[1] - f[1]) * b,
                e = (new mono.Vec3).lerpVectors(h, i, b),
                l = j + (k - j) * b,
                m = new mono.Vec3;
                m.x = e.x + l * Math.sin(c * vc) * Math.cos(d * vc),
                m.z = e.z + l * Math.cos(c * vc) * Math.cos(d * vc),
                m.y = e.y + l * Math.sin(d * vc),
                a.lookAt(e),
                a.p(m)
            },
            onDone: function() {
                e && e()
            }
        }).play()
    },
    tc.stopAnimate = function(a, b) {
        Tb(a, b)
    },
    tc.stopAllAnimates = function(a) {
        Ub(a)
    },
    Yb.Utils = tc,
    Yb.GLParameters = function(a, b, c) {
        this.material = a,
        this.network = b,
        this.precision = b._precision,
        this.map = !!a.map,
        this.mapLoaded = !0,
        this.envMap = !!a.envMap,
        this.lightMap = !!a.lightMap,
        this.bumpMap = !!a.bumpMap && "phong" === a._type,
        this.normalMap = !!a.normalMap && "phong" === a._type,
        this.specularMap = !!a.specularMap,
        this.vertexColors = a.vertexColors,
        this.fog = b._fog,
        this.useFog = a.fog,
        this.fogExp = this.fog instanceof Yb.FogExp2,
        this.sizeAttenuation = a.sizeAttenuation,
        this.skinning = a.skinning,
        this.maxBones = b.maxBones,
        this.useVertexTexture = b._supportsBoneTextures && c && c.useVertexTexture,
        this.boneTextureWidth = c && c.boneTextureWidth,
        this.boneTextureHeight = c && c.boneTextureHeight,
        this.morphTargets = a.morphTargets,
        this.morphNormals = a.morphNormals,
        this.maxMorphTargets = b.maxMorphTargets,
        this.maxMorphNormals = b.maxMorphNormals,
        this.maxDirLights = b.maxLightCount.directional,
        this.maxPointLights = b.maxLightCount.point,
        this.maxSpotLights = b.maxLightCount.spot,
        this.maxHemiLights = b.maxLightCount.hemi,
        this.maxShadows = b.maxShadows,
        this.maxPointShadows = b.maxPointShadows,
        this.shadowMapEnable = b._shadowMapEnable && c.receiveShadow && this.maxShadows > 0,
        this.pointShadowMapEnable = b._shadowMapEnable && c.receiveShadow && this.maxPointShadows > 0,
        this.shadowMapType = b.shadowMapType,
        this.shadowMapDebug = b.shadowMapDebug,
        this.shadowMapCascade = b.shadowMapCascade,
        this.alphaTest = a.alphaTest,
        this.metal = a.metal,
        this.perPixel = a.perPixel,
        this.wrapAround = a.wrapAround,
        this.doubleSided = a.side === Yb.DoubleSide && !cc.isIE,
        this.flipSided = a.side === Yb.BackSide,
        this.useSSAO = b.isSSAOEnable() && b.pm.isLightMaterial(a),
        this.gammaInput = b.gammaInput,
        this.gammaOutput = b.gammaOutput,
        this.physicallyBasedShading = b.physicallyBasedShading,
        this.supportsVertexTextures = !1,
        this.shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC",
        this.shadowMapType === Yb.PCFShadowMap ? this.shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF": this.shadowMapType === Yb.PCFSoftShadowMap && (this.shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT"),
        this.maxGrandient = tc.getObjectCount(a.gradient)
    },
    Yb.GLParameters.prototype.getShaders = function(a) {
        a = a === e ? "": a;
        var b = this,
        c = ["precision " + b.precision + " float;", a, this.supportsVertexTextures ? "#define VERTEX_TEXTURES": "", b.gammaInput ? "#define GAMMA_INPUT": "", b.gammaOutput ? "#define GAMMA_OUTPUT": "", b.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING": "", "#define MAX_DIR_LIGHTS " + b.maxDirLights, "#define MAX_POINT_LIGHTS " + b.maxPointLights, "#define MAX_SPOT_LIGHTS " + b.maxSpotLights, "#define MAX_HEMI_LIGHTS " + b.maxHemiLights, "#define MAX_SHADOWS " + b.maxShadows, "#define MAX_POINT_SHADOWS " + b.maxPointShadows, "#define MAX_BONES " + b.maxBones, b.map ? "#define USE_MAP": "", b.envMap ? "#define USE_ENVMAP": "", b.lightMap ? "#define USE_LIGHTMAP": "", b.bumpMap ? "#define USE_BUMPMAP": "", b.normalMap ? "#define USE_NORMALMAP": "", b.specularMap ? "#define USE_SPECULARMAP": "", b.vertexColors ? "#define USE_COLOR": "", b.maxGrandient > 0 ? "#define MAX_GRADIENT " + b.maxGrandient: "", b.skinning ? "#define USE_SKINNING": "", b.useVertexTexture ? "#define BONE_TEXTURE": "", b.boneTextureWidth ? "#define N_BONE_PIXEL_X " + b.boneTextureWidth.toFixed(1) : "", b.boneTextureHeight ? "#define N_BONE_PIXEL_Y " + b.boneTextureHeight.toFixed(1) : "", b.morphTargets ? "#define USE_MORPHTARGETS": "", b.morphNormals ? "#define USE_MORPHNORMALS": "", b.perPixel ? "#define PHONG_PER_PIXEL": "", b.wrapAround ? "#define WRAP_AROUND": "", b.doubleSided ? "#define DOUBLE_SIDED": "", b.flipSided ? "#define FLIP_SIDED": "", b.shadowMapEnable ? "#define USE_SHADOWMAP": "", b.shadowMapEnable ? "#define " + b.shadowMapTypeDefine: "", b.shadowMapDebug ? "#define SHADOWMAP_DEBUG": "", b.shadowMapCascade ? "#define SHADOWMAP_CASCADE": "", b.pointShadowMapEnable ? "#define USE_POINT_SHADOWMAP": "", b.sizeAttenuation ? "#define USE_SIZEATTENUATION": "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "attribute vec3 morphTarget0;", "attribute vec3 morphTarget1;", "attribute vec3 morphTarget2;", "attribute vec3 morphTarget3;", "#ifdef USE_MORPHNORMALS", "attribute vec3 morphNormal0;", "attribute vec3 morphNormal1;", "attribute vec3 morphNormal2;", "attribute vec3 morphNormal3;", "#else", "attribute vec3 morphTarget4;", "attribute vec3 morphTarget5;", "attribute vec3 morphTarget6;", "attribute vec3 morphTarget7;", "#endif", "#endif", "#ifdef USE_SKINNING", "attribute vec4 skinIndex;", "attribute vec4 skinWeight;", "#endif", ""].join("\n"),
        d = ["precision " + this.precision + " float;", b.bumpMap || b.normalMap ? "#extension GL_OES_standard_derivatives : enable": "", a, "#define MAX_DIR_LIGHTS " + b.maxDirLights, "#define MAX_POINT_LIGHTS " + b.maxPointLights, "#define MAX_SPOT_LIGHTS " + b.maxSpotLights, "#define MAX_HEMI_LIGHTS " + b.maxHemiLights, "#define MAX_SHADOWS " + b.maxShadows, "#define MAX_POINT_SHADOWS " + b.maxPointShadows, b.useSSAO ? "#define USE_SSAO": "", b.alphaTest ? "#define ALPHATEST " + b.alphaTest: "", this.gammaInput ? "#define GAMMA_INPUT": "", this.gammaOutput ? "#define GAMMA_OUTPUT": "", this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING": "", b.useFog && b.fog ? "#define USE_FOG": "", b.useFog && b.fogExp ? "#define FOG_EXP2": "", b.map ? "#define USE_MAP": "", b.envMap ? "#define USE_ENVMAP": "", b.lightMap ? "#define USE_LIGHTMAP": "", b.bumpMap ? "#define USE_BUMPMAP": "", b.normalMap ? "#define USE_NORMALMAP": "", b.specularMap ? "#define USE_SPECULARMAP": "", b.maxGrandient > 0 ? "#define MAX_GRADIENT " + b.maxGrandient: "", b.vertexColors ? "#define USE_COLOR": "", b.metal ? "#define METAL": "", b.perPixel ? "#define PHONG_PER_PIXEL": "", b.wrapAround ? "#define WRAP_AROUND": "", b.doubleSided ? "#define DOUBLE_SIDED": "", b.flipSided ? "#define FLIP_SIDED": "", b.shadowMapEnable ? "#define USE_SHADOWMAP": "", b.shadowMapEnable ? "#define " + b.shadowMapTypeDefine: "", b.shadowMapDebug ? "#define SHADOWMAP_DEBUG": "", b.shadowMapCascade ? "#define SHADOWMAP_CASCADE": "", b.pointShadowMapEnable ? "#define USE_POINT_SHADOWMAP": "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", ""].join("\n");
        return [c, d]
    };
    var wc = {};
    wc.setDepthTest = function(a, b) {
        var c = b._gl;
        b._oldDepthTest !== a && (a ? c.enable(c.DEPTH_TEST) : c.disable(c.DEPTH_TEST), b._oldDepthTest = a)
    },
    wc.setSmapleAlphaToCoverage = function(a, b) {
        var c = b._gl;
        b._oldSmapleAlphaToCoverage !== a && (a ? c.enable(c.SAMPLE_ALPHA_TO_COVERAGE) : c.disable(c.SAMPLE_ALPHA_TO_COVERAGE), b._oldSmapleAlphaToCoverage = a)
    },
    wc.setDepthWrite = function(a, b) {
        var c = b._gl;
        b._oldDepthWrite !== a && (c.depthMask(a), b._oldDepthWrite = a)
    },
    wc.clear = function(a, b, c, d) {
        var f = d._gl,
        g = 0; (a === e || a) && (g |= f.COLOR_BUFFER_BIT),
        (b === e || b) && (g |= f.DEPTH_BUFFER_BIT),
        (c === e || c) && (g |= f.STENCIL_BUFFER_BIT),
        d._gl.clear(g)
    },
    wc.setPolygonOffset = function(a, b, c, d) {
        var e = d._gl;
        d._oldPolygonOffset !== a && (a ? e.enable(e.POLYGON_OFFSET_FILL) : e.disable(e.POLYGON_OFFSET_FILL), d._oldPolygonOffset = a),
        a && (d._oldPolygonOffsetFactor !== b || d._oldPolygonOffsetUnits !== c) && (e.polygonOffset(b, c), d._oldPolygonOffsetFactor = b, d._oldPolygonOffsetUnits = c)
    },
    wc.setBlending = function(a, b, c, d, e) {
        var f = e._gl;
        a !== e._oldBlending && (a === Yb.NoBlending ? f.disable(f.BLEND) : a === Yb.AdditiveBlending ? (f.enable(f.BLEND), f.blendEquation(f.FUNC_ADD), f.blendFunc(f.SRC_ALPHA, f.ONE)) : a === Yb.SubtractiveBlending ? (f.enable(f.BLEND), f.blendEquation(f.FUNC_ADD), f.blendFunc(f.ZERO, f.ONE_MINUS_SRC_COLOR)) : a === Yb.MultiplyBlending ? (f.enable(f.BLEND), f.blendEquation(f.FUNC_ADD), f.blendFunc(f.ZERO, f.SRC_COLOR)) : a === Yb.CustomBlending ? f.enable(f.BLEND) : (f.enable(f.BLEND), f.blendEquationSeparate(f.FUNC_ADD, f.FUNC_ADD), f.blendFuncSeparate(f.SRC_ALPHA, f.ONE_MINUS_SRC_ALPHA, f.ONE, f.ONE_MINUS_SRC_ALPHA)), e._oldBlending = a),
        a === Yb.CustomBlending ? (b !== this._oldBlendEquation && (f.blendEquation(paramThreeToGL(b)), e._oldBlendEquation = b), (c !== _oldBlendSrc || d !== _oldBlendDst) && (f.blendFunc(paramToGL(c), paramToGL(d)), e._oldBlendSrc = c, e._oldBlendDst = d)) : (e._oldBlendEquation = null, e._oldBlendSrc = null, e._oldBlendDst = null)
    },
    wc.enableStencil = function(a) {
        a.enable(a.STENCIL_TEST),
        a.stencilFunc(a.ALWAYS, 1, 1),
        a.stencilOp(a.KEEP, a.KEEP, a.REPLACE),
        a.stencilMask(1),
        a.clearStencil(0),
        a.clear(a.STENCIL_BUFFER_BIT)
    },
    wc.stencilTest = function(a) {
        a.enable(a.STENCIL_TEST),
        a.stencilFunc(a.EQUAL, 0, 1),
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP),
        a.stencilMask(0)
    },
    wc.disableStencil = function(a) {
        a.disable(a.STENCIL_TEST)
    },
    wc.r = function(a, b, c, d, e, f, g) {
        a._AK47(b, c, d, e, f, g)
    },
    wc.g = function(a, b, c, d, e, f) {
        a.renderGroup(b, c, d, e, f)
    },
    Yb.GLUtils = wc,
    Yb.GPU = function(a) {
        var b = a._gl;
        this._glExtensionTextureFloat = b.getExtension("OES_texture_float"),
        this._glExtensionStandardDerivatives = b.getExtension("OES_standard_derivatives"),
        this._glExtensionTextureFilterAnisotropic = b.getExtension("EXT_texture_filter_anisotropic") || b.getExtension("MOZ_EXT_texture_filter_anisotropic") || b.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
        this._glExtensionCompressedTextureS3TC = b.getExtension("WEBGL_compressed_texture_s3tc") || b.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || b.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
        this._glExtensionTextureFloat || console.log("Float textures not supported."),
        this._glExtensionStandardDerivatives || console.log("Standard derivatives not supported."),
        this._glExtensionTextureFilterAnisotropic || console.log("Anisotropic texture filtering not supported."),
        this._glExtensionCompressedTextureS3TC || console.log("S3TC compressed textures not supported."),
        this._maxTextures = b.getParameter(b.MAX_TEXTURE_IMAGE_UNITS),
        this._maxVertexTextures = b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        this._maxTextureSize = b.getParameter(b.MAX_TEXTURE_SIZE),
        this._maxCubemapSize = b.getParameter(b.MAX_CUBE_MAP_TEXTURE_SIZE),
        this._maxAnisotropy = this._glExtensionTextureFilterAnisotropic ? b.getParameter(this._glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
        this._supportsVertexTextures = this._maxVertexTextures > 0,
        this._supportsBoneTextures = this._supportsVertexTextures && this._glExtensionTextureFloat,
        this._compressedTextureFormats = this._glExtensionCompressedTextureS3TC ? b.getParameter(b.COMPRESSED_TEXTURE_FORMATS) : [],
        this._vertexShaderPrecisionHighpFloat = b.getShaderPrecisionFormat(b.VERTEX_SHADER, b.HIGH_FLOAT),
        this._vertexShaderPrecisionMediumpFloat = b.getShaderPrecisionFormat(b.VERTEX_SHADER, b.MEDIUM_FLOAT),
        this._vertexShaderPrecisionLowpFloat = b.getShaderPrecisionFormat(b.VERTEX_SHADER, b.LOW_FLOAT),
        this._fragmentShaderPrecisionHighpFloat = b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.HIGH_FLOAT),
        this._fragmentShaderPrecisionMediumpFloat = b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.MEDIUM_FLOAT),
        this._fragmentShaderPrecisionLowpFloat = b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.LOW_FLOAT),
        this._vertexShaderPrecisionHighpInt = b.getShaderPrecisionFormat(b.VERTEX_SHADER, b.HIGH_INT),
        this._vertexShaderPrecisionMediumpInt = b.getShaderPrecisionFormat(b.VERTEX_SHADER, b.MEDIUM_INT),
        this._vertexShaderPrecisionLowpInt = b.getShaderPrecisionFormat(b.VERTEX_SHADER, b.LOW_INT),
        this._fragmentShaderPrecisionHighpInt = b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.HIGH_INT),
        this._fragmentShaderPrecisionMediumpInt = b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.MEDIUM_INT),
        this._fragmentShaderPrecisionLowpInt = b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.LOW_INT);
        var c = this._vertexShaderPrecisionHighpFloat.precision > 0 && this._fragmentShaderPrecisionHighpFloat.precision > 0,
        d = this._vertexShaderPrecisionMediumpFloat.precision > 0 && this._fragmentShaderPrecisionMediumpFloat.precision > 0,
        e = a._precision;
        "highp" === e && !c && (d ? (e = "mediump", console.log("highp not supported, using mediump")) : (e = "lowp", console.log("highp and mediump not supported, using lowp"))),
        "mediump" === e && !d && (e = "lowp", console.log("mediump not supported, using lowp")),
        a._precision = e
    },
    Yb.Program = function(a, b, c, d) {
        this.entity = a,
        this.group = b,
        this.material = c,
        this.network = d
    },
    Yb.Program.prototype.setEntity = function() {
        this.entity
    },
    Yb.Program.prototype.buildGLProgram = function() {},
    Yb.Uniform = function(a, b, c) {
        this.id = a,
        this.type = b,
        this.value = c,
        this.location = e
    },
    Yb.Uniform.prototype = {
        constructor: Yb.Uniform,
        setValue: function(a) {
            this.value = a
        },
        getUniformLocation: function(a, b) {
            return a.getUniformLocation(this.id)
        }
    },
    Yb.Uniform.loadUniform = function(a, b, c) {
        if (type = b.type, value = b.value, "i" === type) c.uniform1i(a, value);
        else if ("f" === type) c.uniform1f(a, value);
        else if ("v2" === type) c.uniform2f(a, value.x, value.y);
        else if ("v3" === type) c.uniform3f(a, value.x, value.y, value.z);
        else if ("v4" === type) c.uniform4f(a, value.x, value.y, value.z, value.w);
        else if ("c" === type) c.uniform3f(a, value.r, value.g, value.b);
        else if ("iv1" === type) c.uniform1iv(a, value);
        else if ("iv" === type) c.uniform3iv(a, value);
        else if ("fv1" === type) c.uniform1fv(a, value);
        else if ("fv" === type) c.uniform3fv(a, value);
        else if ("v2v" === type) {
            for (b._array === e && (b._array = new Float32Array(2 * value.length)), i = 0, il = value.length; i < il; i++) offset = 2 * i,
            b._array[offset] = value[i].x,
            b._array[offset + 1] = value[i].y;
            c.uniform2fv(a, b._array)
        } else if ("v3v" === type) {
            for (b._array === e && (b._array = new Float32Array(3 * value.length)), i = 0, il = value.length; i < il; i++) offset = 3 * i,
            b._array[offset] = value[i].x,
            b._array[offset + 1] = value[i].y,
            b._array[offset + 2] = value[i].z;
            c.uniform3fv(a, b._array)
        } else if ("v4v" === type) {
            for (b._array === e && (b._array = new Float32Array(4 * value.length)), i = 0, il = value.length; i < il; i++) offset = 4 * i,
            b._array[offset] = value[i].x,
            b._array[offset + 1] = value[i].y,
            b._array[offset + 2] = value[i].z,
            b._array[offset + 3] = value[i].w;
            c.uniform4fv(a, b._array)
        } else if ("m4" === type) b._array === e && (b._array = new Float32Array(16)),
        value.flattenToArray(b._array),
        c.uniformMatrix4fv(a, !1, b._array);
        else if ("m4v" === type) {
            for (b._array === e && (b._array = new Float32Array(16 * value.length)), i = 0, il = value.length; i < il; i++) value[i].flattenToArrayOffset(b._array, 16 * i);
            c.uniformMatrix4fv(a, !1, b._array)
        } else if ("t" === type) texture = value,
        textureUnit = getTextureUnit(),
        c.uniform1i(a, textureUnit),
        !texture || (texture.image instanceof Array && 6 === texture.image.length ? setCubeTexture(texture, textureUnit) : texture instanceof $CubeRenderTargetCube ? setCubeTextureDynamic(texture, textureUnit) : _this.setTexture(texture, textureUnit));
        else if ("tv" === type) {
            for (b._array === e && (b._array = []), i = 0, il = b.value.length; i < il; i++) b._array[i] = getTextureUnit();
            for (c.uniform1iv(a, b._array), i = 0, il = b.value.length; i < il; i++) texture = b.value[i],
            textureUnit = b._array[i],
            texture && _this.setTexture(texture, textureUnit)
        }
    },
    Yb.Uniform.loadGeneralUniforms = function(a, b, c) {
        var d, e, f, g;
        for (f = 0, g = b.length; g > f; f++) e = a.uniforms[b[f][1]],
        e && (d = b[f][0], Yb.Uniform.loadUniform(d, c))
    },
    Yb.ProgramManager = function(a) {
        this.id = Yb.ProgramManagerId++,
        Yb.ProgramManagerCache.count++,
        this.network = a,
        this.gl = this.network._gl,
        this.gpu = this.network.gpu,
        this.programs = [],
        this.currentProgram = null,
        this.currentEntity = null,
        this.currentGroup = null,
        this.currentMaterial = null,
        this.info = {
            memory: {
                programs: 0,
                geometries: 0,
                textures: 0
            },
            render: {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            },
            currentMaterialId: -1
        },
        this.textures = [],
        this.textureCount = 0,
        this._lightNeedsUpdate = !0,
        this._lights = {
            ambient: [0, 0, 0],
            directional: {
                length: 0,
                colors: new Array,
                positions: new Array
            },
            point: {
                length: 0,
                colors: new Array,
                positions: new Array,
                distances: new Array
            },
            spot: {
                length: 0,
                colors: new Array,
                positions: new Array,
                distances: new Array,
                directions: new Array,
                anglesCos: new Array,
                exponents: new Array
            },
            hemi: {
                length: 0,
                skyColors: new Array,
                groundColors: new Array,
                positions: new Array
            }
        },
        this.gammaInput = !1,
        this.textureCount = 0,
        this.programMap = {},
        this.textureMap = {},
        this.textureUpdateFlags = {},
        this.glTextureMap = {},
        this.textureMaterialMap = {},
        this.unLoadedImage = {},
        this.materialMap = {},
        this.materialUpdateFlags = {},
        this.handleTextureChange = function(a) {
            if ("image" === a.property || "loaded" === a.property) {
                var b = a.source;
                this.changeTextureUpdateFlags(b, !0),
                delete this.unLoadedImage[b._image]
            } else if ("disposed" === a.property) {
                var b = a.source;
                this.deallocateTexture(b),
                b.removePropertyChangeListener(this.handleTextureChange),
                delete this.textureUpdateFlags[b.id],
                delete this.textureMap[b.id]
            }
            tc.getObjectCount(this.unLoadedImage) <= 0 && this.network.dirtyNetwork()
        },
        this.handleMaterialChange = function(a) {
            if ("map" == a.property || a.property.endsWith("Map") || "needsUpdate" === a.property) {
                var b = a.source;
                this.materialUpdateFlags[b.id] = !0
            } else if ("disposed" === a.property) {
                var b = a.source;
                this.deallocateMaterial(b),
                b.removePropertyChangeListener(this.handleMaterialChange),
                delete this.materialUpdateFlags[b.id],
                delete this.materialMap[b.id],
                delete this.programMap[b.id]
            }
            tc.getObjectCount(this.unLoadedImage) <= 0 && this.network.dirtyNetwork()
        }
    },
    Yb.ProgramManager.prototype.addMaterial = function(a) {
        null == this.materialMap[a.id] && (this.materialMap[a.id] = a, a.addPropertyChangeListener(this.handleMaterialChange, this))
    },
    Yb.ProgramManager.prototype.needsUpdateMaterial = function(a) {
        return this.materialUpdateFlags[a.id] === e || this.materialUpdateFlags[a.id] === !0 ? !0 : a.map instanceof xc || a.map instanceof yc ? !0 : !1
    },
    Yb.ProgramManager.prototype.changeMaterialUpdateFlags = function(a, b) {
        this.materialUpdateFlags[a.id] = b
    },
    Yb.ProgramManager.prototype.isLightMaterial = function(a) {
        return a instanceof Yb.LambertMaterial || a instanceof Yb.PhongMaterial || a.lights || "lambert" === a._type || "phong" === a._type || "terrain" === a._type
    },
    Yb.ProgramManager.prototype.changeAllMaterialUpdateFlags = function(a, b, c) {
        for (var d in this.materialMap) {
            var e = this.materialMap[d]; (null == b || b.call(c, e)) && (this.materialUpdateFlags[e.id] = a)
        }
    },
    Yb.ProgramManager.prototype.changeAllLightMaterialUpdateFlags = function(a) {
        this.changeAllMaterialUpdateFlags(a, this.isLightMaterial, this)
    },
    Yb.ProgramManager.prototype.addTexture = function(a) {
        null != a.id && this.textureMap[a.id] === e && (this.textureMap[a.id] = a, a.addPropertyChangeListener(this.handleTextureChange, this), a._image.loaded || (this.unLoadedImage[a._image] = 1))
    },
    Yb.ProgramManager.prototype.needsUpdateTexture = function(a) {
        return this.textureUpdateFlags[a.id] === e || this.textureUpdateFlags[a.id] === !0 ? !0 : !1
    },
    Yb.ProgramManager.prototype.changeTextureUpdateFlags = function(a, b) {
        this.textureUpdateFlags[a.id] = b;
        for (var c in this.materialMap) {
            var d = this.materialMap[c]; (d.map === a || d.lightMap === a || d.envMap === a || d.normalMap === a || d.specularMap === a) && this.changeMaterialUpdateFlags(d, !0)
        }
    },
    Yb.ProgramManager.prototype.buildProgram = function(a, b, c) {
        this.currentEntity = a,
        this.currentGroup = b,
        this.currentMaterial = c,
        c.shaderID || c.setupMaterialShader();
        var d, e, f, g, h = new Yb.GLParameters(this.currentMaterial, this.network, a),
        i = [];
        c.shaderID ? i.push(c.shaderID) : (i.push(c.vertexShader), i.push(c.fragmentShader));
        for (Wc in h)"material" !== Wc && "network" !== Wc && "node" !== Wc && (i.push(Wc), i.push(h[Wc]));
        for (g = i.join(), d = 0, e = this.programs.length; e > d; d++) if (this.programs[d].code === g) {
            c.program = this.programs[d].program,
            c.uniformsList = [];
            for (o in c.uniforms) c.uniformsList.push([c.uniforms[o], o]);
            return this.programs[d].usedTimes++,
            this.programs[d].program
        }
        f = this.gl.createProgram();
        var j = h.getShaders(),
        k = j[1],
        m = j[0];
        this.gl.attachShader(f, l("fragment", k + c.fragmentShader, this.gl)),
        this.gl.attachShader(f, l("vertex", m + c.vertexShader, this.gl)),
        this.gl.linkProgram(f),
        this.gl.getProgramParameter(f, this.gl.LINK_STATUS) || console.log("Could not initialise shader\nVALIDATE_STATUS: " + this.gl.getProgramParameter(f, this.gl.VALIDATE_STATUS) + ", gl error [" + this.gl.getError() + "]"),
        f.uniforms = {},
        f.attributes = {};
        var n, o, p, d;
        n = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "boneGlobalMatrices", "morphTargetInfluences"];
        for (o in c.uniforms) n.push(o);
        for (this.attachGLLocations(f, n, "uniform"), n = ["position", "normal", "uv", "uv2", "tangent", "color", "skinVertexA", "skinVertexB", "skinIndex", "skinWeight"], d = 0; d < h.maxMorphTargets; d++) n.push("morphTarget" + d);
        for (d = 0; d < h.maxMorphNormals; d++) n.push("morphNormal" + d);
        for (p in c.attributes) n.push(p);
        this.attachGLLocations(f, n, "attribute"),
        f.id = this.programs.length,
        this.programs.push({
            program: f,
            code: g,
            usedTimes: 1
        }),
        this.info.memory.programCount = this.programs.length,
        c.program = f,
        c.uniformsList = [];
        for (o in c.uniforms) c.uniformsList.push([c.uniforms[o], o]);
        return f
    },
    Yb.ProgramManager.prototype.enableAttribute = function(b, c) {
        var d = c.program.attributes;
        if (d.position >= 0 && _gl.enableVertexAttribArray(d.position), d.color >= 0 && _gl.enableVertexAttribArray(d.color), d.normal >= 0 && _gl.enableVertexAttribArray(d.normal), c.attributes) for (a in c.attributes) d[a] !== e && d[a] >= 0 && _gl.enableVertexAttribArray(d[a])
    },
    Yb.ProgramManager.prototype.attachGLLocations = function(a, b, c) {
        var d, e, f, g = this.gl;
        if ("uniform" === c) for (d = 0, e = b.length; e > d; d++) f = b[d],
        a.uniforms[f] = g.getUniformLocation(a, f);
        else if ("attribute" === c) for (d = 0, e = b.length; e > d; d++) f = b[d],
        a.attributes[f] = g.getAttribLocation(a, f)
    },
    Yb.ProgramManager.prototype.getGLShaders = function(a, b) {
        var c;
        return "fragment" === a ? c = this.gl.createShader(this.gl.FRAGMENT_SHADER) : "vertex" === tpye && (c = this.gl.createShader(this.gl.VERTEX_SHADER)),
        this.gl.shaderSource(c, string),
        this.gl.compileShader(c),
        gl.getShaderParameter(c, gl.COMPILE_STATUS) ? c: (console.log(gl.getShaderInfoLog(c)), console.log(string), null)
    },
    Yb.ProgramManager.prototype.setProgram = function(a, b, c, d, e, f) {
        if (this.textureCount = 0, this.addMaterial(d), this.needsUpdateMaterial(d)) {
            d.setupMaterialShader(),
            this.programMap[d.id] && this.deallocateMaterial(d);
            var i = this.buildProgram(f, e, d);
            this.programMap[d.id] = i,
            this.changeMaterialUpdateFlags(d, !1)
        }
        var j = !1,
        l = this.programMap[d.id],
        n = l.uniforms,
        o = d.uniforms;
        return l != this.currentProgram && (this.gl.useProgram(l), this.currentProgram = l, j = !0),
        d.id !== this.currentMaterialId && (this.currentMaterialId = d.id, j = !0),
        (j || a !== this.network._currentCamera) && (this.gl.uniformMatrix4fv(n.projectionMatrix, !1, a.projectionMatrix.elements), a !== this.network._currentCamera && (this.network._currentCamera = a)),
        c && d.fog && c.refreshUniforms(o),
        (d.lights || "phong" === d._type || "lambert" === d._type || "terrain" === d._type) && (this._lightNeedsUpdate && (this.setupLights(l, b), this._lightNeedsUpdate = !1), m(o, this._lights)),
        j && d.refreshUniforms(!1, {
            camera: this.network._camera
        }),
        f.receiveShadow && !d._shadowPass && this.network.isShadowable() && (g(o, b), h(o, b)),
        j && this.loadUniformsGeneric(l, d.uniformsList, d),
        d.loadCameraPosition(n, a, this.gl),
        (d.skinning || "phong" === d._type || "lambert" === d._type || "terrain" === d._type || d instanceof Yb.ShaderMaterial) && null !== n.viewMatrix && this.gl.uniformMatrix4fv(n.viewMatrix, !1, a.worldMatrixInverse.elements),
        k(n, f, this.gl),
        null != n.modelMatrix && this.gl.uniformMatrix4fv(n.modelMatrix, !1, f.worldMatrix.elements),
        this.network._baseRender && this.loadSSAOUniforms(n, d, j),
        l
    },
    Yb.ProgramManager.prototype.loadSSAOUniforms = function(a, b, c) {
        if (null != a.mapSSAO && this.network._sSAOEnable) {
            var d = a.mapSSAO,
            e = c ? this.getTextureUnit() : b._ssaoSlot;
            this.gl.uniform1i(d, e),
            this.setTexture(this.network.finalSSAOTarget, e),
            b._ssaoSlot = e
        }
    },
    Yb.ProgramManager.prototype.onTextureDispose = function(a) {
        var b = a.target;
        b.removeEventListener("dispose", onTextureDispose),
        deallocateTexture(b),
        this.info.memory.textures--
    },
    Yb.ProgramManager.prototype.deallocateTexture = function(a) {
        var b = this.gl;
        if (a._image && a._image.__webglTextureCube) b.deleteTexture(a._image.__webglTextureCube);
        else {
            if (!a.__webglInit) return;
            a.__webglInit = !1,
            b.deleteTexture(a.__webglTexture)
        }
    },
    Yb.ProgramManager.prototype.setTextureParameters = function(a, b, c, d) {
        var e = this.gl,
        f = this.gpu,
        g = Yb.Utils.paramToGL;
        c && !d ? (e.texParameteri(a, e.TEXTURE_WRAP_S, g(b.wrapS, e)), e.texParameteri(a, e.TEXTURE_WRAP_T, g(b.wrapT, e)), e.texParameteri(a, e.TEXTURE_MAG_FILTER, g(b.magFilter, e)), e.texParameteri(a, e.TEXTURE_MIN_FILTER, g(b.minFilter, e))) : (e.texParameteri(a, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(a, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(a, e.TEXTURE_MAG_FILTER, this.filterFallback(b.magFilter)), e.texParameteri(a, e.TEXTURE_MIN_FILTER, this.filterFallback(b.minFilter))),
        f._glExtensionTextureFilterAnisotropic && b.type !== Yb.FloatType && (b.anisotropy > 1 || b.__oldAnisotropy) && (e.texParameterf(a, f._glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, f._maxAnisotropy)), b.__oldAnisotropy = b.anisotropy)
    },
    Yb.ProgramManager.prototype.setCubeTexture = function(a, b) {
        var c = this.gl;
        this.addTexture(a);
        var d = a.id;
        if (6 === a._image.length) {
            if (!a._image.loaded) return;
            var f = Yb.Utils.isPowerOfTwo,
            g = Yb.Utils.paramToGL;
            if (this.needsUpdateTexture(a)) {
                this.glTextureMap[d] === e && (this.glTextureMap[d] = c.createTexture(), this.info.memory.texture++),
                this.changeTextureUpdateFlags(a, !1),
                c.activeTexture(c.TEXTURE0 + b),
                c.bindTexture(c.TEXTURE_CUBE_MAP, this.glTextureMap[d]),
                c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, a.flipY);
                for (var h = a instanceof Yb.CompressedTexture,
                i = [], j = 0; 6 > j; j++) this.autoScaleCubemaps && !h ? i[j] = clampToMaxSize(a._image[j], _maxCubemapSize) : i[j] = a._image[j];
                var k = i[0],
                l = f(k.width) && f(k.height),
                m = g(a.format, c),
                n = g(a.type, c);
                this.setTextureParameters(c.TEXTURE_CUBE_MAP, a, l);
                for (var j = 0; 6 > j; j++) if (h) for (var o, p = i[j].mipmaps, q = 0, r = p.length; r > q; q++) o = p[q],
                c.compressedTexImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X + j, q, m, o.width, o.height, 0, o.data);
                else c.texImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, m, m, n, i[j]);
                a.generateMipmaps && l && c.generateMipmap(c.TEXTURE_CUBE_MAP),
                a.needsUpdate = !1,
                a.onUpdate && a.onUpdate()
            } else c.activeTexture(c.TEXTURE0 + b),
            c.bindTexture(c.TEXTURE_CUBE_MAP, this.glTextureMap[d])
        }
    },
    Yb.ProgramManager.prototype.setCubeTextureDynamic = function(a, b) {
        var c = this.gl;
        c.activeTexture(c.TEXTURE0 + b),
        c.bindTexture(c.TEXTURE_CUBE_MAP, a.__webglTexture)
    },
    Yb.ProgramManager.prototype.loadUniformsGeneric = function(a, b, c) {
        var d, f, g, h, i, j, k, l, m, n, o, p = this.gl;
        for (m = 0, n = b.length; n > m; m++) if (h = a.uniforms[b[m][1]]) if (d = b[m][0], g = d.type, f = d.value, "i" === g) p.uniform1i(h, f);
        else if ("f" === g) p.uniform1f(h, f);
        else if ("v2" === g) p.uniform2f(h, f.x, f.y);
        else if ("v3" === g) p.uniform3f(h, f.x, f.y, f.z);
        else if ("v4" === g) p.uniform4f(h, f.x, f.y, f.z, f.w);
        else if ("c" === g) p.uniform3f(h, f.r, f.g, f.b);
        else if ("iv1" === g) p.uniform1iv(h, f);
        else if ("iv" === g) p.uniform3iv(h, f);
        else if ("fv1" === g) p.uniform1fv(h, f);
        else if ("fv" === g) p.uniform3fv(h, f);
        else if ("v2v" === g) {
            for (d._array === e && (d._array = new Float32Array(2 * f.length)), k = 0, l = f.length; l > k; k++) o = 2 * k,
            d._array[o] = f[k].x,
            d._array[o + 1] = f[k].y;
            p.uniform2fv(h, d._array)
        } else if ("v3v" === g) {
            for (d._array === e && (d._array = new Float32Array(3 * f.length)), k = 0, l = f.length; l > k; k++) o = 3 * k,
            f[k] instanceof Yb.Color ? (d._array[o] = f[k].r, d._array[o + 1] = f[k].g, d._array[o + 2] = f[k].b) : (d._array[o] = f[k].x, d._array[o + 1] = f[k].y, d._array[o + 2] = f[k].z);
            p.uniform3fv(h, d._array)
        } else if ("v4v" === g) {
            for (d._array === e && (d._array = new Float32Array(4 * f.length)), k = 0, l = f.length; l > k; k++) o = 4 * k,
            d._array[o] = f[k].x,
            d._array[o + 1] = f[k].y,
            d._array[o + 2] = f[k].z,
            d._array[o + 3] = f[k].w;
            p.uniform4fv(h, d._array)
        } else if ("m4" === g) d._array === e && (d._array = new Float32Array(16)),
        f.flattenToArray(d._array),
        p.uniformMatrix4fv(h, !1, d._array);
        else if ("m4v" === g) {
            for (d._array === e && (d._array = new Float32Array(16 * f.length)), k = 0, l = f.length; l > k; k++) f[k].flattenToArrayOffset(d._array, 16 * k);
            p.uniformMatrix4fv(h, !1, d._array)
        } else if ("t" === g) {
            if (i = f, j = this.getTextureUnit(), p.uniform1i(h, j), !i) continue;
            if (i._image instanceof Array && 6 === i._image.length) this.setCubeTexture(i, j);
            else {
                var q = i._image;
                this.setTexture(i, j, q ? !q.loaded: !0)
            }
        } else if ("tv" === g) {
            for (d._array === e && (d._array = []), k = 0, l = d.value.length; l > k; k++) d._array[k] = this.getTextureUnit();
            for (p.uniform1iv(h, d._array), k = 0, l = d.value.length; l > k; k++) if (i = d.value[k], j = d._array[k], i) {
                var q = i._image;
                i instanceof yc ? this.setCubeTextureDynamic(i, j) : this.setTexture(i, j, q ? !q.loaded: !0)
            }
        }
    },
    Yb.ProgramManager.prototype.setTexture = function(a, b, c) {
        var d = this.gl,
        f = Yb.Utils.isPowerOfTwo,
        g = a.id;
        if (this.addTexture(a), !this.needsUpdateTexture(a) || a instanceof xc) d.activeTexture(d.TEXTURE0 + b),
        a instanceof xc ? d.bindTexture(d.TEXTURE_2D, a.__webglTexture) : d.bindTexture(d.TEXTURE_2D, this.glTextureMap[g]);
        else {
            if (!a._image) return;
            this.glTextureMap[g] === e && (this.glTextureMap[g] = d.createTexture(), this.info.memory.textures++),
            this.changeTextureUpdateFlags(a, !1),
            d.activeTexture(d.TEXTURE0 + b),
            d.bindTexture(d.TEXTURE_2D, this.glTextureMap[g]),
            d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, !a.flipY),
            d.pixelStorei(d.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
            d.pixelStorei(d.UNPACK_ALIGNMENT, a.unpackAlignment);
            var h = Yb.Utils.paramToGL,
            i = c ? Yb.ImageCache.Logo: a._image,
            j = f(i.width) && f(i.height),
            k = h(a.format, d),
            l = h(a.type, d);
            this.setTextureParameters(d.TEXTURE_2D, a, j, c);
            var m, n = a.mipmaps;
            if (a instanceof Yb.PixelsTexture) if (n.length > 0 && j) {
                for (var o = 0,
                p = n.length; p > o; o++) m = n[o],
                d.texImage2D(d.TEXTURE_2D, o, k, m.width, m.height, 0, k, l, m.data);
                a.generateMipmaps = !1
            } else d.texImage2D(d.TEXTURE_2D, 0, k, i.width, i.height, 0, k, l, i.data);
            else if (a instanceof Yb.CompressedTexture) for (var o = 0,
            p = n.length; p > o; o++) m = n[o],
            d.compressedTexImage2D(d.TEXTURE_2D, o, k, m.width, m.height, 0, m.data);
            else if (n.length > 0 && j) {
                for (var o = 0,
                p = n.length; p > o; o++) m = n[o],
                d.texImage2D(d.TEXTURE_2D, o, k, k, l, m);
                a.generateMipmaps = !1
            } else try {
                d.texImage2D(d.TEXTURE_2D, 0, k, k, l, i)
            } catch(q) {
                console.log(q)
            }
            a.generateMipmaps && j && d.generateMipmap(d.TEXTURE_2D),
            a.onUpdate && a.onUpdate()
        }
    },
    Yb.ProgramManager.prototype.getTextureUnit = function() {
        var a = this.textureCount;
        return a >= this.gpu._maxTextures && console.warn("Network3D: trying to use " + a + " texture units while this GPU supports only " + this.gpu._maxTextures),
        this.textureCount++,
        a
    },
    Yb.ProgramManager.prototype.deallocateMaterial = function(a) {
        var b = a.program;
        if (b !== e) {
            a.program = e;
            var c, d, f, g = !1;
            for (c = 0, d = this.programs.length; d > c; c++) if (f = this.programs[c], f.program === b) {
                f.usedTimes--,
                0 === f.usedTimes && (g = !0);
                break
            }
            if (g === !0) {
                var h = [];
                for (c = 0, d = this.programs.length; d > c; c++) f = this.programs[c],
                f.program !== b && h.push(f);
                this.programs = h,
                this.gl.deleteProgram(b),
                this.info.memory.programs--
            }
        }
    },
    Yb.ProgramManager.prototype.filterFallback = function(a) {
        return a === Yb.NearestFilter || a === Yb.NearestMipMapNearestFilter || a === Yb.NearestMipMapLinearFilter ? this.gl.NEAREST: this.gl.LINEAR
    },
    Yb.ProgramManager.prototype.setupLights = function(a, b) {
        var c, d, e, f, g, h, i, j, k, l, m = 0,
        p = 0,
        q = 0,
        r = this._lights,
        s = r.directional.colors,
        t = r.directional.positions,
        u = r.point.colors,
        v = r.point.positions,
        w = r.point.distances,
        x = r.spot.colors,
        y = r.spot.positions,
        z = r.spot.distances,
        A = r.spot.directions,
        B = r.spot.anglesCos,
        C = r.spot.exponents,
        D = r.hemi.skyColors,
        E = r.hemi.groundColors,
        F = r.hemi.positions,
        G = 0,
        H = 0,
        I = 0,
        J = 0,
        K = 0,
        L = 0,
        M = 0,
        N = 0,
        O = 0,
        P = 0,
        Q = 0,
        R = 0,
        S = new Yb.Vec3;
        for (c = 0, d = b.size(); d > c; c++) if (e = b.get(c), !e.onlyShadow) if (f = e.color, i = e.intensity * this.network.lightIntensityRatio, l = e.distance, e.updateWorldMatrix(!0), e instanceof Yb.AmbientLight) {
            if (!e._visible) continue;
            this.gammaInput ? (m += f.r * f.r, p += f.g * f.g, q += f.b * f.b) : (m += f.r, p += f.g, q += f.b)
        } else if (e instanceof Yb.DirectionalLight) {
            if (K += 1, !e._visible) continue;
            if (e.direction ? S.copy(e.direction) : (S.copy(e.worldMatrix.getPosition()), S.sub(e.target.worldMatrix.getPosition())), S.normalize(), 0 === S.x && 0 === S.y && 0 === S.z) continue;
            O = 3 * G,
            t[O] = S.x,
            t[O + 1] = S.y,
            t[O + 2] = S.z,
            this.gammaInput ? o(s, O, f, i * i) : n(s, O, f, i),
            G += 1
        } else if (e instanceof Yb.PointLight) {
            if (L += 1, !e._visible) continue;
            P = 3 * H,
            this.gammaInput ? o(u, P, f, i * i) : n(u, P, f, i),
            k = e.worldMatrix.getPosition(),
            v[P] = k.x,
            v[P + 1] = k.y,
            v[P + 2] = k.z,
            w[H] = l,
            H += 1
        } else if (e instanceof Yb.SpotLight) {
            if (M += 1, !e._visible) continue;
            Q = 3 * I,
            this.gammaInput ? o(x, Q, f, i * i) : n(x, Q, f, i),
            k = e.worldMatrix.getPosition(),
            y[Q] = k.x,
            y[Q + 1] = k.y,
            y[Q + 2] = k.z,
            z[I] = l,
            S.copy(k),
            S.sub(e.target.worldMatrix.getPosition()),
            S.normalize(),
            A[Q] = S.x,
            A[Q + 1] = S.y,
            A[Q + 2] = S.z,
            B[I] = Math.cos(e.angle),
            C[I] = e.exponent,
            I += 1
        } else if (e instanceof Yb.HemisphereLight) {
            if (N += 1, !e._visible) continue;
            if (S.copy(e.worldMatrix.getPosition()), S.normalize(), 0 === S.x && 0 === S.y && 0 === S.z) continue;
            R = 3 * J,
            F[R] = S.x,
            F[R + 1] = S.y,
            F[R + 2] = S.z,
            g = e.color,
            h = e.groundColor,
            this.gammaInput ? (j = i * i, o(D, R, g, j), o(E, R, h, j)) : (n(D, R, g, i), n(E, R, h, i)),
            J += 1
        }
        for (c = 3 * G, d = Math.max(s.length, 3 * K); d > c; c++) s[c] = 0;
        for (c = 3 * H, d = Math.max(u.length, 3 * L); d > c; c++) u[c] = 0;
        for (c = 3 * I, d = Math.max(x.length, 3 * M); d > c; c++) x[c] = 0;
        for (c = 3 * J, d = Math.max(D.length, 3 * N); d > c; c++) D[c] = 0;
        for (c = 3 * J, d = Math.max(E.length, 3 * N); d > c; c++) E[c] = 0;
        r.directional.length = G,
        r.point.length = H,
        r.spot.length = I,
        r.hemi.length = J,
        r.ambient[0] = m,
        r.ambient[1] = p,
        r.ambient[2] = q
    },
    Yb.ProgramManagerId = 0,
    Yb.ProgramManagerCache = {
        count: 0
    };
    var xc = function(a, b, c) {
        this.width = a,
        this.height = b,
        c = c || {},
        this.wrapS = c.wrapS !== e ? c.wrapS: Yb.ClampToEdgeWrapping,
        this.wrapT = c.wrapT !== e ? c.wrapT: Yb.ClampToEdgeWrapping,
        this.magFilter = c.magFilter !== e ? c.magFilter: Yb.LinearFilter,
        this.minFilter = c.minFilter !== e ? c.minFilter: Yb.LinearMipMapLinearFilter,
        this.anisotropy = c.anisotropy !== e ? c.anisotropy: 1,
        this.offset = new Yb.Vec2(0, 0),
        this.repeat = new Yb.Vec2(1, 1),
        this.format = c.format !== e ? c.format: Yb.RGBAFormat,
        this.type = c.type !== e ? c.type: Yb.UnsignedByteType,
        this.depthBuffer = c.depthBuffer !== e ? c.depthBuffer: !0,
        this.stencilBuffer = c.stencilBuffer !== e ? c.stencilBuffer: !0,
        this.generateMipmaps = !0,
        this.shareDepthFrom = null
    };
    xc.prototype = {
        constructor: xc,
        clone: function() {
            var a = new xc(this.width, this.height);
            return a.wrapS = this.wrapS,
            a.wrapT = this.wrapT,
            a.magFilter = this.magFilter,
            a.minFilter = this.minFilter,
            a.anisotropy = this.anisotropy,
            a.offset.copy(this.offset),
            a.repeat.copy(this.repeat),
            a.format = this.format,
            a.type = this.type,
            a.depthBuffer = this.depthBuffer,
            a.stencilBuffer = this.stencilBuffer,
            a.generateMipmaps = this.generateMipmaps,
            a.shareDepthFrom = this.shareDepthFrom,
            a
        },
        getUniqueCode: function() {
            return this._id
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    };
    var yc = function(a, b, c) {
        xc.call(this, a, b, c),
        this.activeCubeFace = 0
    };
    Yb.extend(yc, xc, {}),
    Yb.Network3D = function(a, b, c, f) {
        Yb.Element.call(this),
        this.id = Yb.Network3DId++,
        this._interactionDispatcher = new Yb.EventDispatcher,
        f = f || {},
        this.helperBox = new Yb.DataBox,
        this.helperBox.addDataBoxChangeListener(this.handleDataBoxChange, this),
        this._rootView = bc.createView("hidden"),
        this._canvas = this.initCanvas(c),
        this._topCanvas = bc.createCanvas(this),
        this._bottomCanvas = bc.createCanvas(this);
        var g = this._canvas.parentNode;
        g && (g.removeChild(this._canvas), g.appendChild(this._rootView), this.adjustRootViewBounds(0, 0, this._canvas.width, this._canvas.height)),
        this._rootView.appendChild(this._bottomCanvas),
        this._rootView.appendChild(this._canvas),
        this._rootView.appendChild(this._topCanvas),
        this.setCanvasPropety(),
        this._camera = b || new Yb.PerspectiveCamera,
        this._camera.addPropertyChangeListener(this.dirtyNetwork, this),
        this._clearColor = f.clearColor !== e ? f.clearColor: new Yb.Color(16777215),
        this._clearAlpha = f.clearAlpha != e ? f.clearAlpha: 1,
        this._precision = f.precision !== e ? f.precision: "mediump",
        this.__fog = new Yb.FogExp2,
        this.devicePixelRatio = f.devicePixelRatio !== e ? f.devicePixelRatio: d.devicePixelRatio !== e ? d.devicePixelRatio: 1,
        this._premultipliedAlpha = null == f.premultipliedAlpha ? !0 : f.premultipliedAlpha,
        this.lightIntensityRatio = 1,
        cc.isIOS || cc.isAndroid ? (this._antialias = !1, this._preserveDrawingBuffer = !1, this.lightIntensityRatio = .1) : (this._preserveDrawingBuffer = null == f.preserveDrawingBuffer ? !0 : f.preserveDrawingBuffer, this._antialias = f.antialias == e ? !0 : f.antialias),
        this._gl = this.initGL(),
        this._programs = [],
        this._currentProgram = null,
        this.overrideMaterial = null,
        this._maxLights = f.maxLights !== e ? f.maxLights: 4,
        this._projScreenMatrix = new ac,
        this._projScreenMatrixPS = new ac,
        this._frustum = new Yb.Frustum,
        this._vector3 = new $b,
        this._oldDoubleSided = -1,
        this._oldFlipSided = -1,
        this._oldBlending = null,
        this._oldBlendEquation = null,
        this._oldBlendSrc = null,
        this._oldBlendDst = null,
        this._currentCamera = null,
        this._enabledAttributes = {},
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.gpu = new Yb.GPU(this),
        this.pm = new Yb.ProgramManager(this),
        this.setDefaultGLState(),
        this.paintSortFunction = Yb.Defaults.paintSortFunction,
        this.sortNodes = !0,
        this.sortOpaqueOrderByMaterial = !0,
        this.glNodeList = [],
        this.helperGLNodeList = [],
        this.info = {
            memory: {
                programs: 0,
                geometries: 0,
                textures: 0
            },
            render: {
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            },
            currentMaterialId: -1
        },
        this.projector = new Yb.Projector,
        this.up = new Yb.Vec3(0, 1, 0),
        this.position = new Yb.Vec3(0, 0, 0),
        this.seletionMaterial = new Yb.BasicMaterial,
        this.seletionMaterial.wireframe = !0,
        this.seletionMaterial.wireframeLinewidth = 1,
        this.seletionMaterial.color = new Yb.Color(65280),
        this.selectionCube = new rc,
        this.selectionCube.material = this.seletionMaterial,
        this.outlineMaterialMap = {},
        this.selectionCube._modelViewMatrix = new ac,
        this.selectionCube._normalMatrix = new _b,
        this.selectionCube.name = "select",
        this.alarmMaterial = new Yb.BasicMaterial,
        this.alarmMaterial.wireframe = !0,
        this.alarmMaterial.wireframeLinewidth = 1,
        this.alarmMaterial.color = new Yb.Color(16711680),
        this.alarmCube = new rc,
        this.alarmCube.material = this.alarmMaterial,
        this.alarmCube._modelViewMatrix = new ac,
        this.alarmCube._normalMatrix = new _b,
        this.alarmCube.name = "alarm";
        var h = 512;
        this._glowSurface = new Yb.Plane(2, 2),
        this._glowSurface2 = new Yb.Plane(h, h),
        this._glowSurface.target = new xc(h, h, {
            type: Yb.UnsignedByteType
        }),
        this._glowSurface.target1 = new xc(h, h, {
            type: Yb.UnsignedByteType
        }),
        this._glowSurface.target2 = new xc(h, h, {
            type: Yb.UnsignedByteType
        }),
        this._glowSurfaceMaterial = new Yb.BlurMaterial,
        this._blurMaterialH = new Yb.BlurMaterial,
        this._blurMaterialH.orientation = 1,
        this._blurMaterialV = new Yb.BlurMaterial,
        this.deferredPostionMaterial = new Yb.DeferredMaterial,
        this.deferredNormalMaterial = new Yb.DeferredMaterial({
            isNormal: 1
        }),
        this.ssaoMaterial = new Yb.SSAOMaterial,
        this.ssaoMaterial.map2 = new Yb.Texture(lc.ssaoNormalImage);
        var i = 1024;
        this.deferredPostionTarget = new xc(i, i, {
            type: Yb.FloatType,
            magFilter: Yb.NearestFilter,
            minFilter: Yb.NearestFilter
        }),
        this.deferredNormalTarget = new xc(i, i, {
            type: Yb.FloatType,
            magFilter: Yb.NearestFilter,
            minFilter: Yb.NearestFilter,
            format: Yb.RGBFormat
        }),
        this.ssaoTarget = new xc(i, i, {
            type: Yb.FloatType,
            magFilter: Yb.NearestFilter,
            minFilter: Yb.NearestFilter
        }),
        this.ssaoTarget1 = new xc(h, h, {
            type: Yb.UnsignedByteType
        }),
        this.ssaoTarget2 = new xc(h, h, {
            type: Yb.UnsignedByteType
        }),
        this.finalSSAOTarget = null,
        this._interactions = null,
        this.billboardRenderer = null,
        this._groupCounter = 0,
        this.groupMap = {},
        this.groupCountMap = {},
        this.bufferNodeMap = {},
        this.lineMap = {},
        this.particleMap = {},
        this.glInited = {},
        this.glNodeMap = {},
        this.normalNodeMap = {},
        this.showAxis = !1,
        this.axisSize = 20,
        this.axisPosition = new Yb.Vec3(0, 0, 0),
        this.axis = new Yb.Axis(this.axisSize),
        this.alarmBillboards = [],
        this.areaPickingRect = {},
        this.setDataBox(a === e ? new Yb.DataBox: a),
        this.renderCallback = null,
        this.beforeRenderFunction = null,
        this.dirtyNetwork(),
        this.prepareData(),
        this.autoUpdateCameraAspect = !0,
        this.shadowMapRenderer = null,
        this.shadowMapType = Yb.PCFSoftShadowMap,
        this.shadowMapCullFace = Yb.CullFaceFront,
        this.adjustBounds(this._canvas.width, this._canvas.height, 0, 0);
        var j = new Yb.DefaultInteraction(this);
        j.panSpeed = 3,
        j.zoomSpeed = 10;
        var k = this;
        this.getRootView().addEventListener("mousedown",
        function(a) {
            k.handleMouseDown(a)
        }),
        this.getRootView().addEventListener("mouseup",
        function(a) {
            k.handleClick(a)
        });
        var l = [j, new Yb.SelectionInteraction(this)];
        this.setInteractions(l),
        this.doubleClickToLookAtFunction = sc.doubleClickToLookAtFunction,
        p(this),
        this.initSurfaceGroup(),
        this.materialRenderListMap = {},
        this._selectTransparencyThreshold = 0,
        this._dynamicBatchDraw = !1,
        this._dynamicBatchDrawCountLimit = 1024,
        this.needSmoothNormalFunction = sc.needSmoothNormalFunction,
        this._annotationMap = {},
        this._activeAnnotation = null
    },
    Yb.extend(Yb.Network3D, Yb.Data, {
        ___accessor: ["shadowMapEnable", "editableFunction", "keyboardRemoveEnabled", "selectTransparencyThreshold", "dynamicBatchDraw", "showFps"],
        setUseFog: function(a) {
            this._useFog = a,
            this._useFog ? this._fog = this.__fog: this._fog = null
        },
        setOverloadMaterial: function(a) {
            this._overloadMaterial = a
        },
        setFogColor: function(a) {
            this.__fog.color = a
        },
        setFogDensity: function(a) {
            this.__fog.density = a
        },
        setDataBox: function(a) {
            if (!a) throw "DataBox can not be null";
            if (this.dataBox !== a) {
                var b = this.dataBox;
                b && (this._clearDataBox(b), b.removeDataBoxChangeListener(this.handleDataBoxChange, this), b.removeDataPropertyChangeListener(this.handleDataPropertyChange, this), b.getAlarmBox().removeDataBoxChangeListener(this.dirtyNetwork, this), b.getSelectionModel().removeSelectionChangeListener(this.dirtyNetwork, this)),
                this.dataBox = a,
                this.dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this),
                this.dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this),
                this.dataBox.getAlarmBox().addDataBoxChangeListener(this.dirtyNetwork, this),
                this.dataBox.getSelectionModel().addSelectionChangeListener(this.dirtyNetwork, this),
                this.firePropertyChange("dataBox", b, this._box),
                this.glNodeList = [],
                this.dirtyNetwork(),
                this._clearNodeCache()
            }
        },
        setRenderCallback: function(a) {
            this.renderCallback = a
        },
        setBeforeRenderFunction: function(a) {
            this.beforeRenderFunction = a
        },
        getDataBox: function() {
            return this.dataBox
        },
        getClearColor: function() {
            return this._clearColor
        },
        setClearColor: function(a) {
            3 == arguments.length ? (this._clearColor = new Yb.Color, this._clearColor.setRGB(arguments[0], arguments[1], arguments[2])) : (this._clearColor = a, this._clearColor instanceof Yb.Color || (this._clearColor = new Yb.Color(a))),
            this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha),
            this.dirtyNetwork()
        },
        setClearAlpha: function(a) {
            this._clearAlpha = a,
            this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha),
            this.dirtyNetwork()
        },
        getClearAlpha: function() {
            return this._clearAlpha
        },
        getPrecision: function() {
            return this._precision
        },
        setPrecision: function(a) {
            this._precesion = a
        },
        setSSAOBlur: function(a) {
            this._ssaoBlur = a
        },
        setSSAOEnable: function(a) {
            return a && !this.isFloatTextureSupport() ? !1 : (this._sSAOEnable = a, this._dirty = !0, !0)
        },
        isSSAOEnable: function() {
            return this._sSAOEnable && this._baseRender
        },
        setSSAOOccluderBias: function(a) {
            this._occluderBias = a,
            this._dirty = !0
        },
        setSSAOSamplingRadius: function(a) {
            this._samplingRadius = a,
            this._dirty = !0
        },
        setSSAOAttenuation: function(a) {
            this._attenuation = a,
            this._dirty = !0
        },
        isFloatTextureSupport: function() {
            return null != this._glExtensionTextureFloat
        },
        getCamera: function() {
            return this._camera
        },
        setCamera: function(a, b) {
            if (this._camera != a) {
                var c = this._camera;
                if (c.removePropertyChangeListener(this.dirtyNetwork), this._camera = a, this._camera.addPropertyChangeListener(this.dirtyNetwork, this), this.autoUpdateCameraAspect) {
                    this._camera.setAspect(c.aspect);
                    var d = this.getDefaultInteraction();
                    d && (d.object = this._camera)
                }
                b && (this._camera.p(c.p()), this._camera.lookAt(c.getTarget())),
                this.dirtyNetwork()
            }
        },
        isVisible: function(a) {
            if (a) {
                if (a instanceof Yb.Link || a instanceof Yb.PathLink) {
                    if (!a.isVisible()) return ! 1;
                    if (!this.isVisible(a._fromNode)) return ! 1;
                    if (!this.isVisible(a._toNode)) return ! 1
                }
                if (!a.isVisible()) return ! 1;
                if (a._parent) return this.isVisible(a._parent);
                if (this.visibleFunction) return this.visibleFunction(a)
            }
            return ! 0
        },
        setCanvasPropety: function() {
            this._canvas && (this._canvas.setAttribute("tabindex", this.id), this._canvas.style.outline = "none", this._canvas.style.position = "absolute")
        },
        initCanvas: function(a) {
            return a === e ? document.createElement("canvas") : ("string" == typeof a && (a = document.getElementById(a)), a)
        },
        initGL: function() {
            var a;
            try {
                a = this._canvas.getContext("webgl", {
                    preserveDrawingBuffer: this._preserveDrawingBuffer,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: !0
                }) || this._canvas.getContext("experimental-webgl", {
                    preserveDrawingBuffer: this._preserveDrawingBuffer,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: !0
                })
            } catch(b) {
                console.log(b)
            }
            return a || console.error("Can not init webgl context"),
            this._glExtensionTextureFloat = a.getExtension("OES_texture_float"),
            this._glExtensionStandardDerivatives = a.getExtension("OES_standard_derivatives"),
            this._glExtensionTextureFilterAnisotropic = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
            this._glExtensionCompressedTextureS3TC = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
            this._glExtensionTextureFloat || console.log("TGL.Network3D: Float textures not supported."),
            this._glExtensionStandardDerivatives || console.log("TGL.Network3D: Standard derivatives not supported."),
            this._glExtensionTextureFilterAnisotropic || console.log("TGL.Network3D: Anisotropic texture filtering not supported."),
            this._glExtensionCompressedTextureS3TC || console.log("TGL.Network3D: S3TC compressed textures not supported."),
            a ? a: void console.log("Error: Your browser does not support WebGL.")
        },
        resetRenderInfo: function() {
            this.info.render.calls = 0,
            this.info.render.vertices = 0,
            this.info.render.faces = 0,
            this.info.render.points = 0,
            this.info.currentMaterialId = -1
        },
        _clearDataBox: function(a) {
            var b = null;
            b = a === this.helperBox ? this.helperGLNodeList: this.glNodeList;
            for (var c = b.length - 1; c >= 0; c--) b[c],
            b.splice(c, 1);
            b = [],
            this.prepareData(),
            this.pm._lightNeedsUpdate = !0,
            this.pm.changeAllLightMaterialUpdateFlags(!0),
            this._clearNodeCache(),
            this.deleteCloneNode()
        },
        handleDataBoxChange: function(a) {
            var b = a.kind,
            c = a.data,
            d = a.source,
            e = null;
            e = d === this.helperBox ? this.helperGLNodeList: this.glNodeList,
            "add" === b ? c instanceof Yb.Light ? (this.pm._lightNeedsUpdate = !0, this.pm.changeAllLightMaterialUpdateFlags(!0), this.prepareData()) : c instanceof Yb.Annotation ? this._createAnnotationDiv(c) : (this.addNodeMaterials(c), 0 === e.length ? this.initWebGLNodes(d, e) : this.addNode(c, e), c._alarmBillboard && this.alarmBillboards.push(c._alarmBillboard)) : "remove" === b ? c instanceof Yb.Light ? (this.pm._lightNeedsUpdate = !0, this.pm.changeAllLightMaterialUpdateFlags(!0), this.prepareData()) : c instanceof Yb.Annotation ? this._removeAnnotationDiv(c) : (this.removeNode(c, e), this.deleteCloneNode(c)) : "clear" === b && this._clearDataBox(),
            this.boundingBox = null,
            this.dirtyNetwork()
        },
        removeNode: function(a, b) {
            for (var c = b.length - 1; c >= 0; c--) {
                var d = b[c];
                d.node === a && b.splice(c, 1)
            }
            this._clearNodeCache(a)
        },
        _clearNodeCache: function(a) {
            if (a) {
                if (a.oldGroups = a.groups || a.oldGroups, null != a.oldGroups) for (var b in a.oldGroups) {
                    var c = a.oldGroups[b],
                    d = this.groupCountMap[c.id];
                    null != d && (d--, 0 >= d ? (delete this.groupCountMap[c.id], delete this.groupMap[c.id]) : this.groupCountMap[c.id] = d)
                }
                for (var e = 0; e < this.alarmBillboards.length; e++) {
                    var f = this.alarmBillboards[e];
                    f.getParent() === a && (this.alarmBillboards.splice(e, 1), e--)
                }
                a instanceof Yb.Annotation && this._removeAnnotationDiv(a)
            } else {
                for (var g in this.groupMap) {
                    var h = this.groupMap[g],
                    i = h._nodeId;
                    this.helperBox.containsById(i) || delete this.groupMap[g]
                }
                this.glInited = new Object,
                this.alarmBillboards.splice(0),
                this.glNodeList = []
            }
            for (var g in this._annotationMap) this._removeAnnotationDiv(g)
        },
        addNode: function(a, b) {
            for (var c = this.addWebGLNode(b, a), d = 0; d < c.length; d++) {
                var e = c[d];
                this.updateWebGLNode(e)
            }
        },
        addNodeMaterials: function(a) {
            var b, c = a.material;
            if (c instanceof Yb.Material) this.addMaterial(c);
            else if (c instanceof Yb.ArrayMaterial) {
                var d = c.materials,
                e = d.length;
                for (b = 0; e > b; b++) this.addMaterial(d[b])
            }
        },
        addMaterial: function(a) {
            this.pm.addMaterial(a),
            a.map && this.pm.addTexture(a.map)
        },
        handleDataPropertyChange: function(a) {
            var b = a.source;
            if (b instanceof Yb.Node) {
                var c = a.property;
                if (b.isSizeChangedProperty(c) || c === Yb.Styles.MaterailType || c === Yb.Styles.NormalType) {
                    if (b instanceof Yb.Line) {
                        b.verticesNeedUpdate = !0;
                        var d = this.lineMap[b._id];
                        this.initLineBuffers(b),
                        gc.buildLineBufferData(b, this._gl.DYNAMIC_DRAW, this._gl, d)
                    } else if (b.groups) {
                        b.verticesNeedUpdate = !0,
                        (c === Yb.Styles.MaterailType || c === Yb.Styles.NormalType) && (b.normalsNeedUpdate = !0);
                        for (var e in b.groups) {
                            var f = b.groups[e],
                            d = this.groupMap[f.id],
                            g = gc.getMaterial(b, f.materialIndex);
                            b.normalsNeedUpdate && this.initGroupBuffer(b, f, d, !0),
                            gc.buildGroupBufferData(f, b, this._gl.DYNAMIC_DRAW, !b.dynamic, g, this._gl, d, this)
                        }
                    }
                } else if ("materialMapping" === c) this._currentGroupHash = null,
                this.glInited[b.getId()] = !1,
                this.removeNode(b, this.glNodeList),
                this.addNode(b, this.glNodeList);
                else if ("alarmBillboard" === c) {
                    var h = a.oldValue,
                    i = a.newValue;
                    this._addNodeAlarmBillboard(b, h, i)
                }
                this.addNodeMaterials(b)
            } else b instanceof Yb.Light && (this.pm._lightNeedsUpdate = !0); (b.isSizeChangedProperty && b.isSizeChangedProperty(c) || "parent" == c || b.isSpaceChangedProperty(c)) && (this.deleteCloneNode(b), this.boundingBox = null),
            this.dirtyNetwork()
        },
        deleteCloneNode: function(a) {
            if (a) {
                var b = a.getId ? a.getId() : a,
                c = this.normalNodeMap[b];
                if (null != c) {
                    c.setParent(null);
                    for (var d in c.groups) {
                        var e = c.groups[d];
                        delete this.groupMap[e.id]
                    }
                }
                delete this.normalNodeMap[b]
            } else for (var b in this.normalNodeMap) this.deleteCloneNode(b)
        },
        setBlurAmount: function(a) {
            this._blurAmount = a
        },
        setBlurScale: function(a) {
            this._blurScale = a
        },
        setBlurStrength: function(a) {
            this._blurStrength = a
        },
        setBlurGlobalAlpha: function(a) {
            this._blurGlobalAlpha = a
        },
        dirtyNetwork: function(a) {
            this.dataBox.batch || (this._dirty = !0)
        },
        _addNodeAlarmBillboard: function(a, b, c) {
            if (c === e && (c = a._alarmBillboard), null != b && -1 !== this.alarmBillboards.indexOf(b)) {
                var d = this.alarmBillboards.indexOf(b);
                this.alarmBillboards.splice(d, 1),
                b.removePropertyChangeListener(this.dirtyNetwork, this)
            }
            c && -1 === this.alarmBillboards.indexOf(c) && (this.alarmBillboards.push(c), c.addPropertyChangeListener(this.dirtyNetwork, this))
        },
        initWebGLNodes: function(a, b) {
            var c, d, e = a.getNodes();
            for (c = 0, d = e.size(); d > c; c++) {
                var f = e.get(c);
                f.renderSelected = !1,
                this.addWebGLNode(b, f),
                this.glNodeMap[f.id] = f
            }
            for (c = 0, d = b.length; d > c; c++) this.updateWebGLNode(b[c])
        },
        updateWebGLNode: function(a) {
            var b, c, d = a.node;
            if (d instanceof Yb.Entity) {
                for (var e in d.groups) if (b = d.groups[e], c = gc.getMaterial(d, b.materialIndex), d.buffersNeedUpdate) {
                    var f = this.groupMap[b.id];
                    this.initGroupBuffer(d, b, f),
                    gc.buildGroupBufferData(b, d, this._gl.DYNAMIC_DRAW, !d.dynamic, c, this._gl, f, this)
                }
                d.setUpdateFlags(!1),
                d.buffersNeedUpdate = !1
            } else if (d instanceof Yb.BufferNode) this.setBufferNodeData(d, this._gl.DYNAMIC_DRAW, !d.dynamic);
            else if (d instanceof Yb.Line) {
                var f = this.lineMap[d._id];
                gc.buildLineBufferData(d, this._gl.DYNAMIC_DRAW, this._gl, f)
            } else if (d instanceof Yb.Particle) {
                var f = this.particleMap[d._id];
                ic(d, this._gl.DYNAMIC_DRAW, this._gl, f)
            }
        },
        addWebGLNode: function(a, b) {
            var c, d, f, g, h = [];
            if (this.glInited[b.getId()] || this._addNodeAlarmBillboard(b), !this.glInited[b.getId()]) if (this.glInited[b.id] = !0, b._modelViewMatrix = new ac, b._normalMatrix = new _b, b instanceof Yb.Entity) {
                b.groups == e && hc(b);
                for (c in b.groups) {
                    d = b.groups[c],
                    d.id = d.id === e ? Yb.Network3D.GroupCache._groupCounter++:d.id;
                    var i = this.groupCountMap[d.id] || 0;
                    i++,
                    this.groupCountMap[d.id] = i,
                    this.groupMap[d.id] === e && (this.groupMap[d.id] = {});
                    var j = this.groupMap[d.id];
                    j._nodeId = b.getId(),
                    j.__webglVertexBuffer || (this.createGroupBuffer(d, j), this.initGroupBuffer(b, d, j), b.setUpdateFlags(!0))
                }
            } else if (b instanceof Yb.Line) {
                null == this.lineMap[b._id] && (this.lineMap[b._id] = {});
                var j = this.lineMap[b._id];
                j._nodeId = b.getId(),
                j.__webglVertexBuffer || (this.createLineBuffers(b), this.initLineBuffers(b), b.verticesNeedUpdate = !0, b.colorsNeedUpdate = !0, b.lineDistancesNeedUpdate = !0)
            } else if (b instanceof Yb.Particle) {
                null == this.lineMap[b._id] && (this.lineMap[b._id] = {});
                var j = this.lineMap[b._id];
                j._nodeId = b.getId(),
                j.__webglVertexBuffer || (this.createParticleBuffers(b), this.initParticleBuffers(b), b.verticesNeedUpdate = !0, b.colorsNeedUpdate = !0)
            } else b instanceof Yb.BufferNode ? this.initBufferNode(b) : b instanceof Yb.Annotation && this._createAnnotationDiv(b);
            if (b instanceof Yb.Entity) {
                for (c in b.groups) d = b.groups[c],
                f = gc.getMaterial(b, d.materialIndex),
                g = {
                    group: d,
                    node: b,
                    opaque: f.transparent ? null: f,
                    transparent: f.transparent ? f: null
                },
                a.push(g),
                h.push(g);
                null === b.groups
            } else b instanceof Yb.Line ? (f = b.material, g = {
                group: b,
                node: b,
                opaque: f.transparent ? null: f,
                transparent: f.transparent ? f: null
            },
            a.push(g), h.push(g)) : b instanceof Yb.Particle ? (f = b.material, g = {
                group: b,
                node: b,
                opaque: f.transparent ? null: f,
                transparent: f.transparent ? f: null
            },
            a.push(g), h.push(g)) : b instanceof Yb.BufferNode && (f = b.material instanceof Yb.ArrayMaterial ? b.material.materials[0] : b.material, g = {
                group: b,
                node: b,
                opaque: f.transparent ? null: f,
                transparent: f.transparent ? f: null
            },
            a.push(g), h.push(g));
            return b.glActive = !0,
            h
        },
        onElementDispose: function(a) {
            var b = a.target;
            b.removeEventListener("dispose", this.onElementDispose),
            deallocateElement(b),
            this.info.memory.geometries--
        },
        deallocateElement: function(a) {},
        _AK47: function(a, b, c, d, f, g) {
            this._fog,
            a.parent === e && a.updateWorldMatrix(!0, !1),
            a.worldMatrixInverse.getInverse(a.worldMatrix),
            this._projScreenMatrix.multiply(a.projectionMatrix, a.worldMatrixInverse),
            this._frustum.setFromMatrix(this._projScreenMatrix),
            0 === c.length && (this.initWebGLNodes(b, c), this.prepareData()),
            this.resetRenderInfo();
            var h, i, j, k;
            if (!g) for (h = 0, i = c.length; i > h; h++) j = c[h],
            k = j.node,
            k.renderSelected = !1,
            j.render = !1,
            this.isVisible(k) && (this.unrollBufferMaterial(j), this.setupMatrices(k, a), (k instanceof Yb.Entity || k instanceof Yb.Particle) && k.frustumCulled && !this._frustum.intersectsObject(k) || (j.render = !0, this.sortNodes && (this._vector3.copy(k.worldMatrix.getPosition()), this._vector3.applyProjection(this._projScreenMatrix), null != k.renderDepth ? j.z = k.renderDepth + this._vector3.z: j.z = this._vector3.z)));
            var l = new kc;
            if (l.addAll(d), !f && !g) {
                for (var m = this.alarmBillboards.length - 1; m >= 0; m--) {
                    var n = this.alarmBillboards[m];
                    null == n.getParent() && this.alarmBillboards.splice(m, 1)
                }
                l.addAll(this.alarmBillboards)
            }
            var o = this; ! g && l.forEach(function(a) {
                a.renderDepth ? a.z = a.renderDepth: (o._vector3.copy(a.worldMatrix.getPosition()), o._vector3.applyProjection(o._projScreenMatrix), a.z = o._vector3.z)
            }),
            l.size() > 0 && !g && null == this.billboardRenderer && (this.billboardRenderer = new Yb.BillboardRenderer);
            var p = [].concat(c).concat(l._as),
            q = this.sortNodesFunc(p);
            this.setBlending(Yb.NoBlending),
            this.renderNodes(q, !1, "opaque", a, b.getLights(), !1, null, g, this.sortOpaqueOrderByMaterial),
            this.renderNodes(q, !0, "transparent", a, b.getLights(), !0, null, g),
            this.setDepthTest(!0),
            this.setDepthWrite(!0)
        },
        unrollBufferMaterial: function(a) {
            var b, c, d, e = a.node,
            f = a.group;
            d = e.material,
            d instanceof Yb.ArrayMaterial ? (c = f.materialIndex || 0, b = d.materials[c], b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null)) : (b = d, b && (b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null)))
        },
        renderLicense: function() {},
        isShadowable: function() {
            return this.isShadowMapEnable() && (this.maxShadows > 0 || this.maxPointShadows > 0)
        },
        render: function() {
            if (this._dirty && (this._dirty = !1, null != this.beforeRenderFunction && this.beforeRenderFunction.call(this), !this.isShadowable() || (this.shadowMapRender(), this.setRenderTarget(e), !this.debugPointLight))) {
                if (Sc.twm(this), this.paintBottom(this._bottomCanvas), this.getShowFps() && (this.__time = (new Date).getTime()), this.innerRender(this._camera, !0), this.renderAnnotations(this._camera), this.extendRender(this._camera), this.paintTopCanvas(), this.getShowFps()) {
                    this._tpf = (new Date).getTime() - this.__time;
                    var a = this._topCanvas.getContext("2d"),
                    b = (1e3 / this._tpf).toFixed(0);
                    b > 500 && (b = "> 500");
                    var c = "FPS:" + b + ",TPF:" + this._tpf + " ms";
                    a.font = "20px Arial sans-serif",
                    a.fontWeight = "bold",
                    a.lineWith = 2,
                    a.fillStyle = "rgba(0, 0, 0, 1)",
                    a.fillText(c, 10, 25)
                }
                if (this._xyz != e) {
                    var d, f = this._xyz,
                    g = f.markText,
                    h = f.type,
                    c = (f.expired, f.innerHTML),
                    i = 0,
                    j = 0,
                    a = (this._topCanvas.getBoundingClientRect(), this._topCanvas.getContext("2d"));
                    g != e && null != g && "" != g || "2" == h ? (a.font = "24px Arial sans-serif", d = fc.getTextSize(a.font, c), a.fillStyle = "red", i = this._canvas.width - d.width - 20, j = this._canvas.height - d.height - 10) : (a.font = "15px Arial sans-serif", a.fillStyle = "rgba(240, 120, 25, 0.6)", d = fc.getTextSize(a.font, c), i = this._canvas.width - d.width - 20, j = this._canvas.height - d.height - 10),
                    a.fillText(c, i, j)
                }
                null != this.renderCallback && this.renderCallback.call(this)
            }
        },
        getTextSize: function(a, b) {
            return fc.getTextSize(a, b)
        },
        shadowMapRender: function() {
            null == this.shadowMapRenderer && (this.shadowMapRenderer = new ad, this.shadowMapRenderer.init(this)),
            0 === this.glNodeList.length && (this.initWebGLNodes(this.dataBox, this.glNodeList), this.prepareData()),
            this.shadowMapRenderer.render(this.dataBox, this._camera)
        },
        handleMouseDown: function(a) {
            var b = a.target;
            this.lastX = a.clientX,
            this.lastY = a.clientY,
            "tgl_annotation" == b.getAttribute("class") && "1" == b.style.opacity && (a.stop = !0, a.stopPropagation())
        },
        handleClick: function(a) {
            var b = a.clientX - this.lastX,
            c = a.clientY - this.lastY;
            if (Math.abs(b) < .1 && Math.abs(c) < .1) {
                var d = a.target;
                if ("tgl_annotation" != d.getAttribute("clazz")) this._activeAnnotation && (this._activeAnnotation = null, this.dirtyNetwork());
                else if ("1" == d.style.opacity) {
                    var e = d.getAttribute("id"),
                    f = this.getDataBox().getDataById(e),
                    g = this._annotationMap[e];
                    this.handleDefaultAnnotationClick(f, g),
                    this.handleAnnotationClick(f, g),
                    this.dirtyNetwork()
                }
            }
        },
        handleDefaultAnnotationClick: function(a, b) {
            this._activeAnnotation != a && (this._activeAnnotation = a)
        },
        handleAnnotationClick: function(a, b) {},
        renderAnnotations: function(a) {
            var b = this.dataBox.getAnnotations(),
            c = this;
            if (b && (b.forEach(function(b) {
                c.renderAnnotation(a, b)
            }), this._createAnnotationStyle()), this._activeAnnotation) {
                this._createAnnotationToolTipDiv();
                var d = this._annotationToolTipDiv;
                d.innerHTML = this._activeAnnotation.getText();
                var e = this._annotationMap[this._activeAnnotation.getId()];
                d.parentNode != e && e.appendChild(d),
                d.style.opacity = e.style.opacity
            }
        },
        getAnnotationDiv: function(a) {
            return this._annotationMap[a.getId()]
        },
        renderAnnotation: function(a, b) {
            var c = this._annotationMap[b.getId()];
            null == c && (c = this._createAnnotationDiv(b)),
            c.innerHTML = b._label,
            b.updateWorldMatrix();
            var d = b.worldMatrix.getPosition(),
            e = b.getStyle("annotation.class");
            c.setAttribute("class", e);
            var f = this.getViewPosition(d);
            this._annotationToolTipDiv,
            c.style.left = f.x + "px",
            c.style.top = f.y + "px",
            c.style.opacity = "1";
            var g = d.distanceTo(a.getPosition()),
            h = this.getElementByScreenPoint(f, !1);
            if (h && h.length > 0) {
                var i = h[0];
                i.distance < g && (c.style.opacity = "0.03")
            }
        },
        _addCSSRule: function(a, b, c, d) {
            d = d || (a.cssRules || a.rules).length,
            a.insertRule ? a.insertRule(b + "{" + c + "}", d) : a.addRule && a.addRule(b, c, d)
        },
        _createAnnotationStyle: function() {
            if (!this._annotationStyle) {
                var a = document.createElement("style");
                a.appendChild(document.createTextNode("")),
                document.head.appendChild(a);
                var b = a.sheet;
                this._addCSSRule(b, ".tgl_annotation", "position:absolute;width:16px;height:16px;border-radius:10px;text-align:center;border : 2px solid gray;"),
                this._addCSSRule(b, ".tgl_annotation:hover", "border : 2px solid black;"),
                this._annotationStyle = a
            }
        },
        _removeAnnotationDiv: function(a) {
            var b = a.getId ? a.getId() : a,
            c = this._annotationMap[b];
            null != c && this.getRootView().removeChild(c)
        },
        _createAnnotationDiv: function(a) {
            var b = document.createElement("div"),
            c = a.getStyle("annotation.class");
            return b.setAttribute("id", a.getId()),
            b.setAttribute("class", c),
            b.setAttribute("clazz", "tgl_annotation"),
            this._annotationMap[a.getId()] = b,
            this.getRootView().appendChild(b),
            b
        },
        _createAnnotationToolTipDiv: function() {
            if (null == this._annotationToolTipDiv) {
                var a = document.createElement("div");
                a.setAttribute("class", "tgl_annotation_tooltip");
                var b = document.createElement("style");
                b.appendChild(document.createTextNode("")),
                document.head.appendChild(b);
                var c = b.sheet,
                d = "position: absolute;border: 3px solid #333; background-color: #ccd; padding: 3px;text-align: left;width: 220px;height: 'auto';border-radius: 10px;bottom:35px;left:-13px;";
                this._addCSSRule(c, ".tgl_annotation_tooltip", d),
                d = "content: ' ';position: absolute;top: 100%; border: 1px solid;",
                this._addCSSRule(c, ".tgl_annotation_tooltip:after, .tgl_annotation_tooltip:before", d),
                d = "border-color: #333 transparent transparent transparent;border-width: 16px 17px 0 7px;left: 10px;",
                this._addCSSRule(c, ".tgl_annotation_tooltip:before", d),
                d = "border-color: #ccd transparent transparent transparent;border-width: 12px 11px 0 4px;left: 14px;",
                this._addCSSRule(c, ".tgl_annotation_tooltip:after", d),
                this._annotationToolTipDiv = a
            }
        },
        extendRender: function(a) {},
        innerRender: function(a, b) {
            if (a === e && (a = this._camera), null === a) return void console.log(" no camera");
            if (this.debug && console.log("inner Render"), this.autoClear) {
                var c = this._clearColor;
                this._gl.clearColor(c.r, c.g, c.b, this._clearAlpha),
                wc.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil, this)
            }
            if (b) for (var d = 0; d < this._interactions.length; d++) {
                var f = this._interactions[d];
                f.update && f.update()
            }
            if (this.billboardRenderer && this.billboardRenderer.disable(), this._gl.viewport(0, 0, this._canvas.width, this._canvas.height), this._sSAOEnable) {
                this.linearDepth = a.far - a.near,
                this.ssaoing = !0,
                this._renderDeferredTarget(a, this.deferredPostionMaterial, this.deferredPostionTarget),
                this._renderDeferredTarget(a, this.deferredNormalMaterial, this.deferredNormalTarget),
                this._setSSAOMaterial(),
                this._overloadMaterial = null,
                this._renderSurface(a, this.ssaoTarget, this.ssaoMaterial);
                var g = this._canvas.width / this._canvas.height;
                this._ssaoBlur ? (this._renderBlurTarget(a, this._blurMaterialH, this.ssaoTarget, this.ssaoTarget1, g), this._renderBlurTarget(a, this._blurMaterialV, this.ssaoTarget1, this.ssaoTarget2, g), this.finalSSAOTarget = this.ssaoTarget2) : this.finalSSAOTarget = this.ssaoTarget,
                this.setRenderTarget(e),
                this.ssaoing = !1
            }
            if (this.renderOutline = !1, this.renderOutlineGlow = !1, wc.enableStencil(this._gl), this._baseRender = !0, wc.r(this, a, this.dataBox, this.glNodeList, this.dataBox.getBillboards()), this._baseRender = !1, wc.stencilTest(this._gl), this.renderOutline && wc.r(this, a, this.dataBox, this.glNodeList, this.dataBox.getBillboards(), !1, "stencil"), this.renderOutlineGlow) {
                var h = this._glowSurface.target,
                i = this._glowSurface.target1,
                j = this._glowSurface.target2;
                wc.disableStencil(this._gl),
                this.setRenderTarget(h),
                h._id = h._id || (new Date).getTime() + "0",
                i._id = i._id || (new Date).getTime() + "1",
                j._id = j._id || (new Date).getTime() + "2",
                this._gl.viewport(0, 0, h.width, h.height),
                this._gl.clearColor(0, 0, 0, 0),
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
                this._gl.colorMask(!1, !1, !1, !1),
                wc.r(this, a, this.dataBox, this.glNodeList, this.dataBox.getBillboards(), !1, "glow.unselect"),
                this._gl.colorMask(!0, !0, !0, !0),
                wc.r(this, a, this.dataBox, this.glNodeList, this.dataBox.getBillboards(), !1, "glow.select");
                var k, l;
                this.setRenderTarget(i),
                this._gl.viewport(0, 0, i.width, i.height),
                this._gl.clearColor(0, 0, 0, 0),
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
                this._blurMaterialH.setMap(h);
                var g = this._canvas.width / this._canvas.height;
                this._blurMaterialH.texelSize = new Zb(h.width, h.height / g),
                this._blurMaterialH.blurAmount = this._blurAmount || 5,
                this._blurMaterialH.blurScale = this._blurScale || 1,
                this._blurMaterialH.blurStrength = this._blurStrength || 1,
                this._blurMaterialH.orientation = 1;
                for (k in this._glowSurface.groups) l = this._glowSurface.groups[k],
                this.renderGroup(a, [], this._blurMaterialH, l, this._glowSurface2);
                this.setRenderTarget(j),
                this._gl.clearColor(0, 0, 0, 0),
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
                this._blurMaterialV.setMap(i),
                this._blurMaterialV.texelSize = new Zb(i.width, i.height / g),
                this._blurMaterialV.blurAmount = this._blurAmount || 5,
                this._blurMaterialV.blurScale = this._blurScale || 1,
                this._blurMaterialV.blurStrength = this._blurStrength || 1,
                this._blurMaterialV.orientation = 0;
                for (k in this._glowSurface.groups) l = this._glowSurface.groups[k],
                this.renderGroup(a, [], this._blurMaterialV, l, this._glowSurface2);
                this.setRenderTarget(e),
                this._glowSurface._modelViewMatrix = new ac,
                this._glowSurface._normalMatrix = new _b,
                this.setupMatrices(this._glowSurface, a),
                this._glowSurfaceMaterial.setMap(j),
                this._glowSurfaceMaterial.useBlur = 0,
                this._glowSurfaceMaterial.blurGlobalAlpha = this._blurGlobalAlpha || 1,
                wc.setBlending(this._glowSurfaceMaterial.blendMode, this._glowSurfaceMaterial.blendEquation, this._glowSurfaceMaterial.blendSrc, this._glowSurfaceMaterial.blendDst, this),
                this._gl.enable(this._gl.STENCIL_TEST);
                for (k in this._glowSurface.groups) l = this._glowSurface.groups[k],
                this.renderGroup(a, [], this._glowSurfaceMaterial, l, this._glowSurface);
                this.setRenderTarget(i),
                this._gl.viewport(0, 0, i.width, i.height),
                this._gl.clearColor(0, 0, 0, 0),
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
                this._blurMaterialH.setMap(h);
                var g = this._canvas.width / this._canvas.height;
                this._blurMaterialH.texelSize = new Zb(h.width, h.height / g),
                this._blurMaterialH.blurAmount = this._blurAmount || 10,
                this._blurMaterialH.blurScale = this._blurScale || 1,
                this._blurMaterialH.blurStrength = this._blurStrength || 1,
                this._blurMaterialH.orientation = 0;
                for (k in this._glowSurface.groups) l = this._glowSurface.groups[k],
                this.renderGroup(a, [], this._blurMaterialH, l, this._glowSurface2);
                this.setRenderTarget(j),
                this._gl.clearColor(0, 0, 0, 0),
                this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
                this._blurMaterialV.setMap(i),
                this._blurMaterialV.texelSize = new Zb(i.width, i.height / g),
                this._blurMaterialV.blurAmount = this._blurAmount || 10,
                this._blurMaterialV.blurScale = this._blurScale || 1,
                this._blurMaterialV.blurStrength = this._blurStrength || 1,
                this._blurMaterialV.orientation = 1;
                for (k in this._glowSurface.groups) l = this._glowSurface.groups[k],
                this.renderGroup(a, [], this._blurMaterialV, l, this._glowSurface2);
                this.setRenderTarget(e),
                this._glowSurface._modelViewMatrix = new ac,
                this._glowSurface._normalMatrix = new _b,
                this.setupMatrices(this._glowSurface, a),
                this._glowSurfaceMaterial.setMap(j),
                this._glowSurfaceMaterial.useBlur = 0,
                this._glowSurfaceMaterial.blurGlobalAlpha = this._blurGlobalAlpha || 1,
                wc.setBlending(this._glowSurfaceMaterial.blendMode, this._glowSurfaceMaterial.blendEquation, this._glowSurfaceMaterial.blendSrc, this._glowSurfaceMaterial.blendDst, this),
                this._gl.enable(this._gl.STENCIL_TEST);
                for (k in this._glowSurface.groups) l = this._glowSurface.groups[k],
                this.renderGroup(a, [], this._glowSurfaceMaterial, l, this._glowSurface);
                this._gl.clearColor(0, 0, 0, 0)
            }
            wc.disableStencil(this._gl),
            this.renderHelper(a)
        },
        _renderDeferredTarget: function(a, b, c, d) {
            d = d || new Yb.Vec4(0, 0, 0, 0, 0),
            b.linearDepth = this.linearDepth,
            this.setRenderTarget(c),
            this._overloadMaterial = b,
            this._gl.clearColor(d.x, d.y, d.z, d.w),
            this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
            wc.r(this, a, this.dataBox, this.glNodeList, this.dataBox.getBillboards())
        },
        _renderBlurTarget: function(a, b, c, d, e) {
            clearColor = clearColor || new Yb.Vec4(0, 0, 0, 0, 0),
            this.setRenderTarget(d),
            this._gl.viewport(0, 0, d.width, d.height),
            this._gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w),
            this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
            b.setMap(c),
            b.texelSize = new Zb(c.width, c.height / e),
            b.blurAmount = this._blurAmount || 5,
            b.blurScale = this._blurScale || 1,
            b.blurStrength = this._blurStrength || 1;
            var f, g;
            for (f in this._glowSurface.groups) g = this._glowSurface.groups[f],
            this.renderGroup(a, [], b, g, this._glowSurface2)
        },
        _setSSAOMaterial: function() {
            this.ssaoMaterial.map = this.deferredPostionTarget,
            this.ssaoMaterial.map1 = this.deferredNormalTarget,
            this.ssaoMaterial.attenuation = this._attenuation || new Zb(1, .02),
            this.ssaoMaterial.occluderBias = this._occluderBias || .5,
            this.ssaoMaterial.samplingRadius = this._samplingRadius || 20,
            this.ssaoMaterial.texelSize = new Zb(1 / this.deferredPostionTarget.width, 1 / this.deferredPostionTarget.height)
        },
        _renderSurface: function(a, b, c, d) {
            d = d || new Yb.Vec4(1, 1, 1, 1),
            this.setRenderTarget(b),
            this._gl.clearColor(d.x, d.y, d.z, d.w),
            this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT),
            this._glowSurface._modelViewMatrix = new ac,
            this._glowSurface._normalMatrix = new _b,
            this.setupMatrices(this._glowSurface, a);
            var e, f;
            for (f in this._glowSurface.groups) e = this._glowSurface.groups[f],
            this.renderGroup(a, [], c, e, this._glowSurface)
        },
        renderHelper: function(a) {
            wc.r(this, a, this.helperBox, this.helperGLNodeList, this.helperBox.getBillboards(), "stencil")
        },
        initSurfaceGroup: function() {
            this._glowSurface.setUpdateFlags(!0),
            hc(this._glowSurface);
            for (var a in this._glowSurface.groups) {
                var b = this._glowSurface.groups[a];
                b.id = b.id === e ? Yb.Network3D.GroupCache._groupCounter++:b.id,
                this.groupMap[b.id] === e && (this.groupMap[b.id] = {});
                var c = this.groupMap[b.id];
                this.createGroupBuffer(b, c),
                this.initGroupBuffer(this._glowSurface, b, c),
                gc.buildGroupBufferData(b, this._glowSurface, this._gl.DYNAMIC_DRAW, !1, this._glowSurfaceMaterial, this._gl, c, this)
            }
            this._glowSurface2.setUpdateFlags(!0),
            hc(this._glowSurface2);
            for (var a in this._glowSurface2.groups) {
                var b = this._glowSurface2.groups[a];
                b.id = b.id === e ? Yb.Network3D.GroupCache._groupCounter++:b.id,
                this.groupMap[b.id] === e && (this.groupMap[b.id] = {});
                var c = this.groupMap[b.id];
                this.createGroupBuffer(b, c),
                this.initGroupBuffer(this._glowSurface2, b, c),
                gc.buildGroupBufferData(b, this._glowSurface2, this._gl.DYNAMIC_DRAW, !1, this._glowSurfaceMaterial, this._gl, c, this)
            }
        },
        getOutlineMaterial: function(a, b) {
            var c = (b.getStyle("select.width") || 1) + 1 + " " + new Yb.Color(b.getStyle("select.color")).getUniqueCode() + a,
            d = this.outlineMaterialMap[c];
            return null == d && (d = new Yb.EntityMaterial, "outline.normal" == a ? (d._type = "outline", d.outline = b.getStyle("select.width") || 1) : "outline.glow" == a ? d._type = "basic": (d.wireframe = !0, d.wireframeLinewidth = (b.getStyle("select.width") || 1) + 1), d.color = new Yb.Color(b.getStyle("select.color")), this.outlineMaterialMap[c] = d),
            d
        },
        renderNodes: function(a, b, c, d, e, f, g, h, i) {
            var j, k, l, m, n, o, p;
            b ? (n = a.length - 1, o = -1, p = -1) : (n = 0, o = a.length, p = 1);
            for (var q = n; q !== o; q += p) if (j = a[q], m = j.node ? j.transparent || j.opaque: j.material) {
                this._overloadMaterial && (m = this._overloadMaterial);
                var r = this.getOverLoadMaterial(j.node ? j.node: j, m);
                if (r) {
                    var s = r.getUniqueCode(),
                    t = $c.getMaterial(s);
                    t ? m = t: ($c.setMaterial(s, r), m = r)
                }
                if (! ("opaque" == c && 1 == m.transparent || "transparent" == c && 0 == m.transparent)) {
                    if (f ? (wc.setBlending(m.blendMode, m.blendEquation, m.blendSrc, m.blendDst, this), wc.setDepthWrite(!1, this)) : wc.setDepthWrite(m.depthMask, this), j instanceof Yb.Billboard) {
                        var u = j.material.transparent ? "transparent": "opaque";
                        c == u && this.billboardRenderer.render(this, [j], d, 2 * this._canvas.width, 2 * this._canvas.height)
                    } else if (j.render) {
                        if (this.billboardRenderer && this.billboardRenderer.disable(), k = j.node, l = j.group, wc.setDepthTest(m.depthTest, this), wc.setPolygonOffset(m.polygonOffset, m.polygonOffsetFactor, m.polygonOffsetUnits, this), this.setGLFaces(m), k instanceof Yb.Particle) {
                            if (k.verticesNeedUpdate || k.colorsNeedUpdate || k.sortParticles) {
                                var v = this.particleMap[k._id];
                                ic(k, this._gl.DYNAMIC_DRAW, this._gl, v)
                            }
                            k.verticesNeedUpdate = !1,
                            k.colorsNeedUpdate = !1
                        }
                        var w = this.getSelectStyle(k);
                        if ("outline" == w && (w = "outline.normal"), h ? "glow.unselect" === h && (k.isSelected() || (k instanceof Yb.BufferNode ? this.renderBufferNode(d, e, m, l, k) : wc.g(this, d, e, m, l, k))) : (!k.isSelected() || "outline.normal" !== w && "outline.wireframe" !== w && "outline.glow" !== w ? this.setStencilTest(!1) : (this.setStencilTest(!0), "outline.glow" === w ? this.renderOutlineGlow = !0 : this.renderOutline = !0), k instanceof Yb.BufferNode ? this.renderBufferNode(d, e, m, l, k) : wc.g(this, d, e, m, l, k)), k.isSelected() && this.renderSelect(k)) if ("outline.normal" === w || "outline.wireframe" === w || "outline.glow" === w) {
                            if (null != h && "glow.unselect" != h) if ("outline.normal" === w) {
                                if (k.renderSelected === !1) {
                                    var x = this.getOutlineMaterial(w, k),
                                    y = this.normalNodeMap[k.getId()];
                                    if (null == y) {
                                        var y = this.cloneNode(k, x);
                                        this.normalNodeMap[k.getId()] = y
                                    }
                                    this.setupMatrices(y, d);
                                    for (var z in y.groups) wc.g(this, d, e, x, y.groups[z], y);
                                    k.renderSelected = !0
                                }
                            } else if ("outline.normal" !== w) {
                                var x = this.getOutlineMaterial(w, k);
                                wc.g(this, d, e, x, l, k)
                            }
                        } else k.renderSelected === !1 && (this.renderNodeSelection(d, e, k), k.renderSelected = !0);
                        k.getAlarmState().getPropagateSeverity() && this.renderAlarmBorder(k) && this.renderNodeAlarm(d, e, k)
                    }
                    k && k.setUpdateFlags(!1)
                }
            }
        },
        cloneNode: function(a, b) {
            var c, d, e = new Yb.Entity,
            f = {
                vertices: [],
                uvs: [],
                faces: []
            };
            for (c = 0, d = a.vertices.length; d > c; c++) f.vertices.push(a.vertices[c].clone());
            for (c = 0, d = a.faces.length; d > c; c++) f.faces.push(a.faces[c].clone());
            for (c = 0, d = a.uvs.lenght; d > c; c++) {
                for (var g = uvs[c], h = [], i = 0; g > i; i++) h.push(g[i].clone());
                f.uvs.push(h)
            }
            return Yb.Node.prototype.mergeVertices.call(f),
            Yb.Node.prototype.computeFaceNormals.call(f),
            Yb.Node.prototype.computeVertexNormals.call(f, !0),
            e.setPosition(a.getPosition()),
            e.setScale(a.getScale()),
            e.setRotation(a.getRotation()),
            e.setParent(a.getParent()),
            e._modelViewMatrix = new ac,
            e._normalMatrix = new _b,
            e.data = f,
            e.vertices = f.vertices,
            e.uvs = f.uvs,
            e.faces = f.faces,
            e.material = b,
            e.primitive = new Yb.Primitive(f),
            e.setUpdateFlags(!0),
            hc(e),
            this.buildNodeBufferData(e),
            e
        },
        buildNodeBufferData: function(a) {
            for (var b in a.groups) {
                var c = a.groups[b];
                c.id = c.id === e ? Yb.Network3D.GroupCache._groupCounter++:c.id,
                this.groupMap[c.id] === e && (this.groupMap[c.id] = {});
                var d = this.groupMap[c.id];
                this.createGroupBuffer(c, d),
                this.initGroupBuffer(a, c, d),
                gc.buildGroupBufferData(c, a, this._gl.DYNAMIC_DRAW, !1, a.material, this._gl, d, this)
            }
        },
        needSmoothNormal: function(a, b) {
            var c = b.normalType;
            return c != e ? c === Yb.NormalTypeSmooth: this.needSmoothNormalFunction ? this.needSmoothNormalFunction(a) : !1
        },
        renderNodeSelection: function(a, b, c) {
            c.createSelectionCube(this.selectionCube),
            this.setupMatrices(this.selectionCube, a);
            var d = this.selectionCube.groups;
            this.selectionCube.material.needsUpdate = !0;
            for (var f in d) {
                var g = d[f];
                g.id = g.id === e ? Yb.Network3D.GroupCache._groupCounter++:g.id,
                this.groupMap[g.id] === e && (this.groupMap[g.id] = {});
                var h = this.groupMap[g.id];
                h.__webglVertexBuffer || (this.createGroupBuffer(g, h), this.initGroupBuffer(c, g, h)),
                this.selectionCube.setUpdateFlags(!0),
                gc.buildGroupBufferData(g, this.selectionCube, this._gl.DYNAMIC_DRAW, !1, this.selectionCube.material, this._gl, h, this),
                this.renderGroup(a, [], this.selectionCube.material, g, this.selectionCube)
            }
        },
        renderNodeAlarm: function(a, b, c) {
            c.createPropagateAlarmCube(this.alarmCube),
            this.setupMatrices(this.alarmCube, a);
            var d = this.alarmCube.groups;
            this.alarmCube.material.needsUpdate = !0;
            for (var f in d) {
                var g = d[f];
                g.id = g.id === e ? Yb.Network3D.GroupCache._groupCounter++:g.id,
                this.groupMap[g.id] === e && (this.groupMap[g.id] = {});
                var h = this.groupMap[g.id];
                h.__webglVertexBuffer || (this.createGroupBuffer(g, h), this.initGroupBuffer(c, g, h)),
                this.alarmCube.setUpdateFlags(!0),
                gc.buildGroupBufferData(g, this.alarmCube, this._gl.DYNAMIC_DRAW, !1, this.alarmCube.material, this._gl, h, this),
                this.renderGroup(a, [], this.alarmCube.material, g, this.alarmCube)
            }
        },
        renderBufferNode: function(a, b, c, d, e, f) {
            if (c.visible !== !1) {
                var g, h;
                g = this.pm.setProgram(a, b, this._fog, c, d, e),
                h = g.attributes;
                var i = e,
                j = !1,
                k = c.wireframe ? 1 : 0,
                l = 16777215 * d._id + 2 * g.id + k; (l !== this._currentGroupHash || f) && (this._currentGroupHash = l, j = !0),
                j && this.disableAttributes();
                var m = this._gl,
                n = i.attributes.index,
                o = this.bufferNodeMap[e._id];
                if (n) {
                    var p = i.offsets;
                    p.length > 1 && (j = !0);
                    for (var q = 0,
                    r = p.length; r > q; q++) {
                        var s = p[q].index;
                        if (j) {
                            var t = i.attributes.position,
                            u = t.itemSize;
                            m.bindBuffer(m.ARRAY_BUFFER, o.position),
                            this.enableAttribute(h.position),
                            m.vertexAttribPointer(h.position, u, m.FLOAT, !1, 0, s * u * 4);
                            var v = i.attributes.normal;
                            if (h.normal >= 0 && v) {
                                var w = v.itemSize;
                                m.bindBuffer(m.ARRAY_BUFFER, o.normal),
                                this.enableAttribute(h.normal),
                                m.vertexAttribPointer(h.normal, w, m.FLOAT, !1, 0, s * w * 4)
                            }
                            var x = i.attributes.uv;
                            if (h.uv >= 0 && x) {
                                var y = x.itemSize;
                                m.bindBuffer(m.ARRAY_BUFFER, o.uv),
                                this.enableAttribute(h.uv),
                                m.vertexAttribPointer(h.uv, y, m.FLOAT, !1, 0, s * y * 4)
                            }
                            var z = i.attributes.color;
                            if (h.color >= 0 && z) {
                                var A = z.itemSize;
                                m.bindBuffer(m.ARRAY_BUFFER, o.color),
                                this.enableAttribute(h.color),
                                m.vertexAttribPointer(h.color, A, m.FLOAT, !1, 0, s * A * 4)
                            }
                            m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, o.index)
                        }
                        m.drawElements(m.TRIANGLES, p[q].count, m.UNSIGNED_SHORT, 2 * p[q].start),
                        this.info.render.calls++,
                        this.info.render.vertices += p[q].count,
                        this.info.render.faces += p[q].count / 3
                    }
                } else {
                    if (j) {
                        var t = i.attributes.position,
                        u = t.itemSize;
                        m.bindBuffer(m.ARRAY_BUFFER, t.buffer),
                        this.enableAttribute(h.position),
                        m.vertexAttribPointer(h.position, u, m.FLOAT, !1, 0, 0);
                        var v = i.attributes.normal;
                        if (h.normal >= 0 && v) {
                            var w = v.itemSize;
                            m.bindBuffer(m.ARRAY_BUFFER, v.buffer),
                            this.enableAttribute(h.normal),
                            m.vertexAttribPointer(h.normal, w, m.FLOAT, !1, 0, 0)
                        }
                        var x = i.attributes.uv;
                        if (h.uv >= 0 && x) {
                            var y = x.itemSize;
                            m.bindBuffer(m.ARRAY_BUFFER, x.buffer),
                            this.enableAttribute(h.uv),
                            m.vertexAttribPointer(h.uv, y, m.FLOAT, !1, 0, 0)
                        }
                        var z = i.attributes.color;
                        if (h.color >= 0 && z) {
                            var A = z.itemSize;
                            m.bindBuffer(m.ARRAY_BUFFER, z.buffer),
                            this.enableAttribute(h.color),
                            m.vertexAttribPointer(h.color, A, m.FLOAT, !1, 0, 0)
                        }
                    }
                    var t = i.attributes.position;
                    m.drawArrays(m.TRIANGLES, 0, t.numItems / 3),
                    this.info.render.calls++,
                    this.info.render.vertices += t.numItems / 3,
                    this.info.render.faces += t.numItems / 3 / 3
                }
            }
        },
        getOverLoadMaterial: function(a, b) {
            return null
        },
        renderGroup: function(a, b, c, d, e) {
            if (null == c && console.log("material is null"), c.visible !== !1) {
                var f, g = this._gl;
                if (e instanceof Yb.Entity ? f = this.groupMap[d.id] : e instanceof Yb.Line ? f = this.lineMap[d._id] : e instanceof Yb.Particle && (f = this.particleMap[d._id]), null == f) return void(this.debug && console.error("tempGroup for id:" + (d.id || d._id) + " is null,please check"));
                var h, i, j, k, l, m;
                h = this.pm.setProgram(a, b, this._fog, c, d, e),
                i = h.attributes;
                var n, o = !1,
                p = c.wireframe ? 1 : 0;
                if (n = null != d.id ? 16777215 * d.id + 2 * h.id + p: d._id + "" + (2 * h.id + p), n !== this._currentGroupHash && (this._currentGroupHash = n, o = !0), o && this.disableAttributes(), i.position >= 0 && o && (g.bindBuffer(g.ARRAY_BUFFER, f.__webglVertexBuffer), this.enableAttribute(i.position), g.vertexAttribPointer(i.position, 3, g.FLOAT, !1, 0, 0)), o) {
                    if (d.__webglCustomAttributesList) for (l = 0, m = d.__webglCustomAttributesList.length; m > l; l++) k = d.__webglCustomAttributesList[l],
                    i[k.buffer.belongsToAttribute] >= 0 && (g.bindBuffer(g.ARRAY_BUFFER, k.buffer), this.enableAttribute(i[k.buffer.belongsToAttribute]), g.vertexAttribPointer(i[k.buffer.belongsToAttribute], k.size, g.FLOAT, !1, 0, 0));
                    i.color >= 0 && (g.bindBuffer(g.ARRAY_BUFFER, f.__webglColorBuffer), this.enableAttribute(i.color), g.vertexAttribPointer(i.color, 3, g.FLOAT, !1, 0, 0)),
                    i.normal >= 0 && (g.bindBuffer(g.ARRAY_BUFFER, f.__webglNormalBuffer), this.enableAttribute(i.normal), g.vertexAttribPointer(i.normal, 3, g.FLOAT, !1, 0, 0)),
                    i.uv >= 0 && (g.bindBuffer(g.ARRAY_BUFFER, f.__webglUVBuffer), this.enableAttribute(i.uv), g.vertexAttribPointer(i.uv, 2, g.FLOAT, !1, 0, 0)),
                    i.uv2 >= 0 && (g.bindBuffer(g.ARRAY_BUFFER, f.__webglUV2Buffer), this.enableAttribute(i.uv2), g.vertexAttribPointer(i.uv2, 2, g.FLOAT, !1, 0, 0)),
                    i.lineDistance >= 0 && (g.bindBuffer(g.ARRAY_BUFFER, f.__webglLineDistanceBuffer), this.enableAttribute(i.lineDistance), g.vertexAttribPointer(i.lineDistance, 1, g.FLOAT, !1, 0, 0))
                }
                e instanceof Yb.Entity ? (c.wireframe ? (this.setLineWidth(c.wireframeLinewidth), this._gl.lineJoin = "round", o && g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, f.__webglLineBuffer), g.drawElements(g.LINES, f.__webglLineCount, g.UNSIGNED_SHORT, 0)) : (o && g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, f.__webglFaceBuffer), g.drawElements(g.TRIANGLES, f.__webglFaceCount, g.UNSIGNED_SHORT, 0)), this.info.render.calls++, this.info.render.vertices += d.__webglFaceCount, this.info.render.faces += d.__webglFaceCount / 3) : e instanceof Yb.Line ? (j = e.type === Yb.LineStrip ? g.LINE_STRIP: g.LINES, this.setLineWidth(c.linewidth), g.drawArrays(j, 0, f.__webglLineCount), this.info.render.calls++) : e instanceof Yb.Particle ? (g.drawArrays(g.POINTS, 0, f.__webglParticleCount), this.info.render.calls++, this.info.render.points += f.__webglParticleCount) : e instanceof Yb.Ribbon && (g.drawArrays(g.TRIANGLE_STRIP, 0, d.__webglVertexCount), this.info.render.calls++)
            }
        },
        prepareData: function() {
            this.maxLightCount = this.dataBox.allocateLights(this._maxLights),
            this.maxShadows = this.dataBox.allocateShadows(),
            this.maxPointShadows = this.dataBox.allocatePointShadows()
        },
        wrapBillboardMaterial: function(a) {
            a instanceof Yb.Billboard && a.material && (a.opaque = a.material.transparent ? null: a.material, a.transparent = a.material.transparent ? a.material: null)
        },
        sortNodesFunc: function(a) {
            if (this.sortNodes && (null !== this.paintSortFunction || this.sortOpaqueOrderByMaterial)) {
                var b = this;
                this.sortOpaqueOrderByMaterial ? null == this.__st && (this.__st = function(a, c) {
                    b.wrapBillboardMaterial(a),
                    b.wrapBillboardMaterial(a);
                    var d = "opaque";
                    if (a[d] && c[d]) return a[d].id - c[d].id;
                    if (!a[d] && c[d]) return - 1;
                    if (a[d] && !c[d]) return 1;
                    var e = a.node ? a.node: a,
                    f = c.node ? c.node: c;
                    return e.z = a.z,
                    f.z = c.z,
                    b.paintSortFunction ? b.paintSortFunction(e, f) : void 0
                }) : null == this.__st && (this.__st = function(a, c) {
                    var d = a.node ? a.node: a,
                    e = c.node ? c.node: c;
                    return d.z = a.z,
                    e.z = c.z,
                    b.paintSortFunction ? b.paintSortFunction(d, e) : void 0
                }),
                a.sort(this.__st)
            }
            return a
        },
        renderNode: function(a, b) {
            this.setupMatrices(a),
            a instanceof Yb.Entity && renderEntity(a)
        },
        paintTopCanvas: function() {
            var a = this._topCanvas.getContext("2d");
            a.clearRect(0, 0, this._topCanvas.width, this._topCanvas.height);
            var b = this.areaPickingRect;
            b && (a.beginPath(), a.lineStyle = "#FFffff", a.rect(b.x, b.y, b.w, b.h), a.stroke()),
            this.renderLicense()
        },
        setBackgroundImage: function(a) {
            if ("string" == typeof a) {
                var b = new Image;
                a.startsWith("data:image") || (b.crossOrigin = "use-credentials"),
                b.src = a,
                this._backgroundImage = b;
                var c = this;
                b.onload = function() {
                    c.dirtyNetwork()
                }
            } else this._backgroundImage = a,
            this.dirtyNetwork()
        },
        paintBottom: function(a) {
            var b = a.getContext("2d");
            b.clearRect(0, 0, a.width, a.height);
            var c = this._backgroundImage;
            c instanceof Image && c.height && b.drawImage(c, 0, 0, a.width, a.height)
        },
        initBufferNode: function(a) {
            if (!this.bufferNodeMap[a._id]) {
                var b = {};
                this.bufferNodeMap[a._id] = b;
                var c, d, e, f = this._gl;
                for (c in a.attributes) e = "index" === c ? f.ELEMENT_ARRAY_BUFFER: f.ARRAY_BUFFER,
                d = a.attributes[c],
                b[c] = f.createBuffer(),
                f.bindBuffer(e, b[c]),
                f.bufferData(e, d.array, f.STATIC_DRAW)
            }
        },
        setBufferNodeData: function(a, b, c) {
            var d = this.bufferNodeMap[a._id],
            f = a.attributes,
            g = f.index,
            h = f.position,
            i = f.normal,
            j = f.uv,
            k = f.color,
            l = f.tangent,
            m = this._gl;
            if (a.elementsNeedUpdate && g !== e && (m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, d.index), m.bufferData(m.ELEMENT_ARRAY_BUFFER, g.array, b)), a.verticesNeedUpdate && h !== e && (m.bindBuffer(m.ARRAY_BUFFER, d.position), m.bufferData(m.ARRAY_BUFFER, h.array, b)), a.normalsNeedUpdate && i !== e && (m.bindBuffer(m.ARRAY_BUFFER, d.normal), m.bufferData(m.ARRAY_BUFFER, i.array, b)), a.uvsNeedUpdate && j !== e && (m.bindBuffer(m.ARRAY_BUFFER, d.uv), m.bufferData(m.ARRAY_BUFFER, j.array, b)), a.colorsNeedUpdate && k !== e && (m.bindBuffer(m.ARRAY_BUFFER, d.color), m.bufferData(m.ARRAY_BUFFER, k.array, b)), a.tangentsNeedUpdate && l !== e && (m.bindBuffer(m.ARRAY_BUFFER, d.tangent), m.bufferData(m.ARRAY_BUFFER, l.array, b)), c) for (var n in a.attributes);
        },
        initGroupBuffer: function(a, b, c, d) {
            var f = b.faces3,
            g = b.faces4,
            h = 3 * f.length + 4 * g.length,
            i = 1 * f.length + 2 * g.length,
            j = 3 * f.length + 4 * g.length,
            k = gc.getMaterial(a, b.materialIndex ? b.materialIndex: 0),
            l = k.needUV(),
            m = k.getNormalType(),
            n = k.isVertexColor();
            if (c.__vertexArray = new Float32Array(3 * h), m && (c.__normalArray = new Float32Array(3 * h)), !d) {
                n && (c.__colorArray = new Float32Array(3 * h)),
                l && (c.__uvArray = new Float32Array(2 * h), a.uv2s && (c.__uv2Array = new Float32Array(2 * h))),
                c.__faceArray = new Uint16Array(3 * i),
                c.__lineArray = new Uint16Array(2 * j);
                var o, p;
                if (b.numMorphTargets) for (c.__morphTargetsArrays = [], o = 0, p = b.numMorphTargets; p > o; o++) c.__morphTargetsArrays.push(new Float32Array(3 * h));
                if (b.numMorphNormals) for (c.__morphNormalsArrays = [], o = 0, p = b.numMorphNormals; p > o; o++) c.__morphNormalsArrays.push(new Float32Array(3 * h));
                if (c.__webglFaceCount = 3 * i, c.__webglLineCount = 2 * j, k.attributes) {
                    c.__webglCustomAttributesList === e && (c.__webglCustomAttributesList = []);
                    for (var q in k.attributes) {
                        var r = k.attributes[q],
                        s = {};
                        for (var t in r) s[t] = r[t];
                        if (!s.__webglInitialized || s.createUniqueBuffers) {
                            s.__webglInitialized = !0;
                            var u = 1;
                            "v2" === s.type ? u = 2 : "v3" === s.type ? u = 3 : "v4" === s.type ? u = 4 : "c" === s.type && (u = 3),
                            s.size = u,
                            s.array = new Float32Array(h * u),
                            s.buffer = _gl.createBuffer(),
                            s.buffer.belongsToAttribute = q,
                            r.needsUpdate = !0,
                            s.__original = r
                        }
                        c.__webglCustomAttributesList.push(s)
                    }
                }
                c.__inittedArrays = !0
            }
        },
        createLineBuffers: function(a) {
            null == this.lineMap[a._id] && (this.lineMap[a._id] = {});
            var b = this.lineMap[a._id],
            c = this._gl;
            b.__webglVertexBuffer = c.createBuffer(),
            b.__webglColorBuffer = c.createBuffer(),
            b.__webglLineDistanceBuffer = c.createBuffer(),
            this.info.memory.geometries++
        },
        initLineBuffers: function(a) {
            null == this.lineMap[a._id] && (this.lineMap[a._id] = {});
            var b = this.lineMap[a._id],
            c = a.vertices.length;
            b.__vertexArray = new Float32Array(3 * c),
            b.__colorArray = new Float32Array(3 * c),
            b.__lineDistanceArray = new Float32Array(1 * c),
            b.__webglLineCount = c
        },
        createParticleBuffers: function(a) {
            null == this.particleMap[a._id] && (this.particleMap[a._id] = {});
            var b = this.particleMap[a._id],
            c = this._gl;
            b.__webglVertexBuffer = c.createBuffer(),
            b.__webglColorBuffer = c.createBuffer(),
            this.info.memory.geometries++
        },
        initParticleBuffers: function(a) {
            null == this.particleMap[a._id] && (this.particleMap[a._id] = {});
            var b = this.particleMap[a._id],
            c = a.vertices.length;
            b.__vertexArray = new Float32Array(3 * c),
            b.__colorArray = new Float32Array(3 * c),
            b.__sortArray = [],
            b.__webglParticleCount = c
        },
        createGroupBuffer: function(a, b) {
            var c = this._gl;
            b.__webglVertexBuffer = c.createBuffer(),
            b.__webglNormalBuffer = c.createBuffer(),
            b.__webglTangentBuffer = c.createBuffer(),
            b.__webglColorBuffer = c.createBuffer(),
            b.__webglUVBuffer = c.createBuffer(),
            b.__webglUV2Buffer = c.createBuffer(),
            b.__webglSkinIndicesBuffer = c.createBuffer(),
            b.__webglSkinWeightsBuffer = c.createBuffer(),
            b.__webglFaceBuffer = c.createBuffer(),
            b.__webglLineBuffer = c.createBuffer(),
            this.info.memory.geometries++
        },
        setRenderTarget: function(a) {
            var b = a instanceof yc,
            c = this._gl;
            if (a && !a.__webglFramebuffer) {
                a.depthBuffer === e && (a.depthBuffer = !0),
                a.stencilBuffer === e && (a.stencilBuffer = !0),
                a.__webglTexture = c.createTexture(),
                this.info.memory.textures++;
                var d = tc.isPowerOfTwo,
                f = d(a.width) && d(a.height),
                g = tc.paramToGL(a.format, c),
                h = tc.paramToGL(a.type, c);
                a.type == Yb.FloatType;
                var i = g;
                if (b) {
                    a.__webglFramebuffer = [],
                    a.__webglRenderbuffer = [],
                    c.bindTexture(c.TEXTURE_CUBE_MAP, a.__webglTexture),
                    this.pm.setTextureParameters(c.TEXTURE_CUBE_MAP, a, f);
                    for (var j = 0; 6 > j; j++) a.__webglFramebuffer[j] = c.createFramebuffer(),
                    a.__webglRenderbuffer[j] = c.createRenderbuffer(),
                    c.texImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, i, a.width, a.height, 0, g, h, null),
                    this.setupFrameBuffer(a.__webglFramebuffer[j], a, c.TEXTURE_CUBE_MAP_POSITIVE_X + j),
                    this.setupRenderBuffer(a.__webglRenderbuffer[j], a);
                    f && c.generateMipmap(c.TEXTURE_CUBE_MAP)
                } else a.__webglFramebuffer = c.createFramebuffer(),
                a.shareDepthFrom ? a.__webglRenderbuffer = a.shareDepthFrom.__webglRenderbuffer: a.__webglRenderbuffer = c.createRenderbuffer(),
                c.bindTexture(c.TEXTURE_2D, a.__webglTexture),
                this.pm.setTextureParameters(c.TEXTURE_2D, a, f),
                c.texImage2D(c.TEXTURE_2D, 0, i, a.width, a.height, 0, g, h, null),
                this.setupFrameBuffer(a.__webglFramebuffer, a, c.TEXTURE_2D),
                a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_ATTACHMENT, c.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_STENCIL_ATTACHMENT, c.RENDERBUFFER, a.__webglRenderbuffer) : this.setupRenderBuffer(a.__webglRenderbuffer, a),
                f && c.generateMipmap(c.TEXTURE_2D);
                b ? c.bindTexture(c.TEXTURE_CUBE_MAP, null) : c.bindTexture(c.TEXTURE_2D, null),
                c.bindRenderbuffer(c.RENDERBUFFER, null),
                c.bindFramebuffer(c.FRAMEBUFFER, null)
            }
            var k, l, m, n, o;
            a ? (k = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, l = a.width, m = a.height, n = 0, o = 0) : (k = null, l = this._viewportWidth, m = this._viewportHeight, n = this._viewportX, o = this._viewportY),
            k !== this._currentFramebuffer && (c.bindFramebuffer(c.FRAMEBUFFER, k), c.viewport(n, o, l, m), this._currentFramebuffer = k),
            this._currentWidth = l,
            this._currentHeight = m
        },
        setupFrameBuffer: function(a, b, c) {
            var d = this._gl;
            d.bindFramebuffer(d.FRAMEBUFFER, a),
            d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, c, b.__webglTexture, 0)
        },
        setupRenderBuffer: function(a, b) {
            var c = this._gl;
            c.bindRenderbuffer(c.RENDERBUFFER, a),
            b.depthBuffer && !b.stencilBuffer ? (c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_COMPONENT16, b.width, b.height), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_ATTACHMENT, c.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, b.width, b.height), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_STENCIL_ATTACHMENT, c.RENDERBUFFER, a)) : c.renderbufferStorage(c.RENDERBUFFER, c.RGBA4, b.width, b.height)
        },
        setLineWidth: function(a) {
            a !== this._oldLineWidth && (this._gl.lineWidth && this._gl.lineWidth(a), this._oldLineWidth = a)
        },
        setupMatrices: function(a, b) {
            a.fixSize(b),
            a.updateWorldMatrix(),
            a._modelViewMatrix.multiplyMatrices(b.worldMatrixInverse, a.worldMatrix),
            a._normalMatrix.getNormalMatrix(a._modelViewMatrix)
        },
        setDefaultGLState: function() {
            var a = this._gl,
            b = new Yb.Color(this._clearColor);
            a.clearColor(b.r, b.g, b.b, this._clearAlpha),
            a.clearDepth(1),
            cc.isIE || a.clearStencil(0),
            a.enable(a.DEPTH_TEST),
            a.depthFunc(a.LEQUAL),
            a.frontFace(a.CCW),
            a.cullFace(a.BACK),
            a.enable(a.CULL_FACE),
            a.enable(a.BLEND),
            a.blendEquation(a.FUNC_ADD),
            a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA)
        },
        clear: function(a, b, c) {
            var d = this._gl,
            f = 0; (a === e || a) && (f |= d.COLOR_BUFFER_BIT),
            (b === e || b) && (f |= d.DEPTH_BUFFER_BIT),
            (c === e || c) && (f |= d.STENCIL_BUFFER_BIT),
            d.clear(f)
        },
        setGLFaces: function(a) {
            var b = this._gl,
            c = a.side === Yb.DoubleSide,
            d = a.side === Yb.BackSide;
            this._oldDoubleSided !== c && (c ? b.disable(b.CULL_FACE) : b.enable(b.CULL_FACE), this._oldDoubleSided = c),
            this._oldFlipSided !== d && (d ? b.frontFace(b.CW) : b.frontFace(b.CCW), this._oldFlipSided = d)
        },
        getView: function() {
            return this._canvas
        },
        getRootView: function() {
            return this._rootView
        },
        setBlending: function(a, b, c, d) {
            wc.setBlending(a, b, c, d, this)
        },
        setDepthTest: function(a) {
            wc.setDepthTest(a, this)
        },
        setStencilTest: function(a) {
            this._oldStencilTest != a && (a ? this._gl.enable(this._gl.STENCIL_TEST) : this._gl.disable(this._gl.STENCIL_TEST), this._oldStencilTest = a)
        },
        setDepthWrite: function(a) {
            wc.setDepthWrite(a, this)
        },
        getLineWidthRange: function() {
            var a = this._gl;
            return a.getParameter(a.ALIASED_LINE_WIDTH_RANGE)
        },
        setTexture: function(a, b) {
            this.pm.setTexture(a, b)
        },
        disableAttributes: function() {
            for (var a in this._enabledAttributes) this._enabledAttributes[a] && (this._gl.disableVertexAttribArray(a), this._enabledAttributes[a] = !1)
        },
        enableAttribute: function(a) {
            this._enabledAttributes[a] || (this._gl.enableVertexAttribArray(a), this._enabledAttributes[a] = !0)
        },
        adjustRootViewBounds: function(a, b) {
            var c = this._rootView;
            c.style.width = a + "px",
            c.style.height = b + "px"
        },
        adjustCanvasBounds: function(a, b, c, d, e) {
            a.width = b * this.devicePixelRatio,
            a.height = c * this.devicePixelRatio,
            a.style.margin = "0px",
            a.style.padding = "0px",
            a.style.width = b + "px",
            a.style.height = c + "px"
        },
        adjustBounds: function(a, b, c, d) {
            var e = this.getView();
            if (this.adjustRootViewBounds(a, b, c, d), this.adjustCanvasBounds(e, a, b, c, d), this.adjustCanvasBounds(this._topCanvas, a, b, c, d), this.adjustCanvasBounds(this._bottomCanvas, a, b, c, d), this.adjustCallback(a, b, c, d), this.setViewport(0, 0, e.width, e.height), this.autoUpdateCameraAspect && 0 !== b) {
                var f = this._camera;
                f.aspect = a / b,
                f.updateProjectionMatrix(),
                this._currentCamera = null
            }
            this.dirtyNetwork()
        },
        adjustCallback: function() {},
        setViewport: function(a, b, c, d) {
            this._viewportX = a !== e ? a: 0,
            this._viewportY = b !== e ? b: 0,
            this._viewportWidth = c !== e ? c: _canvas.width,
            this._viewportHeight = d !== e ? d: _canvas.height,
            this._gl.viewport(this._viewportX, this._viewportY, this._viewportWidth, this._viewportHeight)
        },
        setShowAxis: function(a) {
            this.showAxis !== a && (this.showAxis = a, this.showAxis && (this.helperBox.contains(this.axis) || this.helperBox.addByDescendant(this.axis)), this.axis._visible = a, this.dirtyNetwork())
        },
        setShowAxisText: function(a) {
            this.axis.showAxisText(a),
            this.dirtyNetwork()
        },
        setAxisSize: function(a) {
            this.axis.setSize(a)
        },
        onSelect: function(a) {
            null != this.onSelectFunction && this.onSelectFunction(a)
        },
        setOnSelectFunction: function(a) {
            this.onSelectFunction = a
        },
        isSelectable: function(a) {
            return a.isSelectable() ? this.selectableFunction ? this.selectableFunction(a) : !0 : !1
        },
        setSelectableFunction: function(a) {
            this.selectableFunction = a
        },
        setRenderSelectFunction: function(a) {
            this.renderSelectFunction = a
        },
        renderSelect: function(a) {
            return this.renderSelectFunction ? this.renderSelectFunction(a) : !0
        },
        renderAlarmBorder: function(a) {
            return this.renderAlarmBorderFunction ? this.renderAlarmBorderFunction(a) : !0
        },
        selectable: function(a) {
            return a.element.isVisible() && this.isSelectable(a.element) && this.getDataBox().getSelectionModel().isSelectable(a.element)
        },
        editable: function(a) {
            var b = this.selectable(a);
            return b && null != this.editableFunction ? this.editableFunction(a.element) : b
        },
        getFirstSelectElement: function(a) {
            if (null == a) return null;
            for (var b, c = 0; c < a.length;) {
                var d = a[c];
                if (this.selectable(d)) {
                    b = d.element;
                    break
                }
                c++
            }
            return b
        },
        getFirstEditElement: function(a) {
            if (null == a) return null;
            for (var b, c = 0; c < a.length;) {
                var d = a[c];
                if (this.editable(d)) {
                    b = d.element;
                    break
                }
                c++
            }
            return b
        },
        toImageData: function(a, b, c, d) {
            return this.dirtyNetwork(),
            this.render(),
            a = a || "PNG",
            a.toUpperCase(),
            "PNG" === a ? dc.saveAsPNG(this.getView(), b, !1, c, d) : "JPEG" === a ? dc.saveAsJPEG(this.getView(), b, !1, c, d) : "BMP" === a ? dc.saveAsBMP(this.getView(), b, !1, c, d) : void console.log("Not surport type " + a)
        },
        getPickingByEvent: function(a) {
            var b = this._camera,
            c = {},
            d = this.getView(),
            e = d.getBoundingClientRect(),
            f = a.clientX,
            g = a.clientY;
            a.touches && a.touches.length && (f = a.touches[0].pageX, g = a.touches[0].pageY);
            var h = (f - e.left) / e.width,
            i = (g - e.top) / e.height;
            c.x = 2 * h - 1,
            c.y = 2 * -i + 1;
            var j = new Yb.Vec3(c.x, c.y, .5);
            this.projector.unprojectVector(j, b);
            var k = null;
            if (b instanceof Yb.PerspectiveCamera) k = new Yb.Picking(b._position, j.sub(b._position).normalize(), b.up, null, null, this);
            else {
                var l = j.clone().sub(b._position),
                m = b.getTarget().clone().sub(b.p()).normalize(),
                n = m.multiplyScalar(l.clone().dot(m)),
                o = l.sub(n),
                p = (new $b).addVectors(b._position, o);
                k = new Yb.Picking(p, j.sub(p).normalize(), b.up, null, null, this)
            }
            return k
        },
        getElementsByMouseEvent: function(a, b, c) {
            var d = this.getPickingByEvent(a),
            e = new kc;
            e.addAll(this.dataBox.getNodes()),
            e.addAll(this.dataBox.getBillboards()),
            c && e.addAll(new kc(this.alarmBillboards));
            var f = d.intersectObjects(e.toArray(), !1, b);
            return f
        },
        getElementByScreenPoint: function(a, b, c) {
            var d = {},
            e = this.getView(),
            f = this._camera,
            g = e.getBoundingClientRect();
            a.x && (c = b, b = a.y, a = a.x),
            a /= g.width,
            b /= g.height,
            d.x = 2 * a - 1,
            d.y = 2 * -b + 1;
            var h = new Yb.Vec3(d.x, d.y, .5);
            this.projector.unprojectVector(h, f);
            var i = new Yb.Picking(f._position, h.sub(f._position).normalize(), f.up, null, null, this),
            j = new kc;
            j.addAll(this.dataBox.getNodes()),
            j.addAll(this.dataBox.getBillboards());
            var k = i.intersectObjects(j.toArray(), !1, c);
            return k
        },
        getFirstElementByMouseEvent: function(a, b, c, d) {
            var e = this.getElementsByMouseEvent(a, b, d);
            if (e.length) for (var f = 0; f < e.length; f++) {
                var g = e[f],
                h = g.element;
                if (null == c || c.call(null, h)) return g
            }
            return null
        },
        getUnProjectVector: function(a) {
            var b = {},
            c = this.getView().getBoundingClientRect(),
            d = a.x / c.width,
            e = a.y / c.height;
            b.x = 2 * d - 1,
            b.y = 2 * -e + 1;
            var f = new Yb.Vec3(b.x, b.y, .5);
            return this.projector.unprojectVector(f, this._camera),
            f
        },
        getFrustumByBounding: function(a) {
            var b = a,
            c = this.getUnProjectVector(new Zb(b.x, b.y)),
            d = this.getUnProjectVector(new Zb(b.x + b.w, b.y)),
            e = this.getUnProjectVector(new Zb(b.x, b.y + b.h)),
            f = this.getUnProjectVector(new Zb(b.x + b.w, b.y + b.h)),
            g = this.getNearFarPoints(c),
            h = this.getNearFarPoints(d),
            i = this.getNearFarPoints(e),
            j = this.getNearFarPoints(f),
            k = new Yb.math.Plane,
            l = new Yb.math.Plane,
            m = new Yb.math.Plane,
            n = new Yb.math.Plane,
            o = new Yb.math.Plane,
            p = new Yb.math.Plane;
            k.setFromCoplanarPoints(g[0], h[0], i[0]),
            l.setFromCoplanarPoints(g[0], g[1], h[0]),
            m.setFromCoplanarPoints(g[0], i[0], g[1]),
            n.setFromCoplanarPoints(h[0], h[1], j[0]),
            o.setFromCoplanarPoints(i[0], j[0], i[1]),
            p.setFromCoplanarPoints(g[1], i[1], h[1]);
            var q = new Yb.Frustum(k, l, m, n, o, p);
            return q.setPoints([g[0], h[0], i[0], j[0], g[1], h[1], i[1], j[1]]),
            q
        },
        getNearFarPoints: function(a) {
            var b = this._camera,
            c = a.sub(b._position).normalize(),
            d = b.target.clone().sub(b._position),
            e = c.angleTo(d),
            f = b.getNear() / Math.acos(e),
            g = b.getFar() / Math.acos(e),
            h = b._position.clone().add(c.clone().multiplyScalar(f)),
            i = b._position.clone().add(c.clone().multiplyScalar(g));
            return [h, i]
        },
        getSpacePointOnPlane: function(a, b) {
            var c = {},
            d = this.getView(),
            e = this._camera,
            f = d.getBoundingClientRect(),
            g = a.clientX,
            h = a.clientY;
            a.touches && a.touches.length && (g = a.touches[0].pageX, h = a.touches[0].pageY);
            var i = (g - f.left) / f.width,
            j = (h - f.top) / f.height;
            c.x = 2 * i - 1,
            c.y = 2 * -j + 1;
            var k = new Yb.Vec3(c.x, c.y, .5);
            this.projector.unprojectVector(k, e);
            var l = e._position,
            m = k.sub(e._position).normalize(),
            n = new Yb.Ray(l, m),
            o = n.distanceToPlane(b);
            if (0 > o || Math.abs(o) < Yb.Picking.prototype.precision) return null;
            var p = n.at(o);
            return p
        },
        getElementsByBounding: function(a, b, c) {
            var d = new kc;
            d.addAll(this.dataBox.getNodes()),
            d.addAll(this.dataBox.getBillboards());
            var e, f = this.getFrustumByBounding(a),
            g = [],
            h = new $b,
            i = this._camera;
            return d.forEach(function(a) {
                if (a instanceof Yb.Billboard) {
                    h.setFromMatrixPosition(a.worldMatrix);
                    var b = a.material,
                    d = b.alignment;
                    e = new Yb.Plane(1, 1),
                    (d.x || d.y) && (e.setPosition(d.x, d.y, 0), e = Yb.Utils.transformElement(e, !0)),
                    e.setPosition(h);
                    var j = (new $b).getScaleFromMatrix(a.worldMatrix);
                    e.setScale(j.x, j.y, 1);
                    var k = i.getTarget().clone(),
                    l = i.getPosition();
                    k.sub(l);
                    var m = e.getPosition().clone();
                    b && b.vertical && (k.y = 0),
                    m.sub(k),
                    e.lookAt(m),
                    e.updateWorldMatrix(!0),
                    f.intersectsObjectAccurate(e, c) && g.push({
                        element: a
                    })
                } else a instanceof Yb.Line ? f.intersectsObjectAccurate(a, c) && g.push({
                    element: a
                }) : f.intersectsObjectAccurate(a, c) && g.push({
                    element: a
                })
            }),
            g
        },
        getViewPosition: function(a) {
            var b = new $b;
            b = this.projector.projectVector(a, this._camera, b),
            b.x = b.x / 2 + .5,
            b.y = -b.y / 2 + .5;
            var c = {
                x: this._canvas.width * b.x / this.devicePixelRatio,
                y: this._canvas.height * b.y / this.devicePixelRatio,
                h: this._canvas.height
            };
            return c
        },
        setInteractions: function(a) {
            var b, c, d = this._interactions;
            if (d) for (b = 0; b < d.length; b++) c = d[b],
            c.tearDown();
            if (this._interactions = a, a) for (b = 0; b < a.length; b++) c = a[b],
            c.setUp()
        },
        getDefaultInteraction: function() {
            if (this._interactions && this._interactions.length > 0) for (var a = 0; a < this._interactions.length; a++) {
                var b = this._interactions[a];
                if (b instanceof Yb.DefaultInteraction) return b
            }
            return null
        },
        getInteractions: function() {
            return this._interactions
        },
        fireInteractionEvent: function(a) {
            this._interactionDispatcher.fire(a)
        },
        addInteractionListener: function(a, b, c) {
            this._interactionDispatcher.add(a, b, c)
        },
        removeInteractionListener: function(a, b) {
            this._interactionDispatcher.remove(a, b)
        },
        dispose: function() {},
        setRenderInterval: function(a) { (tc.isNaN(a) || 5 >= a) && (a = 5),
            this._renderInterval = a
        },
        _computeNetworkBoundingBox: function() {
            function a(a, b) {
                a.applyMatrix4(b),
                h.push(a)
            }
            var b, c, d, e, f = this.getDataBox().size(),
            g = this.getDataBox().getDatas(),
            h = [];
            for (b = 0; f > b; b++) if (c = g.get(b), c instanceof Yb.Node) {
                d = c.getBoundingBox(),
                e = c.worldMatrix;
                var i = d.min,
                j = d.max;
                a(i.clone(), e),
                a(j.clone(), e),
                a(new $b(i.x, i.y, j.z), e),
                a(new $b(i.x, j.y, i.z), e),
                a(new $b(j.x, i.y, i.z), e),
                a(new $b(j.x, j.y, i.z), e),
                a(new $b(j.x, i.y, j.z), e),
                a(new $b(i.x, j.y, j.z), e)
            }
            if (h.length <= 1) return null;
            var k = new Yb.BoundingBox;
            return k.setFromPoints(h),
            k
        },
        getNetworkBoundingBox: function() {
            return null == this.boundingBox && (this.boundingBox = this._computeNetworkBoundingBox()),
            this.boundingBox
        },
        getSelectStyle: function(a) {
            return a.getSelectStyle()
        },
        setZoomStandard: function(a) {
            this._zoomStandard = a
        },
        getZoomStandard: function() {
            return this._zoomStandard
        },
        zoom: function(a, b) {
            b = b || this._zoomStandard;
            var c = this._camera;
            c.zoom(a, b)
        },
        zoomIn: function(a) {
            this.zoom(.9, a)
        },
        zoomOut: function(a) {
            this.zoom(1.1, a)
        },
        move: function(a, b) {
            var c = (new mono.Vec3( - a, -b, 0), this._camera.t()),
            d = this._camera.p();
            this._camera.translateX( - a),
            this._camera.translateY( - b);
            var e = this._camera.p();
            c.add(e.clone().sub(d)),
            this._camera.lookAt(c)
        },
        moveLeft: function(a) {
            a = a || 50,
            this.move( - a, 0)
        },
        moveRight: function(a) {
            a = a || 50,
            this.move(a, 0)
        },
        moveUp: function(a) {
            a = a || 30,
            this.move(0, a)
        },
        moveDown: function(a) {
            a = a || 30,
            this.move(0, -a)
        },
        zoomEstimateOverview: function(a) {
            var b = this.getNetworkBoundingBox();
            if (null != b) {
                var c = b.center(),
                d = new $b(0, b.max.y - b.min.y, b.max.z - b.min.z),
                e = new $b(b.max.x - b.min.x, 0, 0, 0),
                f = d.clone();
                f.length() < e.length() && (f = e.clone());
                var g;
                if (a) {
                    var h = d.length();
                    d.y = d.z * Math.tan(a / 180 * Math.PI),
                    d.setLength(h)
                }
                g = (new $b).addVectors(c, d.multiplyScalar(.5));
                var i = this._camera.fov,
                j = (this._camera.aspect, f.length() / 2 / Math.tan(i * Math.PI / 180));
                g.add(d.normalize().multiplyScalar(j)),
                this._camera.setPosition(g),
                this._camera.lookAt(c),
                this._overviewDistance = this._camera.getDistance()
            }
        }
    }),
    Yb.Network3DId = 0,
    Yb.Network3D.GroupCache = {
        _groupCounter: 0
    };
    var zc = function() {
        function a() {
            if (k === w) {
                var a = new $RenderObject;
                return v.push(a),
                w++,
                k++,
                a
            }
            return v[k++]
        }
        function b() {
            if (m === y) {
                var a = new $RenderVertex;
                return x.push(a),
                y++,
                m++,
                a
            }
            return x[m++]
        }
        function c() {
            if (o === A) {
                var a = new Yb.RenderFace3;
                return z.push(a),
                A++,
                o++,
                a
            }
            return z[o++]
        }
        function d() {
            if (p === C) {
                var a = new Yb.RenderFace4;
                return B.push(a),
                C++,
                p++,
                a
            }
            return B[p++]
        }
        function f() {
            if (r === E) {
                var a = new Yb.RenderLine;
                return D.push(a),
                E++,
                r++,
                a
            }
            return D[r++]
        }
        function g() {
            if (t === G) {
                var a = new Yb.RenderableParticle;
                return F.push(a),
                G++,
                t++,
                a
            }
            return F[t++]
        }
        function h(a, b) {
            return b.z - a.z
        }
        function i(a, b) {
            var c = 0,
            d = 1,
            e = a.z + a.w,
            f = b.z + b.w,
            g = -a.z + a.w,
            h = -b.z + b.w;
            return e >= 0 && f >= 0 && g >= 0 && h >= 0 ? !0 : 0 > e && 0 > f || 0 > g && 0 > h ? !1 : (0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f))), 0 > g ? c = Math.max(c, g / (g - h)) : 0 > h && (d = Math.min(d, g / (g - h))), c > d ? !1 : (a.lerp(b, c), b.lerp(a, 1 - d), !0))
        }
        var j, k, l, m, n, o, p, q, r, s, t, u, v = [],
        w = 0,
        x = [],
        y = 0,
        z = [],
        A = 0,
        B = [],
        C = 0,
        D = [],
        E = 0,
        F = [],
        G = 0,
        H = {
            objects: [],
            sprites: [],
            lights: [],
            elements: []
        },
        I = new Yb.Vec3,
        J = new Yb.Vec4,
        K = new Yb.BoundingBox(new Yb.Vec3( - 1, -1, -1), new Yb.Vec3(1, 1, 1)),
        L = new Yb.BoundingBox,
        M = new Array(3),
        N = new Array(4),
        O = new Yb.Mat4,
        P = new Yb.Mat4,
        Q = new Yb.Mat4,
        R = new Yb.Mat3,
        S = new Yb.Mat3,
        T = new Yb.Vec3,
        U = new Yb.Frustum,
        V = new Yb.Vec4,
        W = new Yb.Vec4;
        this.projectVector = function(a, b, c) {
            return b.worldMatrixInverse.getInverse(b.worldMatrix),
            P.multiplyMatrices(b.projectionMatrix, b.worldMatrixInverse),
            c === e ? a.applyProjection(P) : (c.copy(a), c.applyProjection(P))
        },
        this.unprojectVector = function(a, b) {
            return b.projectionMatrixInverse.getInverse(b.projectionMatrix),
            P.multiplyMatrices(b.worldMatrix, b.projectionMatrixInverse),
            a.applyProjection(P)
        },
        this.pickingRay = function(a, b) {
            a.z = -1;
            var c = new Yb.Vec3(a.x, a.y, 1);
            return this.unprojectVector(a, b),
            this.unprojectVector(c, b),
            c.sub(a).normalize(),
            new Yb.Picking(a, c)
        };
        var X = function(b, c) {
            k = 0,
            H.objects.length = 0,
            H.sprites.length = 0,
            H.lights.length = 0;
            var d = function(b) {
                var c;
                c = b instanceof Yb.DataBox ? b.getRoots() : b.getChildren(),
                c = c.toList();
                for (var e = 0,
                f = c.size(); f > e; e++) {
                    var g = c.get(e);
                    g.isSelected() && g instanceof Yb.Node && (c.add(g.createCanvasSelectionCube(), e), e++)
                }
                for (var e = 0,
                f = c.size(); f > e; e++) {
                    var g = c.get(e);
                    g._visible !== !1 && (g instanceof Yb.Light ? H.lights.push(g) : g instanceof Yb.Entity || g instanceof Yb.Line ? (g.frustumCulled === !1 || U.intersectsObject(g) === !0) && (j = a(), j.object = g, null !== g.renderDepth ? j.z = g.renderDepth: (I.copy(g.worldMatrix.getPosition()), I.applyProjection(P), j.z = I.z), H.objects.push(j)) : g instanceof Yb.Billboard || g instanceof Yb.Particle ? (j = a(), j.object = g, null !== g.renderDepth ? j.z = g.renderDepth: (I.copy(g.worldMatrix.getPosition()), I.applyProjection(P), j.z = I.z), H.sprites.push(j)) : (j = a(), j.object = g, null !== g.renderDepth ? j.z = g.renderDepth: (I.copy(g.worldMatrix.getPosition()), I.applyProjection(P), j.z = I.z), H.objects.push(j)), d(g))
                }
            };
            return d(b),
            c === !0 && H.objects.sort(h),
            H
        };
        this.projectDataBox = function(a, j, k, v) {
            var w, y, z, A, B, C, D, E, F, G, I, Y, Z, $, _, aa, ba, ca, da, ea, fa, ga, ha, ia = !1;
            o = 0,
            p = 0,
            r = 0,
            t = 0,
            H.elements.length = 0;
            for (var ja = 0; ja < a.getRoots().size(); ja++) {
                var ka = a.getRoots().get(ja);
                ka.updateWorldMatrix()
            }
            for (j.parent === e && j.updateWorldMatrix(!0, !1), O.copy(j.worldMatrixInverse.getInverse(j.worldMatrix)), P.multiplyMatrices(j.projectionMatrix, O), S.getInverse(O), S.transpose(), U.setFromMatrix(P), H = X(a, k), w = 0, y = H.objects.length; y > w; w++) if (I = H.objects[w].object, u = I.worldMatrix, m = 0, I instanceof Yb.Entity) {
                for (Y = I, Z = Y.vertices, $ = Y.faces, ba = Y.uvs, R.getInverse(u), R.transpose(), ga = I.material instanceof Yb.ArrayMaterial, ha = ga === !0 ? I.material: null, z = 0, A = Z.length; A > z; z++) l = b(),
                l.positionWorld.copy(Z[z]).applyMatrix4(u),
                l.positionScreen.copy(l.positionWorld).applyMatrix4(P),
                l.positionScreen.x /= l.positionScreen.w,
                l.positionScreen.y /= l.positionScreen.w,
                l.positionScreen.z /= l.positionScreen.w,
                l.visible = !(l.positionScreen.x < -1 || l.positionScreen.x > 1 || l.positionScreen.y < -1 || l.positionScreen.y > 1 || l.positionScreen.z < -1 || l.positionScreen.z > 1);
                for (B = 0, C = $.length; C > B; B++) {
                    _ = $[B];
                    var la = ga === !0 ? ha.materials[_.materialIndex] : I.material;
                    if (la !== e) {
                        var ma = la.side;
                        if (_ instanceof Yb.Face3) {
                            if (ca = x[_.a], da = x[_.b], ea = x[_.c], M[0] = ca.positionScreen, M[1] = da.positionScreen, M[2] = ea.positionScreen, ca.visible !== !0 && da.visible !== !0 && ea.visible !== !0 && !K.isIntersectionBox(L.setFromPoints(M))) continue;
                            if (ia = (ea.positionScreen.x - ca.positionScreen.x) * (da.positionScreen.y - ca.positionScreen.y) - (ea.positionScreen.y - ca.positionScreen.y) * (da.positionScreen.x - ca.positionScreen.x) < 0, ma !== Yb.DoubleSide && ia !== (ma === Yb.FrontSide)) continue;
                            n = c(),
                            n.v1.copy(ca),
                            n.v2.copy(da),
                            n.v3.copy(ea)
                        } else if (_ instanceof Yb.Face4) {
                            if (ca = x[_.a], da = x[_.b], ea = x[_.c], fa = x[_.d], N[0] = ca.positionScreen, N[1] = da.positionScreen, N[2] = ea.positionScreen, N[3] = fa.positionScreen, ca.visible !== !0 && da.visible !== !0 && ea.visible !== !0 && fa.visible !== !0 && !K.isIntersectionBox(L.setFromPoints(N))) continue;
                            if (ia = (fa.positionScreen.x - ca.positionScreen.x) * (da.positionScreen.y - ca.positionScreen.y) - (fa.positionScreen.y - ca.positionScreen.y) * (da.positionScreen.x - ca.positionScreen.x) < 0 || (da.positionScreen.x - ea.positionScreen.x) * (fa.positionScreen.y - ea.positionScreen.y) - (da.positionScreen.y - ea.positionScreen.y) * (fa.positionScreen.x - ea.positionScreen.x) < 0, ma !== Yb.DoubleSide && ia !== (ma === Yb.FrontSide)) continue;
                            n = d(),
                            n.v1.copy(ca),
                            n.v2.copy(da),
                            n.v3.copy(ea),
                            n.v4.copy(fa)
                        }
                        for (n.normalModel.copy(_.normal), ia === !1 && (ma === Yb.BackSide || ma === Yb.DoubleSide) && n.normalModel.negate(), n.normalModel.applyMatrix3(R).normalize(), n.normalModelView.copy(n.normalModel).applyMatrix3(S), n.centroidModel.copy(_.centroid).applyMatrix4(u), aa = _.vertexNormals, D = 0, E = aa.length; E > D; D++) {
                            var na = n.vertexNormalsModel[D];
                            na.copy(aa[D]),
                            ia === !1 && (ma === Yb.BackSide || ma === Yb.DoubleSide) && na.negate(),
                            na.applyMatrix3(R).normalize();
                            var oa = n.vertexNormalsModelView[D];
                            oa.copy(na).applyMatrix3(S)
                        }
                        n.vertexNormalsLength = aa.length;
                        var pa = ba[B];
                        for (F = 0, G = pa.length; G > F; F++) n.uvs[0][F] = pa[F];
                        n.color = _.color,
                        n.material = la,
                        T.copy(n.centroidModel).applyProjection(P),
                        n.z = T.z,
                        H.elements.push(n)
                    }
                }
            } else if (I instanceof Yb.Line) {
                Q.multiplyMatrices(P, u),
                Z = I.vertices,
                ca = b(),
                ca.positionScreen.copy(Z[0]).applyMatrix4(Q);
                var qa = I.type === Yb.LinePieces ? 2 : 1;
                for (z = 1, A = Z.length; A > z; z++) ca = b(),
                ca.positionScreen.copy(Z[z]).applyMatrix4(Q),
                (z + 1) % qa > 0 || (da = x[m - 2], V.copy(ca.positionScreen), W.copy(da.positionScreen), i(V, W) === !0 && (V.multiplyScalar(1 / V.w), W.multiplyScalar(1 / W.w), q = f(), q.v1.positionScreen.copy(V), q.v2.positionScreen.copy(W), q.z = Math.max(V.z, W.z), q.material = I.material, H.elements.push(q)))
            }
            for (w = 0, y = H.sprites.length; y > w; w++) I = H.sprites[w].object,
            u = I.worldMatrix,
            I instanceof Yb.Particle && (J.set(u.elements[12], u.elements[13], u.elements[14], 1), J.applyMatrix4(P), J.z /= J.w, J.z > 0 && J.z < 1 && (s = g(), s.object = I, s.x = J.x / J.w, s.y = J.y / J.w, s.z = J.z, s.rotation = I.rotation.z, s.scale.x = I.scale.x * Math.abs(s.x - (J.x + j.projectionMatrix.elements[0]) / (J.w + j.projectionMatrix.elements[12])), s.scale.y = I.scale.y * Math.abs(s.y - (J.y + j.projectionMatrix.elements[5]) / (J.w + j.projectionMatrix.elements[13])), s.material = I.material, H.elements.push(s)));
            return v === !0 && H.elements.sort(h),
            H
        }
    };
    Yb.Projector = zc,
    Yb.Billboard = function(a) {
        null != a && null != a.id ? this._id = a.id: this._id = a,
        Yb.Element.call(this, this._id),
        this.material = new Yb.BillboardMaterial,
        this.rotation3d = this._rotation,
        this.rotation = 0,
        this.vertices = [new $b( - .5, -.5, 0), new $b(.5, -.5, 0), new $b(.5, .5, 0), new $b( - .5, .5, 0)]
    },
    Yb.extend(Yb.Billboard, Yb.Element, {
        constructor: Yb.Billboard,
        className: "TGL.Billboard",
        updateMatrix: function() {
            this.matrix.setPosition(this._position),
            this.rotation = this._rotation.z,
            this.rotation3d.set(0, 0, this.rotation),
            this.matrix.setRotationFromEuler(this.rotation3d),
            (1 !== this._scale.x || 1 !== this._scale.y) && this.matrix.scale(this._scale),
            this.matrixWorldNeedsUpdate = !0
        },
        clone: function(a) {
            return a === e && (a = new Yb.Billboard(this.material)),
            Yb.Element.prototype.clone.call(this, a),
            a
        },
        setMaterialStyle: function(a, b) {
            var c = this.material.clone();
            a = a.substr(a.indexOf(".") + 1),
            this._A97(c, a, b);
            var d = c.getUniqueCode(),
            e = $c.getMaterial(d);
            null != e ? ($c.unUseMaterial(this.material), this.material = e, $c.useMaterial(e)) : ($c.unUseMaterial(this.material), $c.setMaterial(d, c), this.material = c)
        }
    }),
    Yb.ShaderSprite = {
        sprite: {
            vertexShader: ["uniform int useScreenCoordinates;", "uniform int sizeAttenuation;", "uniform vec3 screenPosition;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 alignment;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "uniform bool vertical;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = (position + alignment) * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "vec4 upPosition;", "vec4 rightPosition = vec4(scale.x,0.0,0.0,1.0);", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "if(vertical){", "upPosition =  modelViewMatrix * vec4( 0.0, 1.0, 0.0, 1.0 ) - finalPosition;", "normalize(upPosition);", "}", "if(vertical){", "finalPosition.xyz += (rotatedPosition.x * rightPosition.xyz / scale.x) + (rotatedPosition.y * upPosition.xyz / scale.y);", "}else{", "finalPosition.xy += rotatedPosition;", "}", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n"),
            fragmentShader: ["uniform vec3 color;", "uniform int useMap;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "if(useMap > 0){", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "} else {", "gl_FragColor = vec4( color, 1.0);", "}", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")
        }
    },
    Yb.BillboardRenderer = function() {
        function a(a, c) {
            var d = b.createProgram(),
            e = b.createShader(b.FRAGMENT_SHADER),
            f = b.createShader(b.VERTEX_SHADER),
            g = "precision " + c + " float;\n";
            return b.shaderSource(e, g + a.fragmentShader),
            b.shaderSource(f, g + a.vertexShader),
            b.compileShader(e),
            b.compileShader(f),
            b.attachShader(d, e),
            b.attachShader(d, f),
            b.linkProgram(d),
            d
        }
        var b, c, d, e = {},
        f = (new Yb.Billboard, new Yb.BillboardMaterial({
            color: 255
        }));
        this.init = function(f) {
            this.enable = !0,
            f._currentGroupHash = null,
            b = f._gl,
            c = f,
            d = f.getPrecision(),
            e.vertices = new Float32Array(16),
            e.faces = new Uint16Array(6),
            e.lines = new Uint16Array(8);
            var g = 0;
            e.vertices[g++] = -.5,
            e.vertices[g++] = -.5,
            e.vertices[g++] = 0,
            e.vertices[g++] = 0,
            e.vertices[g++] = .5,
            e.vertices[g++] = -.5,
            e.vertices[g++] = 1,
            e.vertices[g++] = 0,
            e.vertices[g++] = .5,
            e.vertices[g++] = .5,
            e.vertices[g++] = 1,
            e.vertices[g++] = 1,
            e.vertices[g++] = -.5,
            e.vertices[g++] = .5,
            e.vertices[g++] = 0,
            e.vertices[g++] = 1,
            g = 0,
            e.faces[g++] = 0,
            e.faces[g++] = 1,
            e.faces[g++] = 2,
            e.faces[g++] = 0,
            e.faces[g++] = 2,
            e.faces[g++] = 3,
            g = 0,
            e.lines[g++] = 0,
            e.lines[g++] = 1,
            e.lines[g++] = 0,
            e.lines[g++] = 3,
            e.lines[g++] = 1,
            e.lines[g++] = 2,
            e.lines[g++] = 2,
            e.lines[g++] = 3,
            e.vertexBuffer = b.createBuffer(),
            e.elementBuffer = b.createBuffer(),
            b.bindBuffer(b.ARRAY_BUFFER, e.vertexBuffer),
            b.bufferData(b.ARRAY_BUFFER, e.vertices, b.STATIC_DRAW),
            b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, e.elementBuffer),
            b.bufferData(b.ELEMENT_ARRAY_BUFFER, e.faces, b.STATIC_DRAW),
            e.program = a(Yb.ShaderSprite.sprite, d),
            e.attributes = {},
            e.uniforms = {},
            e.attributes.position = b.getAttribLocation(e.program, "position"),
            e.attributes.uv = b.getAttribLocation(e.program, "uv"),
            e.uniforms.uvOffset = b.getUniformLocation(e.program, "uvOffset"),
            e.uniforms.uvScale = b.getUniformLocation(e.program, "uvScale"),
            e.uniforms.rotation = b.getUniformLocation(e.program, "rotation"),
            e.uniforms.scale = b.getUniformLocation(e.program, "scale"),
            e.uniforms.alignment = b.getUniformLocation(e.program, "alignment"),
            e.uniforms.color = b.getUniformLocation(e.program, "color"),
            e.uniforms.useMap = b.getUniformLocation(e.program, "useMap"),
            e.uniforms.map = b.getUniformLocation(e.program, "map"),
            e.uniforms.opacity = b.getUniformLocation(e.program, "opacity"),
            e.uniforms.vertical = b.getUniformLocation(e.program, "vertical"),
            e.uniforms.useScreenCoordinates = b.getUniformLocation(e.program, "useScreenCoordinates"),
            e.uniforms.sizeAttenuation = b.getUniformLocation(e.program, "sizeAttenuation"),
            e.uniforms.screenPosition = b.getUniformLocation(e.program, "screenPosition"),
            e.uniforms.modelViewMatrix = b.getUniformLocation(e.program, "modelViewMatrix"),
            e.uniforms.projectionMatrix = b.getUniformLocation(e.program, "projectionMatrix"),
            e.uniforms.fogType = b.getUniformLocation(e.program, "fogType"),
            e.uniforms.fogDensity = b.getUniformLocation(e.program, "fogDensity"),
            e.uniforms.fogNear = b.getUniformLocation(e.program, "fogNear"),
            e.uniforms.fogFar = b.getUniformLocation(e.program, "fogFar"),
            e.uniforms.fogColor = b.getUniformLocation(e.program, "fogColor"),
            e.uniforms.alphaTest = b.getUniformLocation(e.program, "alphaTest"),
            this.inited = !0
        },
        this.render = function(a, d, g, h, i) {
            this.inited || this.init(a);
            var j = new kc(d),
            k = j.size();
            if (k) {
                var l = e.attributes,
                m = e.uniforms,
                n = !1;
                a.pm.currentProgram != e.program && (b.useProgram(e.program), a.pm.currentProgram = e.program, a._currentGroupHash = null, b.enableVertexAttribArray(l.position), b.enableVertexAttribArray(l.uv), b.disable(b.CULL_FACE), b.bindBuffer(b.ARRAY_BUFFER, e.vertexBuffer), b.vertexAttribPointer(l.position, 2, b.FLOAT, !1, 16, 0), b.vertexAttribPointer(l.uv, 2, b.FLOAT, !1, 16, 8), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, e.elementBuffer), this.enable = !0, n = !0),
                b.uniformMatrix4fv(m.projectionMatrix, !1, g.projectionMatrix.elements),
                n && b.activeTexture(b.TEXTURE0),
                n && b.uniform1i(m.map, 0);
                var o = 0,
                p = 0,
                q = a.fog;
                q ? (b.uniform3f(m.fogColor, q.color.r, q.color.g, q.color.b), q instanceof Yb.Fog ? (b.uniform1f(m.fogNear, q.near), b.uniform1f(m.fogFar, q.far), b.uniform1i(m.fogType, 1), o = 1, p = 1) : q instanceof Yb.FogExp2 && (b.uniform1f(m.fogDensity, q.density), b.uniform1i(m.fogType, 2), o = 2, p = 2)) : (o = 0, p = 0);
                var r, s, t;
                for (r = 0; k > r; r++) s = j.get(r),
                t = s.material,
                c.isVisible(s) && 0 !== t.opacity && (s.updateWorldMatrix(!0, !1), t.useScreenCoordinates ? s.z = -s.position.z: (s._modelViewMatrix = new Yb.Mat4, s._modelViewMatrix.multiplyMatrices(g.worldMatrixInverse, s.worldMatrix), s.z = -s._modelViewMatrix.elements[14]));
                for (r = 0; k > r; r++) s = j.get(r),
                this.renderBillboard(s, m, a, o, p),
                s._selected && (s._scale.x = 1.01 * s._scale.x, s._scale.y = 1.01 * s._scale.y, s.material.clone(f), f.map = null, f.color.set(65280), this.renderBillboard(s, m, a, o, p, f), s._scale.x = s._scale.x / 1.01, s._scale.y = s._scale.y / 1.01)
            }
        },
        this.disable = function() {
            if (this.enable) {
                var a = e.attributes;
                e.uniforms,
                b.disableVertexAttribArray(a.position),
                b.disableVertexAttribArray(a.uv),
                c._oldDoubleSided || b.enable(b.CULL_FACE),
                c._oldBlending === Yb.NoBlending && b.disable(b.BLEND),
                wc.setDepthWrite(!0, c),
                this.enable = !1,
                this.lastMaterialId = null,
                c.pm.currentProgram = null
            }
        },
        this.renderBillboard = function(a, d, f, g, h, i) {
            var j, k, l, m = [],
            n = new $b;
            if (j = i ? i: a.material, c.isVisible(a) && 0 !== j.opacity) {
                var o = j.id,
                p = o != this.lastMaterialId;
                p && b.uniform1f(d.alphaTest, j.alphaTest),
                p && (j.useScreenCoordinates === !0 ? (b.uniform1i(d.useScreenCoordinates, 1), b.uniform3f(d.screenPosition, (a.position.x * c.devicePixelRatio - halfViewportWidth) / halfViewportWidth, (halfViewportHeight - a.position.y * c.devicePixelRatio) / halfViewportHeight, Math.max(0, Math.min(1, a.position.z)))) : (b.uniform1i(d.useScreenCoordinates, 0), b.uniform1i(d.sizeAttenuation, j.sizeAttenuation ? 1 : 0))),
                j.useScreenCoordinates === !0 ? (m[0] = c.devicePixelRatio, m[1] = c.devicePixelRatio) : (b.uniformMatrix4fv(d.modelViewMatrix, !1, a._modelViewMatrix.elements), m[0] = 1, m[1] = 1),
                l = f.fog && j.fog ? h: 0,
                g !== l && (b.uniform1i(d.fogType, l), g = l),
                k = 1 / (j.scaleByViewport ? viewportHeight: 1),
                n.getScaleFromMatrix(a.worldMatrix),
                m[0] *= k * n.x,
                m[1] *= k * n.y,
                p && (b.uniform2f(d.uvScale, j.repeat.x, j.repeat.y), b.uniform2f(d.uvOffset, j.offset.x, j.offset.y), b.uniform2f(d.alignment, j.alignment.x, j.alignment.y), b.uniform1f(d.opacity, j.opacity), b.uniform1i(d.vertical, j.vertical), b.uniform3f(d.color, j.color.r, j.color.g, j.color.b), b.uniform1f(d.rotation, a.rotation)),
                b.uniform2fv(d.scale, m),
                p && (c.setBlending(j.blending, j.blendEquation, j.blendSrc, j.blendDst), c.setDepthTest(j.depthTest), c.setDepthWrite(j.depthMask)),
                j.map && j.map._image && c.pm.addTexture(j.map),
                p = p || j.map && c.pm.needsUpdateTexture(j.map),
                j.map && j.map._image && j.map._image.width ? (p && c.setTexture(j.map, 0), p && b.uniform1i(d.useMap, 1)) : p && b.uniform1i(d.useMap, 0),
                i ? (p && b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, e.elementBuffer), p && b.bufferData(b.ELEMENT_ARRAY_BUFFER, e.lines, b.STATIC_DRAW), p && b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, e.elementBuffer), b.drawElements(b.LINES, 8, b.UNSIGNED_SHORT, 0)) : (p && b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, e.elementBuffer), p && b.bufferData(b.ELEMENT_ARRAY_BUFFER, e.faces, b.STATIC_DRAW), p && b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, e.elementBuffer), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0)),
                this.lastMaterialId = j.id
            }
        }
    };
    var xc = function(a, b, c) {
        this.width = a,
        this.height = b,
        c = c || {},
        this.wrapS = c.wrapS !== e ? c.wrapS: Yb.ClampToEdgeWrapping,
        this.wrapT = c.wrapT !== e ? c.wrapT: Yb.ClampToEdgeWrapping,
        this.magFilter = c.magFilter !== e ? c.magFilter: Yb.LinearFilter,
        this.minFilter = c.minFilter !== e ? c.minFilter: Yb.LinearMipMapLinearFilter,
        this.anisotropy = c.anisotropy !== e ? c.anisotropy: 1,
        this.offset = new Yb.Vec2(0, 0),
        this.repeat = new Yb.Vec2(1, 1),
        this.format = c.format !== e ? c.format: Yb.RGBAFormat,
        this.type = c.type !== e ? c.type: Yb.UnsignedByteType,
        this.depthBuffer = c.depthBuffer !== e ? c.depthBuffer: !0,
        this.stencilBuffer = c.stencilBuffer !== e ? c.stencilBuffer: !0,
        this.generateMipmaps = !0,
        this.shareDepthFrom = null
    };
    xc.prototype = {
        constructor: xc,
        clone: function() {
            var a = new xc(this.width, this.height);
            return a.wrapS = this.wrapS,
            a.wrapT = this.wrapT,
            a.magFilter = this.magFilter,
            a.minFilter = this.minFilter,
            a.anisotropy = this.anisotropy,
            a.offset.copy(this.offset),
            a.repeat.copy(this.repeat),
            a.format = this.format,
            a.type = this.type,
            a.depthBuffer = this.depthBuffer,
            a.stencilBuffer = this.stencilBuffer,
            a.generateMipmaps = this.generateMipmaps,
            a.shareDepthFrom = this.shareDepthFrom,
            a
        },
        getUniqueCode: function() {
            return this._id
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    };
    var yc = function(a, b, c) {
        xc.call(this, a, b, c),
        this.activeCubeFace = 0
    };
    Yb.extend(yc, xc, {});
    var Ac, Bc = "l=1.0\ntype=1\ngis=0\n3d=1\nstart=2015-10-21\nend=2016-10-31\nnote=This license applies to the evaluation version of TWaver. The License is limited to noncommercial use. Noncommercial use relates only to educational, research, personal or evaluation purposes. Any other use is commercial use. You may not use the Software in connection with any business activities.And You are not permitted to modify the software or attempt to decipher, decompile, disassemble or reverse engineer this Software.\nsignature=69b57c46f9801b1ad4c0ec28e49fafd90df6bd4f63e42b019ff240736150c9a2070b4f2c7c1b2d94063a1402d811e757aa6aced3defef6ccafdf6f28b0dd4bc4e5ee9b033b9d9a12629329c76b5e22d608e561c8caa0dfeafb1cd9d1b1c988edf1b7a8d1d9520555f87e20626de98388c1bd30c0079ebacc6229b199648b774538a5abd45055658bcdf472770f1b7574d6ee17c0ec273ec2bcdd3053b24e7f547e93dbd4a180f9cd937541164297564dfa4d28ea4709ca165cbd515262976cc230459a86a7790be4f696b49f5b14e03b30abd94ca1f034c4376e1fad9ab7252c3e2930d2ac9383e84182683ac47ee29e109388c8165ea8001a0526dac643ac073edbb5038f065378dd77d69b22fc9716cc0a8c2adf4e090de8ebe24724d3a14ff73855193182c01cf7e5344e4400d9303f3e9a8d762862cab6ac4d8f37af59c1dcde69eb92a1b7b1a3493d63c1404b6f0c5c00975e9ab12daa68d7f4d3fe3b6863a72618ec0c6a6f6cb77a8476fd904cefcff326eaf2328c49b05c35898418ca2b974359d639f399a9a6f4cb14caf3af590753e67c52d44fed018fcb607a042ebecb4b6bb7d43ed364f76fbe47644c125e9cd97f393029e9cee49a910ae672041ec026ec55709c02662cccb62818dcd33e96a4c59d13995752636ae6ca2a7f961421adabf1277986ed03bdec170e1d00cb4c3668fb65bcc087996a7174163f63179507fc710fbf8697b7e8ddc5bbe5d54177a4dbe073ed1d90e6b842b42f04e6fd69f26a7dc3227f0189c21424b556ccdaa8d2b1829c35039670ea7663a8088220fffe99a530863fdff1ca18a468edd6adcc5a680e13c5a432096977d5b157ff5848f6bf464ca5dbf670f2cb090c3cbc4ccd8f8355b91505502e215b97646b86",
    Cc = 0xdeadbeefcafe,
    Dc = 15715070 == (16777215 & Cc);
    Dc && "Microsoft Internet Explorer" == navigator.appName ? (q.prototype.am = t, Ac = 30) : Dc && "Netscape" != navigator.appName ? (q.prototype.am = s, Ac = 26) : (q.prototype.am = v, Ac = 28),
    q.prototype.DB = Ac,
    q.prototype.DM = (1 << Ac) - 1,
    q.prototype.DV = 1 << Ac;
    var Ec = 52;
    q.prototype.FV = Math.pow(2, Ec),
    q.prototype.F1 = Ec - Ac,
    q.prototype.F2 = 2 * Ac - Ec;
    var Fc, Gc, Hc = "0123456789abcdefghijklmnopqrstuvwxyz",
    Ic = new Array;
    for (Fc = "0".charCodeAt(0), Gc = 0; 9 >= Gc; ++Gc) Ic[Fc++] = Gc;
    for (Fc = "a".charCodeAt(0), Gc = 10; 36 > Gc; ++Gc) Ic[Fc++] = Gc;
    for (Fc = "A".charCodeAt(0), Gc = 10; 36 > Gc; ++Gc) Ic[Fc++] = Gc;
    S.prototype.convert = T,
    S.prototype.revert = U,
    S.prototype.reduce = V,
    S.prototype.mulTo = W,
    S.prototype.sqrTo = X,
    Z.prototype.convert = $,
    Z.prototype.revert = _,
    Z.prototype.reduce = aa,
    Z.prototype.mulTo = ca,
    Z.prototype.sqrTo = ba,
    q.prototype.copyTo = y,
    q.prototype.fromInt = z,
    q.prototype.fromString = B,
    q.prototype.clamp = C,
    q.prototype.dlShiftTo = J,
    q.prototype.drShiftTo = K,
    q.prototype.lShiftTo = L,
    q.prototype.rShiftTo = M,
    q.prototype.subTo = N,
    q.prototype.multiplyTo = O,
    q.prototype.squareTo = P,
    q.prototype.divRemTo = Q,
    q.prototype.invDigit = Y,
    q.prototype.isEven = da,
    q.prototype.exp = ea,
    q.prototype.toString = D,
    q.prototype.negate = E,
    q.prototype.abs = F,
    q.prototype.compareTo = G,
    q.prototype.bitLength = I,
    q.prototype.mod = R,
    q.prototype.modPowInt = fa,
    q.ZERO = A(0),
    q.ONE = A(1),
    Ya.prototype.convert = Za,
    Ya.prototype.revert = Za,
    Ya.prototype.mulTo = $a,
    Ya.prototype.sqrTo = _a,
    db.prototype.convert = eb,
    db.prototype.revert = fb,
    db.prototype.reduce = gb,
    db.prototype.mulTo = ib,
    db.prototype.sqrTo = hb;
    var Jc = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
    Kc = (1 << 26) / Jc[Jc.length - 1];
    q.prototype.chunkSize = ka,
    q.prototype.toRadix = ma,
    q.prototype.fromRadix = na,
    q.prototype.fromNumber = oa,
    q.prototype.bitwiseTo = ta,
    q.prototype.changeBit = Ka,
    q.prototype.addTo = Oa,
    q.prototype.dMultiply = Wa,
    q.prototype.dAddOffset = Xa,
    q.prototype.multiplyLowerTo = bb,
    q.prototype.multiplyUpperTo = cb,
    q.prototype.modInt = lb,
    q.prototype.millerRabin = ob,
    q.prototype.clone = ga,
    q.prototype.intValue = ha,
    q.prototype.byteValue = ia,
    q.prototype.shortValue = ja,
    q.prototype.signum = la,
    q.prototype.toByteArray = pa,
    q.prototype.equals = qa,
    q.prototype.min = ra,
    q.prototype.max = sa,
    q.prototype.and = va,
    q.prototype.or = xa,
    q.prototype.xor = za,
    q.prototype.andNot = Ba,
    q.prototype.not = Ca,
    q.prototype.shiftLeft = Da,
    q.prototype.shiftRight = Ea,
    q.prototype.getLowestSetBit = Ga,
    q.prototype.bitCount = Ia,
    q.prototype.testBit = Ja,
    q.prototype.setBit = La,
    q.prototype.clearBit = Ma,
    q.prototype.flipBit = Na,
    q.prototype.add = Pa,
    q.prototype.subtract = Qa,
    q.prototype.multiply = Ra,
    q.prototype.divide = Ta,
    q.prototype.remainder = Ua,
    q.prototype.divideAndRemainder = Va,
    q.prototype.modPow = jb,
    q.prototype.modInverse = mb,
    q.prototype.pow = ab,
    q.prototype.gcd = kb,
    q.prototype.isProbablePrime = nb,
    q.prototype.square = Sa,
    pb.prototype.init = qb,
    pb.prototype.next = rb;
    var Lc, Mc, Nc, Oc = 256;
    if (null == Mc) {
        Mc = new Array,
        Nc = 0;
        var Pc;
        if ("Netscape" == navigator.appName && navigator.appVersion < "5" && d.crypto) {
            var Qc = d.crypto.random(32);
            for (Pc = 0; Pc < Qc.length; ++Pc) Mc[Nc++] = 255 & Qc.charCodeAt(Pc)
        }
        for (; Oc > Nc;) Pc = Math.floor(65536 * Math.random()),
        Mc[Nc++] = Pc >>> 8,
        Mc[Nc++] = 255 & Pc;
        Nc = 0,
        ub()
    }
    xb.prototype.nextBytes = wb,
    Ab.prototype.doPublic = Cb,
    Ab.prototype.setPublic = Bb,
    Ab.prototype.encrypt = Db,
    Ab.prototype.doPrivate = Hb,
    Ab.prototype.setPrivate = Fb,
    Ab.prototype.setPrivateEx = Gb,
    Ab.prototype.decrypt = Ib;
    var Rc = function() {
        Sc.v(Bc)
    },
    Sc = {},
    Tc = "6a384c1259bdb5e731ec96b3174683f48a2c56a85e52e7a5bb20b58711ce50c1a294bd5e1d1752e766085e9ae94bae6d217c25dbb5fcdb86a8a9a7e180fa066723d00fcb85fcf7c9d29f8cc8859f53244a49c0bc30dcc45156daf8843ce1d24fe8ebc9a3c186bb26e9d0714041aef160304c1db8cc5728cf4acb39d29755f319",
    Uc = "10001",
    Vc = "61a921483dfa8f24e26204ace4d990b965d11e5bef5d8a5e768ebc5853a6bdd94b02369a3165207460fb91001d3fd83fbe69c6e51b8e40c8ae8a4e30a7c539dca98b44858bdc0b76f25af6803d4d13dacd9fa1a28f66cf561fa36309d4239a2cf50fe20ef0e99e01fc8701090f0685a524f411e00ca91f877d3b49d2d0052f9",
    Wc = "b881f568eb43e7a60c256a8a90e08b7c7638fd66ce3cded9005c72e283ca4f2b8601e2edc687d7f898348a05723b515d9edeb626af7b499a56ddaea93b0c2047";
    Sc.cross = function(a) {
        if (a) {
            for (var b = "",
            c = 0; c < a.length;) c + 1 < a.length ? (b += a[c + 1], b += a[c]) : b += a[c],
            c += 2;
            return b
        }
        return null
    },
    Sc.reverse = function(a) {
        if (a) {
            for (var b = "",
            c = a.length; c > 0; c--) b += a[c - 1];
            return b
        }
        return null
    },
    Sc.v = function(a) {
        if (a) {
            var b = Sc;
            if (b.start = null, b.beginDate = null, b.end = null, b.endDate = null, b.gis = null, b["3D"] = null, b["3d"] = null, b.l = null, b.__li__ = null, a.indexOf("signature=") > 0) {
                var c = a.split("signature="),
                d = c[0],
                e = c[1],
                f = new Ab;
                f.setPublic(Tc, Uc);
                for (var g = e,
                h = g.length,
                i = 256,
                j = 0,
                k = "",
                l = ""; h > j;) k = g.substr(j, i),
                l += f.decrypt(k),
                j += i;
                if (l === d) return b.i(a),
                !0
            }
        }
        return ! 1
    },
    Sc.i = function(a) {
        var b = Sc;
        b.__li__ = a;
        var c, d, f, g, h, i = a.split("\n");
        for (c = 0; c < i.length; c++) d = i[c],
        h = d.split("="),
        f = h[0],
        g = h[1],
        b[f] = g;
        b.start != e && (b.beginDate = new Date(Date.parse(b.start.replace(/-/g, "/")))),
        b.end != e && (b.endDate = new Date(Date.parse(b.end.replace(/-/g, "/"))));
        var j = b.gis;
        j != e && (j = parseInt(j)),
        j && (b._isPermissionGIS = !0);
        var k = b["3D"] || b["3d"];
        k != e && (k = parseInt(k)),
        k && (b._isPermission3D = !0),
        b.l != e && (b.version = b.l)
    };
    var Xc = function(a) {
        return a.__li__ !== e && a._isPermission3D
    },
    Yc = function(a) {
        if (!Xc(a)) return ! 0;
        var b = new Date;
        return null != a.beginDate && a.beginDate.getTime() - b.getTime() >= 0 || null != a.endDate && a.endDate.getTime() - b.getTime() <= 0
    };
    Sc.$z = function(a) {
        var b = new Ab;
        b.setPublic(Tc, Uc);
        for (var c = a,
        d = c.length,
        e = 256,
        f = 0,
        g = "",
        h = ""; d > f;) g = c.substr(f, e),
        h += b.decrypt(g),
        f += e;
        return h
    },
    Sc.twm = function(a) {
        var b = Sc,
        c = b.$z("4cd18113d0c7046bfe51f7a3fbd41c2b7cf14dd785d6ea7cec9da17710d3acfb8ce0cb9cf10839f4bd51e88819de19cdc0db09278584396156fcb65abe0353ac49d01326b30efa0ea98a07da9f8ceeb7572fc1b37b5965ba6103ccba4913b62e36e49425c6ff21a2f008830c59cff8f29058769f858c8a9f0bab3eaea7fb8a9e"),
        d = this.type,
        f = this.markText,
        g = b.$z("648be38cd61c870e95ffc1ea0676af40736c1365015abc326e891a4de67b4de3d4b05da70b9aebedc83ec26ecf71eb74c72f42f6d9a4be2d507d2f67d2860b7b66e3ba1d565e15923f2db335ff922eef17c01b59818b583d5656412d6cc9d9ba70001c2c88e3efd492c6b13a07fda5f325b333138a2036f4696542ec137cc341");
        a[g] = b.__li__;
        var h = a;
        if (h._xyz = null, "3" !== d || Yc(Sc) || f !== e) {
            a.DEBUG && (console.log("license: " + Sc.__li__), console.log("license Type : " + d), console.log("beginDate: " + Sc.beginDate), console.log("endDate: " + Sc.endDate), console.log("mark: " + f)),
            a.__liLabel == e && (a.__liLabel = document.createElement("div")),
            b.startDate === e && (b.startDate = new Date);
            var i = (new Date).getTime() - b.startDate.getTime(),
            j = "2" === d ? 7200 : 300;
            if (! (1e3 * j > i)) {
                var k = Yc(b) && i > 1e3 * j,
                l = f;
                if (k ? l = b.$z("0dd629dbd0ce341ecdd447e35ddc3135a0b46916f7571a687f38ae665cf0ae095fee885e14329caa75112d8787508da17285b0897845d8ccae73e6a2727dd19f1ca335fe139d0e60d240f9ececc78f81c2c5667f51aeed4135b9c4bb436b8acb7cd418eeeb404bc4f3bcdedb481ac0edff7644435ce2b9f2bda78c892bd56d73") : "2" != d || l !== e && "" != l ? "1" == d && !f && (l = c) : l = b.$z("644d54bf9c59afbd8a742a9e7e2731f23f149ccb7f04c3547548c50ac2d77faea108b55f1f6261e99869f1c06b84e8abdefdf45b5170048531421f3d528123972ba2f03d70f37c33f1341dc12f986e0089e42bab517e2a05b455d12d90991bbba9bc45c715a81943062ea5fa5408c8b1b9270d260cc5a67b38ecc4178ce512fc"), l !== e) {
                    var m = h.__liLabel;
                    m.innerHTML = l,
                    m.type = d,
                    m.mark = f,
                    m.expired = k,
                    h._xyz = m,
                    k && (h.getView().style.opacity = .1)
                }
            }
        }
    },
    tc.validateLicense(Bc),
    Yb.Material = function(a) {
        Yb.PropertyChangeDispatcher.call(this),
        this.id = Yb.MaterialIdCount++,
        this.type = "basic",
        this.shaderID = "",
        this.uniforms = e,
        this.vertexShader = "",
        this.fragmentShader = "",
        this.alarmColor = null,
        this.name = "",
        this.side = Yb.FrontSide,
        this.fog = !0,
        this.normalType = e,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.vertexColors = Yb.NoColors,
        this.blendMode = Yb.NormalBlending,
        this.blendSrc = Yb.SrcAlphaFactor,
        this.blendDst = Yb.OneMinusSrcAlphaFactor,
        this.blendEquation = Yb.AddEquation,
        this.depthTest = !0,
        this.depthMask = !0,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.alphaTest = 0,
        this.transparent = !1,
        this.opacity = 1,
        this.visible = !0,
        this.needsUpdate = !0,
        this.setValues(a),
        this.useCount = 0,
        this.styleMap = {},
        this.offset = new Zb(0, 0),
        this.repeat = new Zb(1, 1),
        this.gradient = {},
        this.gradientType = 1,
        this.gradientCenter = new Zb(.5, .5),
        this.outline = 0
    },
    Yb.extend(Yb.Material, Yb.PropertyChangeDispatcher, {
        generateKey: function() {},
        setMap: function(a, b) {
            if (null == b && (b = "map"), this[b] !== a) {
                var c = this[b];
                this[b] = a,
                this.firePropertyChange(b, c, a),
                this.onMapChanged(c, a)
            }
        },
        handleTextureChange: function(a) {
            "image" === a.property ? this.firePropertyChange("needsUpdate", !1, !0) : "disposed" === a.property
        },
        onPropertyChange: function(a, b, c) {},
        onMapChanged: function(a, b) {},
        setColor: function(a) {
            if (this.color !== a) {
                var b = this.color.clone();
                a instanceof Yb.Color ? this.color.copy(a) : this.color.set(a),
                this.firePropertyChange("color", b, a)
            }
        },
        setPropertyValue: function(a, b) {
            if (this[a] !== b) {
                var c = this[a];
                if (c instanceof Yb.Color) null != b && (c = c.clone(), b instanceof Yb.Color ? this[a].copy(b) : this[a].set(b));
                else if ("gradient" == a) {
                    var d = {};
                    for (var e in b) b[e] instanceof Yb.Color ? d[e] = b[e] : d[e] = new Yb.Color(b[e]);
                    this[a] = d
                } else this[a] = b;
                this._uniqueCode = null,
                this.firePropertyChange(a, c, b)
            }
        },
        isTextureStyle: function(a) {
            return "terrain" === this._type ? a.startsWith("texture1.") || a.startsWith("texture2.") || a.startsWith("textureb.") || a.startsWith("texturen.") || a.startsWith("texturebp.") : a.startsWith("texture.") || a.startsWith("lightmap") || a.startsWith("envmap") || a.startsWith("normalmap") || a.startsWith("specularmap")
        },
        setNeedsUpdate: function(a) {},
        getShaderID: function() {
            return this instanceof Yb.BasicMaterial && (this.shaderID = "basic"),
            this.shaderID
        },
        setupMaterialShader: function() {
            var a = this.getShaderID(),
            b = Yb.ShaderLib[a];
            this.uniforms = Yb.UniformsUtils.clone(b.uniforms),
            this.vertexShader = b.vertexShader,
            this.fragmentShader = b.fragmentShader
        },
        refreshUniforms: function(a, b) {
            this.refreshUniformsCommon(a, b),
            this.refreshUniformsSpecific(a, b)
        },
        loadCameraPosition: function(a, b, c) {
            if ((this instanceof Yb.ShaderMaterial || this instanceof Yb.PhongMaterial || this.envMap || "phong" === this._type) && null != a.cameraPosition) {
                var d = b.worldMatrix.getPosition();
                c.uniform3f(a.cameraPosition, d.x, d.y, d.z)
            }
        },
        loadViewMatrix: function(a, b, c) { ("lambert" === this.type || "phong" === this.type || material.skinning) && null !== a.viewMatrix && c.uniformMatrix4fv(p_uniforms.viewMatrix, !1, b.worldMatrixInverse.elements)
        },
        refreshUniformsSpecific: function(a) {},
        refreshUniformsCommon: function(a) {
            var b = this.uniforms,
            c = this;
            b.opacity.value = c.opacity;
            var d = tc.getObjectCount(this.gradient) > 0;
            if (a ? b.diffuse.value.copyGammaToLinear(this.alarmColor ? this.alarmColor: this.color) : b.diffuse.value = this.alarmColor ? this.alarmColor: this.color, d) {
                var f = [],
                g = [];
                for (var h in this.gradient) f.push(h);
                f.sort();
                for (var i = 0; i < f.length; i++) g.push(this.gradient[f[i]]);
                b.gradientColor.value = g,
                b.gradientStop.value = f,
                b.gradientType.value = this.gradientType
            }
            b.map.value = c.map,
            b.lightMap.value = c.lightMap,
            b.specularMap.value = c.specularMap,
            c.bumpMap && (b.bumpMap.value = c.bumpMap, b.bumpScale.value = c.bumpScale),
            c.normalMap && "phong" === c._type && (b.normalMap.value = c.normalMap, b.normalScale.value.copy(c.normalScale));
            var j;
            if (c.map ? j = c.map: c.specularMap ? j = c.specularMap: c.normalMap && "phong" === c._type ? j = c.normalMap: c.bumpMap && "phong" === c._type && (j = c.bumpMap), j != e) {
                var k = this.offset,
                l = this.repeat;
                b.offsetRepeat.value.set(k.x, k.y, l.x, l.y),
                b.flipX.value = j.flipX ? 1 : 0,
                b.mapLoaded.value = 1,
                j._image && !j._image.loaded && b.offsetRepeat.value.set(0, 0, 1, 1)
            }
            b.envMap.value = c.envMap,
            b.flipEnvMap.value = 1,
            a ? b.reflectivity.value = c.reflectRatio * c.reflectRatio: b.reflectivity.value = c.reflectRatio,
            b.refractionRatio.value = c.refractionRatio,
            b.combine.value = c.combine,
            b.useRefract.value = c.envMap && c.envMap.mapping instanceof Yb.CubeRefractionMapping
        },
        loadGeneralUniforms: function() {},
        getNormalType: function() {
            var a = this && this.normalType !== e && this.normalType === Yb.NormalTypeSmooth;
            return a ? Yb.SmoothShading: Yb.FlatShading
        },
        isVertexColor: function() {
            return this.vertexColors ? this.vertexColors: !1
        },
        needUV: function() {
            return this.map || this.lightMap || this.bumpMap || this.normalMap || this.specularMap ? !0 : !0
        },
        setValues: function(a) {
            if (a !== e) for (var b in a) {
                var c = a[b];
                if (c !== e) {
                    if (b in this) {
                        var d = this[b];
                        d instanceof Yb.Color && c instanceof Yb.Color ? d.copy(c) : d instanceof Yb.Color ? d.set(c) : d instanceof Yb.Vec3 && c instanceof Yb.Vec3 ? d.copy(c) : this[b] = c
                    }
                } else console.warn("TGL.Material: '" + b + "' parameter is undefined.")
            }
        },
        isCustomAttributesNeedUpdate: function() {
            if (!this.attributes) return ! 1;
            for (var a in this.attributes) if (this.attributes[a].needsUpdate) return ! 0;
            return ! 1
        },
        clearCustomAttributes: function() {
            if (this.attributes) for (var a in this.attributes) this.attributes[a].needsUpdate = !1
        },
        clone: function(a) {
            return a === e && (a = new Yb.Material),
            a.name = this.name,
            a.side = this.side,
            a.blendMode = this.blendMode,
            a.blendSrc = this.blendSrc,
            a.blendDst = this.blendDst,
            a.blendEquation = this.blendEquation,
            a.depthTest = this.depthTest,
            a.depthMask = this.depthMask,
            a.polygonOffset = this.polygonOffset,
            a.polygonOffsetFactor = this.polygonOffsetFactor,
            a.polygonOffsetUnits = this.polygonOffsetUnits,
            a.alphaTest = this.alphaTest,
            a.transparent = this.transparent,
            a.opacity = this.opacity,
            a.visible = this.visible,
            a.normalType = this.normalType,
            a.wireframe = this.wireframe,
            a.wireframeLinecap = this.wireframeLinecap,
            a.wireframeLinejoin = this.wireframeLinejoin,
            a.wireframeLinewidth = this.wireframeLinewidth,
            a.gradient = this.gradient,
            a.gradientType = this.gradientType,
            a.outline = this.outline,
            a
        },
        dispose: function() {
            this.firePropertyChange("disposed", !1, !0)
        }
    }),
    Yb.MaterialIdCount = 0,
    Yb.EntityMaterial = function(a) {
        Yb.Material.call(this),
        this._type = "basic",
        this.color = new Yb.Color(16777215),
        this.map = null,
        this.ambient = new Yb.Color(16777215),
        this.emissive = new Yb.Color(0),
        this.specular = new Yb.Color(1118481),
        this.specularStrength = 1,
        this.shininess = 30,
        this.wrapAround = !1,
        this.wrapRGB = new Yb.Vec3(1, 1, 1),
        this.lightMap = null,
        this.specularMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new Yb.Vec2(1, 1),
        this.envMap = null,
        this.combine = Yb.MultiplyOperation,
        this.reflectRatio = 1,
        this.refractionRatio = .98,
        this.fog = !0,
        this.shading = Yb.SmoothShading,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.metal = !1,
        this.perPixel = !0,
        this.map1 = null,
        this.map2 = null,
        this.blendMap = null,
        this.detailMap = null,
        this.specularMap = null,
        this.blendRange = new Zb(0, 1),
        this.setValues(a)
    },
    Yb.extend(Yb.EntityMaterial, Yb.Material, {
        getShaderID: function() {
            return this.getType()
        },
        getUniqueCode: function() {
            if (null != this._uniqueCode) return this._uniqueCode;
            var a = this._type + " " + this.color.r + this.color.g + this.color.b + " " + this.ambient.getUniqueCode() + " " + this.emissive.getUniqueCode() + this.specular.getUniqueCode() + " " + this.transparent + " " + this.visible + " " + this.opacity + " " + this.depthTest + this.depthMask + " " + this.side + " " + this.wireframe + " " + this.wireframeLinewidth + " " + this.polygonOffset + " " + this.polygonOffsetFactor + " " + this.polygonOffsetUnits + " " + this.overdraw + " " + this.shininess + " " + this.metal + " " + this.specularStrength;
            if (this.alphaTest && (a += this.alphaTest), a += " " + this.normalType + " ", a += this.repeat.x + " " + this.repeat.y + this.offset.x + " " + this.offset.y, a += " " + this.blendRange.x + " " + this.blendRange.y, a += " " + this.normalScale.x + " " + this.normalScale.y, a += " " + this.reflectRatio, this.map && (a += this.map.getUniqueCode()), this.map1 && (a += this.map1.getUniqueCode()), this.map2 && (a += this.map2.getUniqueCode()), this.blendMap && (a += this.blendMap.getUniqueCode()), this.normalMap && (a += this.normalMap.getUniqueCode()), this.lightMap && (a += this.lightMap.getUniqueCode()), this.envMap && (a += this.envMap.getUniqueCode()), this.specularMap && (a += this.specularMap.getUniqueCode()), this.alarmColor && (a += " " + this.alarmColor.getUniqueCode()), this.gradient) for (var b in this.gradient) a += " " + b + ":" + this.gradient[b].getUniqueCode();
            return a += " " + this.gradientType,
            a += " " + this.outline,
            a += this.combine,
            this._uniqueCode = a,
            a
        },
        loadViewMatrix: function(a, b, c) { ("lambert" === this._type || "phong" === this._type || material.skinning) && null !== a.viewMatrix && c.uniformMatrix4fv(p_uniforms.viewMatrix, !1, b.worldMatrixInverse.elements)
        },
        onMapChanged: function(a, b) {
            if (Yb.TexturePool.useTexture(b), Yb.TexturePool.unUseTexture(a), b) {
                var c = b.getUniqueCode();
                null == Yb.TexturePool.getTexture(c) && Yb.TexturePool.setTexture(c, b)
            }
        },
        setType: function(a) {
            if (this._type !== a) {
                var b = this._type;
                this._type = a,
                this.firePropertyChange("type", b, a),
                this.onTypeChanged(b, a)
            }
        },
        onTypeChanged: function() {},
        getType: function() {
            return this._type
        },
        setStyle: function(a, b) {
            if (null != a) {
                null == this.styleMap && (this.styleMap = {});
                var c = this.styleMap[a];
                return null == b ? delete this.styleMap[a] : this.styleMap[a] = b,
                this.firePropertyChange(Yb.Styles.PREFIX_STYLE + a, c, b),
                this.onStyleChanged(a, c, b),
                this
            }
        },
        getStyle: function(a, b) {
            null == b && (b = !0);
            var c;
            return null != this.styleMap && (c = this.styleMap[a]),
            null == c && b && (c = Yb.Styles.getStyle(a)),
            c
        },
        clone: function(a) {
            return a = a || new Yb.EntityMaterial,
            Yb.Material.prototype.clone.call(this, a),
            a._type = this._type,
            a.color.copy(this.color),
            a.setMap(this.map, "map"),
            a.setMap(this.map1, "map1"),
            a.setMap(this.map2, "map2"),
            a.setMap(this.blendMap, "blendMap"),
            a.setMap(this.normalMap, "normalMap"),
            a.setMap(this.specularMap, "specularMap"),
            a.setMap(this.envMap, "envMap"),
            a.ambient.copy(this.ambient),
            a.emissive.copy(this.emissive),
            a.specular.copy(this.specular),
            a.shininess = this.shininess,
            a.metal = this.metal,
            a.perPixel = this.perPixel,
            a.wrapAround = this.wrapAround,
            a.wrapRGB.copy(this.wrapRGB),
            a.setMap(this.lightMap, "lightMap"),
            a.bumpMap = this.bumpMap,
            a.bumpScale = this.bumpScale,
            a.normalScale.copy(this.normalScale),
            a.combine = this.combine,
            a.reflectRatio = this.reflectRatio,
            a.refractionRatio = this.refractionRatio,
            a.fog = this.fog,
            a.shading = this.shading,
            a.skinning = this.skinning,
            a.morphTargets = this.morphTargets,
            a.morphNormals = this.morphNormals,
            a.specularStrength = this.specularStrength,
            a.offset.copy(this.offset),
            a.repeat.copy(this.repeat),
            a.blendRange.copy(this.blendRange),
            a
        },
        refreshUniformsSpecific: function(a) {
            var b = this.uniforms;
            "lambert" === this._type ? (a ? (b.ambient.value.copyGammaToLinear(this.ambient), b.emissive.value.copyGammaToLinear(this.emissive)) : (b.ambient.value = this.ambient, b.emissive.value = this.emissive), this.wrapAround && b.wrapRGB.value.copy(this.wrapRGB)) : "phong" === this._type && (b.shininess.value = this.shininess, a ? (b.ambient.value.copyGammaToLinear(this.alarmColor ? this.alarmColor: this.ambient), b.emissive.value.copyGammaToLinear(this.emissive), b.specular.value.copyGammaToLinear(this.specular)) : (b.ambient.value = this.alarmColor ? this.alarmColor: this.ambient, b.emissive.value = this.emissive, b.specular.value = this.specular), b.uspecularStrength.value = this.specularStrength, this.wrapAround && b.wrapRGB.value.copy(this.wrapRGB))
        },
        refreshUniformsCommon: function(a) {
            if ("terrain" === this._type) {
                var b = this.uniforms;
                b.enableDiffuse1.value = this.map ? 1 : 0,
                b.tDiffuse1.value = this.map,
                b.enableDiffuse2.value = this.map1 ? 1 : 0,
                b.tDiffuse2.value = this.map1,
                b.enableDiffuse3.value = this.map2 ? 1 : 0,
                b.tDiffuse3.value = this.map2,
                b.enableDisplacement.value = this.blendMap ? 1 : 0,
                b.tDisplacement.value = this.blendMap,
                b.uRepeatOverlay.value = this.repeat,
                null == this.blendRangeArray && (this.blendRangeArray = [0, 1]),
                this.blendRangeArray[0] = this.blendRange.x,
                this.blendRangeArray[1] = this.blendRange.y,
                b.blendRange.value = this.blendRangeArray
            } else if ("outline" === this._type) {
                var b = this.uniforms;
                b.diffuse.value = this.color,
                b.outline_offset.value = this.outline
            } else Yb.Material.prototype.refreshUniformsCommon.call(this, a)
        }
    }),
    Yb.BlurMaterial = function() {
        Yb.Material.call(this),
        this.orientation = 0,
        this.blurAmount = 5,
        this.blurScale = 1,
        this.blurStrength = 1,
        this.useBlur = 1,
        this.texelSize = new Zb(512, 512),
        this.blurGlobalAlpha = 1
    },
    Yb.extend(Yb.BlurMaterial, Yb.Material, {
        refreshUniformsCommon: function(a) {
            var b = this.uniforms;
            b.map.value = this.map,
            b.orientation.value = this.orientation,
            b.blurAmount.value = this.blurAmount,
            b.blurScale.value = this.blurScale,
            b.blurStrength.value = this.blurStrength,
            b.useBlur.value = this.useBlur,
            b.texelSize.value = this.texelSize,
            b.blurGlobalAlpha.value = this.blurGlobalAlpha
        },
        getShaderID: function() {
            return "blur"
        }
    }),
    Yb.DeferredMaterial = function(a) {
        a = a || {},
        Yb.Material.call(this, a),
        this.linearDepth = 30,
        this.isNormal = a.isNormal !== e ? a.isNormal: 0
    },
    Yb.extend(Yb.DeferredMaterial, Yb.Material, {
        getShaderID: function() {
            return "deferred"
        },
        refreshUniformsCommon: function(a) {
            var b = this.uniforms;
            b.linearDepth.value = this.linearDepth,
            b.isNormal.value = this.isNormal
        }
    }),
    Yb.SSAOMaterial = function(a) {
        Yb.Material.call(this),
        this.map1 = null,
        this.map2 = null,
        this.occluderBias = .05,
        this.samplingRadius = 20,
        this.attenuation = new Zb(1, .02),
        this.texelSize = new Zb(1 / 512, 1 / 512)
    },
    Yb.extend(Yb.SSAOMaterial, Yb.Material, {
        getShaderID: function() {
            return "ssao"
        },
        refreshUniformsCommon: function(a) {
            var b = this.uniforms;
            b.map0.value = this.map,
            b.map1.value = this.map1,
            b.map2.value = this.map2,
            b.occluderBias.value = this.occluderBias,
            b.samplingRadius.value = this.samplingRadius,
            b.attenuation.value = this.attenuation,
            b.texelSize.value = this.texelSize
        }
    }),
    Yb.BasicMaterial = function(a) {
        Yb.Material.call(this),
        this._type = "basic",
        this.color = new Yb.Color(16777215),
        this.map = null,
        this.setValues(a),
        this.offset = new Zb(0, 0),
        this.repeat = new Zb(1, 1)
    },
    Yb.extend(Yb.BasicMaterial, Yb.Material, {
        getShaderID: function() {
            return "basic"
        },
        clone: function() {
            var a = new Yb.BasicMaterial;
            return Yb.Material.prototype.clone.call(this, a),
            a.color.copy(this.color),
            a.map = this.map,
            a
        },
        getUniqueCode: function() {
            var a = this.color.r + this.color.g + this.color.b + " " + this.transparent + " " + this.visible + " " + this.opacity + " " + this.depthTest + this.depthMask + " " + this.side + " " + this.wireframe + " " + this.wireframeLinewidth;
            return a += this.repeat.x + " " + this.repeat.y + this.offset.x + " " + this.offset.y,
            this.map && (a += this.map.getUniqueCode()),
            a
        }
    }),
    Yb.LambertMaterial = function(a) {
        Yb.Material.call(this),
        this._type = "basic",
        this.color = new Yb.Color(16777215),
        this.ambient = new Yb.Color(16777215),
        this.emissive = new Yb.Color(0),
        this.wrapAround = !1,
        this.wrapRGB = new Yb.Vec3(1, 1, 1),
        this.map = null,
        this.lightMap = null,
        this.specularMap = null,
        this.envMap = null,
        this.combine = Yb.MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.fog = !0,
        this.shading = Yb.SmoothShading,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.vertexColors = Yb.NoColors,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(a)
    },
    Yb.extend(Yb.LambertMaterial, Yb.Material, {
        clone: function() {
            var a = new Yb.LambertMaterial;
            return Yb.Material.prototype.clone.call(this, a),
            a.color.copy(this.color),
            a.ambient.copy(this.ambient),
            a.emissive.copy(this.emissive),
            a.wrapAround = this.wrapAround,
            a.wrapRGB.copy(this.wrapRGB),
            a.map = this.map,
            a.lightMap = this.lightMap,
            a.specularMap = this.specularMap,
            a.envMap = this.envMap,
            a.combine = this.combine,
            a.reflectivity = this.reflectivity,
            a.refractionRatio = this.refractionRatio,
            a.fog = this.fog,
            a.shading = this.shading,
            a.wireframe = this.wireframe,
            a.wireframeLinewidth = this.wireframeLinewidth,
            a.wireframeLinecap = this.wireframeLinecap,
            a.wireframeLinejoin = this.wireframeLinejoin,
            a.vertexColors = this.vertexColors,
            a.skinning = this.skinning,
            a.morphTargets = this.morphTargets,
            a.morphNormals = this.morphNormals,
            a
        },
        getShaderID: function() {
            return "lambert"
        },
        refreshUniformsSpecific: function(a) {
            var b = this.uniforms;
            a ? (b.ambient.value.copyGammaToLinear(this.ambient), b.emissive.value.copyGammaToLinear(this.emissive)) : (b.ambient.value = this.ambient, b.emissive.value = this.emissive),
            this.wrapAround && b.wrapRGB.value.copy(this.wrapRGB)
        }
    }),
    Yb.PhongMaterial = function(a) {
        Yb.Material.call(this),
        this._type = "basic",
        this.color = new Yb.Color(16777215),
        this.ambient = new Yb.Color(16777215),
        this.emissive = new Yb.Color(0),
        this.specular = new Yb.Color(1118481),
        this.shininess = 30,
        this.metal = !1,
        this.perPixel = !0,
        this.wrapAround = !1,
        this.wrapRGB = new Yb.Vec3(1, 1, 1),
        this.map = null,
        this.lightMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new Yb.Vec2(1, 1),
        this.specularMap = null,
        this.envMap = null,
        this.combine = Yb.MultiplyOperation,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.fog = !0,
        this.shading = Yb.SmoothShading,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.vertexColors = Yb.NoColors,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(a),
        this.offset = new Zb(0, 0),
        this.repeat = new Zb(1, 1)
    },
    Yb.extend(Yb.PhongMaterial, Yb.Material, {
        getUniqueCode: function() {
            var a = "phong " + this.color.r + this.color.g + this.color.b + " " + this.transparent + " " + this.visible + " " + this.opacity + " " + this.depthTest + this.depthMask + " " + this.side + " " + this.wireframe + " " + this.wireframeLinewidth;
            return a += this.repeat.x + " " + this.repeat.y + this.offset.x + " " + this.offset.y,
            this.map && (a += this.map.getUniqueCode()),
            a
        },
        clone: function() {
            var a = new Yb.PhongMaterial;
            return Yb.Material.prototype.clone.call(this, a),
            a.color.copy(this.color),
            a.ambient.copy(this.ambient),
            a.emissive.copy(this.emissive),
            a.specular.copy(this.specular),
            a.shininess = this.shininess,
            a.metal = this.metal,
            a.perPixel = this.perPixel,
            a.wrapAround = this.wrapAround,
            a.wrapRGB.copy(this.wrapRGB),
            a.map = this.map,
            a.lightMap = this.lightMap,
            a.bumpMap = this.bumpMap,
            a.bumpScale = this.bumpScale,
            a.normalMap = this.normalMap,
            a.normalScale.copy(this.normalScale),
            a.specularMap = this.specularMap,
            a.envMap = this.envMap,
            a.combine = this.combine,
            a.reflectivity = this.reflectivity,
            a.refractionRatio = this.refractionRatio,
            a.fog = this.fog,
            a.shading = this.shading,
            a.wireframe = this.wireframe,
            a.wireframeLinewidth = this.wireframeLinewidth,
            a.wireframeLinecap = this.wireframeLinecap,
            a.wireframeLinejoin = this.wireframeLinejoin,
            a.vertexColors = this.vertexColors,
            a.skinning = this.skinning,
            a.morphTargets = this.morphTargets,
            a.morphNormals = this.morphNormals,
            a
        },
        getShaderID: function() {
            return "phong"
        },
        refreshUniformsSpecific: function(a) {
            var b = this.uniforms;
            b.shininess.value = this.shininess,
            a ? (b.ambient.value.copyGammaToLinear(this.ambient), b.emissive.value.copyGammaToLinear(this.emissive), b.specular.value.copyGammaToLinear(this.specular)) : (b.ambient.value = this.ambient, b.emissive.value = this.emissive, b.specular.value = this.specular),
            this.wrapAround && b.wrapRGB.value.copy(material.wrapRGB)
        }
    }),
    Yb.LineMaterial = function(a) {
        Yb.Material.call(this),
        this.color = new Yb.Color(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.dashed = !0,
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.vertexColors = !1,
        this.fog = !0,
        this.setValues(a)
    },
    Yb.extend(Yb.LineMaterial, Yb.Material, {
        getUniqueCode: function() {
            return this.color.getUniqueCode + " " + this.linewidth + " " + this.dashed
        },
        clone: function() {
            var a = new Yb.LineMaterial;
            return Yb.Material.prototype.clone.call(this, a),
            a.color.copy(this.color),
            a.linewidth = this.linewidth,
            a.linecap = this.linecap,
            a.linejoin = this.linejoin,
            a.dashed = this.dashed,
            a.scale = this.scale,
            a.dashSize = this.dashSize,
            matetial.gapSize = this.gapSize,
            a.vertexColors = this.vertexColors,
            a.fog = this.fog,
            a
        },
        getShaderID: function() {
            return this.dashed ? "dashed": "basic"
        },
        refreshUniforms: function(a) {
            Jb(this.uniforms, this),
            this.dashed && Kb(this.uniforms, this)
        }
    }),
    Yb.ArrayMaterial = function(a) {
        this.materials = a || []
    },
    Yb.extend(Yb.ArrayMaterial, Object, {
        clone: function() {
            for (var a = new Yb.ArrayMaterial,
            b = 0; b < this.materials.length; b++) {
                var c = this.materials[b],
                d = this.materials.indexOf(c);
                null != a.materials[d] ? a.materials.push(a.materials[d]) : a.materials.push(c.clone())
            }
            return a
        }
    }),
    Yb.BillboardMaterial = function(a) {
        Yb.Material.call(this),
        this.alignment = Yb.BillboardAlignment.center.clone(),
        this.fog = !1,
        this.color = new Yb.Color(16777215),
        this.map = null,
        this.rotation = 0,
        this.fog = !1,
        this.offset = new Yb.Vec2(0, 0),
        this.repeat = new Yb.Vec2(1, 1),
        this.transparent = !0,
        this.setValues(a),
        this.depthMask = !0,
        this.vertical = !1,
        this.alphaTest = 0
    },
    Yb.extend(Yb.BillboardMaterial, Yb.Material, {
        clone: function(a) {
            return a = a ? a: new Yb.BillboardMaterial,
            Yb.Material.prototype.clone.call(this, a),
            a.alignment.copy(this.alignment),
            a.color.copy(this.color),
            a.map = this.map,
            a.rotation = this.rotation,
            a.offset.copy(this.offset),
            a.repeat.copy(this.repeat),
            a.fog = this.fog,
            a.vertical = this.vertical,
            a.transparent = this.transparent,
            a.alphaTest = this.alphaTest,
            a
        },
        getUniqueCode: function() {
            var a = "Billboard " + this.color.r + this.color.g + this.color.b + " " + this.transparent + " " + this.visible + " " + this.opacity + " " + this.depthTest + this.depthMask + " " + this.side + " " + this.wireframe + " " + this.wireframeLinewidth;
            return a += this.vertical + " " + this.alphaTest + " " + this.alignment.x + " " + this.alignment.y,
            a += this.repeat.x + " " + this.repeat.y,
            a += this.offset.x + " " + this.offset.y,
            this.map && (a += this.map.getUniqueCode()),
            a
        }
    }),
    Yb.BillboardAlignment = {},
    Yb.BillboardAlignment.topLeft = new Yb.Vec2(.5, -.5),
    Yb.BillboardAlignment.topCenter = new Yb.Vec2(0, -.5),
    Yb.BillboardAlignment.topRight = new Yb.Vec2( - .5, -.5),
    Yb.BillboardAlignment.centerLeft = new Yb.Vec2(.5, 0),
    Yb.BillboardAlignment.center = new Yb.Vec2(0, 0),
    Yb.BillboardAlignment.centerRight = new Yb.Vec2( - .5, 0),
    Yb.BillboardAlignment.bottomLeft = new Yb.Vec2(.5, .5),
    Yb.BillboardAlignment.bottomCenter = new Yb.Vec2(0, .5),
    Yb.BillboardAlignment.bottomRight = new Yb.Vec2( - .5, .5);
    var Zc = function(a) {
        Yb.Material.call(this),
        this.fragmentShader = "void main() {}",
        this.vertexShader = "void main() {}",
        this.uniforms = {},
        this.defines = {},
        this.attributes = null,
        this.shaderID = a.shaderID || "depth",
        this._type = "shader",
        this.shading = Yb.SmoothShading,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.vertexColors = Yb.NoColors,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = "position",
        this.setValues(a)
    };
    Yb.ShaderMaterial = Zc,
    Yb.extend(Yb.ShaderMaterial, Yb.Material, {
        clone: function() {
            var a = new Yb.ShaderMaterial;
            return Yb.Material.prototype.clone.call(this, a),
            a.fragmentShader = this.fragmentShader,
            a.vertexShader = this.vertexShader,
            a.uniforms = Yb.UniformsUtils.clone(this.uniforms),
            a.attributes = this.attributes,
            a.defines = this.defines,
            a.shading = this.shading,
            a.wireframe = this.wireframe,
            a.wireframeLinewidth = this.wireframeLinewidth,
            a.fog = this.fog,
            a.lights = this.lights,
            a.vertexColors = this.vertexColors,
            a.skinning = this.skinning,
            a.morphTargets = this.morphTargets,
            a.morphNormals = this.morphNormals,
            a
        },
        needUV: function() {
            return ! 0
        },
        getShaderID: function() {
            return null
        },
        refreshUniformsCommon: function(a, b) {}
    }),
    Yb.TransformGizmoMaterial = function(a) {
        Yb.BasicMaterial.call(this),
        this.depthTest = !1,
        this.depthMask = !1,
        this.side = Yb.DoubleSide,
        this.transparent = !0,
        this.setValues(a)
    },
    Yb.extend(Yb.TransformGizmoMaterial, Yb.BasicMaterial, {
        getUniqueCode: function() {
            var a = this.id + "TransformGizmo " + this.color.r + this.color.g + this.color.b + " " + this.transparent + " " + this.visible + " " + this.opacity + " " + this.depthTest + this.depthMask + " " + this.side + " " + this.wireframe + " " + this.wireframeLinewidth;
            return this.map && (a += this.map.getUniqueCode()),
            a
        }
    });
    var $c = {
        pools: {},
        useTimes: {},
        size: 0,
        getMaterial: function(a) {
            return $c.pools[a]
        },
        setMaterial: function(a, b) {
            $c.size++,
            $c.pools[a] = b
        },
        useMaterial: function(a) {
            if (a) {
                var b = a.id,
                c = $c.useTimes[b] || 0;
                c++,
                $c.useTimes[b] = c
            }
        },
        unUseMaterial: function(a) {
            if (a) {
                var b = a.id,
                c = $c.useTimes[b] || 0;
                if (c--, $c.useTimes[b] = c, 0 >= c) {
                    var d = a.getUniqueCode();
                    delete $c.pools[d],
                    $c.size--,
                    a.dispose()
                }
            }
        }
    };
    Yb.MaterialPool = $c,
    $c.DefaultMaterial = new Yb.EntityMaterial,
    $c.TestMaterial = new Yb.EntityMaterial,
    $c.DefaultBillBoardMaterial = new Yb.BillboardMaterial,
    $c.DefaultLineMaterial = new Yb.LineMaterial,
    Yb.ParticleMaterial = function(a) {
        Yb.Material.call(this),
        this.color = new Yb.Color(16777215),
        this.map = null,
        this.size = 2,
        this.sizeAttenuation = !1,
        this.vertexColors = !1,
        this.fog = !0,
        this.setValues(a)
    },
    Yb.extend(Yb.ParticleMaterial, Yb.Material, {
        clone: function() {
            var a = new Yb.ParticleMaterial;
            return Yb.Material.prototype.clone.call(this, a),
            a.color.copy(this.color),
            a.map = this.map,
            a.size = this.size,
            a.sizeAttenuation = this.sizeAttenuation,
            a.vertexColors = this.vertexColors,
            a.fog = this.fog,
            a
        },
        getShaderID: function() {
            return this.shaderID = "particle_basic",
            this.shaderID
        },
        refreshUniforms: function(a) {
            Lb(this.uniforms, this)
        }
    }),
    Yb.Light = function(a, b) {
        Yb.Element.call(this, b),
        this.color = new Yb.Color(a),
        this.ambient = new Yb.Color,
        this.diffuse = new Yb.Color,
        this.specular = new Yb.Color,
        this.castShadow = !1,
        this.onlyShadow = !1
    },
    Yb.extend(Yb.Light, Yb.Element, {
        __accessor: ["color", "ambient", "diffuse", "specular"],
        constructor: Yb.Light,
        className: "TGL.Light",
        setCastShadow: function(a) {
            this.castShadow = a
        },
        setOnlyShadow: function(a) {
            this.onlyShadow = a
        },
        refreshShadowUniforms: function(a, b) {
            var c = this;
            return a.shadowMatrix && c.castShadow && (c instanceof Yb.SpotLight || c instanceof Yb.DirectionalLight && !c.shadowCascade) ? (a.shadowMap.value[b] = c.shadowMap, a.shadowMapSize.value[b] = c.shadowMapSize, a.shadowMatrix.value[b] = c.shadowMatrix, a.shadowDarkness.value[b] = c.shadowDarkness, a.shadowBias.value[b] = c.shadowBias, !0) : void 0
        },
        refreshUniformsPointShadow: function(a, b) {
            var c = this;
            return a.pShadowMap && c.castShadow && c instanceof Yb.PointLight ? (a.pShadowMap.value[b] = c.shadowMap, a.pShadowMapSize.value[b] = c.shadowMapSize, a.pShadowDarkness.value[b] = c.shadowDarkness || .5, a.pPosition.value[b] = c.getPosition(), !0) : void 0
        }
    }),
    Yb.PositionLight = function() {},
    Yb.PointLight = function(a, b, c, d) {
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var f = arguments[0];
            a = f.hex,
            b = f.intensity,
            c = f.intensity,
            d = f.id
        }
        Yb.Light.call(this, a, d),
        this.position = new Yb.Vec3(0, 0, 0),
        this.intensity = b !== e ? b: 1,
        this.distance = c !== e ? c: 0,
        this.shadowCameraNear = 10,
        this.shadowCameraFar = 1e4,
        this.shadowMapWidth = 512,
        this.shadowMapHeight = 512
    },
    Yb.extend(Yb.PointLight, Yb.Light, {
        constructor: Yb.PointLight,
        className: "TGL.PointLight",
        __accessor: ["intensity", "distance"]
    }),
    Yb.SpotLight = function(a, b, c, d, f) {
        Yb.Light.call(this, a),
        this._position = new Yb.Vec3(0, 1, 0),
        this.target = new Yb.Element,
        this.intensity = b !== e ? b: 1,
        this.distance = c !== e ? c: 0,
        this.angle = d !== e ? d: Math.PI / 2,
        this.exponent = f !== e ? f: 10,
        this.shadowCameraNear = 100,
        this.shadowCameraFar = 5e3,
        this.shadowCameraFov = 50,
        this.shadowCameraVisible = !1,
        this.shadowBias = 0,
        this.shadowDarkness = .5,
        this.shadowMapWidth = 512,
        this.shadowMapHeight = 512,
        this.shadowMap = null,
        this.shadowMapSize = null,
        this.shadowCamera = null,
        this.shadowMatrix = null
    },
    Yb.extend(Yb.SpotLight, Yb.Light, {
        __accessor: ["color", "ambient", "diffuse", "specular", "intensity", "distance", "angle", "exponent"],
        constructor: Yb.SpotLight,
        className: "TGL.SpotLight"
    }),
    Yb.DirectionalLight = function(a, b, c) {
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var d = arguments[0];
            a = d.hex,
            b = d.intensity,
            c = d.id
        }
        Yb.Light.call(this, a, c),
        this.direction = new Yb.Vec3(0, 1, 0),
        this.position = new Yb.Vec3(0, 1, 0),
        this.target = new Yb.Element,
        this.intensity = b !== e ? b: 1,
        this.shadowCameraNear = 50,
        this.shadowCameraFar = 5e3,
        this.shadowCameraLeft = -500,
        this.shadowCameraRight = 500,
        this.shadowCameraTop = 500,
        this.shadowCameraBottom = -500,
        this.shadowCameraVisible = !1,
        this.shadowBias = 0,
        this.shadowDarkness = .5,
        this.shadowMapWidth = 512,
        this.shadowMapHeight = 512,
        this.shadowCascade = !1,
        this.shadowCascadeOffset = new Yb.Vec3(0, 0, -1e3),
        this.shadowCascadeCount = 2,
        this.shadowCascadeBias = [0, 0, 0],
        this.shadowCascadeWidth = [512, 512, 512],
        this.shadowCascadeHeight = [512, 512, 512],
        this.shadowCascadeNearZ = [ - 1, .99, .998],
        this.shadowCascadeFarZ = [.99, .998, 1],
        this.shadowCascadeArray = [],
        this.shadowMap = null,
        this.shadowMapSize = null,
        this.shadowCamera = null,
        this.shadowMatrix = null
    },
    Yb.extend(Yb.DirectionalLight, Yb.Light, {
        className: "TGL.DirectionalLight"
    }),
    Yb.AmbientLight = function(a, b) {
        if (1 === arguments.length && arguments[0] instanceof Object && !Array.isArray(arguments[0])) {
            var c = arguments[0];
            a = c.hex,
            b = c.id
        }
        Yb.Light.call(this, a, b)
    },
    Yb.extend(Yb.AmbientLight, Yb.Light, {
        constructor: Yb.AmbientLight,
        className: "TGL.AmbientLight",
        clone: function() {
            var a = new Yb.AmbientLight;
            return Yb.Light.prototype.clone.call(this, a),
            a
        }
    }),
    Yb.Camera = function() {
        Yb.Element.call(this),
        this.projectionMatrix = new Yb.Mat4,
        this.projectionMatrixInverse = new Yb.Mat4,
        this.worldMatrixInverse = new Yb.Mat4,
        this.target = new Yb.Vec3,
        this.setPosition(0, 0, 500),
        this.lookat = this.lookAt
    },
    Yb.extend(Yb.Camera, Yb.Element, {
        constructor: Yb.Camera,
        updateCameraMatrix: function(a) {
            var b = this.matrix.clone();
            this.matrix.lookAt(this._position, this.target, this.up),
            this.rotationAutoUpdate && this._rotation.setEulerFromRotationMatrix(this.matrix),
            !b.equals(this.matrix) && a && this.firePropertyChange("matrix", b, this.matrix)
        },
        lookAt: function(a, b) {
            3 === arguments.length && a.x === e ? (a = new mono.Vec3(arguments[0], arguments[1], arguments[2]), b = e) : 4 === arguments.length && a.x === e && (a = new mono.Vec3(arguments[0], arguments[1], arguments[2]), b = arguments[4]),
            b === e && (b = !0),
            this.target = a,
            this.updateCameraMatrix(b)
        },
        look: function(a) {
            3 === arguments.length && a.x === e && (a = new mono.Vec3(arguments[0], arguments[1], arguments[2])),
            this.lookAt(a, !0)
        },
        onUpChanged: function(a, b) {
            this.updateCameraMatrix()
        },
        getTarget: function() {
            return this.target
        },
        t: function() {
            return this.getTarget()
        },
        getDistance: function() {
            return (new $b).subVectors(this._position, this.target).length()
        },
        setDistance: function(a) {
            var b = this.getDistance();
            this.zoom(a / b)
        },
        lookAtElement: function(a, b, c) {
            b instanceof $b ? (c = b, b = this.getDistance()) : c = c || new $b(0, 0, 1),
            a instanceof Yb.Element && (b = b ? b: this.getDistance(), this.setPosition(a.worldPosition(c, b)), this.look(a.getWorldPosition()))
        },
        zoomOut: function(a) {
            this.zoom(1.1, a)
        },
        zoomIn: function(a) {
            this.zoom(.9, a)
        },
        zoom: function(a, b) {
            if (a > 0) {
                var c = b || this.getDistance();
                c *= a;
                var d = (new $b).addVectors(this.target, (new $b).subVectors(this._position, this.target).setLength(c));
                this.setPosition(d)
            }
        }
    }),
    Yb.OrthoCamera = function(a, b, c, d) {
        Yb.Camera.call(this),
        this.width = a || 1,
        this.aspect = b || 1,
        this.near = c || .1,
        this.far = d || 1e4,
        this.updateProjectionMatrix()
    },
    Yb.extend(Yb.OrthoCamera, Yb.Camera, {
        constructor: Yb.OrthoCamera,
        className: "TGL.OrthoCamera",
        __accessor: ["width", "aspect", "near", "far"],
        updateProjectionMatrix: function() {
            var a = this.getDistance(),
            b = a * this.width / 2,
            c = -b,
            d = a / this.aspect * this.width / 2,
            e = -d;
            this.projectionMatrix.makeOrthographic(c, b, d, e, this.near, this.far)
        },
        onPropertyChange: function() {
            this.updateProjectionMatrix()
        },
        updateCameraMatrix: function(a) {
            Yb.Camera.prototype.updateCameraMatrix.call(this, a),
            this.updateProjectionMatrix()
        }
    }),
    Yb.PerspectiveCamera = function(a, b, c, d) {
        Yb.Camera.call(this),
        this.fov = a !== e ? a: 50,
        this.aspect = b !== e ? b: 1,
        this.near = c !== e ? c: 1,
        this.far = d !== e ? d: 5e4,
        this.updateProjectionMatrix()
    },
    Yb.extend(Yb.PerspectiveCamera, Yb.Camera, {
        constructor: Yb.PerspectiveCamera,
        className: "TGL.PerspectiveCamera",
        __accessor: ["fov", "aspect", "near", "far"],
        updateProjectionMatrix: function() {
            this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
        },
        onPropertyChange: function() {
            this.updateProjectionMatrix()
        }
    }),
    Yb.CameraHelper = function(a) {
        function b(a, b, d) {
            c(a, d),
            c(b, d)
        }
        function c(a, b) {
            d.vertices.push(new Yb.Vec3),
            d.colors.push(new Yb.Color(b)),
            g[a] === e && (g[a] = []),
            g[a].push(d.vertices.length - 1)
        }
        var d = new Yb.Entity,
        f = new Yb.LineMaterial({
            color: 16777215,
            vertexColors: Yb.FaceColors
        }),
        g = {},
        h = 16755200,
        i = 16711680,
        j = 43775,
        k = 16777215,
        l = 3355443;
        b("n1", "n2", h),
        b("n2", "n4", h),
        b("n4", "n3", h),
        b("n3", "n1", h),
        b("f1", "f2", h),
        b("f2", "f4", h),
        b("f4", "f3", h),
        b("f3", "f1", h),
        b("n1", "f1", h),
        b("n2", "f2", h),
        b("n3", "f3", h),
        b("n4", "f4", h),
        b("p", "n1", i),
        b("p", "n2", i),
        b("p", "n3", i),
        b("p", "n4", i),
        b("u1", "u2", j),
        b("u2", "u3", j),
        b("u3", "u1", j),
        b("c", "t", k),
        b("p", "c", l),
        b("cn1", "cn2", l),
        b("cn3", "cn4", l),
        b("cf1", "cf2", l),
        b("cf3", "cf4", l),
        Yb.Line.call(this, d.vertices, d.colors, f, Yb.LinePieces),
        this.camera = a,
        this.worldMatrix = a.worldMatrix,
        this.matrixAutoUpdate = !1,
        this.pointMap = g,
        this.update()
    },
    Yb.CameraHelper.prototype = Object.create(Yb.Line.prototype),
    Yb.CameraHelper.prototype.update = function() {
        var a = new Yb.Vec3,
        b = new Yb.Camera,
        c = new Yb.Projector;
        return function() {
            function d(d, g, h, i) {
                a.set(g, h, i),
                c.unprojectVector(a, b);
                var j = f.pointMap[d];
                if (j !== e) for (var k = 0,
                l = j.length; l > k; k++) f.vertices[j[k]].copy(a)
            }
            var f = this,
            g = 1,
            h = 1;
            b.projectionMatrix.copy(this.camera.projectionMatrix),
            d("c", 0, 0, -1),
            d("t", 0, 0, 1),
            d("n1", -g, -h, -1),
            d("n2", g, -h, -1),
            d("n3", -g, h, -1),
            d("n4", g, h, -1),
            d("f1", -g, -h, 1),
            d("f2", g, -h, 1),
            d("f3", -g, h, 1),
            d("f4", g, h, 1),
            d("u1", .7 * g, 1.1 * h, -1),
            d("u2", .7 * -g, 1.1 * h, -1),
            d("u3", 0, 2 * h, -1),
            d("cf1", -g, 0, 1),
            d("cf2", g, 0, 1),
            d("cf3", 0, -h, 1),
            d("cf4", 0, h, 1),
            d("cn1", -g, 0, -1),
            d("cn2", g, 0, -1),
            d("cn3", 0, -h, -1),
            d("cn4", 0, h, -1),
            this.verticesNeedUpdate = !0
        }
    } ();
    var _c = function() {
        Yb.Element.call(this)
    };
    _c.prototype = Object.create(Yb.Element.prototype),
    _c.prototype.updateworldMatrix = function(a) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.worldMatrixNeedsUpdate || a) && (this._parent ? (this.worldMatrix.multiplyMatrices(this._parent.worldMatrix, this.matrix), this.worldMatrix.decompose(this.translationWorld, this.QuatWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.QuatObject, this.scaleObject), this.worldMatrix.compose(this.translationWorld, this.QuatObject, this.scaleWorld)) : this.worldMatrix.copy(this.matrix), this.worldMatrixNeedsUpdate = !1, a = !0);
        for (var b = 0,
        c = this.getChildren().size(); c > b; b++) this.getChildren().get(b).updateworldMatrix(a)
    },
    _c.prototype.translationWorld = new Yb.Vec3,
    _c.prototype.translationObject = new Yb.Vec3,
    _c.prototype.QuatWorld = new Yb.Quat,
    _c.prototype.QuatObject = new Yb.Quat,
    _c.prototype.scaleWorld = new Yb.Vec3,
    _c.prototype.scaleObject = new Yb.Vec3;
    var ad = function() {
        function a(a, b) {
            var c = new Yb.DirectionalLight;
            c.isVirtual = !0,
            c.onlyShadow = !0,
            c.castShadow = !0,
            c.shadowCameraNear = a.shadowCameraNear,
            c.shadowCameraFar = a.shadowCameraFar,
            c.shadowCameraLeft = a.shadowCameraLeft,
            c.shadowCameraRight = a.shadowCameraRight,
            c.shadowCameraBottom = a.shadowCameraBottom,
            c.shadowCameraTop = a.shadowCameraTop,
            c.shadowCameraVisible = a.shadowCameraVisible,
            c.shadowDarkness = a.shadowDarkness,
            c.shadowBias = a.shadowCascadeBias[b],
            c.shadowMapWidth = a.shadowCascadeWidth[b],
            c.shadowMapHeight = a.shadowCascadeHeight[b],
            c.pointsWorld = [],
            c.pointsFrustum = [];
            for (var d = c.pointsWorld,
            e = c.pointsFrustum,
            f = 0; 8 > f; f++) d[f] = new Yb.Vec3,
            e[f] = new Yb.Vec3;
            var g = a.shadowCascadeNearZ[b],
            h = a.shadowCascadeFarZ[b];
            return e[0].set( - 1, -1, g),
            e[1].set(1, -1, g),
            e[2].set( - 1, 1, g),
            e[3].set(1, 1, g),
            e[4].set( - 1, -1, h),
            e[5].set(1, -1, h),
            e[6].set( - 1, 1, h),
            e[7].set(1, 1, h),
            c
        }
        function b(a, b) {
            var c = a.shadowCascadeArray[b];
            c.position.copy(a.position),
            c.target.position.copy(a.target.position),
            c.lookAt(c.target),
            c.shadowCameraVisible = a.shadowCameraVisible,
            c.shadowDarkness = a.shadowDarkness,
            c.shadowBias = a.shadowCascadeBias[b];
            var d = a.shadowCascadeNearZ[b],
            e = a.shadowCascadeFarZ[b],
            f = c.pointsFrustum;
            f[0].z = d,
            f[1].z = d,
            f[2].z = d,
            f[3].z = d,
            f[4].z = e,
            f[5].z = e,
            f[6].z = e,
            f[7].z = e
        }
        function c(a, b) {
            var c = b.shadowCamera,
            d = b.pointsFrustum,
            e = b.pointsWorld;
            n.set(1 / 0, 1 / 0, 1 / 0),
            o.set( - (1 / 0), -(1 / 0), -(1 / 0));
            for (var f = 0; 8 > f; f++) {
                var g = e[f];
                g.copy(d[f]),
                ad.__projector.unprojectVector(g, a),
                g.applyMatrix4(c.worldMatrixInverse),
                g.x < n.x && (n.x = g.x),
                g.x > o.x && (o.x = g.x),
                g.y < n.y && (n.y = g.y),
                g.y > o.y && (o.y = g.y),
                g.z < n.z && (n.z = g.z),
                g.z > o.z && (o.z = g.z)
            }
            c.left = n.x,
            c.right = o.x,
            c.top = o.y,
            c.bottom = n.y,
            c.updateProjectionMatrix()
        }
        function d(a) {
            return a.material instanceof Yb.ArrayMaterial ? a.material.materials[0] : a.material
        }
        var f, g, h, i, j, k, l = new Yb.Frustum,
        m = new Yb.Mat4,
        n = new Yb.Vec3,
        o = new Yb.Vec3,
        p = new Yb.Vec3;
        this.init = function(a) {
            f = a._gl,
            g = a;
            var b = Yb.ShaderLib.depthRGBA,
            c = Yb.UniformsUtils.clone(b.uniforms);
            h = new Zc({
                fragmentShader: b.fragmentShader,
                vertexShader: b.vertexShader,
                uniforms: c
            }),
            _depthCubeMaterial = new Zc({
                fragmentShader: b.fragmentShader,
                vertexShader: b.vertexShader,
                uniforms: c,
                refreshUniformsCommon: function(a) {
                    this.uniforms.isCube.value = 1
                }
            }),
            i = new Zc({
                fragmentShader: b.fragmentShader,
                vertexShader: b.vertexShader,
                uniforms: c,
                morphTargets: !0
            }),
            j = new Zc({
                fragmentShader: b.fragmentShader,
                vertexShader: b.vertexShader,
                uniforms: c,
                skinning: !0
            }),
            k = new Zc({
                fragmentShader: b.fragmentShader,
                vertexShader: b.vertexShader,
                uniforms: c,
                morphTargets: !0,
                skinning: !0
            }),
            h._shadowPass = !0,
            i._shadowPass = !0,
            j._shadowPass = !0,
            k._shadowPass = !0
        },
        this.render = function(a, b) {
            g._shadowMapEnable && this.update(a, b)
        },
        this.update = function(n, o) {
            var q, r, s, t, u, v, w, x, y, z, A, B, C, D, E = [],
            F = 0;
            f.clearColor(1, 1, 1, 1),
            f.disable(f.BLEND),
            f.enable(f.CULL_FACE),
            f.frontFace(f.CCW),
            g.shadowMapCullFace === Yb.CullFaceFront ? f.cullFace(f.FRONT) : f.cullFace(f.BACK),
            g.setDepthTest(!0);
            var G = n.getLights();
            for (q = 0, r = G.size(); r > q; q++) if (C = G.get(q), C.castShadow) if (C instanceof Yb.DirectionalLight && C.shadowCascade) for (u = 0; u < C.shadowCascadeCount; u++) {
                var H;
                if (C.shadowCascadeArray[u]) H = C.shadowCascadeArray[u];
                else {
                    H = a(C, u),
                    H.originalCamera = o;
                    var I = new _c;
                    I.position = C.shadowCascadeOffset,
                    I.add(H),
                    I.add(H.target),
                    o.add(I),
                    C.shadowCascadeArray[u] = H
                }
                b(C, u),
                E[F] = H,
                F++
            } else E[F] = C,
            F++;
            for (q = 0, r = E.length; r > q; q++) {
                if (C = E[q], !C.shadowMap) {
                    var J = Yb.LinearFilter;
                    g.shadowMapType === Yb.PCFSoftShadowMap && (J = Yb.NearestFilter);
                    var K = {
                        minFilter: J,
                        magFilter: J,
                        format: Yb.RGBAFormat
                    };
                    C instanceof Yb.PointLight ? (C.shadowMap = new yc(C.shadowMapWidth, C.shadowMapHeight, K), C.shadowMapSize = new Zb(C.shadowMapWidth, C.shadowMapHeight), C.shadowMatrix = new Yb.Mat4) : (C.shadowMap = new xc(C.shadowMapWidth, C.shadowMapHeight, K), C.shadowMapSize = new Zb(C.shadowMapWidth, C.shadowMapHeight), C.shadowMatrix = new Yb.Mat4)
                }
                if (!C.shadowCamera) {
                    if (C instanceof Yb.SpotLight) C.shadowCamera = new Yb.PerspectiveCamera(C.shadowCameraFov, C.shadowMapWidth / C.shadowMapHeight, C.shadowCameraNear, C.shadowCameraFar);
                    else if (C instanceof Yb.DirectionalLight) C.shadowCamera = new Yb.OrthoCamera(C.shadowCameraLeft, C.shadowCameraRight, C.shadowCameraTop, C.shadowCameraBottom, C.shadowCameraNear, C.shadowCameraFar);
                    else {
                        if (! (C instanceof Yb.PointLight)) {
                            console.error("Unsupported light type for shadow");
                            continue
                        }
                        C.shadowCamera = new Yb.PerspectiveCamera(90, 1, C.shadowCameraNear, C.shadowCameraFar)
                    }
                    C.shadowCamera.updateWorldMatrix();
                    for (var L, M = n.getRoots(), N = M.size(), O = 0; N > O; O++) L = M.get(O),
                    L.updateWorldMatrix()
                }
                C.shadowCameraVisible && !C.cameraHelper && (C.cameraHelper = new Yb.CameraHelper(C.shadowCamera), C.shadowCamera.addChild(C.cameraHelper), C.shadowCamera.updateWorldMatrix(!0), g.helperBox.add(C.shadowCamera), g.helperBox.add(C.cameraHelper)),
                C.isVirtual && H.originalCamera == o && c(o, C);
                for (var P = C instanceof Yb.PointLight ? 6 : 1, Q = [new $b(1, 0, 0), new $b( - 1, 0, 0), new $b(0, 1, 0), new $b(0, -1, 0), new $b(0, 0, 1), new $b(0, 0, -1)], F = 0; P > F; F++) if (null == C.debugFace || F == C.debugFace) {
                    for (v = C.shadowMap, w = C.shadowMatrix, x = C.shadowCamera, x._position.setFromMatrixPosition(C.worldMatrix), C.target ? p.setFromMatrixPosition(C.target.worldMatrix) : p = x._position.clone().add(Q[F]), x.lookAt(p), x.updateWorldMatrix(!0), x.worldMatrixInverse.getInverse(x.worldMatrix), C.cameraHelper && (C.cameraHelper.visible = C.shadowCameraVisible), C.shadowCameraVisible && C.cameraHelper.update(), w.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), w.multiply(x.projectionMatrix), w.multiply(x.worldMatrixInverse), m.multiplyMatrices(x.projectionMatrix, x.worldMatrixInverse), l.setFromMatrix(m), v.activeCubeFace = F, g.debugPointLight == e && g.setRenderTarget(v), g.clear(), D = g.glNodeList, s = 0, t = D.length; t > s; s++) A = D[s],
                    B = A.node,
                    A.render = !1,
                    B._visible && B.castShadow && (!(B instanceof Yb.Node || B instanceof Yb.Particle) || !B.frustumCulled || l.intersectsObject(B)) && (B._modelViewMatrix.multiplyMatrices(x.worldMatrixInverse, B.worldMatrix), A.render = !0);
                    var R, S, T;
                    for (s = 0, t = D.length; t > s; s++) A = D[s],
                    A.render && (B = A.node, y = A.group, R = d(B), S = !1, T = !1, z = B.customDepthMaterial ? B.customDepthMaterial: T ? S ? k: j: S ? i: 1 == P ? h: _depthCubeMaterial, B instanceof Yb.BufferNode || g.renderGroup(x, n.getLights(), z, y, B))
                }
            }
            var U = g.getClearColor(),
            V = g.getClearAlpha();
            f.clearColor(U.r, U.g, U.b, V),
            f.enable(f.BLEND),
            g.shadowMapCullFace === Yb.CullFaceFront && f.cullFace(f.BACK)
        }
    };
    ad.__projector = new Yb.Projector,
    Yb.Picking = function(a, b, c, d, e, f) {
        this.network = f,
        this.origin = a,
        this.cameraUp = c,
        this.direction = b,
        this.near = d || 0,
        this.far = e || 1 / 0,
        this.ray = new Yb.Ray(a, b),
        this.ray.direction.length > 0 && this.ray.direction.normalize()
    },
    Yb.Picking.testPlane = new Yb.Plane(1, 1),
    Yb.Picking.prototype = {
        constructor: Yb.Picking,
        precision: 1e-4,
        linePrecision: 2,
        matrixPosition: new Yb.Vec3,
        set: function(a, b) {
            this.origin = a,
            this.direction = b,
            this.ray.set(a, b),
            this.ray.direction.length > 0 && this.ray.direction.normalize()
        },
        intersectObject: function(a, b, c) {
            var d = [];
            return b === !0 && Ob(a, this, d, c),
            Nb(a, this, d, c),
            d.sort(Mb),
            d
        },
        intersectObjects: function(a, b, c) {
            a._as && (a = a._as);
            for (var d = [], e = 0, f = a.length; f > e; e++) Nb(a[e], this, d, c, this.network),
            b === !0 && Ob(a[e], this, d, c, this.network);
            return d.sort(Mb),
            d
        }
    };
    var bd = new Yb.Ray,
    cd = new Yb.Mat4,
    dd = new Yb.math.Plane,
    ed = new Yb.Vec3,
    fd = new Yb.BoundingSphere,
    gd = function(a) {
        arguments.length > 0 && this.init(a)
    };
    gd.prototype.init = function(a) {
        this.status = a,
        this.points = new Array
    },
    gd.prototype.appendPoint = function(a) {
        this.points.push(a)
    },
    gd.prototype.appendPoints = function(a) {
        this.points = this.points.concat(a)
    },
    gd.intersectShapes = function(a, b) {
        var c, d = a.getIntersectionParams(),
        e = b.getIntersectionParams();
        if (null != d && null != e) if ("Path" == d.name) c = gd.intersectPathShape(a, b);
        else if ("Path" == e.name) c = gd.intersectPathShape(b, a);
        else {
            var f, g;
            if (d.name < e.name ? (f = "intersect" + d.name + e.name, g = d.params.concat(e.params)) : (f = "intersect" + e.name + d.name, g = e.params.concat(d.params)), !(f in gd)) throw new Error("Intersection not available: " + f);
            c = gd[f].apply(null, g)
        } else c = new gd("No Intersection");
        return c
    },
    gd.intersectPathShape = function(a, b) {
        return a.intersectShape(b)
    },
    gd.intersectBezier2Bezier2 = function(a, b, c, d, e, f) {
        var g, h, i, j, k, l, m, n, o, p = new gd("No Intersection");
        if (g = b.multiply( - 2), i = a.add(g.add(c)), g = a.multiply( - 2), h = b.multiply(2), j = g.add(h), k = new Zb(a.x, a.y), g = e.multiply( - 2), l = d.add(g.add(f)), g = d.multiply( - 2), h = e.multiply(2), m = g.add(h), n = new Zb(d.x, d.y), 0 == i.y) {
            var q = i.x * (k.y - n.y),
            r = q - j.x * j.y,
            s = q + r,
            t = j.y * j.y;
            o = new Polynomial(i.x * l.y * l.y, 2 * i.x * m.y * l.y, i.x * m.y * m.y - l.x * t - l.y * q - l.y * r, -m.x * t - m.y * q - m.y * r, (k.x - n.x) * t + (k.y - n.y) * r)
        } else {
            var q = i.x * l.y - i.y * l.x,
            r = i.x * m.y - m.x * i.y,
            s = j.x * i.y - j.y * i.x,
            t = k.y - n.y,
            u = i.y * (k.x - n.x) - i.x * t,
            v = -j.y * s + i.y * u,
            w = s * s;
            o = new Polynomial(q * q, 2 * q * r, ( - l.y * w + i.y * r * r + i.y * q * u + q * v) / i.y, ( - m.y * w + i.y * r * u + r * v) / i.y, (t * w + u * v) / i.y)
        }
        for (var x = o.getRoots(), y = 0; y < x.length; y++) {
            var z = x[y];
            if (z >= 0 && 1 >= z) {
                var A = new Polynomial(i.x, j.x, k.x - n.x - z * m.x - z * z * l.x).getRoots(),
                B = new Polynomial(i.y, j.y, k.y - n.y - z * m.y - z * z * l.y).getRoots();
                if (A.length > 0 && B.length > 0) {
                    var C = 1e-4;
                    a: for (var D = 0; D < A.length; D++) {
                        var E = A[D];
                        if (E >= 0 && 1 >= E) for (var F = 0; F < B.length; F++) if (Math.abs(E - B[F]) < C) {
                            p.points.push(l.multiply(z * z).add(m.multiply(z).add(n)));
                            break a
                        }
                    }
                }
            }
        }
        return p.points.length > 0 && (p.status = "$Intersection"),
        p
    },
    gd.intersectBezier2Bezier3 = function(a, b, c, d, e, f, g) {
        var h, i, j, k, l, m, n, o, p, q, r, s = new gd("No Intersection");
        h = b.multiply( - 2),
        l = a.add(h.add(c)),
        h = a.multiply( - 2),
        i = b.multiply(2),
        m = h.add(i),
        n = new Zb(a.x, a.y),
        h = d.multiply( - 1),
        i = e.multiply(3),
        j = f.multiply( - 3),
        k = h.add(i.add(j.add(g))),
        o = new Vector2D(k.x, k.y),
        h = d.multiply(3),
        i = e.multiply( - 6),
        j = f.multiply(3),
        k = h.add(i.add(j)),
        p = new Vector2D(k.x, k.y),
        h = d.multiply( - 3),
        i = e.multiply(3),
        j = h.add(i),
        q = new Vector2D(j.x, j.y),
        r = new Vector2D(d.x, d.y);
        for (var t = n.x * n.x,
        u = n.y * n.y,
        v = m.x * m.x,
        w = m.y * m.y,
        x = l.x * l.x,
        y = l.y * l.y,
        z = r.x * r.x,
        A = r.y * r.y,
        B = q.x * q.x,
        C = q.y * q.y,
        D = p.x * p.x,
        E = p.y * p.y,
        F = o.x * o.x,
        G = o.y * o.y,
        H = new Polynomial( - 2 * l.x * l.y * o.x * o.y + x * G + y * F, -2 * l.x * l.y * p.x * o.y - 2 * l.x * l.y * p.y * o.x + 2 * y * p.x * o.x + 2 * x * p.y * o.y, -2 * l.x * q.x * l.y * o.y - 2 * l.x * l.y * q.y * o.x - 2 * l.x * l.y * p.x * p.y + 2 * q.x * y * o.x + y * D + x * (2 * q.y * o.y + E), 2 * n.x * l.x * l.y * o.y + 2 * n.y * l.x * l.y * o.x + m.x * m.y * l.x * o.y + m.x * m.y * l.y * o.x - 2 * r.x * l.x * l.y * o.y - 2 * l.x * r.y * l.y * o.x - 2 * l.x * q.x * l.y * p.y - 2 * l.x * l.y * q.y * p.x - 2 * n.x * y * o.x - 2 * n.y * x * o.y + 2 * r.x * y * o.x + 2 * q.x * y * p.x - w * l.x * o.x - v * l.y * o.y + x * (2 * r.y * o.y + 2 * q.y * p.y), 2 * n.x * l.x * l.y * p.y + 2 * n.y * l.x * l.y * p.x + m.x * m.y * l.x * p.y + m.x * m.y * l.y * p.x - 2 * r.x * l.x * l.y * p.y - 2 * l.x * r.y * l.y * p.x - 2 * l.x * q.x * l.y * q.y - 2 * n.x * y * p.x - 2 * n.y * x * p.y + 2 * r.x * y * p.x - w * l.x * p.x - v * l.y * p.y + B * y + x * (2 * r.y * p.y + C), 2 * n.x * l.x * l.y * q.y + 2 * n.y * l.x * q.x * l.y + m.x * m.y * l.x * q.y + m.x * m.y * q.x * l.y - 2 * r.x * l.x * l.y * q.y - 2 * l.x * r.y * q.x * l.y - 2 * n.x * q.x * y - 2 * n.y * x * q.y + 2 * r.x * q.x * y - w * l.x * q.x - v * l.y * q.y + 2 * x * r.y * q.y, -2 * n.x * n.y * l.x * l.y - n.x * m.x * m.y * l.y - n.y * m.x * m.y * l.x + 2 * n.x * l.x * r.y * l.y + 2 * n.y * r.x * l.x * l.y + m.x * r.x * m.y * l.y + m.x * m.y * l.x * r.y - 2 * r.x * l.x * r.y * l.y - 2 * n.x * r.x * y + n.x * w * l.x + n.y * v * l.y - 2 * n.y * x * r.y - r.x * w * l.x - v * r.y * l.y + t * y + u * x + z * y + x * A), I = H.getRootsInInterval(0, 1), J = 0; J < I.length; J++) {
            var K = I[J],
            L = new Polynomial(l.x, m.x, n.x - r.x - K * q.x - K * K * p.x - K * K * K * o.x).getRoots(),
            M = new Polynomial(l.y, m.y, n.y - r.y - K * q.y - K * K * p.y - K * K * K * o.y).getRoots();
            if (L.length > 0 && M.length > 0) {
                var N = 1e-4;
                a: for (var O = 0; O < L.length; O++) {
                    var P = L[O];
                    if (P >= 0 && 1 >= P) for (var Q = 0; Q < M.length; Q++) if (Math.abs(P - M[Q]) < N) {
                        s.points.push(o.multiply(K * K * K).add(p.multiply(K * K).add(q.multiply(K).add(r))));
                        break a
                    }
                }
            }
        }
        return s.points.length > 0 && (s.status = "Intersection"),
        s
    },
    gd.intersectBezier2Circle = function(a, b, c, d, e) {
        return gd.intersectBezier2Ellipse(a, b, c, d, e, e)
    },
    gd.intersectBezier2Ellipse = function(a, b, c, d, e, f) {
        var g, h, i, j, k, l = new gd("No Intersection");
        g = b.multiply( - 2),
        i = a.add(g.add(c)),
        g = a.multiply( - 2),
        h = b.multiply(2),
        j = g.add(h),
        k = new Zb(a.x, a.y);
        for (var m = e * e,
        n = f * f,
        o = new Polynomial(n * i.x * i.x + m * i.y * i.y, 2 * (n * i.x * j.x + m * i.y * j.y), n * (2 * i.x * k.x + j.x * j.x) + m * (2 * i.y * k.y + j.y * j.y) - 2 * (n * d.x * i.x + m * d.y * i.y), 2 * (n * j.x * (k.x - d.x) + m * j.y * (k.y - d.y)), n * (k.x * k.x + d.x * d.x) + m * (k.y * k.y + d.y * d.y) - 2 * (n * d.x * k.x + m * d.y * k.y) - m * n).getRoots(), p = 0; p < o.length; p++) {
            var q = o[p];
            q >= 0 && 1 >= q && l.points.push(i.multiply(q * q).add(j.multiply(q).add(k)))
        }
        return l.points.length > 0 && (l.status = "Intersection"),
        l
    },
    gd.intersectBezier2Line = function(a, b, c, d, e) {
        var f, g, h, i, j, k, l, m = d.min(e),
        n = d.max(e),
        o = new gd("No Intersection");
        f = b.multiply( - 2),
        h = a.add(f.add(c)),
        f = a.multiply( - 2),
        g = b.multiply(2),
        i = f.add(g),
        j = new Zb(a.x, a.y),
        l = new Vector2D(d.y - e.y, e.x - d.x),
        k = d.x * e.y - e.x * d.y,
        roots = new Polynomial(l.dot(h), l.dot(i), l.dot(j) + k).getRoots();
        for (var p = 0; p < roots.length; p++) {
            var q = roots[p];
            if (q >= 0 && 1 >= q) {
                var r = a.lerp(b, q),
                s = b.lerp(c, q),
                t = r.lerp(s, q);
                d.x == e.x ? m.y <= t.y && t.y <= n.y && (o.status = "Intersection", o.appendPoint(t)) : d.y == e.y ? m.x <= t.x && t.x <= n.x && (o.status = "Intersection", o.appendPoint(t)) : t.gte(m) && t.lte(n) && (o.status = "Intersection", o.appendPoint(t))
            }
        }
        return o
    },
    gd.intersectBezier2Polygon = function(a, b, c, d) {
        for (var e = new gd("No Intersection"), f = d.length, g = 0; f > g; g++) {
            var h = d[g],
            i = d[(g + 1) % f],
            j = gd.intersectBezier2Line(a, b, c, h, i);
            e.appendPoints(j.points)
        }
        return e.points.length > 0 && (e.status = "Intersection"),
        e
    },
    gd.intersectBezier2Rectangle = function(a, b, c, d, e) {
        var f = d.min(e),
        g = d.max(e),
        h = new Zb(g.x, f.y),
        i = new Zb(f.x, g.y),
        j = gd.intersectBezier2Line(a, b, c, f, h),
        k = gd.intersectBezier2Line(a, b, c, h, g),
        l = gd.intersectBezier2Line(a, b, c, g, i),
        m = gd.intersectBezier2Line(a, b, c, i, f),
        n = new gd("No Intersection");
        return n.appendPoints(j.points),
        n.appendPoints(k.points),
        n.appendPoints(l.points),
        n.appendPoints(m.points),
        n.points.length > 0 && (n.status = "Intersection"),
        n
    },
    gd.intersectBezier3Bezier3 = function(a, b, c, d, e, f, g, h) {
        var i, j, k, l, m, n, o, p, q, r, s, t, u = new gd("No Intersection");
        i = a.multiply( - 1),
        j = b.multiply(3),
        k = c.multiply( - 3),
        l = i.add(j.add(k.add(d))),
        m = new Vector2D(l.x, l.y),
        i = a.multiply(3),
        j = b.multiply( - 6),
        k = c.multiply(3),
        l = i.add(j.add(k)),
        n = new Vector2D(l.x, l.y),
        i = a.multiply( - 3),
        j = b.multiply(3),
        k = i.add(j),
        o = new Vector2D(k.x, k.y),
        p = new Vector2D(a.x, a.y),
        i = e.multiply( - 1),
        j = f.multiply(3),
        k = g.multiply( - 3),
        l = i.add(j.add(k.add(h))),
        q = new Vector2D(l.x, l.y),
        i = e.multiply(3),
        j = f.multiply( - 6),
        k = g.multiply(3),
        l = i.add(j.add(k)),
        r = new Vector2D(l.x, l.y),
        i = e.multiply( - 3),
        j = f.multiply(3),
        k = i.add(j),
        s = new Vector2D(k.x, k.y),
        t = new Vector2D(e.x, e.y);
        for (var v = p.x * p.x,
        w = p.x * p.x * p.x,
        x = p.y * p.y,
        y = p.y * p.y * p.y,
        z = o.x * o.x,
        A = o.x * o.x * o.x,
        B = o.y * o.y,
        C = o.y * o.y * o.y,
        D = n.x * n.x,
        E = n.x * n.x * n.x,
        F = n.y * n.y,
        G = n.y * n.y * n.y,
        H = m.x * m.x,
        I = m.x * m.x * m.x,
        J = m.y * m.y,
        K = m.y * m.y * m.y,
        L = t.x * t.x,
        M = t.x * t.x * t.x,
        N = t.y * t.y,
        O = t.y * t.y * t.y,
        P = s.x * s.x,
        Q = s.x * s.x * s.x,
        R = s.y * s.y,
        S = r.x * r.x,
        T = r.x * r.x * r.x,
        U = r.y * r.y,
        V = q.x * q.x,
        W = q.x * q.x * q.x,
        X = q.y * q.y,
        Y = q.y * q.y * q.y,
        Z = new Polynomial( - I * Y + K * W - 3 * m.x * J * V * q.y + 3 * H * m.y * q.x * X, -6 * m.x * r.x * J * q.x * q.y + 6 * H * m.y * r.y * q.x * q.y + 3 * r.x * K * V - 3 * I * r.y * X - 3 * m.x * J * r.y * V + 3 * H * r.x * m.y * X, -6 * s.x * m.x * J * q.x * q.y - 6 * m.x * r.x * J * r.y * q.x + 6 * H * r.x * m.y * r.y * q.y + 3 * s.x * K * V + 3 * S * K * q.x + 3 * s.x * H * m.y * X - 3 * m.x * s.y * J * V - 3 * m.x * S * J * q.y + H * m.y * q.x * (6 * s.y * q.y + 3 * U) + I * ( - s.y * X - 2 * U * q.y - q.y * (2 * s.y * q.y + U)), o.x * n.y * m.x * m.y * q.x * q.y - o.y * n.x * m.x * m.y * q.x * q.y + 6 * s.x * r.x * K * q.x + 3 * o.x * n.x * m.x * m.y * X + 6 * p.x * m.x * J * q.x * q.y - 3 * o.x * n.x * J * q.x * q.y - 3 * o.y * n.y * m.x * m.y * V - 6 * p.y * H * m.y * q.x * q.y - 6 * t.x * m.x * J * q.x * q.y + 3 * o.y * n.y * H * q.x * q.y - 2 * n.x * F * m.x * q.x * q.y - 6 * s.x * m.x * r.x * J * q.y - 6 * s.x * m.x * J * r.y * q.x - 6 * m.x * s.y * r.x * J * q.x + 6 * s.x * H * m.y * r.y * q.y + 2 * D * n.y * m.y * q.x * q.y + T * K - 3 * p.x * K * V + 3 * p.y * I * X + 3 * t.x * K * V + G * m.x * V - E * m.y * X - 3 * p.x * H * m.y * X + 3 * p.y * m.x * J * V - 2 * o.x * n.y * H * X + o.x * n.y * J * V - o.y * n.x * H * X + 2 * o.y * n.x * J * V + 3 * t.x * H * m.y * X - n.x * F * m.y * V - 3 * t.y * m.x * J * V + D * n.y * m.x * X - 3 * m.x * S * J * r.y + H * m.y * q.x * (6 * t.y * q.y + 6 * s.y * r.y) + H * r.x * m.y * (6 * s.y * q.y + 3 * U) + I * ( - 2 * s.y * r.y * q.y - t.y * X - r.y * (2 * s.y * q.y + U) - q.y * (2 * t.y * q.y + 2 * s.y * r.y)), 6 * o.x * n.x * m.x * m.y * r.y * q.y + o.x * n.y * m.x * r.x * m.y * q.y + o.x * n.y * m.x * m.y * r.y * q.x - o.y * n.x * m.x * r.x * m.y * q.y - o.y * n.x * m.x * m.y * r.y * q.x - 6 * o.y * n.y * m.x * r.x * m.y * q.x - 6 * p.x * r.x * K * q.x + 6 * t.x * r.x * K * q.x + 6 * p.y * I * r.y * q.y + 2 * G * m.x * r.x * q.x - 2 * E * m.y * r.y * q.y + 6 * p.x * m.x * r.x * J * q.y + 6 * p.x * m.x * J * r.y * q.x + 6 * p.y * m.x * r.x * J * q.x - 3 * o.x * n.x * r.x * J * q.y - 3 * o.x * n.x * J * r.y * q.x + 2 * o.x * n.y * r.x * J * q.x + 4 * o.y * n.x * r.x * J * q.x - 6 * p.x * H * m.y * r.y * q.y - 6 * p.y * H * r.x * m.y * q.y - 6 * p.y * H * m.y * r.y * q.x - 4 * o.x * n.y * H * r.y * q.y - 6 * t.x * m.x * r.x * J * q.y - 6 * t.x * m.x * J * r.y * q.x - 2 * o.y * n.x * H * r.y * q.y + 3 * o.y * n.y * H * r.x * q.y + 3 * o.y * n.y * H * r.y * q.x - 2 * n.x * F * m.x * r.x * q.y - 2 * n.x * F * m.x * r.y * q.x - 2 * n.x * F * r.x * m.y * q.x - 6 * t.y * m.x * r.x * J * q.x - 6 * s.x * m.x * s.y * J * q.x - 6 * s.x * m.x * r.x * J * r.y + 6 * t.x * H * m.y * r.y * q.y + 2 * D * n.y * m.x * r.y * q.y + 2 * D * n.y * r.x * m.y * q.y + 2 * D * n.y * m.y * r.y * q.x + 3 * s.x * S * K + 3 * P * K * q.x - 3 * m.x * s.y * S * J - 3 * P * m.x * J * q.y + H * r.x * m.y * (6 * t.y * q.y + 6 * s.y * r.y) + H * m.y * q.x * (6 * t.y * r.y + 3 * R) + s.x * H * m.y * (6 * s.y * q.y + 3 * U) + I * ( - 2 * t.y * r.y * q.y - q.y * (2 * t.y * r.y + R) - s.y * (2 * s.y * q.y + U) - r.y * (2 * t.y * q.y + 2 * s.y * r.y)), o.x * s.x * n.y * m.x * m.y * q.y + o.x * n.y * m.x * s.y * m.y * q.x + o.x * n.y * m.x * r.x * m.y * r.y - o.y * n.x * s.x * m.x * m.y * q.y - o.y * n.x * m.x * s.y * m.y * q.x - o.y * n.x * m.x * r.x * m.y * r.y - 6 * o.y * s.x * n.y * m.x * m.y * q.x - 6 * p.x * s.x * K * q.x + 6 * t.x * s.x * K * q.x + 2 * s.x * G * m.x * q.x + 6 * p.x * s.x * m.x * J * q.y + 6 * p.x * m.x * s.y * J * q.x + 6 * p.x * m.x * r.x * J * r.y + 6 * p.y * s.x * m.x * J * q.x - 3 * o.x * n.x * s.x * J * q.y - 3 * o.x * n.x * s.y * J * q.x - 3 * o.x * n.x * r.x * J * r.y + 2 * o.x * s.x * n.y * J * q.x + 4 * o.y * n.x * s.x * J * q.x - 6 * p.y * s.x * H * m.y * q.y - 6 * p.y * H * s.y * m.y * q.x - 6 * p.y * H * r.x * m.y * r.y - 6 * t.x * s.x * m.x * J * q.y - 6 * t.x * m.x * s.y * J * q.x - 6 * t.x * m.x * r.x * J * r.y + 3 * o.y * s.x * n.y * H * q.y - 3 * o.y * n.y * m.x * S * m.y + 3 * o.y * n.y * H * s.y * q.x + 3 * o.y * n.y * H * r.x * r.y - 2 * n.x * s.x * F * m.x * q.y - 2 * n.x * s.x * F * m.y * q.x - 2 * n.x * F * m.x * s.y * q.x - 2 * n.x * F * m.x * r.x * r.y - 6 * t.y * s.x * m.x * J * q.x - 6 * s.x * m.x * s.y * r.x * J + 6 * t.y * H * s.y * m.y * q.x + 2 * D * s.x * n.y * m.y * q.y + 2 * D * n.y * s.y * m.y * q.x + 2 * D * n.y * r.x * m.y * r.y - 3 * p.x * S * K + 3 * t.x * S * K + 3 * P * r.x * K + G * m.x * S + 3 * p.y * m.x * S * J + o.x * n.y * S * J + 2 * o.y * n.x * S * J - n.x * F * S * m.y - 3 * t.y * m.x * S * J - 3 * P * m.x * J * r.y + D * n.y * m.x * (2 * s.y * q.y + U) + o.x * n.x * m.x * m.y * (6 * s.y * q.y + 3 * U) + s.x * H * m.y * (6 * t.y * q.y + 6 * s.y * r.y) + E * m.y * ( - 2 * s.y * q.y - U) + p.y * I * (6 * s.y * q.y + 3 * U) + o.y * n.x * H * ( - 2 * s.y * q.y - U) + o.x * n.y * H * ( - 4 * s.y * q.y - 2 * U) + p.x * H * m.y * ( - 6 * s.y * q.y - 3 * U) + H * r.x * m.y * (6 * t.y * r.y + 3 * R) + t.x * H * m.y * (6 * s.y * q.y + 3 * U) + I * ( - 2 * t.y * s.y * q.y - r.y * (2 * t.y * r.y + R) - t.y * (2 * s.y * q.y + U) - s.y * (2 * t.y * q.y + 2 * s.y * r.y)), -p.x * o.x * n.y * m.x * m.y * q.y + p.x * o.y * n.x * m.x * m.y * q.y + 6 * p.x * o.y * n.y * m.x * m.y * q.x - 6 * p.y * o.x * n.x * m.x * m.y * q.y - p.y * o.x * n.y * m.x * m.y * q.x + p.y * o.y * n.x * m.x * m.y * q.x + o.x * o.y * n.x * n.y * m.x * q.y - o.x * o.y * n.x * n.y * m.y * q.x + o.x * t.x * n.y * m.x * m.y * q.y + o.x * t.y * n.y * m.x * m.y * q.x + o.x * s.x * n.y * m.x * m.y * r.y + o.x * n.y * m.x * s.y * r.x * m.y - t.x * o.y * n.x * m.x * m.y * q.y - 6 * t.x * o.y * n.y * m.x * m.y * q.x - o.y * n.x * t.y * m.x * m.y * q.x - o.y * n.x * s.x * m.x * m.y * r.y - o.y * n.x * m.x * s.y * r.x * m.y - 6 * o.y * s.x * n.y * m.x * r.x * m.y - 6 * p.x * t.x * K * q.x - 6 * p.x * s.x * r.x * K - 2 * p.x * G * m.x * q.x + 6 * t.x * s.x * r.x * K + 2 * t.x * G * m.x * q.x + 2 * s.x * G * m.x * r.x + 2 * p.y * E * m.y * q.y - 6 * p.x * p.y * m.x * J * q.x + 3 * p.x * o.x * n.x * J * q.y - 2 * p.x * o.x * n.y * J * q.x - 4 * p.x * o.y * n.x * J * q.x + 3 * p.y * o.x * n.x * J * q.x + 6 * p.x * p.y * H * m.y * q.y + 6 * p.x * t.x * m.x * J * q.y - 3 * p.x * o.y * n.y * H * q.y + 2 * p.x * n.x * F * m.x * q.y + 2 * p.x * n.x * F * m.y * q.x + 6 * p.x * t.y * m.x * J * q.x + 6 * p.x * s.x * m.x * J * r.y + 6 * p.x * m.x * s.y * r.x * J + 4 * p.y * o.x * n.y * H * q.y + 6 * p.y * t.x * m.x * J * q.x + 2 * p.y * o.y * n.x * H * q.y - 3 * p.y * o.y * n.y * H * q.x + 2 * p.y * n.x * F * m.x * q.x + 6 * p.y * s.x * m.x * r.x * J - 3 * o.x * t.x * n.x * J * q.y + 2 * o.x * t.x * n.y * J * q.x + o.x * o.y * F * m.x * q.x - 3 * o.x * n.x * t.y * J * q.x - 3 * o.x * n.x * s.x * J * r.y - 3 * o.x * n.x * s.y * r.x * J + 2 * o.x * s.x * n.y * r.x * J + 4 * t.x * o.y * n.x * J * q.x + 4 * o.y * n.x * s.x * r.x * J - 2 * p.x * D * n.y * m.y * q.y - 6 * p.y * t.x * H * m.y * q.y - 6 * p.y * t.y * H * m.y * q.x - 6 * p.y * s.x * H * m.y * r.y - 2 * p.y * D * n.y * m.x * q.y - 2 * p.y * D * n.y * m.y * q.x - 6 * p.y * H * s.y * r.x * m.y - o.x * o.y * D * m.y * q.y - 2 * o.x * B * m.x * m.y * q.x + 3 * t.x * o.y * n.y * H * q.y - 2 * t.x * n.x * F * m.x * q.y - 2 * t.x * n.x * F * m.y * q.x - 6 * t.x * t.y * m.x * J * q.x - 6 * t.x * s.x * m.x * J * r.y - 6 * t.x * m.x * s.y * r.x * J + 3 * o.y * t.y * n.y * H * q.x + 3 * o.y * s.x * n.y * H * r.y + 3 * o.y * n.y * H * s.y * r.x - 2 * n.x * t.y * F * m.x * q.x - 2 * n.x * s.x * F * m.x * r.y - 2 * n.x * s.x * F * r.x * m.y - 2 * n.x * F * m.x * s.y * r.x - 6 * t.y * s.x * m.x * r.x * J - B * n.x * n.y * m.x * q.x + 2 * t.x * D * n.y * m.y * q.y + 6 * t.y * H * s.y * r.x * m.y + 2 * z * o.y * m.x * m.y * q.y + z * n.x * n.y * m.y * q.y + 2 * D * t.y * n.y * m.y * q.x + 2 * D * s.x * n.y * m.y * r.y + 2 * D * n.y * s.y * r.x * m.y + Q * K + 3 * v * K * q.x - 3 * x * I * q.y + 3 * L * K * q.x + C * H * q.x - A * J * q.y - o.x * B * H * q.y + z * o.y * J * q.x - 3 * v * m.x * J * q.y + 3 * x * H * m.y * q.x - z * F * m.x * q.y + B * D * m.y * q.x - 3 * P * m.x * s.y * J - 3 * L * m.x * J * q.y + 3 * N * H * m.y * q.x + o.x * n.x * m.x * m.y * (6 * t.y * q.y + 6 * s.y * r.y) + E * m.y * ( - 2 * t.y * q.y - 2 * s.y * r.y) + p.y * I * (6 * t.y * q.y + 6 * s.y * r.y) + o.y * n.x * H * ( - 2 * t.y * q.y - 2 * s.y * r.y) + D * n.y * m.x * (2 * t.y * q.y + 2 * s.y * r.y) + o.x * n.y * H * ( - 4 * t.y * q.y - 4 * s.y * r.y) + p.x * H * m.y * ( - 6 * t.y * q.y - 6 * s.y * r.y) + t.x * H * m.y * (6 * t.y * q.y + 6 * s.y * r.y) + s.x * H * m.y * (6 * t.y * r.y + 3 * R) + I * ( - 2 * t.y * s.y * r.y - N * q.y - s.y * (2 * t.y * r.y + R) - t.y * (2 * t.y * q.y + 2 * s.y * r.y)), -p.x * o.x * n.y * m.x * m.y * r.y + p.x * o.y * n.x * m.x * m.y * r.y + 6 * p.x * o.y * n.y * m.x * r.x * m.y - 6 * p.y * o.x * n.x * m.x * m.y * r.y - p.y * o.x * n.y * m.x * r.x * m.y + p.y * o.y * n.x * m.x * r.x * m.y + o.x * o.y * n.x * n.y * m.x * r.y - o.x * o.y * n.x * n.y * r.x * m.y + o.x * t.x * n.y * m.x * m.y * r.y + o.x * t.y * n.y * m.x * r.x * m.y + o.x * s.x * n.y * m.x * s.y * m.y - t.x * o.y * n.x * m.x * m.y * r.y - 6 * t.x * o.y * n.y * m.x * r.x * m.y - o.y * n.x * t.y * m.x * r.x * m.y - o.y * n.x * s.x * m.x * s.y * m.y - 6 * p.x * t.x * r.x * K - 2 * p.x * G * m.x * r.x + 2 * t.x * G * m.x * r.x + 2 * p.y * E * m.y * r.y - 6 * p.x * p.y * m.x * r.x * J + 3 * p.x * o.x * n.x * J * r.y - 2 * p.x * o.x * n.y * r.x * J - 4 * p.x * o.y * n.x * r.x * J + 3 * p.y * o.x * n.x * r.x * J + 6 * p.x * p.y * H * m.y * r.y + 6 * p.x * t.x * m.x * J * r.y - 3 * p.x * o.y * n.y * H * r.y + 2 * p.x * n.x * F * m.x * r.y + 2 * p.x * n.x * F * r.x * m.y + 6 * p.x * t.y * m.x * r.x * J + 6 * p.x * s.x * m.x * s.y * J + 4 * p.y * o.x * n.y * H * r.y + 6 * p.y * t.x * m.x * r.x * J + 2 * p.y * o.y * n.x * H * r.y - 3 * p.y * o.y * n.y * H * r.x + 2 * p.y * n.x * F * m.x * r.x - 3 * o.x * t.x * n.x * J * r.y + 2 * o.x * t.x * n.y * r.x * J + o.x * o.y * F * m.x * r.x - 3 * o.x * n.x * t.y * r.x * J - 3 * o.x * n.x * s.x * s.y * J + 4 * t.x * o.y * n.x * r.x * J - 2 * p.x * D * n.y * m.y * r.y - 6 * p.y * t.x * H * m.y * r.y - 6 * p.y * t.y * H * r.x * m.y - 6 * p.y * s.x * H * s.y * m.y - 2 * p.y * D * n.y * m.x * r.y - 2 * p.y * D * n.y * r.x * m.y - o.x * o.y * D * m.y * r.y - 2 * o.x * B * m.x * r.x * m.y + 3 * t.x * o.y * n.y * H * r.y - 2 * t.x * n.x * F * m.x * r.y - 2 * t.x * n.x * F * r.x * m.y - 6 * t.x * t.y * m.x * r.x * J - 6 * t.x * s.x * m.x * s.y * J + 3 * o.y * t.y * n.y * H * r.x + 3 * o.y * s.x * n.y * H * s.y - 2 * n.x * t.y * F * m.x * r.x - 2 * n.x * s.x * F * m.x * s.y - B * n.x * n.y * m.x * r.x + 2 * t.x * D * n.y * m.y * r.y - 3 * o.y * P * n.y * m.x * m.y + 6 * t.y * s.x * H * s.y * m.y + 2 * z * o.y * m.x * m.y * r.y + z * n.x * n.y * m.y * r.y + 2 * D * t.y * n.y * r.x * m.y + 2 * D * s.x * n.y * s.y * m.y - 3 * p.x * P * K + 3 * t.x * P * K + 3 * v * r.x * K - 3 * x * I * r.y + 3 * L * r.x * K + P * G * m.x + C * H * r.x - A * J * r.y + 3 * p.y * P * m.x * J - o.x * B * H * r.y + o.x * P * n.y * J + 2 * o.y * n.x * P * J + z * o.y * r.x * J - n.x * P * F * m.y - 3 * t.y * P * m.x * J - 3 * v * m.x * J * r.y + 3 * x * H * r.x * m.y - z * F * m.x * r.y + B * D * r.x * m.y - 3 * L * m.x * J * r.y + 3 * N * H * r.x * m.y + D * n.y * m.x * (2 * t.y * r.y + R) + o.x * n.x * m.x * m.y * (6 * t.y * r.y + 3 * R) + E * m.y * ( - 2 * t.y * r.y - R) + p.y * I * (6 * t.y * r.y + 3 * R) + o.y * n.x * H * ( - 2 * t.y * r.y - R) + o.x * n.y * H * ( - 4 * t.y * r.y - 2 * R) + p.x * H * m.y * ( - 6 * t.y * r.y - 3 * R) + t.x * H * m.y * (6 * t.y * r.y + 3 * R) + I * ( - 2 * t.y * R - N * r.y - t.y * (2 * t.y * r.y + R)), -p.x * o.x * n.y * m.x * s.y * m.y + p.x * o.y * n.x * m.x * s.y * m.y + 6 * p.x * o.y * s.x * n.y * m.x * m.y - 6 * p.y * o.x * n.x * m.x * s.y * m.y - p.y * o.x * s.x * n.y * m.x * m.y + p.y * o.y * n.x * s.x * m.x * m.y - o.x * o.y * n.x * s.x * n.y * m.y + o.x * o.y * n.x * n.y * m.x * s.y + o.x * t.x * n.y * m.x * s.y * m.y + 6 * o.x * n.x * t.y * m.x * s.y * m.y + o.x * t.y * s.x * n.y * m.x * m.y - t.x * o.y * n.x * m.x * s.y * m.y - 6 * t.x * o.y * s.x * n.y * m.x * m.y - o.y * n.x * t.y * s.x * m.x * m.y - 6 * p.x * t.x * s.x * K - 2 * p.x * s.x * G * m.x + 6 * p.y * t.y * I * s.y + 2 * t.x * s.x * G * m.x + 2 * p.y * E * s.y * m.y - 2 * E * t.y * s.y * m.y - 6 * p.x * p.y * s.x * m.x * J + 3 * p.x * o.x * n.x * s.y * J - 2 * p.x * o.x * s.x * n.y * J - 4 * p.x * o.y * n.x * s.x * J + 3 * p.y * o.x * n.x * s.x * J + 6 * p.x * p.y * H * s.y * m.y + 6 * p.x * t.x * m.x * s.y * J - 3 * p.x * o.y * n.y * H * s.y + 2 * p.x * n.x * s.x * F * m.y + 2 * p.x * n.x * F * m.x * s.y + 6 * p.x * t.y * s.x * m.x * J + 4 * p.y * o.x * n.y * H * s.y + 6 * p.y * t.x * s.x * m.x * J + 2 * p.y * o.y * n.x * H * s.y - 3 * p.y * o.y * s.x * n.y * H + 2 * p.y * n.x * s.x * F * m.x - 3 * o.x * t.x * n.x * s.y * J + 2 * o.x * t.x * s.x * n.y * J + o.x * o.y * s.x * F * m.x - 3 * o.x * n.x * t.y * s.x * J + 4 * t.x * o.y * n.x * s.x * J - 6 * p.x * t.y * H * s.y * m.y - 2 * p.x * D * n.y * s.y * m.y - 6 * p.y * t.x * H * s.y * m.y - 6 * p.y * t.y * s.x * H * m.y - 2 * p.y * D * s.x * n.y * m.y - 2 * p.y * D * n.y * m.x * s.y - o.x * o.y * D * s.y * m.y - 4 * o.x * t.y * n.y * H * s.y - 2 * o.x * B * s.x * m.x * m.y + 3 * t.x * o.y * n.y * H * s.y - 2 * t.x * n.x * s.x * F * m.y - 2 * t.x * n.x * F * m.x * s.y - 6 * t.x * t.y * s.x * m.x * J - 2 * o.y * n.x * t.y * H * s.y + 3 * o.y * t.y * s.x * n.y * H - 2 * n.x * t.y * s.x * F * m.x - B * n.x * s.x * n.y * m.x + 6 * t.x * t.y * H * s.y * m.y + 2 * t.x * D * n.y * s.y * m.y + 2 * z * o.y * m.x * s.y * m.y + z * n.x * n.y * s.y * m.y + 2 * D * t.y * s.x * n.y * m.y + 2 * D * t.y * n.y * m.x * s.y + 3 * v * s.x * K - 3 * x * I * s.y + 3 * L * s.x * K + C * s.x * H - A * s.y * J - 3 * N * I * s.y - o.x * B * H * s.y + z * o.y * s.x * J - 3 * v * m.x * s.y * J + 3 * x * s.x * H * m.y - z * F * m.x * s.y + B * D * s.x * m.y - 3 * L * m.x * s.y * J + 3 * N * s.x * H * m.y, p.x * p.y * o.x * n.y * m.x * m.y - p.x * p.y * o.y * n.x * m.x * m.y + p.x * o.x * o.y * n.x * n.y * m.y - p.y * o.x * o.y * n.x * n.y * m.x - p.x * o.x * t.y * n.y * m.x * m.y + 6 * p.x * t.x * o.y * n.y * m.x * m.y + p.x * o.y * n.x * t.y * m.x * m.y - p.y * o.x * t.x * n.y * m.x * m.y - 6 * p.y * o.x * n.x * t.y * m.x * m.y + p.y * t.x * o.y * n.x * m.x * m.y - o.x * t.x * o.y * n.x * n.y * m.y + o.x * o.y * n.x * t.y * n.y * m.x + o.x * t.x * t.y * n.y * m.x * m.y - t.x * o.y * n.x * t.y * m.x * m.y - 2 * p.x * t.x * G * m.x + 2 * p.y * E * t.y * m.y - 3 * p.x * p.y * o.x * n.x * J - 6 * p.x * p.y * t.x * m.x * J + 3 * p.x * p.y * o.y * n.y * H - 2 * p.x * p.y * n.x * F * m.x - 2 * p.x * o.x * t.x * n.y * J - p.x * o.x * o.y * F * m.x + 3 * p.x * o.x * n.x * t.y * J - 4 * p.x * t.x * o.y * n.x * J + 3 * p.y * o.x * t.x * n.x * J + 6 * p.x * p.y * t.y * H * m.y + 2 * p.x * p.y * D * n.y * m.y + 2 * p.x * o.x * B * m.x * m.y + 2 * p.x * t.x * n.x * F * m.y + 6 * p.x * t.x * t.y * m.x * J - 3 * p.x * o.y * t.y * n.y * H + 2 * p.x * n.x * t.y * F * m.x + p.x * B * n.x * n.y * m.x + p.y * o.x * o.y * D * m.y + 4 * p.y * o.x * t.y * n.y * H - 3 * p.y * t.x * o.y * n.y * H + 2 * p.y * t.x * n.x * F * m.x + 2 * p.y * o.y * n.x * t.y * H + o.x * t.x * o.y * F * m.x - 3 * o.x * t.x * n.x * t.y * J - 2 * p.x * D * t.y * n.y * m.y - 6 * p.y * t.x * t.y * H * m.y - 2 * p.y * t.x * D * n.y * m.y - 2 * p.y * z * o.y * m.x * m.y - p.y * z * n.x * n.y * m.y - 2 * p.y * D * t.y * n.y * m.x - 2 * o.x * t.x * B * m.x * m.y - o.x * o.y * D * t.y * m.y + 3 * t.x * o.y * t.y * n.y * H - 2 * t.x * n.x * t.y * F * m.x - t.x * B * n.x * n.y * m.x + 3 * x * o.x * n.x * m.x * m.y + 3 * o.x * n.x * N * m.x * m.y + 2 * t.x * D * t.y * n.y * m.y - 3 * v * o.y * n.y * m.x * m.y + 2 * z * o.y * t.y * m.x * m.y + z * n.x * t.y * n.y * m.y - 3 * L * o.y * n.y * m.x * m.y - w * K + y * I + M * K - O * I - 3 * p.x * L * K - p.x * C * H + 3 * v * t.x * K + p.y * A * J + 3 * p.y * N * I + t.x * C * H + v * G * m.x - 3 * x * t.y * I - x * E * m.y + L * G * m.x - A * t.y * J - E * N * m.y - p.x * z * o.y * J + p.y * o.x * B * H - 3 * p.x * x * H * m.y - p.x * B * D * m.y + p.y * z * F * m.x - o.x * B * t.y * H + 3 * v * p.y * m.x * J + v * o.x * n.y * J + 2 * v * o.y * n.x * J - 2 * x * o.x * n.y * H - x * o.y * n.x * H + z * t.x * o.y * J - 3 * p.x * N * H * m.y + 3 * p.y * L * m.x * J + o.x * L * n.y * J - 2 * o.x * N * n.y * H + t.x * B * D * m.y - o.y * n.x * N * H - v * n.x * F * m.y - 3 * v * t.y * m.x * J + 3 * x * t.x * H * m.y + x * D * n.y * m.x - z * t.y * F * m.x + 2 * L * o.y * n.x * J + 3 * t.x * N * H * m.y - L * n.x * F * m.y - 3 * L * t.y * m.x * J + D * N * n.y * m.x), $ = Z.getRootsInInterval(0, 1), _ = 0; _ < $.length; _++) {
            var aa = $[_],
            ba = new Polynomial(m.x, n.x, o.x, p.x - t.x - aa * s.x - aa * aa * r.x - aa * aa * aa * q.x).getRoots(),
            ca = new Polynomial(m.y, n.y, o.y, p.y - t.y - aa * s.y - aa * aa * r.y - aa * aa * aa * q.y).getRoots();
            if (ba.length > 0 && ca.length > 0) {
                var da = 1e-4;
                a: for (var ea = 0; ea < ba.length; ea++) {
                    var fa = ba[ea];
                    if (fa >= 0 && 1 >= fa) for (var ga = 0; ga < ca.length; ga++) if (Math.abs(fa - ca[ga]) < da) {
                        u.points.push(q.multiply(aa * aa * aa).add(r.multiply(aa * aa).add(s.multiply(aa).add(t))));
                        break a
                    }
                }
            }
        }
        return u.points.length > 0 && (u.status = "Intersection"),
        u
    },
    gd.intersectBezier3Circle = function(a, b, c, d, e, f) {
        return gd.intersectBezier3Ellipse(a, b, c, d, e, f, f)
    },
    gd.intersectBezier3Ellipse = function(a, b, c, d, e, f, g) {
        var h, i, j, k, l, m, n, o, p = new gd("No Intersection");
        h = a.multiply( - 1),
        i = b.multiply(3),
        j = c.multiply( - 3),
        k = h.add(i.add(j.add(d))),
        l = new Vector2D(k.x, k.y),
        h = a.multiply(3),
        i = b.multiply( - 6),
        j = c.multiply(3),
        k = h.add(i.add(j)),
        m = new Vector2D(k.x, k.y),
        h = a.multiply( - 3),
        i = b.multiply(3),
        j = h.add(i),
        n = new Vector2D(j.x, j.y),
        o = new Vector2D(a.x, a.y);
        for (var q = f * f,
        r = g * g,
        s = new Polynomial(l.x * l.x * r + l.y * l.y * q, 2 * (l.x * m.x * r + l.y * m.y * q), 2 * (l.x * n.x * r + l.y * n.y * q) + m.x * m.x * r + m.y * m.y * q, 2 * l.x * r * (o.x - e.x) + 2 * l.y * q * (o.y - e.y) + 2 * (m.x * n.x * r + m.y * n.y * q), 2 * m.x * r * (o.x - e.x) + 2 * m.y * q * (o.y - e.y) + n.x * n.x * r + n.y * n.y * q, 2 * n.x * r * (o.x - e.x) + 2 * n.y * q * (o.y - e.y), o.x * o.x * r - 2 * o.y * e.y * q - 2 * o.x * e.x * r + o.y * o.y * q + e.x * e.x * r + e.y * e.y * q - q * r), t = s.getRootsInInterval(0, 1), u = 0; u < t.length; u++) {
            var v = t[u];
            p.points.push(l.multiply(v * v * v).add(m.multiply(v * v).add(n.multiply(v).add(o))))
        }
        return p.points.length > 0 && (p.status = "Intersection"),
        p
    },
    gd.intersectBezier3Line = function(a, b, c, d, e, f) {
        var g, h, i, j, k, l, m, n, o, p, q = e.min(f),
        r = e.max(f),
        s = new gd("No Intersection");
        g = a.multiply( - 1),
        h = b.multiply(3),
        i = c.multiply( - 3),
        j = g.add(h.add(i.add(d))),
        k = new Vector2D(j.x, j.y),
        g = a.multiply(3),
        h = b.multiply( - 6),
        i = c.multiply(3),
        j = g.add(h.add(i)),
        l = new Vector2D(j.x, j.y),
        g = a.multiply( - 3),
        h = b.multiply(3),
        i = g.add(h),
        m = new Vector2D(i.x, i.y),
        n = new Vector2D(a.x, a.y),
        p = new Vector2D(e.y - f.y, f.x - e.x),
        o = e.x * f.y - f.x * e.y,
        roots = new Polynomial(p.dot(k), p.dot(l), p.dot(m), p.dot(n) + o).getRoots();
        for (var t = 0; t < roots.length; t++) {
            var u = roots[t];
            if (u >= 0 && 1 >= u) {
                var v = a.lerp(b, u),
                w = b.lerp(c, u),
                x = c.lerp(d, u),
                y = v.lerp(w, u),
                z = w.lerp(x, u),
                A = y.lerp(z, u);
                e.x == f.x ? q.y <= A.y && A.y <= r.y && (s.status = "Intersection", s.appendPoint(A)) : e.y == f.y ? q.x <= A.x && A.x <= r.x && (s.status = "Intersection", s.appendPoint(A)) : A.gte(q) && A.lte(r) && (s.status = "Intersection", s.appendPoint(A))
            }
        }
        return s
    },
    gd.intersectBezier3Polygon = function(a, b, c, d, e) {
        for (var f = new gd("No Intersection"), g = e.length, h = 0; g > h; h++) {
            var i = e[h],
            j = e[(h + 1) % g],
            k = gd.intersectBezier3Line(a, b, c, d, i, j);
            f.appendPoints(k.points)
        }
        return f.points.length > 0 && (f.status = "Intersection"),
        f
    },
    gd.intersectBezier3Rectangle = function(a, b, c, d, e, f) {
        var g = e.min(f),
        h = e.max(f),
        i = new Zb(h.x, g.y),
        j = new Zb(g.x, h.y),
        k = gd.intersectBezier3Line(a, b, c, d, g, i),
        l = gd.intersectBezier3Line(a, b, c, d, i, h),
        m = gd.intersectBezier3Line(a, b, c, d, h, j),
        n = gd.intersectBezier3Line(a, b, c, d, j, g),
        o = new gd("No Intersection");
        return o.appendPoints(k.points),
        o.appendPoints(l.points),
        o.appendPoints(m.points),
        o.appendPoints(n.points),
        o.points.length > 0 && (o.status = "Intersection"),
        o
    },
    gd.intersectCircleCircle = function(a, b, c, d) {
        var e, f = b + d,
        g = Math.abs(b - d),
        h = a.distanceFrom(c);
        if (h > f) e = new gd("Outside");
        else if (g > h) e = new gd("Inside");
        else {
            e = new gd("Intersection");
            var i = (b * b - d * d + h * h) / (2 * h),
            j = Math.sqrt(b * b - i * i),
            k = a.lerp(c, i / h),
            l = j / h;
            e.points.push(new Zb(k.x - l * (c.y - a.y), k.y + l * (c.x - a.x))),
            e.points.push(new Zb(k.x + l * (c.y - a.y), k.y - l * (c.x - a.x)))
        }
        return e
    },
    gd.intersectCircleEllipse = function(a, b, c, d, e) {
        return gd.intersectEllipseEllipse(a, b, b, c, d, e)
    },
    gd.intersectCircleLine = function(a, b, c, d) {
        var e, f = (d.x - c.x) * (d.x - c.x) + (d.y - c.y) * (d.y - c.y),
        g = 2 * ((d.x - c.x) * (c.x - a.x) + (d.y - c.y) * (c.y - a.y)),
        h = a.x * a.x + a.y * a.y + c.x * c.x + c.y * c.y - 2 * (a.x * c.x + a.y * c.y) - b * b,
        i = g * g - 4 * f * h;
        if (0 > i) e = new gd("Outside");
        else if (0 == i) e = new gd("Tangent");
        else {
            var j = Math.sqrt(i),
            k = ( - g + j) / (2 * f),
            l = ( - g - j) / (2 * f); (0 > k || k > 1) && (0 > l || l > 1) ? e = new gd(0 > k && 0 > l || k > 1 && l > 1 ? "Outside": "Inside") : (e = new gd("Intersection"), k >= 0 && 1 >= k && e.points.push(c.lerp(d, k)), l >= 0 && 1 >= l && e.points.push(c.lerp(d, l)))
        }
        return e
    },
    gd.intersectCirclePolygon = function(a, b, c) {
        for (var d, e = new gd("No Intersection"), f = c.length, g = 0; f > g; g++) {
            var h = c[g],
            i = c[(g + 1) % f];
            d = gd.intersectCircleLine(a, b, h, i),
            e.appendPoints(d.points)
        }
        return e.points.length > 0 ? e.status = "Intersection": e.status = d.status,
        e
    },
    gd.intersectCircleRectangle = function(a, b, c, d) {
        var e = c.min(d),
        f = c.max(d),
        g = new Zb(f.x, e.y),
        h = new Zb(e.x, f.y),
        i = gd.intersectCircleLine(a, b, e, g),
        j = gd.intersectCircleLine(a, b, g, f),
        k = gd.intersectCircleLine(a, b, f, h),
        l = gd.intersectCircleLine(a, b, h, e),
        m = new gd("No Intersection");
        return m.appendPoints(i.points),
        m.appendPoints(j.points),
        m.appendPoints(k.points),
        m.appendPoints(l.points),
        m.points.length > 0 ? m.status = "Intersection": m.status = i.status,
        m
    },
    gd.intersectEllipseEllipse = function(a, b, c, d, e, f) {
        for (var g = [c * c, 0, b * b, -2 * c * c * a.x, -2 * b * b * a.y, c * c * a.x * a.x + b * b * a.y * a.y - b * b * c * c], h = [f * f, 0, e * e, -2 * f * f * d.x, -2 * e * e * d.y, f * f * d.x * d.x + e * e * d.y * d.y - e * e * f * f], i = gd.bezout(g, h), j = i.getRoots(), k = .001, l = (g[0] * g[0] + 2 * g[1] * g[1] + g[2] * g[2]) * k, m = (h[0] * h[0] + 2 * h[1] * h[1] + h[2] * h[2]) * k, n = new gd("No Intersection"), o = 0; o < j.length; o++) for (var p = new Polynomial(g[0], g[3] + j[o] * g[1], g[5] + j[o] * (g[4] + j[o] * g[2])), q = p.getRoots(), r = 0; r < q.length; r++) {
            var s = (g[0] * q[r] + g[1] * j[o] + g[3]) * q[r] + (g[2] * j[o] + g[4]) * j[o] + g[5];
            Math.abs(s) < l && (s = (h[0] * q[r] + h[1] * j[o] + h[3]) * q[r] + (h[2] * j[o] + h[4]) * j[o] + h[5], Math.abs(s) < m && n.appendPoint(new Zb(q[r], j[o])))
        }
        return n.points.length > 0 && (n.status = "Intersection"),
        n
    },
    gd.intersectEllipseLine = function(a, b, c, d, e) {
        var f, g = new Vector2D(d.x, d.y),
        h = Vector2D.fromPoints(d, e),
        i = new Vector2D(a.x, a.y),
        j = g.subtract(i),
        k = new Vector2D(h.x / (b * b), h.y / (c * c)),
        l = new Vector2D(j.x / (b * b), j.y / (c * c)),
        m = h.dot(k),
        n = h.dot(l),
        a = j.dot(l) - 1,
        o = n * n - m * a;
        if (0 > o) f = new gd("Outside");
        else if (o > 0) {
            var p = Math.sqrt(o),
            q = ( - n - p) / m,
            r = ( - n + p) / m; (0 > q || q > 1) && (0 > r || r > 1) ? f = new gd(0 > q && 0 > r || q > 1 && r > 1 ? "Outside": "Inside") : (f = new gd("Intersection"), q >= 0 && 1 >= q && f.appendPoint(d.lerp(e, q)), r >= 0 && 1 >= r && f.appendPoint(d.lerp(e, r)))
        } else {
            var s = -n / m;
            s >= 0 && 1 >= s ? (f = new gd("Intersection"), f.appendPoint(d.lerp(e, s))) : f = new gd("Outside")
        }
        return f
    },
    gd.intersectEllipsePolygon = function(a, b, c, d) {
        for (var e = new gd("No Intersection"), f = d.length, g = 0; f > g; g++) {
            var h = d[g],
            i = d[(g + 1) % f],
            j = gd.intersectEllipseLine(a, b, c, h, i);
            e.appendPoints(j.points)
        }
        return e.points.length > 0 && (e.status = "Intersection"),
        e
    },
    gd.intersectEllipseRectangle = function(a, b, c, d, e) {
        var f = d.min(e),
        g = d.max(e),
        h = new Zb(g.x, f.y),
        i = new Zb(f.x, g.y),
        j = gd.intersectEllipseLine(a, b, c, f, h),
        k = gd.intersectEllipseLine(a, b, c, h, g),
        l = gd.intersectEllipseLine(a, b, c, g, i),
        m = gd.intersectEllipseLine(a, b, c, i, f),
        n = new gd("No Intersection");
        return n.appendPoints(j.points),
        n.appendPoints(k.points),
        n.appendPoints(l.points),
        n.appendPoints(m.points),
        n.points.length > 0 && (n.status = "Intersection"),
        n
    },
    gd.intersectLineLine = function(a, b, c, d) {
        var e, f = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x),
        g = (b.x - a.x) * (a.y - c.y) - (b.y - a.y) * (a.x - c.x),
        h = (d.y - c.y) * (b.x - a.x) - (d.x - c.x) * (b.y - a.y);
        if (0 != h) {
            var i = f / h,
            j = g / h;
            i >= 0 && 1 >= i && j >= 0 && 1 >= j ? (e = new gd("Intersection"), e.points.push(new Zb(a.x + i * (b.x - a.x), a.y + i * (b.y - a.y)))) : e = new gd("No Intersection")
        } else e = new gd(0 == f || 0 == g ? "Coincident": "Parallel");
        return e
    },
    gd.intersectLinePolygon = function(a, b, c) {
        for (var d = new gd("No Intersection"), e = c.length, f = 0; e > f; f++) {
            var g = c[f],
            h = c[(f + 1) % e],
            i = gd.intersectLineLine(a, b, g, h);
            d.appendPoints(i.points)
        }
        return d.points.length > 0 && (d.status = "Intersection"),
        d
    },
    gd.intersectLineRectangle = function(a, b, c, d) {
        var e = c.min(d),
        f = c.max(d),
        g = new Zb(f.x, e.y),
        h = new Zb(e.x, f.y),
        i = gd.intersectLineLine(e, g, a, b),
        j = gd.intersectLineLine(g, f, a, b),
        k = gd.intersectLineLine(f, h, a, b),
        l = gd.intersectLineLine(h, e, a, b),
        m = new gd("No Intersection");
        return m.appendPoints(i.points),
        m.appendPoints(j.points),
        m.appendPoints(k.points),
        m.appendPoints(l.points),
        m.points.length > 0 && (m.status = "Intersection"),
        m
    },
    gd.intersectPolygonPolygon = function(a, b) {
        for (var c = new gd("No Intersection"), d = a.length, e = 0; d > e; e++) {
            var f = a[e],
            g = a[(e + 1) % d],
            h = gd.intersectLinePolygon(f, g, b);
            c.appendPoints(h.points)
        }
        return c.points.length > 0 && (c.status = "Intersection"),
        c
    },
    gd.intersectPolygonRectangle = function(a, b, c) {
        var d = b.min(c),
        e = b.max(c),
        f = new Zb(e.x, d.y),
        g = new Zb(d.x, e.y),
        h = gd.intersectLinePolygon(d, f, a),
        i = gd.intersectLinePolygon(f, e, a),
        j = gd.intersectLinePolygon(e, g, a),
        k = gd.intersectLinePolygon(g, d, a),
        l = new gd("No Intersection");
        return l.appendPoints(h.points),
        l.appendPoints(i.points),
        l.appendPoints(j.points),
        l.appendPoints(k.points),
        l.points.length > 0 && (l.status = "Intersection"),
        l
    },
    gd.intersectRayRay = function(a, b, c, d) {
        var e, f = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x),
        g = (b.x - a.x) * (a.y - c.y) - (b.y - a.y) * (a.x - c.x),
        h = (d.y - c.y) * (b.x - a.x) - (d.x - c.x) * (b.y - a.y);
        if (0 != h) {
            var i = f / h;
            e = new gd("Intersection"),
            e.points.push(new Zb(a.x + i * (b.x - a.x), a.y + i * (b.y - a.y)))
        } else e = new gd(0 == f || 0 == g ? "Coincident": "Parallel");
        return e
    },
    gd.intersectRectangleRectangle = function(a, b, c, d) {
        var e = a.min(b),
        f = a.max(b),
        g = new Zb(f.x, e.y),
        h = new Zb(e.x, f.y),
        i = gd.intersectLineRectangle(e, g, c, d),
        j = gd.intersectLineRectangle(g, f, c, d),
        k = gd.intersectLineRectangle(f, h, c, d),
        l = gd.intersectLineRectangle(h, e, c, d),
        m = new gd("No Intersection");
        return m.appendPoints(i.points),
        m.appendPoints(j.points),
        m.appendPoints(k.points),
        m.appendPoints(l.points),
        m.points.length > 0 && (m.status = "Intersection"),
        m
    },
    gd.bezout = function(a, b) {
        var c = a[0] * b[1] - b[0] * a[1],
        d = a[0] * b[2] - b[0] * a[2],
        e = a[0] * b[3] - b[0] * a[3],
        f = a[0] * b[4] - b[0] * a[4],
        g = a[0] * b[5] - b[0] * a[5],
        h = a[1] * b[2] - b[1] * a[2],
        i = a[1] * b[4] - b[1] * a[4],
        j = a[1] * b[5] - b[1] * a[5],
        k = a[2] * b[3] - b[2] * a[3],
        l = a[3] * b[4] - b[3] * a[4],
        m = a[3] * b[5] - b[3] * a[5],
        n = j + l,
        o = i - k;
        return new Polynomial(c * h - d * d, c * o + e * h - 2 * d * f, c * n + e * o - f * f - 2 * d * g, c * m + e * n - 2 * f * g, e * m - g * g)
    },
    Yb.Intersection = gd,
    Yb.AreaPicking = function(a, b) {
        this.network = a,
        this.bounding = b,
        this.cache = {}
    },
    Yb.extend(Yb.AreaPicking, Object, {
        intersectObjects: function(a) {
            for (var b = [], c = 0; c < a.length; c++) {
                var d = a[c];
                this.intersectObject(d, b)
            }
            return b
        },
        getViewPoint: function(a, b) {
            var c = b.vertices[a].clone(),
            d = this.cache[b.getId()][c.x + " " + c.y + " " + c.z];
            return d ? d: (c.applyMatrix4(b.worldMatrix), d = this.network.getViewPosition(c), d.y = d.h - d.y, d)
        },
        intersectObject: function(a, b) {
            if (a instanceof Yb.Entity) {
                this.cache[a.getId()] = {};
                for (var c = 0; c < a.vertices.length; c++) {
                    var d = a.vertices[c].clone();
                    d.applyMatrix4(a.worldMatrix);
                    var e = this.network.getViewPosition(d);
                    if (e.y = e.h - e.y, this.cache[a.getId()][d.x + " " + d.y + " " + d.z] = e, e.x > this.bounding.x && e.y > this.bounding.y && e.x < this.bounding.x + this.bounding.w && e.y < this.bounding.y + this.bounding.h) {
                        var f = {
                            element: a
                        };
                        return void b.push(f)
                    }
                }
            }
        }
    }),
    Yb.BaseInteraction = function(a) {
        this.network = a,
        this.view = a.getView() || document
    },
    Yb.addEventListener = function(a, b, c, d) {
        var e = "_" + a + "_";
        if (!d[e]) {
            var f = function(a) {
                d[b](a)
            };
            d[e] = f,
            c.addEventListener(a, f, !1)
        }
    },
    Yb.removeEventListener = function(a, b, c) {
        var d = "_" + a + "_",
        e = c[d];
        e && (b.removeEventListener(a, e, !1), delete c[d])
    },
    Yb.extend(Yb.BaseInteraction, Object, {
        onPropertyChange: function() {},
        firePropertyChange: function() {},
        setUp: function() {},
        tearDown: function() {},
        update: function() {},
        addListener: function() {
            for (var a = 0; a < arguments.length; a++) {
                var b = arguments[a];
                Yb.addEventListener(b, "handle_" + b, this.network.getRootView(), this)
            }
        },
        removeListener: function() {
            for (var a = 0; a < arguments.length; a++) arguments[a],
            Yb.removeEventListener(arguments[a], this.network.getRootView(), this)
        },
        isCtrlDown: function(a) {
            return a.ctrlKey || a.metaKey
        },
        isFinished: function() {
            return ! 0
        }
    }),
    Yb.DefaultInteraction = function(a) {
        Yb.BaseInteraction.call(this, a),
        this.screen = {
            width: 0,
            height: 0,
            offsetLeft: 0,
            offsetTop: 0
        },
        this.radius = this.screen.width / 4,
        this.domElement = this.network.getRootView(),
        this.rotateSpeed = 1,
        this.zoomSpeed = 1.2,
        this.panSpeed = .3,
        this.noRotate = !1,
        this.noZoom = !1,
        this.noPan = !1,
        this.easing = !0,
        this.dynamicDampingFactor = .05,
        this.timeInterval = 2e3,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.keys = [65, 83, 68],
        this.lastPosition = new Yb.Vec3;
        var b, c, e = this.STATE.NONE,
        f = (this.STATE.NONE, new Yb.Vec3),
        g = new Yb.Vec3,
        h = new Yb.Vec3,
        i = new Yb.Vec2,
        j = new Yb.Vec2,
        k = 0,
        l = 0,
        m = new Yb.Vec2,
        n = new Yb.Vec2;
        this.object = this.network._camera,
        this.object.target || (this.object.target = new Yb.Vec3),
        this.movementSpeed = 1,
        this.lookSpeed = .005,
        this.verticalLookRatio = .1,
        this.keyboardEnable = !0,
        this.lookVertical = !0,
        this.autoForward = !1,
        this.fpsMode = !1,
        this.dragMode = !0,
        this.activeLook = !1,
        this.heightSpeed = !1,
        this.heightCoef = 1,
        this.heightMin = 0,
        this.heightMax = 1,
        this.constrainVertical = !1,
        this.verticalFixed = !1,
        this.verticalMin = 0,
        this.verticalMax = Math.PI,
        this.autoSpeedFactor = 0,
        this.mouseX = 0,
        this.mouseY = 0,
        this.lat = 0,
        this.lon = 0,
        this.phi = 0,
        this.theta = 0,
        this.moveForward = !1,
        this.moveBackward = !1,
        this.moveLeft = !1,
        this.moveRight = !1,
        this.freeze = !1,
        this.mouseDragOn = !1,
        this.viewHalfX = 0,
        this.viewHalfY = 0,
        this.lastX = 0,
        this.lastY = 0,
        this.touchSeq = [1, 2, 3],
        this.network.getRootView().addEventListener("contextmenu",
        function(a) {
            a.preventDefault()
        },
        !1),
        this.yRistrict = !0,
        this.yLowerLimitAngle = -Math.PI / 2,
        this.yUpLimitAngle = Math.PI / 2,
        this.updateIntervalTime = 0;
        var o = null;
        this.handleResize = function() {
            this.screen.width = d.innerWidth,
            this.screen.height = d.innerHeight,
            this.screen.offsetLeft = 0,
            this.screen.offsetTop = 0,
            this.radius = (this.screen.width + this.screen.height) / 4
        },
        this.handleResize(),
        this.handle_mousedown = function(a) {
            if (!bc.isCtrlDown(a)) {
                if (a.preventDefault(), this.fpsMode) {
                    if (this.domElement !== document && this.domElement.focus(), this.activeLook) switch (a.button) {
                    case 0:
                        this.moveForward = !0;
                        break;
                    case 2:
                        this.moveBackward = !0
                    }
                    this.lastX = a.pageX,
                    this.lastY = a.pageY,
                    this.mouseDragOn = !0;
                } else e === this.STATE.NONE && (e = a.button),
                e !== this.STATE.ROTATE || this.noRotate ? this.state !== this.STATE.ZOOM || this.noZoom ? e === this.STATE.PAN && !this.noPan && (m = n = this.getMouseOnScreen(a.clientX, a.clientY)) : i = j = this.getMouseOnScreen(a.clientX, a.clientY) : (g = h = this.getMouseProjectionOnBall(a.clientX, a.clientY), b = c = this.getRotateY(a.clientX, a.clientY));
                this.beforeUpdate(),
                this.addListener("mousemove", "mouseup")
            }
        },
        this.handle_mousemove = function(a) {
            if (!a.stop) {
                a.preventDefault(),
                this.fpsMode ? this.dragMode ? this.mouseDragOn ? (this.mouseX = 300 * (a.pageX - this.lastX), this.mouseY = 300 * (a.pageY - this.lastY), this.lastX = a.pageX, this.lastY = a.pageY) : (this.mouseX = 0, this.mouseY = 0) : this.domElement === document ? (this.mouseX = a.pageX - this.viewHalfX, this.mouseY = a.pageY - this.viewHalfY) : (this.mouseX = a.pageX - this.domElement.offsetLeft - this.viewHalfX, this.mouseY = a.pageY - this.domElement.offsetTop - this.viewHalfY) : e !== this.STATE.ROTATE || this.noRotate ? e !== this.STATE.ZOOM || this.noZoom ? e === this.STATE.PAN && !this.noPan && (n = this.getMouseOnScreen(a.clientX, a.clientY)) : j = this.getMouseOnScreen(a.clientX, a.clientY) : (h = this.getMouseProjectionOnBall(a.clientX, a.clientY), c = this.getRotateY(a.clientX, a.clientY));
                var b = (new Date).getTime();
                if (null == this._lt) this.update();
                else {
                    if (b - this._lt < this.updateIntervalTime) return;
                    this.update()
                }
                this._lt = b
            }
        },
        this.handle_mouseup = function(a) {
            if (a.preventDefault(), this.fpsMode) {
                if (this.activeLook) switch (a.button) {
                case 0:
                    this.moveForward = !1;
                    break;
                case 2:
                    this.moveBackward = !1
                }
                this.lastX = 0,
                this.lastY = 0,
                this.dragMode && (this.mouseX = 0, this.mouseY = 0),
                this.mouseDragOn = !1
            } else e = this.STATE.NONE;
            this.removeListener("mousemove", "mouseup"),
            this.update()
        },
        this.handle_touchstart = function(a) {
            if (this.enabled !== !1) {
                switch (a.touches.length) {
                case this.touchSeq[0]:
                    e = this.STATE.TOUCH_ROTATE,
                    g = this.getMouseProjectionOnBall(a.touches[0].pageX, a.touches[0].pageY),
                    b = c = this.getRotateY(a.touches[0].pageX, a.touches[0].pageY),
                    h.copy(g);
                    break;
                case this.touchSeq[1]:
                    e = this.STATE.TOUCH_ZOOM;
                    var d = a.touches[0].pageX - a.touches[1].pageX,
                    f = a.touches[0].pageY - a.touches[1].pageY;
                    l = k = Math.sqrt(d * d + f * f);
                    break;
                case this.touchSeq[2]:
                    e = this.STATE.TOUCH_PAN,
                    m.copy(this.getMouseOnScreen(a.touches[0].pageX, a.touches[0].pageY)),
                    n.copy(m);
                    break;
                default:
                    e = this.STATE.NONE
                }
                this.update()
            }
        },
        this.handle_touchmove = function(a) {
            if (this.enabled !== !1) {
                switch (a.preventDefault(), a.touches.length) {
                case this.touchSeq[0]:
                    h = this.getMouseProjectionOnBall(a.touches[0].pageX, a.touches[0].pageY, h),
                    c = this.getRotateY(a.touches[0].pageX, a.touches[0].pageY);
                    break;
                case this.touchSeq[1]:
                    var b = a.touches[0].pageX - a.touches[1].pageX,
                    d = a.touches[0].pageY - a.touches[1].pageY;
                    l = Math.sqrt(b * b + d * d);
                    break;
                case this.touchSeq[2]:
                    n = this.getMouseOnScreen(a.touches[0].pageX, a.touches[0].pageY, n);
                    break;
                default:
                    e = this.STATE.NONE
                }
                this.update()
            }
        },
        this.handle_touchend = function(a) {
            if (this.enabled !== !1) {
                switch (a.touches.length) {
                case this.touchSeq[0]:
                    g.copy(this.getMouseProjectionOnBall(a.touches[0].pageX, a.touches[0].pageY, h));
                    break;
                case this.touchSeq[1]:
                    k = l = 0;
                    break;
                case this.touchSeq[2]:
                    n.copy(this.getMouseOnScreen(a.touches[0].pageX, a.touches[0].pageY)),
                    m.copy(n)
                }
                e = this.STATE.NONE,
                this.update()
            }
        },
        this.handle_DOMMouseScroll = function(a) {
            this.handle_mousewheel(a)
        },
        this.handle_mousewheel = function(a) {
            a.preventDefault();
            var b = 0;
            a.wheelDelta ? b = a.wheelDelta % 120 === 0 ? a.wheelDelta / 40 : a.wheelDelta: a.detail && (b = -a.detail / 3),
            b && (i.y += 1 / b * .01),
            this.mouseMoving = !0,
            this.update()
        },
        this.handle_dblclick = function(a) {
            if (this.isCtrlDown(a)) {
                var b = this.network.getElementsByMouseEvent(a);
                b.length > 0 && (o = b[0]),
                this.update()
            }
        },
        this.getMouseOnScreen = function(a, b) {
            return new Yb.Vec2((a - this.screen.offsetLeft) / this.radius * .5, (b - this.screen.offsetTop) / this.radius * .5)
        },
        this.getRotateY = function(a, b) {
            if (this.yRistrict) {
                var c = (.5 * this.screen.height + this.screen.offsetTop - b) / this.screen.height * 2;
                return c
            }
        },
        this.handle_keydown = function(a) {
            if (this.keyboardEnable) {
                switch (a.keyCode) {
                case 38:
                case 87:
                    this.moveForward = !0;
                    break;
                case 37:
                case 65:
                    this.moveLeft = !0;
                    break;
                case 40:
                case 83:
                    this.moveBackward = !0;
                    break;
                case 39:
                case 68:
                    this.moveRight = !0;
                    break;
                case 82:
                    this.moveUp = !0;
                    break;
                case 70:
                    this.moveDown = !0;
                    break;
                case 81:
                    this.freeze = !this.freeze
                }
                this.update()
            }
        },
        this.handle_keyup = function(a) {
            if (this.keyboardEnable) {
                switch (a.keyCode) {
                case 38:
                case 87:
                    this.moveForward = !1;
                    break;
                case 37:
                case 65:
                    this.moveLeft = !1;
                    break;
                case 40:
                case 83:
                    this.moveBackward = !1;
                    break;
                case 39:
                case 68:
                    this.moveRight = !1;
                    break;
                case 82:
                    this.moveUp = !1;
                    break;
                case 70:
                    this.moveDown = !1
                }
                this.update()
            }
        },
        this.getMouseProjectionOnBall = function(a, b) {
            if (this.yRistrict) {
                var c = new Yb.Vec3((a - .5 * this.screen.width - this.screen.offsetLeft) / (.5 * this.screen.width), 0, 0),
                d = c.length();
                return d > 1 ? c.normalize() : c.z = Math.sqrt(1 - d * d),
                c.normalize()
            }
            var c = new Yb.Vec3((a - .5 * this.screen.width - this.screen.offsetLeft) / this.radius, (.5 * this.screen.height + this.screen.offsetTop - b) / this.radius, 0),
            d = c.length();
            d > 1 ? c.normalize() : c.z = Math.sqrt(1 - d * d),
            f.copy(this.object._position).sub(this.object.target);
            var e = this.object.up.clone().setLength(c.y);
            return e.add(this.object.up.clone().cross(f).setLength(c.x)),
            e.add(f.setLength(c.z)),
            e
        },
        this.rotateCamera = function() {
            var a = g.dot(h) / g.length() / h.length(),
            d = Math.acos(a),
            e = !this.easing || Math.abs(d) < 1e-4,
            i = !1;
            if (d) {
                var j = (new Yb.Vec3).crossVectors(g, h).normalize(),
                k = new Yb.Quat;
                k.setFromAxisAngle(j, -d * this.dynamicDampingFactor * this.rotateSpeed),
                e ? (k.setFromAxisAngle(j, -d * this.rotateSpeed), f.applyQuaternion(k), this.object.up.applyQuaternion(k), g.copy(h)) : (k.setFromAxisAngle(j, -d * this.dynamicDampingFactor * this.rotateSpeed), f.applyQuaternion(k), this.object.up.applyQuaternion(k), k.setFromAxisAngle(j, d * this.dynamicDampingFactor), g.applyQuaternion(k), i = !0)
            }
            var e = !this.easing || Math.abs(c - b) < 1e-4,
            l = (c - b) * f.length();
            if (!tc.isNaN(l)) if (e) l && this.yRistrict && this.limitY(l),
            b = c;
            else {
                var l = l * this.dynamicDampingFactor;
                l && this.yRistrict && this.limitY(l),
                b += (c - b) * this.dynamicDampingFactor,
                i = !0
            }
            i && this.network.dirtyNetwork()
        },
        this.limitY = function(a) {
            var b = f.length();
            Math.abs(f.x) <= .1 * b && Math.abs(f.z) <= .1 * b && (f.x = .1 * b);
            var c = f.x,
            d = f.z,
            e = Math.sqrt(c * c + d * d),
            g = Math.tan(this.yLowerLimitAngle) * e,
            h = Math.tan(this.yUpLimitAngle) * e;
            f.y -= a,
            f.y > h ? f.y = h: f.y < g && (f.y = g)
        },
        this.getValueByTime = function(a, b) {
            var c = (new Date).getTime(),
            d = c - this._timeStart;
            return d > this.timeInterval ? b: a + (b - a) * d / this.timeInterval
        },
        this.zoomCamera = function() {
            if (e === this.STATE.TOUCH_ZOOM) {
                var a = k / l;
                k = l,
                f.multiplyScalar(a)
            } else {
                var b = this.zoomSpeed;
                this.easing || (b *= 5);
                var a;
                a = 1 + (j.y - i.y) * b,
                1 !== a && a > 0 && (f.multiplyScalar(a), !this.easing || Math.abs(j.y - i.y) < .001 ? i.copy(j) : (i.y += (j.y - i.y) * this.dynamicDampingFactor, this.network.dirtyNetwork()))
            }
        },
        this.panCamera = function() {
            var a = n.clone().sub(m);
            if (a.lengthSq()) {
                a.multiplyScalar(f.length() * this.panSpeed);
                var b = f.clone().cross(this.object.up).setLength(a.x),
                c = (new ac).extractRotation(this.object.matrix),
                d = this.object.up.clone().applyMatrix4(c);
                b.add(d.setLength(a.y));
                var e = this.object.p().add(b);
                this.object.checkPosition(e) && (this.object.p(e), this.object.target.add(b)),
                m = n,
                this.network.dirtyNetwork()
            }
        },
        this.checkAngles = function() {},
        this.checkDistances = function() {
            this.noZoom && this.noPan || (f.lengthSq() > this.maxDistance * this.maxDistance && this.object._position.addVectors(this.object.target, f.setLength(this.maxDistance)), f.lengthSq() < this.minDistance * this.minDistance && this.object._position.addVectors(this.object.target, f.setLength(this.minDistance)))
        },
        this.updateFPS = function() {
            var a = 2;
            if (!this.freeze) {
                if (this.heightSpeed) {
                    var b = Yb.Math.clamp(this.object._position.y, this.heightMin, this.heightMax),
                    c = b - this.heightMin;
                    this.autoSpeedFactor = a * c * this.heightCoef
                } else this.autoSpeedFactor = 0;
                var d = a * this.movementSpeed;
                if (this.moveForward || this.autoForward && !this.moveBackward) {
                    var e = this.object._position.clone();
                    this.object.translateZ( - (d + this.autoSpeedFactor));
                    var g = this.object.target;
                    this.verticalFixed && this.object.setY(e.y);
                    var h = this.object._position,
                    i = new $b,
                    j = new $b;
                    i.subVectors(h, g),
                    j.subVectors(e, g),
                    i.z * j.z <= this.minDistance * this.minDistance && this.object.target.subVectors(this.object._position, f)
                }
                if (this.moveBackward) {
                    var e = this.object._position.clone();
                    this.object.translateZ(d),
                    this.verticalFixed && this.object.setY(e.y)
                }
                this.moveLeft && (this.object.translateX( - d), this.object.target.subVectors(this.object._position, f)),
                this.moveRight && (this.object.translateX(d), this.object.target.subVectors(this.object._position, f)),
                this.moveUp && (this.object.translateY(d), this.object.target.subVectors(this.object._position, f)),
                this.moveDown && (this.object.translateY( - d), this.object.target.subVectors(this.object._position, f));
                var k = a * this.lookSpeed; ! this.activeLook && !this.dragMode && (k = 0);
                var l = this.verticalLookRatio;
                if (this.constrainVertical && (l = Math.PI / (this.verticalMax - this.verticalMin)), this.lon += this.mouseX * k, this.dragMode && (this.mouseX = 0), this.lookVertical && (this.lat -= this.mouseY * k * l), this.lat = Math.max( - 85, Math.min(85, this.lat)), this.phi = Yb.Math.degToRad(90 - this.lat), this.theta = Yb.Math.degToRad(this.lon), this.constrainVertical && (this.phi = Yb.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax)), this.fpsMode) {
                    var m = this.object.target,
                    h = this.object._position;
                    m.x = h.x + 100 * Math.sin(this.phi) * Math.sin(this.theta),
                    m.y = h.y + 100 * Math.cos(this.phi),
                    m.z = h.z - 100 * Math.sin(this.phi) * Math.cos(this.theta),
                    this.object.look(m)
                }
            }
        },
        this.update = function() {
            if (f.subVectors(this.object._position, this.object.target), !this.noRotate && !this.fpsMode && this.rotateCamera(), this.noZoom || this.zoomCamera(), !this.noPan && !this.fpsMode && this.panCamera(), o && o.element && this.network.doubleClickToLookAtFunction(o.element)) {
                this.object.target = o.point;
                var a = this.object._position.distanceTo(this.object.target),
                b = o.face.normal.clone();
                b = b.applyMatrix4((new Yb.Mat4).extractRotation(o.element.worldMatrix)),
                b.normalize(),
                f = b.multiplyScalar(a),
                o = null
            }
            this.object.setPosition(this.object._position.clone().addVectors(this.object.target, f)),
            this.updateFPS(),
            this.fpsMode || (this.checkDistances(), this.object.look(this.object.target)),
            this.lastPosition.distanceToSquared(this.object._position) > 0 && this.lastPosition.copy(this.object._position)
        }
    },
    Yb.extend(Yb.DefaultInteraction, Yb.BaseInteraction, {
        STATE: {
            NONE: -1,
            ROTATE: 0,
            ZOOM: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_ZOOM: 4,
            TOUCH_PAN: 5
        },
        __accessor: ["rotateSpeed", "zoomSpeed", "panSpeed", "yLowerLimitAngle", "yUpLimitAngle", "minDistance", "maxDistance", "easing", "touchSeq"],
        setUp: function() {
            this.addListener("mousedown", "touchstart", "touchend", "touchmove", "mousewheel", "DOMMouseScroll", "dblclick", "keydown", "keyup")
        },
        tearDown: function() {
            this.removeListener("mousedown", "touchstart", "touchend", "touchmove", "mousewheel", "DOMMouseScroll", "dblclick", "keydown", "keyup")
        },
        beforeUpdate: function() {},
        setUpdateIntervalTime: function(a) {
            this.updateIntervalTime = a
        }
    }),
    Yb.SelectionInteraction = function(a) {
        Yb.BaseInteraction.call(this, a),
        this.selectUnVisible = !0,
        this.ctrlDown = !1,
        this.deleteTimeoutId = null,
        this._areaPickingLevel = 1
    },
    Yb.extend(Yb.SelectionInteraction, Yb.BaseInteraction, {
        constructor: Yb.SelectionInteraction,
        setAreaPickingLevel: function(a) {
            this._areaPickingLevel = a
        },
        getAreaPickingLevel: function() {
            return this._areaPickingLevel
        },
        setUp: function() {
            this.addListener("mousedown")
        },
        tearDown: function() {
            this.removeListener("mousedown")
        },
        setFocus: function(a) {
            if (document.activeElement !== a) {
                var b, c, d, e = document.documentElement;
                document.body,
                e && (cc.isIE || cc.isOpera || e.scrollLeft || e.scrollTop) && (b = e.scrollLeft, c = e.scrollTop, d = e),
                a.focus(),
                d && (d.scrollLeft = b, d.scrollTop = c)
            }
        },
        handle_mousedown: function(a) {
            if (1 != a.stop && !bc.isRightClick(a)) {
                this.setFocus(this.network.getView()),
                this.isCtrlDown(a) ? (this.addListener("mousemove", "mouseup"), this.ctrlDownEvent = a) : this.network.getDataBox().clearSelection();
                var b = this.network.getElementsByMouseEvent(a, !0),
                c = this.network.getFirstSelectElement(b);
                this.network.getDataBox().getSelectionModel().appendSelection(c),
                this.network.onSelect(c)
            }
        },
        handle_mousemove: function(a) {
            var b = this.getBoundingByMouseEvent(a, this.ctrlDownEvent, this.network.devicePixelRatio);
            this.mousemoved = !0,
            this.network.areaPickingRect = b,
            this.network.paintTopCanvas()
        },
        handle_mouseup: function(a) {
            this.network.areaPickingRect = null,
            this.network.paintTopCanvas();
            var b = this.getBoundingByMouseEvent(a, this.ctrlDownEvent);
            if (this.removeListener("mousemove", "mouseup"), this.ctrlDownEvent = null, b && this.mousemoved) {
                var c = this.network.getElementsByBounding(b, !0, this._areaPickingLevel),
                d = new kc;
                if (c.length > 0) for (var e = 0; e < c.length; e++) {
                    var f = c[e].element;
                    this.network.selectable(c[e]) && d.add(f)
                }
                d.size() > 0 && this.network.getDataBox().getSelectionModel().appendSelection(d)
            }
        },
        getBoundingByMouseEvent: function(a, b, c) {
            if (a && b) {
                var d = this.network.getView().getBoundingClientRect(),
                e = a.clientX - d.left,
                f = a.clientY - d.top,
                g = b.clientX - d.left,
                h = b.clientY - d.top,
                i = c || 1,
                j = Math.min(e, g) * i,
                k = Math.min(f, h) * i,
                l = Math.abs(e - g) * i,
                m = Math.abs(f - h) * i;
                return 0 === l && 0 === m ? null: {
                    x: j,
                    y: k,
                    w: l,
                    h: m
                }
            }
        }
    }),
    Yb.TransformGizmo = function() {
        var a = new Yb.TransformGizmoMaterial({
            color: 16711680
        }),
        b = new Yb.TransformGizmoMaterial({
            color: 65280
        }),
        c = new Yb.TransformGizmoMaterial({
            color: 255
        });
        this.handleGizmos = {
            X: [new Yb.Cylinder(a, .005, .005, 1, 4, 1, !1, !1), new $b(.5, 0, 0), new $b(0, 0, -Math.PI / 2)],
            Y: [new Yb.Cylinder(b, .005, .005, 1, 4, 1, !1, !1), new $b(0, .5, 0)],
            Z: [new Yb.Cylinder(c, .005, .005, 1, 4, 1, !1, !1), new $b(0, 0, .5), new $b(Math.PI / 2, 0, 0)]
        };
        var d = !1,
        f = !1;
        this.showHelpers = !0,
        this.showable = !0,
        this.init = function() {
            Yb.Element.call(this),
            this.handles = new Yb.Element,
            this.pickers = new Yb.Element,
            this.planes = new Yb.Element,
            this.addChild(this.handles),
            this.addChild(this.pickers),
            this.addChild(this.planes);
            var a = new Yb.BasicMaterial({
                wireframe: !1,
                color: 65535,
                side: Yb.DoubleSide
            }),
            b = (new Yb.Plane(a, 5e4, 5e4, 2, 2), {
                XY: new Yb.Plane(a, 5e4, 5e4, 2, 2),
                YZ: new Yb.Plane(a, 5e4, 5e4, 2, 2),
                XZ: new Yb.Plane(a, 5e4, 5e4, 2, 2),
                XYZE: new Yb.Plane(a, 5e4, 5e4, 2, 2)
            });
            b.YZ._rotation.set(0, Math.PI / 2, 0),
            b.XZ._rotation.set( - Math.PI / 2, 0, 0);
            for (var c in b) b[c].name = c,
            this.planes.addChild(b[c]),
            this.planes[c] = b[c],
            b[c]._visible = !0;
            for (var c in this.handleGizmos) {
                var d = this.handleGizmos[c][0];
                if (d.name = c, this.handleGizmos[c][1] && d._position.set(this.handleGizmos[c][1].x, this.handleGizmos[c][1].y, this.handleGizmos[c][1].z), this.handleGizmos[c][2] && d._rotation.set(this.handleGizmos[c][2].x, this.handleGizmos[c][2].y, this.handleGizmos[c][2].z), d.mode = this.mode, this.handles.addChild(d), this.pickerGizmos && this.pickerGizmos[c]) {
                    var e = this.pickerGizmos[c][0];
                    this.pickerGizmos[c][1] && e._position.set(this.pickerGizmos[c][1].x, this.pickerGizmos[c][1].y, this.pickerGizmos[c][1].z),
                    this.pickerGizmos[c][2] && e._rotation.set(this.pickerGizmos[c][2].x, this.pickerGizmos[c][2].y, this.pickerGizmos[c][2].z)
                } else var e = d.clone();
                e.mode = this.mode,
                e.name = c,
                this.pickers.addChild(e)
            }
            this.iterator(function(a) {
                a instanceof Yb.Entity && Yb.Utils.transformElement(a)
            })
        },
        this.hide = function() {
            this.handles.getChildren().forEach(function(a) {
                a._visible = !1
            }),
            this.pickers.getChildren().forEach(function(a) {
                a._visible = !1
            }),
            this.planes.getChildren().forEach(function(a) {
                a._visible = !1
            })
        },
        this.show = function() {
            var a = this;
            this.handles.getChildren().forEach(function(b) {
                b._visible = a.showHelpers && a.showable
            }),
            this.pickers.getChildren().forEach(function(a) {
                a._visible = d
            }),
            this.activePlane && (this.activePlane._visible = f)
        },
        this.highlight = function(a) {
            var b;
            for (var c in this.handleGizmos) b = this.handleGizmos[c][0],
            b.oldColor && (b.material instanceof Yb.ArrayMaterial ? (b.material.materials[0].color.copy(b.oldColor), b.material.materials[0].opacity = b.oldOpacity) : (b.material.color.copy(b.oldColor), b.material.opacity = b.oldOpacity), b.oldColor = null);
            this.handleGizmos[a] && (b = this.handleGizmos[a][0], b.material instanceof Yb.ArrayMaterial ? (b.oldColor = b.oldColor || b.material.materials[0].color.clone(), b.oldOpacity = b.oldOpacit !== e ? b.oldOpacity: b.material.materials[0].opacity, b.material.materials[0].opacity = 1) : (b.oldColor = b.oldColor || b.material.color.clone(), b.oldOpacity = b.material.opacity, b.setStyle("material.opacity", 1)))
        },
        this.init()
    },
    Yb.TransformGizmo.prototype = Object.create(Yb.Element.prototype),
    Yb.TransformGizmo.prototype.update = function(a, b) {
        for (var c = new $b(0, 0, 0), d = new $b(0, 1, 0), e = new ac, f = 0; f < this.getChildren().size(); f++) for (var g = 0; g < this.getChildren().get(f).getChildren().size(); g++) {
            var h = this.getChildren().get(f).getChildren().get(g); - 1 != h.name.search("E") ? (h.quaternion.setFromRotationMatrix(e.lookAt(b, c, d)), h._rotation.setEulerFromQuaternion(h.quaternion)) : (h.quaternion.setFromEuler(a), h._rotation.setEulerFromQuaternion(h.quaternion))
        }
    },
    Yb.TransformGizmoTranslate = function() {
        Yb.TransformGizmo.call(this);
        var a = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .2
        }),
        b = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .2
        }),
        c = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .2
        }),
        d = new Yb.Arrow(a, 1, .03, .2, .05, 30),
        e = new Yb.Arrow(b, 1, .03, .2, .05, 30),
        f = new Yb.Arrow(c, 1, .03, .2, .05, 30),
        g = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .5
        }),
        h = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .5
        }),
        i = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .5
        }),
        j = new Yb.TransformGizmoMaterial({
            color: 16777215,
            opacity: .5
        }),
        k = new Yb.Circle(g, .5, 10, 0, Math.PI / 2),
        l = new Yb.Circle(h, .5, 10, 0, Math.PI / 2),
        m = new Yb.Circle(i, .5, 10, 0, Math.PI / 2),
        n = new Yb.Octahedron(j, 1e-4, 0);
        this.handleGizmos = {
            X: [d, new $b(1.6, 0, 0), new $b(0, 0, -Math.PI / 2)],
            Y: [e, new $b(0, 1.6, 0)],
            Z: [f, new $b(0, 0, 1.6), new $b(Math.PI / 2, 0, 0)],
            XYZ: [n],
            XY: [k, new $b(0, 0, 0)],
            YZ: [l, new $b(0, 0, 0), new $b(Math.PI / 2, Math.PI / 2, 0)],
            XZ: [m, new $b(0, 0, 0), new $b(Math.PI / 2, 0, 0)]
        };
        var j = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .25
        }),
        o = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .25
        }),
        p = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .25
        }),
        q = new Yb.Cylinder(j, .075, 0, 1.2, 4, 1, !1),
        r = new Yb.Cylinder(o, .075, 0, 1.2, 4, 1, !1),
        s = new Yb.Cylinder(p, .075, 0, 1.2, 4, 1, !1),
        n = new Yb.Octahedron(j, 1e-4, 0);
        this.pickerGizmos = {
            X: [q, new $b(1.6, 0, 0), new $b(0, 0, -Math.PI / 2)],
            Y: [r, new $b(0, 1.6, 0)],
            Z: [s, new $b(0, 0, 1.6), new $b(Math.PI / 2, 0, 0)],
            XYZ: [n]
        },
        this.setActivePlane = function(a, b) {
            var c = new ac;
            b.applyProjection(c.getInverse(c.extractRotation(this.planes.XY.worldMatrix))),
            "X" == a && (this.activePlane = this.planes.XY, Math.abs(b.y) > Math.abs(b.z) && (this.activePlane = this.planes.XZ)),
            "Y" == a && (this.activePlane = this.planes.XY, Math.abs(b.x) > Math.abs(b.z) && (this.activePlane = this.planes.YZ)),
            "Z" == a && (this.activePlane = this.planes.XZ, Math.abs(b.x) > Math.abs(b.y) && (this.activePlane = this.planes.YZ)),
            "XYZ" == a && (this.activePlane = this.planes.XYZE),
            "XY" == a && (this.activePlane = this.planes.XY),
            "YZ" == a && (this.activePlane = this.planes.YZ),
            "XZ" == a && (this.activePlane = this.planes.XZ),
            this.hide(),
            this.show()
        },
        this.init()
    },
    Yb.TransformGizmoTranslate.prototype = Object.create(Yb.TransformGizmo.prototype),
    Yb.TransformGizmoTranslate.prototype.mode = "translate",
    Yb.TransformGizmoRotate = function() {
        Yb.TransformGizmo.call(this);
        var a = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .2
        }),
        b = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .2
        }),
        c = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .2
        }),
        d = new Yb.TransformGizmoMaterial({
            color: 16776960
        }),
        e = new Yb.TransformGizmoMaterial({
            color: 7895160,
            opacity: .25
        }),
        e = new Yb.TransformGizmoMaterial({
            color: 16711680
        }),
        f = new Yb.Torus(a, 1, .02, 4, 32, Math.PI),
        g = new Yb.Torus(b, 1, .02, 4, 32, Math.PI),
        h = new Yb.Torus(c, 1, .02, 4, 32, Math.PI);
        new Yb.Torus(d, 1.25, .01, 4, 64),
        new Yb.Torus(e, 1, .01, 4, 64),
        this.handleGizmos = {
            X: [f, new $b(0, 0, 0), new $b(0, -Math.PI / 2, -Math.PI / 2)],
            Y: [g, new $b(0, 0, 0), new $b(Math.PI / 2, 0, 0)],
            Z: [h, new $b(0, 0, 0), new $b(0, 0, -Math.PI / 2)]
        };
        var i = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .25
        }),
        j = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .25
        }),
        k = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .25
        }),
        l = new Yb.TransformGizmoMaterial({
            color: 983040,
            opacity: .25
        }),
        m = new Yb.Torus(i, 1, .05, 4, 12, Math.PI),
        n = new Yb.Torus(j, 1, .05, 4, 12, Math.PI),
        o = new Yb.Torus(k, 1, .05, 4, 12, Math.PI);
        new Yb.Torus(l, 1, .05, 2, 24),
        this.pickerGizmos = {
            X: [m, new $b(0, 0, 0), new $b(0, -Math.PI / 2, -Math.PI / 2)],
            Y: [n, new $b(0, 0, 0), new $b(Math.PI / 2, 0, 0)],
            Z: [o, new $b(0, 0, 0), new $b(0, 0, -Math.PI / 2)]
        },
        this.setActivePlane = function(a) {
            "E" == a && (this.activePlane = this.planes.XYZE),
            "X" == a && (this.activePlane = this.planes.YZ),
            "Y" == a && (this.activePlane = this.planes.XZ),
            "Z" == a && (this.activePlane = this.planes.XY),
            this.hide(),
            this.show()
        },
        this.update = function(a, b) {
            Yb.TransformGizmo.prototype.update.apply(this, arguments);
            var c = {
                handles: this.handles,
                pickers: this.pickers
            },
            d = new ac,
            e = new Yb.Euler(0, 0, 1),
            f = new Yb.Quat,
            g = new $b(1, 0, 0),
            h = new $b(0, 1, 0),
            i = new $b(0, 0, 1),
            j = new Yb.Quat,
            k = new Yb.Quat,
            l = new Yb.Quat,
            m = b.clone();
            e.copy(this.planes.XY._rotation),
            f.setFromEuler(e),
            d.makeRotationFromQuaternion(f).getInverse(d),
            m.applyProjection(d);
            for (var n in c) for (var o = 0; o < c[n].getChildren().size; o++) {
                var p = c[n].getChildren().get(o);
                f.setFromEuler(e),
                "X" == p.name && (j.setFromAxisAngle(g, Math.atan2( - m.y, m.z)), f.multiplyQuaternions(f, j), p.quaternion.copy(f)),
                "Y" == p.name && (k.setFromAxisAngle(h, Math.atan2(m.x, m.z)), f.multiplyQuaternions(f, k), p.quaternion.copy(f)),
                "Z" == p.name && (l.setFromAxisAngle(i, Math.atan2(m.y, m.x)), f.multiplyQuaternions(f, l), p.quaternion.copy(f))
            }
        },
        this.init()
    },
    Yb.TransformGizmoRotate.prototype = Object.create(Yb.TransformGizmo.prototype),
    Yb.TransformGizmoRotate.prototype.mode = "rotate",
    Yb.TransformGizmoScale = function() {
        Yb.TransformGizmo.call(this);
        var a = new Yb.TransformGizmoMaterial({
            color: 11184810,
            opacity: 1
        }),
        b = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .2
        }),
        c = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .2
        }),
        d = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .2
        }),
        e = new Yb.Cube(a, .25, .25, .25),
        f = new Yb.Cylinder(null, .1, .1, 1, 4, 1, !1),
        g = new Yb.Cube(a, .225, .225, .225),
        h = new Yb.Cylinder(null, .1, 0, 1, 20, 1, !0);
        h._position.y = .05;
        var h = Yb.Utils.createElement(f, h, b),
        i = (Yb.Utils.createElement(f, h, c), Yb.Utils.createElement(f, h, d), new Yb.Cylinder(b, .08, 0, 1, 4, 1, !1)),
        j = new Yb.Cylinder(c, .08, 0, 1, 4, 1, !1),
        k = new Yb.Cylinder(d, .08, 0, 1, 4, 1, !1),
        l = new Yb.Element;
        l.material = new Yb.BasicMaterial;
        var m = new Yb.Element;
        m.material = new Yb.BasicMaterial;
        var n = new Yb.Element;
        n.material = new Yb.BasicMaterial,
        this.handleGizmos = {
            X: [i, new $b(.5, 0, 0), new $b(0, 0, -Math.PI / 2)],
            Y: [j, new $b(0, .5, 0)],
            Z: [k, new $b(0, 0, .5), new $b(Math.PI / 2, 0, 0)],
            XY: [l],
            YZ: [m],
            XZ: [n],
            XYZ: [e]
        };
        var o = new Yb.TransformGizmoMaterial({
            color: 16711680,
            opacity: .25
        }),
        p = new Yb.TransformGizmoMaterial({
            color: 65280,
            opacity: .25
        }),
        q = new Yb.TransformGizmoMaterial({
            color: 255,
            opacity: .25
        }),
        r = new Yb.Cylinder(o, .125, 0, 1, 4, 1, !1),
        s = new Yb.Cylinder(p, .125, 0, 1, 4, 1, !1),
        t = new Yb.Cylinder(q, .125, 0, 1, 4, 1, !1);
        this.pickerGizmos = {
            X: [r, new $b(.6, 0, 0), new $b(Math.PI / 4, 0, -Math.PI / 2)],
            Y: [s, new $b(0, .6, 0), new $b(0, Math.PI / 4, 0)],
            Z: [t, new $b(0, 0, .6), new $b(Math.PI / 2, Math.PI / 4, 0)],
            XYZ: [g]
        },
        this.setActivePlane = function(a, b) {
            var c = new ac;
            b.applyProjection(c.getInverse(c.extractRotation(this.planes.XY.worldMatrix))),
            "X" == a ? (this.activePlane = this.planes.XY, Math.abs(b.y) > Math.abs(b.z) && (this.activePlane = this.planes.XZ)) : "Y" == a ? (this.activePlane = this.planes.XY, Math.abs(b.x) > Math.abs(b.z) && (this.activePlane = this.planes.YZ)) : "Z" == a ? (this.activePlane = this.planes.XZ, Math.abs(b.x) > Math.abs(b.y) && (this.activePlane = this.planes.YZ)) : "XYZ" == a ? this.activePlane = this.planes.XYZE: this.activePlane = this.planes[a],
            this.hide(),
            this.show()
        },
        this.init()
    },
    Yb.TransformGizmoScale.prototype = Object.create(Yb.TransformGizmo.prototype),
    Yb.TransformGizmoScale.prototype.mode = "scale",
    Yb.EditInteraction = function(a) {
        function b(b) {
            if (r.network._keyboardRemoveEnabled && 46 == b.keyCode && a.getDataBox().getSelectionModel().size() > 0) {
                var c = "Delete?";
                d.confirm(c) && a.getDataBox().removeSelection()
            }
        }
        function c(a) {
            1 === a.touches.length && (r.deleteTimeoutId = setTimeout(function() {
                var b = r.network.getElementsByMouseEvent(a, r.selectUnVisible);
                if (b.length > 0) {
                    var c = b[0],
                    e = "Delete?";
                    d.confirm(e) && r.network.getDataBox().remove(c.element)
                }
            },
            300))
        }
        function f(a) {
            clearTimeout(r.deleteTimeoutId)
        }
        function g(a) {
            clearTimeout(r.deleteTimeoutId)
        }
        function h(a) {
            r.update()
        }
        function i(a) {
            if (r.object && !s) {
                a.preventDefault(),
                a.stopPropagation();
                var b = a.touches ? a.touches[0] : a,
                c = n(b, r.filterIntersectPicker(r.pickers));
                if (c) r.axis = c.object.name,
                r.setMode(c.object.mode);
                else {
                    var d = l(a);
                    d === r.object || null != d && d.editTransformToParent && d.isDescendantOf(r.object) ? (r.axis = r.getAxis(), r.setMode(r.getMode())) : r.axis = !1
                }
                r.update(!0)
            }
        }
        function j(b) {
            if (!b.stop) {
                if (Y.set(b.clientX, b.clientY), r.showHelpers && r.axis || (m(b), i(b)), !r.object || s) return void r.network.dirtyNetwork();
                b.preventDefault(),
                b.stopPropagation();
                var c = b.touches ? b.touches[0] : b;
                if (0 === c.button || c.button == e) {
                    var d = r.filterIntersectPicker(r.pickers),
                    f = n(c, d),
                    g = l(b);
                    if (f || (g === r.object || null != g && g.editTransformToParent && g.isDescendantOf(r.object)) && r.getDefaultPickers() && (f = {
                        object: r.getDefaultPickers()
                    }), f) {
                        r.axis = f.object.name,
                        B.copy(V).sub(S).normalize(),
                        r.gizmo[t].setActivePlane(r.axis, B);
                        var h = n(c, [r.gizmo[t].activePlane]);
                        if (!h && g && (h = n(c, [g])), h) {
                            N.copy(r.object._position),
                            O.copy(r.object._scale),
                            P.extractRotation(r.object.matrix),
                            U.extractRotation(r.object.worldMatrix);
                            var j = r.object.getParent();
                            j == e && (j = a),
                            Q.extractRotation(j.worldMatrix),
                            R.getScaleFromMatrix(C.getInverse(j.worldMatrix)),
                            w.copy(h.point)
                        }
                    }
                }
                r.update(!0),
                s = !0
            }
        }
        function k(b) {
            if (r.object && r.axis && s) {
                b.preventDefault(),
                b.stopPropagation(),
                b.stop = !0;
                var c = b.touches ? b.touches[0] : b,
                d = n(c, [r.gizmo[t].activePlane]);
                if (d || (d = n(c, [r.object])), d) {
                    if (r.moving ? a.fireInteractionEvent({
                        kind: "liveMoveBetween",
                        event: Uc
                    }) : (a.fireInteractionEvent({
                        kind: "liveMoveStart",
                        event: Uc
                    }), r.moving = !0), v.copy(d.point), "translate" == t && r.translateable) {
                        if (v.sub(w), v.multiply(R), "local" == r.space && (v.applyMatrix4(C.getInverse(U)), -1 == r.axis.search("X") && (v.x = 0), -1 == r.axis.search("Y") && (v.y = 0), -1 == r.axis.search("Z") && (v.z = 0), v.applyMatrix4(P), r.object.setPosition(N.clone().add(v))), "world" == r.space || -1 != r.axis.search("XYZ")) { - 1 == r.axis.search("X") && (v.x = 0),
                            -1 == r.axis.search("Y") && (v.y = 0),
                            -1 == r.axis.search("Z") && (v.z = 0),
                            v.applyMatrix4(C.getInverse(Q)),
                            r.object._position.copy(N);
                            var e = r.object._position.clone().add(v);
                            r.snap && ( - 1 != r.axis.search("X") && (e.x = Math.round(r.object._position.x / r.snap) * r.snap), -1 != r.axis.search("Y") && (e.y = Math.round(r.object._position.y / r.snap) * r.snap), -1 != r.axis.search("Z") && (e.z = Math.round(r.object._position.z / r.snap) * r.snap)),
                            r.object.setPosition(e)
                        }
                    } else if ("scale" == t && r.scaleable) {
                        v.sub(w),
                        v.multiply(R);
                        var f = r.object._scale.clone(),
                        g = (r.scaleRate || 1) / 10;
                        if ("XYZ" == r.axis) j = 1 + v.y * g,
                        f.x = O.x * j,
                        f.y = O.y * j,
                        f.z = O.z * j;
                        else if ("XY" === r.axis) {
                            var h = 1 + v.x * g,
                            i = 1 + v.y * g;
                            if (r.forceSameScale) {
                                var j = Math.max(h, i);
                                f.x = O.x * j,
                                f.y = O.y * j
                            } else f.x = O.x * h,
                            f.y = O.y * i
                        } else if ("YZ" === r.axis) {
                            var k = 1 + v.z * g,
                            i = 1 + v.y * g;
                            if (r.forceSameScale) {
                                var j = Math.max(k, i);
                                f.z = O.z * j,
                                f.y = O.y * j
                            } else f.z = O.z * k,
                            f.y = O.y * i
                        } else if ("XZ" === r.axis) {
                            var h = 1 + v.x * g,
                            k = 1 + v.z * g;
                            if (r.forceSameScale) {
                                var j = Math.max(h, i);
                                f.x = O.x * j,
                                f.z = O.z * j
                            } else f.x = O.x * h,
                            f.z = O.z * k
                        } else v.applyMatrix4(C.getInverse(U)),
                        "X" == r.axis && (f.x = O.x * (1 + v.x * g)),
                        "Y" == r.axis && (f.y = O.y * (1 + v.y * g)),
                        "Z" == r.axis && (f.z = O.z * (1 + v.z * g));
                        r.object.setScale(f)
                    } else if ("rotate" == t && r.rotateable) if (v.sub(S), v.multiply(R), D.copy(w).sub(S), D.multiply(R), "E" == r.axis) v.applyMatrix4(C.getInverse(A)),
                    D.applyMatrix4(C.getInverse(A)),
                    x.set(Math.atan2(v.z, v.y), Math.atan2(v.x, v.z), Math.atan2(v.y, v.x)),
                    y.set(Math.atan2(D.z, D.y), Math.atan2(D.x, D.z), Math.atan2(D.y, D.x)),
                    E.setFromRotationMatrix(C.getInverse(Q)),
                    M.setFromAxisAngle(B, x.z - y.z),
                    I.setFromRotationMatrix(U),
                    E.multiplyQuaternions(E, M),
                    E.multiplyQuaternions(E, I),
                    r.object.quaternion.copy(E);
                    else if ("XYZE" == r.axis) M.setFromEuler(v.clone().cross(D).normalize()),
                    E.setFromRotationMatrix(C.getInverse(Q)),
                    J.setFromAxisAngle(M, -v.clone().angleTo(D)),
                    I.setFromRotationMatrix(U),
                    E.multiplyQuaternions(E, J),
                    E.multiplyQuaternions(E, I),
                    r.object.quaternion.copy(E);
                    else if ("local" == r.space) {
                        v.applyMatrix4(C.getInverse(U)),
                        D.applyMatrix4(C.getInverse(U)),
                        x.set(Math.atan2(v.z, v.y), Math.atan2(v.x, v.z), Math.atan2(v.y, v.x)),
                        y.set(Math.atan2(D.z, D.y), Math.atan2(D.x, D.z), Math.atan2(D.y, D.x)),
                        I.setFromRotationMatrix(P),
                        J.setFromAxisAngle(F, x.x - y.x),
                        K.setFromAxisAngle(G, x.y - y.y),
                        L.setFromAxisAngle(H, x.z - y.z),
                        "X" == r.axis && I.multiplyQuaternions(I, J),
                        "Y" == r.axis && I.multiplyQuaternions(I, K),
                        "Z" == r.axis && I.multiplyQuaternions(I, L),
                        r.object.quaternion.copy(I);
                        var l = r.object._rotation.clone();
                        l.setEulerFromQuaternion(I),
                        r.object.setRotation(l)
                    } else if ("world" == r.space) {
                        x.set(Math.atan2(v.z, v.y), Math.atan2(v.x, v.z), Math.atan2(v.y, v.x)),
                        y.set(Math.atan2(D.z, D.y), Math.atan2(D.x, D.z), Math.atan2(D.y, D.x)),
                        E.setFromRotationMatrix(C.getInverse(Q)),
                        J.setFromAxisAngle(F, x.x - y.x),
                        K.setFromAxisAngle(G, x.y - y.y),
                        L.setFromAxisAngle(H, x.z - y.z),
                        I.setFromRotationMatrix(U),
                        "X" == r.axis && E.multiplyQuaternions(E, J),
                        "Y" == r.axis && E.multiplyQuaternions(E, K),
                        "Z" == r.axis && E.multiplyQuaternions(E, L),
                        E.multiplyQuaternions(E, I),
                        r.object.quaternion.copy(E);
                        var l = r.object._rotation.clone();
                        l.setEulerFromQuaternion(E),
                        r.object.setRotation(l)
                    }
                    r.changed = !0
                }
                r.update(!0),
                r.updateTextNote(b, r.object)
            }
        }
        function l(b) {
            var c = r.network.getElementsByMouseEvent(b);
            return a.getFirstEditElement(c)
        }
        function m(b) {
            if (null === X && (X = new Zb), X.set(b.clientX, b.clientY), a.getDataBox().clearEditing(), 0 === X.distanceTo(Y)) {
                var c = r.network.getElementsByMouseEvent(b),
                d = a.getFirstEditElement(c);
                d && (d !== r.object, r.object = d, r.translateable && r.gizmo.translate.show(), r.rotateable && r.gizmo.rotate.show(), r.scaleable && r.gizmo.scale.show()),
                d || (r.gizmo[t].hide(), r.gizmo.translate.hide(), r.gizmo.rotate.hide(), r.gizmo.scale.hide(), r.object = null)
            } else r.changed && r.onElementPropertyChanged && (r.changed = !1, r.moving = !1, r.onElementPropertyChanged(b, r.object), a.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: {
                    e: b,
                    source: r.object,
                    time: (new Date).getTime()
                }
            }));
            r.axis = !1,
            s = !1,
            r.update(!0),
            r.hideTextNote()
        }
        function n(a, b) {
            if (!b) return null;
            var c = r.network.getPickingByEvent(a),
            d = c.intersectObjects(b, !0, !0);
            return d[0] ? d[0] : !1
        }
        Yb.BaseInteraction.call(this, a);
        var o = new Yb.Element,
        p = a.getCamera(),
        q = a.getRootView();
        q = q !== e ? q: document,
        this.domElement = q,
        this.gizmo = {},
        this.gizmo.translate = new Yb.TransformGizmoTranslate,
        this.gizmo.rotate = new Yb.TransformGizmoRotate,
        this.gizmo.scale = new Yb.TransformGizmoScale,
        o.addChild(this.gizmo.translate),
        o.addChild(this.gizmo.rotate),
        o.addChild(this.gizmo.scale),
        this.gizmo.translate.hide(),
        this.gizmo.rotate.hide(),
        this.gizmo.scale.hide(),
        this.object = !1,
        this.snap = !1,
        this.space = "local",
        this.size = 1,
        this.axis = !1;
        var r = this;
        this.scaleable = !0,
        this.rotateable = !0,
        this.translateable = !0,
        this.setShowHelpers(!0);
        var s = !1,
        t = "translate",
        u = {
            type: "change"
        },
        v = (new Yb.Picking, new Yb.Projector, new $b, new $b),
        w = new $b,
        x = new $b,
        y = new $b,
        z = 1,
        A = new ac,
        B = new $b,
        C = new ac,
        D = new $b,
        E = new Yb.Quat,
        F = new $b(1, 0, 0),
        G = new $b(0, 1, 0),
        H = new $b(0, 0, 1),
        I = new Yb.Quat,
        J = new Yb.Quat,
        K = new Yb.Quat,
        L = new Yb.Quat,
        M = new Yb.Quat,
        N = new $b,
        O = new $b,
        P = new ac,
        Q = new ac,
        R = new $b,
        S = new $b,
        T = new Yb.Euler,
        U = new ac,
        V = new $b,
        W = new Yb.Euler;
        this.showNote = !0,
        this.handleDataBoxChange = function(a) {
            "remove" == a.kind ? a.data == r.object && (r.gizmo.translate.hide(), r.gizmo.rotate.hide(), r.gizmo.scale.hide()) : "clear" == a.kind && (r.gizmo.translate.hide(), r.gizmo.rotate.hide(), r.gizmo.scale.hide())
        },
        this.network.getDataBox().addDataBoxChangeListener(this.handleDataBoxChange, this),
        this.network.addPropertyChangeListener(function(a) {
            if ("dataBox" == a.property) {
                var b = a.oldValue,
                c = a.value;
                b.removeDataBoxChangeListener(this.handleDataBoxChange),
                c.addDataBoxChangeListener(this.handleDataBoxChange, this)
            }
        }),
        this.defaultMode = "TranslateXY",
        this.pickers = [],
        this.gizmo.translate.pickers.getChildren().forEach(function(a) {
            r.pickers.push(a)
        }),
        this.gizmo.rotate.pickers.getChildren().forEach(function(a) {
            r.pickers.push(a)
        }),
        this.gizmo.scale.pickers.getChildren().forEach(function(a) {
            r.pickers.push(a)
        }),
        this.attach = function(a) {
            r.object = a,
            this.gizmo.translate.hide(),
            this.gizmo.rotate.hide(),
            this.gizmo.scale.hide(),
            this.gizmo[t].show(),
            r.update()
        },
        this.detach = function(a) {
            r.object = !1,
            this.axis = !1,
            this.gizmo.translate.hide(),
            this.gizmo.rotate.hide(),
            this.gizmo.scale.hide()
        },
        this.setMode = function(a) {
            t = a ? a: t,
            this.update()
        },
        this.setUp = function() {
            q.addEventListener("mousedown", j, !1),
            q.addEventListener("touchstart", j, !1),
            q.addEventListener("mousemove", i, !1),
            q.addEventListener("touchmove", i, !1),
            q.addEventListener("mousemove", k, !1),
            q.addEventListener("touchmove", k, !1),
            q.addEventListener("mouseup", m, !1),
            q.addEventListener("mouseout", m, !1),
            q.addEventListener("touchend", m, !1),
            q.addEventListener("touchcancel", m, !1),
            q.addEventListener("touchleave", m, !1),
            q.addEventListener("keydown", b, !1),
            q.addEventListener("touchstart", c, !1),
            q.addEventListener("touchmove", f, !1),
            q.addEventListener("touchend", g, !1),
            q.addEventListener("mousewheel", h, !1),
            r.network.helperBox.addByDescendant(o)
        },
        this.tearDown = function() {
            q.removeEventListener("mousedown", j, !1),
            q.removeEventListener("touchstart", j, !1),
            q.removeEventListener("mousemove", i, !1),
            q.removeEventListener("touchmove", i, !1),
            q.removeEventListener("mousemove", k, !1),
            q.removeEventListener("touchmove", k, !1),
            q.removeEventListener("mouseup", m, !1),
            q.removeEventListener("mouseout", m, !1),
            q.removeEventListener("touchend", m, !1),
            q.removeEventListener("touchcancel", m, !1),
            q.removeEventListener("touchleave", m, !1),
            q.removeEventListener("keydown", b, !1),
            q.removeEventListener("touchstart", c, !1),
            q.removeEventListener("touchmove", f, !1),
            q.removeEventListener("touchend", g, !1),
            q.removeEventListener("mousewheel", h, !1),
            r.gizmo.translate.hide(),
            r.gizmo.rotate.hide(),
            r.gizmo.scale.hide(),
            r.network.helperBox.removeByDescendant(o)
        },
        this.setSnap = function(a) {
            r.snap = a
        },
        this.setSize = function(a) {
            r.size = a,
            r.dispatchEvent(u),
            this.update()
        },
        this.setSpace = function(a) {
            r.space = a,
            this.update()
        },
        this.update = function(a) {
            r.object && (r.object.updateWorldMatrix(), S.getPositionFromMatrix(r.object.worldMatrix), T.setFromRotationMatrix(C.extractRotation(r.object.worldMatrix)), p.updateWorldMatrix(), V.getPositionFromMatrix(p.worldMatrix), W.setFromRotationMatrix(C.extractRotation(p.worldMatrix)), z = S.distanceTo(V) / 12 * r.size, o.setPosition(S), o.setScale(z, z, z), B.copy(V).sub(S).normalize(), this.gizmo.scale.update(T, B), "local" == r.space ? (this.gizmo.translate.update(T, B), this.gizmo.rotate.update(T, B)) : (this.gizmo.translate.update(new Yb.Euler, B), this.gizmo.rotate.update(new Yb.Euler, B)), this.gizmo.translate.highlight(null), this.gizmo.rotate.highlight(null), this.gizmo.scale.highlight(null), this.gizmo[t].highlight(r.axis), o.updateWorldMatrix(!0), a && r.network.dirtyNetwork())
        },
        this.getDefaultPickers = function() {
            return "TranslateX" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(0) : "TranslateY" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(1) : "TranslateZ" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(2) : "TranslateXY" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(4) : "TranslateYZ" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(5) : "TranslateXZ" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(6) : "TranslateXYZ" === this.defaultMode ? r.gizmo.translate.pickers.getChildren().get(3) : "RotateX" === this.defaultMode ? r.gizmo.rotate.pickers.getChildren().get(0) : "RotateY" === this.defaultMode ? r.gizmo.rotate.pickers.getChildren().get(1) : "RotateZ" === this.defaultMode ? r.gizmo.rotate.pickers.getChildren().get(2) : "ScaleX" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(0) : "ScaleY" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(1) : "ScaleZ" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(2) : "ScaleXYZ" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(6) : "ScaleXY" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(3) : "ScaleYZ" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(4) : "ScaleXZ" === this.defaultMode ? r.gizmo.scale.pickers.getChildren().get(5) : null
        },
        this.getMode = function() {
            var a = this.defaultMode;
            return a.startsWith("Translate") ? "translate": a.startsWith("Rotate") ? "rotate": a.startsWith("Scale") ? "scale": "translate"
        },
        this.getAxis = function() {
            var a = this.defaultMode;
            return a.endsWith("XYZ") ? "XYZ": a.endsWith("XY") ? "XY": a.endsWith("YZ") ? "YZ": a.endsWith("XZ") ? "XZ": a.endsWith("Y") ? "X": a.endsWith("Y") ? "Y": a.endsWith("Z") ? "Z": ""
        };
        var X = null,
        Y = new Zb;
        this.filterIntersectPicker = function(a) {
            var b = [];
            if (!this.showHelpers) return b;
            for (var c = 0; c < a.length; c++) {
                var d = a[c];
                d.getParent() === this.gizmo.translate.pickers && this.translateable && b.push(d),
                d.getParent() === this.gizmo.rotate.pickers && this.rotateable && b.push(d),
                d.getParent() === this.gizmo.scale.pickers && this.scaleable && b.push(d)
            }
            return b
        }
    },
    Yb.extend(Yb.EditInteraction, Yb.BaseInteraction, {
        setShowHelpers: function(a) {
            this.showHelpers = a,
            this.gizmo.translate.showHelpers = a,
            this.gizmo.rotate.showHelpers = a,
            this.gizmo.scale.showHelpers = a,
            this.resetHelpers()
        },
        onElementPropertyChanged: function(a, b) {},
        resetHelpers: function() {
            this.showHelpers && this.translateable && this.object ? this.gizmo.translate.show() : this.gizmo.translate.hide(),
            this.showHelpers && this.rotateable && this.object ? this.gizmo.rotate.show() : this.gizmo.rotate.hide(),
            this.showHelpers && this.scaleable && this.object ? this.gizmo.scale.show() : this.gizmo.scale.hide(),
            this.update(!0)
        },
        setShowNote: function(a) {
            this.showNote = a
        },
        setScaleable: function(a) {
            this.scaleable = a,
            this.gizmo.scale.showable = a,
            this.resetHelpers()
        },
        setRotateable: function(a) {
            this.rotateable = a,
            this.gizmo.rotate.showable = a,
            this.resetHelpers()
        },
        setTranslateable: function(a) {
            this.translateable = a,
            this.gizmo.translate.showable = a,
            this.resetHelpers()
        },
        setDefaultMode: function(a) {
            this.defaultMode = a
        },
        setScaleRate: function(a) {
            this.scaleRate = a || 1
        },
        setForceSameScale: function(a) {
            this.forceSameScale = a
        },
        setSpaceMode: function(a) {
            "world" == a ? this.space = "world": this.space = "local",
            this.update()
        },
        createTextNote: function() {
            this.textNote = document.createElement("div"),
            this.textNote.style.position = "relative",
            this.textNote.style.color = "black",
            this.textNote.style.height = "0px",
            this.textNote.style.zIndex = "1000",
            this.domElement.appendChild(this.textNote);
            var a = document.createElement("table");
            this.noteTable = a,
            this.textNote.appendChild(this.noteTable),
            a.createTHead(),
            a.style.borderLeft = "1px solid #ffa500",
            a.style.borderTop = "1px solid #ffa500",
            a.style.fontSize = "14px",
            a.style.backgroundColor = "rgba(255, 170, 13, 0.5)",
            a.setAttribute("border", 0),
            a.setAttribute("cellspacing", 0),
            a.setAttribute("cellpadding", 0);
            for (var b = 0; 4 > b; b++) {
                for (var c = document.createElement("tr"), d = 0; 4 > d; d++) {
                    var e = document.createElement("td");
                    e.style.borderRight = "1px solid #ffa500",
                    e.style.borderBottom = "1px solid #ffa500",
                    e.style.paddingLeft = "5px",
                    e.style.paddingRight = "5px",
                    e.style.paddingTop = "2px",
                    e.style.paddingBottom = "2px",
                    0 == b && d > 0 || b > 0 && 0 == d ? (e.style.textAlign = "center", e.style.fontWeight = "bold") : e.style.textAlign = "right",
                    c.appendChild(e)
                }
                a.appendChild(c)
            }
        },
        showTextNote: function() {
            this.showNote && (null == this.textNote && this.createTextNote(), this.textNote.style.display = "")
        },
        hideTextNote: function() {
            this.textNote && (this.textNote.style.display = "none")
        },
        updateTextNote: function(a, b) {
            if (null != b && this.showNote) {
                var c = this.network.getRootView().getBoundingClientRect();
                this.showTextNote(),
                this.textNote.style.top = a.clientY - c.top + 20 + "px",
                this.textNote.style.left = a.clientX - c.left + 20 + "px";
                for (var d = b.getRotation(), e = b.getPosition(), f = b.getScale(), g = [[" ", "x", "y", "z"], ["p", e.x, e.y, e.z], ["r", d.x, d.y, d.z], ["s", f.x, f.y, f.z]], h = this.noteTable, i = 0; 4 > i; i++) for (var j = 0; 4 > j; j++) {
                    var k = g[i][j];
                    i > 0 && j > 0 && (k = 2 == i ? (180 * k / Math.PI).toFixed(0) + "&deg;": k.toFixed(2)),
                    h.rows[i].cells[j].innerHTML = "" + k
                }
            }
        }
    });
    var hd = 1e-5,
    id = 0,
    jd = 1,
    kd = 2,
    ld = 3;
    Yb.CSG = function(a) {
        var b, c, d, e, f, g, h, i = [];
        if (! (a instanceof Yb.Element)) {
            if (a instanceof od) return this.tree = a,
            this.matrix = new ac,
            this;
            throw "TGL.CSG: Given geometry is unsupported"
        }
        for (a.computeNodeData && a.computeNodeData(), a.updateWorldMatrix(!0), this.matrix = a.worldMatrix.clone(), b = 0, c = a.faces.length; c > b; b++) {
            if (d = a.faces[b], f = a.uvs[b], g = a.uv2s[b], h = new md, d instanceof pc) e = a.vertices[d.a],
            e = new nd(e.x, e.y, e.z, d.vertexNormals[0], new Zb(f[0].x, f[0].y), g[0].clone()),
            e.materialIndex = d.materialIndex,
            e.applyMatrix4(this.matrix),
            h.vertices.push(e),
            e = a.vertices[d.b],
            e = new nd(e.x, e.y, e.z, d.vertexNormals[1], new Zb(f[1].x, f[1].y), g[1].clone()),
            e.materialIndex = d.materialIndex,
            e.applyMatrix4(this.matrix),
            h.vertices.push(e),
            e = a.vertices[d.c],
            e = new nd(e.x, e.y, e.z, d.vertexNormals[2], new Zb(f[2].x, f[2].y), g[2].clone()),
            e.applyMatrix4(this.matrix),
            e.materialIndex = d.materialIndex,
            h.vertices.push(e);
            else {
                if (! (d instanceof qc)) throw "Invalid face type at index " + b;
                e = a.vertices[d.a],
                e = new nd(e.x, e.y, e.z, d.vertexNormals[0], new Zb(f[0].x, f[0].y), g[0].clone()),
                e.materialIndex = d.materialIndex,
                e.applyMatrix4(this.matrix),
                h.vertices.push(e),
                e = a.vertices[d.b],
                e = new nd(e.x, e.y, e.z, d.vertexNormals[1], new Zb(f[1].x, f[1].y), g[1].clone()),
                e.materialIndex = d.materialIndex,
                e.applyMatrix4(this.matrix),
                h.vertices.push(e),
                e = a.vertices[d.c],
                e = new nd(e.x, e.y, e.z, d.vertexNormals[2], new Zb(f[2].x, f[2].y), g[2].clone()),
                e.materialIndex = d.materialIndex,
                e.applyMatrix4(this.matrix),
                h.vertices.push(e),
                e = a.vertices[d.d],
                e = new nd(e.x, e.y, e.z, d.vertexNormals[3], new Zb(f[3].x, f[3].y), g[3].clone()),
                e.applyMatrix4(this.matrix),
                e.materialIndex = d.materialIndex,
                h.vertices.push(e)
            }
            isNaN(h.calculateProperties().w) ? console.log("Not right polygon") : i.push(h)
        }
        if (this.tree = new od(i), this.tree.materialSize = a.getMaterialSize ? a.getMaterialSize() : 0, a.material instanceof Yb.ArrayMaterial) this.tree.material = a.material;
        else {
            var j = new Yb.ArrayMaterial;
            this.tree.material = j;
            for (var b = 0; b < this.tree.materialSize; b++) j.push(a.material)
        }
    },
    Yb.CSG.prototype.substract = function(a) {
        var b = this.tree.clone(),
        c = a.tree.clone();
        return b.sumMateriaSize(c),
        b.invert(),
        b.clipTo(c),
        c.clipTo(b),
        c.invert(),
        c.clipTo(b),
        c.invert(),
        b.build(c.allPolygons()),
        b.invert(),
        b = new Yb.CSG(b),
        b.matrix = this.matrix,
        b
    },
    Yb.CSG.prototype.union = function(a) {
        var b = this.tree.clone(),
        c = a.tree.clone();
        return b.sumMateriaSize(c),
        b.clipTo(c),
        c.clipTo(b),
        c.invert(),
        c.clipTo(b),
        c.invert(),
        b.build(c.allPolygons()),
        b = new Yb.CSG(b),
        b.matrix = this.matrix,
        b
    },
    Yb.CSG.prototype.intersect = function(a) {
        var b = this.tree.clone(),
        c = a.tree.clone();
        return b.sumMateriaSize(c),
        b.invert(),
        c.clipTo(b),
        c.invert(),
        b.clipTo(c),
        c.clipTo(b),
        b.build(c.allPolygons()),
        b.invert(),
        b = new Yb.CSG(b),
        b.matrix = this.matrix,
        b
    },
    Yb.CSG.prototype.inverse = function() {
        var a = this.tree.clone();
        return a.polygons.map(function(a) {
            a.flip()
        }),
        a = new Yb.CSG(a)
    },
    Yb.CSG.prototype.toGeometry = function(a) {
        var b, c, d, e, f, g, h, i, j, k, l, m = ((new ac).getInverse(this.matrix), new Yb.Entity(this.tree.material, a)),
        n = this.tree.allPolygons(),
        o = n.length,
        p = {};
        for (b = 0; o > b; b++) for (d = n[b], e = d.vertices.length, c = 2; e > c; c++) {
            k = [],
            l = [],
            i = d.vertices[0],
            k.push(new Zb(i.uv.x, i.uv.y)),
            l.push(i.uv2.clone());
            var q = i.materialIndex;
            i = new $b(i.x, i.y, i.z),
            "undefined" != typeof p[i.x + "," + i.y + "," + i.z] ? f = p[i.x + "," + i.y + "," + i.z] : (m.vertices.push(i), f = p[i.x + "," + i.y + "," + i.z] = m.vertices.length - 1),
            i = d.vertices[c - 1],
            k.push(new Zb(i.uv.x, i.uv.y)),
            l.push(i.uv2.clone()),
            i = new $b(i.x, i.y, i.z),
            "undefined" != typeof p[i.x + "," + i.y + "," + i.z] ? g = p[i.x + "," + i.y + "," + i.z] : (m.vertices.push(i), g = p[i.x + "," + i.y + "," + i.z] = m.vertices.length - 1),
            i = d.vertices[c],
            k.push(new Zb(i.uv.x, i.uv.y)),
            l.push(i.uv2.clone()),
            i = new $b(i.x, i.y, i.z),
            "undefined" != typeof p[i.x + "," + i.y + "," + i.z] ? h = p[i.x + "," + i.y + "," + i.z] : (m.vertices.push(i), h = p[i.x + "," + i.y + "," + i.z] = m.vertices.length - 1),
            j = new pc(f, g, h, new $b(d.normal.x, d.normal.y, d.normal.z)),
            j.materialIndex = q || 0,
            m.faces.push(j),
            m.uvs.push(k),
            m.uv2s.push(l)
        }
        return m
    },
    Yb.CSG.prototype.toMesh = function(a) {
        var b = this.toGeometry(a);
        return b.computeBoundingBox(),
        b
    };
    var md = function(a, b, c) {
        a instanceof Array || (a = []),
        this.vertices = a,
        a.length > 0 ? this.calculateProperties() : this.normal = this.w = e
    };
    md.prototype.calculateProperties = function() {
        var a = this.vertices[0],
        b = this.vertices[1],
        c = this.vertices[2],
        d = b.clone().subtract(a),
        e = c.clone().subtract(a);
        return this.normal = d.cross(e).normalize(),
        this.w = this.normal.clone().dot(a),
        this
    },
    md.prototype.clone = function() {
        var a, b, c = new md;
        for (a = 0, b = this.vertices.length; b > a; a++) c.vertices.push(this.vertices[a].clone());
        return c.calculateProperties(),
        c
    },
    md.prototype.flip = function() {
        var a, b = [];
        for (this.normal.multiplyScalar( - 1), this.w *= -1, a = this.vertices.length - 1; a >= 0; a--) b.push(this.vertices[a]);
        return this.vertices = b,
        this
    },
    md.prototype.classifyVertex = function(a) {
        var b = this.normal.dot(a) - this.w;
        return - hd > b ? kd: b > hd ? jd: id
    },
    md.prototype.classifySide = function(a) {
        var b, c, d, e = 0,
        f = 0,
        g = a.vertices.length;
        for (b = 0; g > b; b++) c = a.vertices[b],
        d = this.classifyVertex(c),
        d === jd ? e++:d === kd && f++;
        return e > 0 && 0 === f ? jd: 0 === e && f > 0 ? kd: 0 === e && 0 === f ? id: ld
    },
    md.prototype.splitPolygon = function(a, b, c, d, e) {
        var f = this.classifySide(a);
        if (f === id)(this.normal.dot(a.normal) > 0 ? b: c).push(a);
        else if (f === jd) d.push(a);
        else if (f === kd) e.push(a);
        else {
            var g, h, i, j, k, l, m, n, o, p = [],
            q = [];
            for (h = 0, g = a.vertices.length; g > h; h++) i = (h + 1) % g,
            l = a.vertices[h],
            m = a.vertices[i],
            j = this.classifyVertex(l),
            k = this.classifyVertex(m),
            j != kd && p.push(l),
            j != jd && q.push(l),
            (j | k) === ld && (n = (this.w - this.normal.dot(l)) / this.normal.dot(m.clone().subtract(l)), o = l.interpolate(m, n), p.push(o), q.push(o));
            p.length >= 3 && d.push(new md(p).calculateProperties()),
            q.length >= 3 && e.push(new md(q).calculateProperties())
        }
    },
    Yb.CSG.Polygon = md;
    var nd = function(a, b, c, d, e, f) {
        this.x = a,
        this.y = b,
        this.z = c,
        this.normal = d || new $b,
        this.uv = e || new Zb,
        this.uv2 = f || new Zb
    };
    nd.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    nd.prototype.clone = function() {
        var a = new nd(this.x, this.y, this.z, this.normal.clone(), this.uv.clone(), this.uv2.clone());
        return a.materialIndex = this.materialIndex,
        a
    },
    nd.prototype.add = function(a) {
        return this.x += a.x,
        this.y += a.y,
        this.z += a.z,
        this
    },
    nd.prototype.subtract = function(a) {
        return this.x -= a.x,
        this.y -= a.y,
        this.z -= a.z,
        this
    },
    nd.prototype.multiplyScalar = function(a) {
        return this.x *= a,
        this.y *= a,
        this.z *= a,
        this
    },
    nd.prototype.cross = function(a) {
        var b = this.x,
        c = this.y,
        d = this.z;
        return this.x = c * a.z - d * a.y,
        this.y = d * a.x - b * a.z,
        this.z = b * a.y - c * a.x,
        this
    },
    nd.prototype.normalize = function() {
        var a = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        return this.x /= a,
        this.y /= a,
        this.z /= a,
        this
    },
    nd.prototype.dot = function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    nd.prototype.lerp = function(a, b) {
        return this.add(a.clone().subtract(this).multiplyScalar(b)),
        this.normal.add(a.normal.clone().sub(this.normal).multiplyScalar(b)),
        this.uv.add(a.uv.clone().sub(this.uv).multiplyScalar(b)),
        this.uv2.add(a.uv2.clone().sub(this.uv2).multiplyScalar(b)),
        this
    },
    nd.prototype.interpolate = function(a, b) {
        return this.clone().lerp(a, b)
    },
    nd.prototype.applyMatrix4 = function(a) {
        var b = this.x,
        c = this.y,
        d = this.z,
        e = a.elements;
        return this.x = e[0] * b + e[4] * c + e[8] * d + e[12],
        this.y = e[1] * b + e[5] * c + e[9] * d + e[13],
        this.z = e[2] * b + e[6] * c + e[10] * d + e[14],
        this
    },
    Yb.CSG.Vertex = nd;
    var od = function(a) {
        var b, c, d = [],
        f = [];
        if (this.polygons = [], this.front = this.back = e, a instanceof Array && 0 !== a.length) {
            for (this.divider = a[0].clone(), b = 0, c = a.length; c > b; b++) this.divider.splitPolygon(a[b], this.polygons, this.polygons, d, f);
            d.length > 0 && (this.front = new od(d)),
            f.length > 0 && (this.back = new od(f))
        }
    };
    od.isConvex = function(a) {
        var b, c;
        for (b = 0; b < a.length; b++) for (c = 0; c < a.length; c++) if (b !== c && a[b].classifySide(a[c]) !== kd) return ! 1;
        return ! 0
    },
    od.prototype.build = function(a) {
        var b, c, d = [],
        e = [];
        for (this.divider || (this.divider = a[0].clone()), b = 0, c = a.length; c > b; b++) this.divider.splitPolygon(a[b], this.polygons, this.polygons, d, e);
        d.length > 0 && (this.front || (this.front = new od), this.front.build(d)),
        e.length > 0 && (this.back || (this.back = new od), this.back.build(e))
    },
    od.prototype.allPolygons = function() {
        var a = this.polygons.slice();
        return this.front && (a = a.concat(this.front.allPolygons())),
        this.back && (a = a.concat(this.back.allPolygons())),
        a
    },
    od.prototype.clone = function() {
        var a = new od;
        if (this.divider && (a.divider = this.divider.clone()), a.polygons = this.polygons.map(function(a) {
            return a.clone()
        }), a.front = this.front && this.front.clone(), a.back = this.back && this.back.clone(), a.materialSize = this.materialSize, a.material = new Yb.ArrayMaterial, this.material) for (var b = 0; b < this.material.materials.length; b++) a.material.materials.push(this.material.materials[b]);
        return a
    },
    od.prototype.invert = function() {
        var a, b, c;
        for (a = 0, b = this.polygons.length; b > a; a++) this.polygons[a].flip();
        return this.divider && this.divider.flip(),
        this.front && this.front.invert(),
        this.back && this.back.invert(),
        c = this.front,
        this.front = this.back,
        this.back = c,
        this
    },
    od.prototype.clipPolygons = function(a) {
        var b, c, d, e;
        if (!this.divider) return a.slice();
        for (d = [], e = [], b = 0, c = a.length; c > b; b++) this.divider.splitPolygon(a[b], d, e, d, e);
        return this.front && (d = this.front.clipPolygons(d)),
        e = this.back ? this.back.clipPolygons(e) : [],
        d.concat(e)
    },
    od.prototype.clipTo = function(a) {
        this.polygons = a.clipPolygons(this.polygons),
        this.front && this.front.clipTo(a),
        this.back && this.back.clipTo(a)
    },
    od.prototype.sumMateriaSize = function(a) {
        a.changeMaterialIndex(this.materialSize),
        this.materialSize = this.materialSize + a.materialSize;
        for (var b = 0; b < a.material.materials.length; b++) this.material.materials.push(a.material.materials[b])
    },
    od.prototype.changeMaterialIndex = function(a) {
        for (var b = 0; b < this.polygons.length; b++) for (var c = this.polygons[b], d = 0; d < c.vertices.length; d++) {
            var e = c.vertices[d];
            e.materialIndex = e.materialIndex + a
        }
        this.front && this.front.changeMaterialIndex(a),
        this.back && this.back.changeMaterialIndex(a)
    },
    Yb.CSG.Node = od,
    Yb.XmlSerializer = function(a, b, c) {
        this.dataBox = a,
        this.settings = b ? b: new Yb.SerializationSettings,
        this.filterFunction = c,
        this.ref = 0,
        this.refMap = {},
        this.idMap = {},
        this.xmlString = ""
    },
    Yb.extend(Yb.XmlSerializer, Object, {
        serialize: function() {
            return this.xmlString = "<TGL version='" + Yb.version + "' platform='html5'>\n",
            this.serializeBody(),
            this.xmlString += "</TGL>\n",
            this.xmlString
        },
        serializeBody: function() {
            this.ref = 0,
            this.dataBox.getRoots().forEach(this.initRefs, this),
            this.settings.isDataBoxSerializable && (this.xmlString += "<dataBox class='" + this.dataBox.getClassName() + "'>\n", this.dataBox.serializeXml(this, this.dataBox.newInstance()), this.xmlString += "</dataBox>\n"),
            this.dataBox.getRoots().forEach(this.serializeData, this)
        },
        initRefs: function(a) {
            this.refMap[a.getId()] = this.ref++,
            a.getChildren().forEach(this.initRefs, this)
        },
        isSerializable: function(a) {
            return this.dataBox.contains(a) ? this.filterFunction && !this.filterFunction(a) ? !1 : !0 : !1
        },
        getPropertyType: function(a, b) {
            var c = this.settings.getPropertyType(b);
            return c || a.__SizePropeties && -1 != a.__SizePropeties.indexOf(b) && (c = "number"),
            c
        },
        serializeData: function(a) {
            if (this.isSerializable(a)) {
                var b = a.newInstance(),
                c = this.refMap[a.getId()];
                this.xmlString += "<data class='" + a.getClassName() + "' ref='" + c + "'",
                null != this.settings.getPropertyType("id") && (this.xmlString += " id='" + a.getId() + "'"),
                this.xmlString += ">\n",
                a.serializeXml(this, b),
                this.xmlString += "</data>\n"
            }
            a.getChildren().forEach(this.serializeData, this)
        },
        serializePropertyXml: function(a, b, c) {
            var d = this.getPropertyType(a, b);
            if (d) {
                var e = Yb.getValue(a, b, d),
                f = Yb.getValue(c, b, d);
                e !== f && this.serializeValue("p", b, e, f, d)
            }
        },
        serializeStyleXml: function(a, b, c) {
            var d = this.settings.getStyleType(b);
            if (d) {
                var e = a.getStyle(b),
                f = c.getStyle(b);
                e != f && this.serializeValue("s", b, e, f, d)
            }
        },
        serializeClientXml: function(a, b, c) {
            var d = this.settings.getClientType(b);
            if (null != d) {
                var e = a.getClient(b),
                f = c.getClient(b);
                e != f && this.serializeValue("c", b, e, f, d)
            }
        },
        serializeValue: function(a, b, c, d, e) {
            if ("s" === a && (c = this.flattenArray(c), c instanceof Array && "string" !== e && "color" !== e && "number" !== e && (e = "list." + e, c = new kc(c))), null == c) this.xmlString += "	<" + a + " n='" + b + "' none=''/>\n";
            else if ("cdata" === e) this.xmlString += "	<" + a + " n='" + b + "'><![CDATA[" + c + "]]></" + a + ">\n";
            else if ("data" === e) {
                var f = this.refMap[c.getId()];
                null != f && (this.xmlString += "	<" + a + " n='" + b + "' ref='" + f + "'/>\n")
            } else "vec2" === e ? d && c.x === d.x && c.y === d.y || (this.xmlString += "	<" + a + " n='" + b + "' x='" + c.x + "' y='" + c.y + "'/>\n") : "vec3" === e ? d && c.x === d.x && c.y === d.y && c.z == d.z || (this.xmlString += "	<" + a + " n='" + b + "' x='" + c.x + "' y='" + c.y + "' z='" + c.z + "'/>\n") : "list.vec2" === e ? (this.xmlString += "	<" + a + " n='" + b + "'>\n", c instanceof Array && (c = new kc(c)), c.forEach(function(b) {
                if (b instanceof Array) {
                    this.xmlString += "	<" + a + ">\n";
                    for (var c = 0; c < b.length; c++) {
                        var d = b[c];
                        this.xmlString += "		<p x='" + d.x + "' y='" + d.y + "'/>\n"
                    }
                    this.xmlString += "	</" + a + ">\n"
                } else this.xmlString += "		<p x='" + b.x + "' y='" + b.y + "'/>\n"
            },
            this), this.xmlString += "	</" + a + ">\n") : "list.vec3" === e ? (this.xmlString += "	<" + a + " n='" + b + "'>\n", c instanceof Array && (c = new kc(c)), c.forEach(function(b) {
                if (b instanceof Array) {
                    this.xmlString += "	<" + a + ">\n";
                    for (var c = 0; c < b.length; c++) {
                        var d = b[c];
                        this.xmlString += "	<" + a + "' x='" + d.x + "' y='" + d.y + "' z='" + d.z + "'/>\n"
                    }
                    this.xmlString += "	</" + a + ">\n"
                } else this.xmlString += "		<" + a + "' x='" + b.x + "' y='" + b.y + "' z='" + b.z + "'/>\n"
            },
            this), this.xmlString += "	</" + a + ">\n") : "list.string" === e || "list.number" === e || "list.color" === e ? (this.xmlString += "	<" + a + " n='" + b + "'>\n", c.forEach(function(a) {
                this.xmlString += "		<s>" + a + "</s>\n"
            },
            this), this.xmlString += "	</" + a + ">\n") : this.xmlString += "	<" + a + " n='" + b + "'>" + c + "</" + a + ">\n"
        },
        flattenArray: function(a) {
            if (a instanceof Array) {
                for (var b = 0; b < a.length - 1; b++) if (a[b] != a[b + 1]) {
                    if (!a[b] || !a[b].equals) return a;
                    if (!a[b].equals(a[b + 1])) return a
                }
                return a[0]
            }
            return a
        },
        deserialize: function(a, b) {
            Yb.isDeserializing = !0,
            this.xmlString = a;
            var c = Yb.xml(a).documentElement;
            this.refMap = {},
            this.idMap = {};
            var d, e, f, g = new kc,
            h = new kc,
            i = c.getElementsByTagName("data"),
            j = i.length;
            for (f = 0; j > f; f++) {
                e = i[f];
                var k = e.getAttribute("class"),
                l = this.settings.getPropertyType("id");
                if (l && e.hasAttribute("id")) {
                    var m = null;
                    if ("string" === l) m = e.getAttribute("id");
                    else if ("int" === l) m = parseInt(e.getAttribute("id"));
                    else {
                        if ("number" !== l) throw "Unsupported id type '" + l + "'";
                        m = parseFloat(e.getAttribute("id"))
                    }
                    if ("remove" === e.getAttribute("action")) {
                        this.dataBox.removeById(m);
                        continue
                    }
                    d = this.dataBox.getDataById(m),
                    d || (d = Yb.newInstance(k, m))
                } else d = Yb.newInstance(k);
                if (e.hasAttribute("ref")) {
                    var n = e.getAttribute("ref");
                    this.refMap[n] = d
                }
                g.add(d),
                h.add(e),
                this.idMap[d.getId()] = d
            }
            for (this.dataBox.forEach(function(a) {
                this.idMap[a.getId()] = a
            },
            this), j = g.size(), f = 0; j > f; f++) d = g.get(f),
            this.dataBox.containsById(d.getId()) || (b && !d.getParent() && d.setParent(b), this.dataBox.add(d));
            for (f = 0; j > f; f++) d = g.get(f),
            e = h.get(f),
            d.deserializeXml(this, e);
            this.settings.isDataBoxSerializable && 1 === c.getElementsByTagName("dataBox").length && this.dataBox.deserializeXml(this, c.getElementsByTagName("dataBox")[0]),
            Yb.isDeserializing = !1
        },
        deserializePropertyXml: function(a, b, c) {
            var d = this.getPropertyType(a, c);
            d && Yb.setValue(a, c, this.deserializeValue(b, d))
        },
        deserializeStyleXml: function(a, b, c) {
            var d = this.settings.getStyleType(c);
            d && a.setStyle(c, this.deserializeValue(b, d))
        },
        deserializeClientXml: function(a, b, c) {
            var d = this.settings.getClientType(c);
            d && a.setClient(c, this.deserializeValue(b, d))
        },
        deserializePoint: function(a) {
            var b = a.getAttribute("x") ? parseFloat(a.getAttribute("x")) : null,
            c = a.getAttribute("a") ? parseFloat(a.getAttribute("a")) : null;
            if (null != b) {
                var d = a.getAttribute("y") ? parseFloat(a.getAttribute("y")) : null,
                e = a.getAttribute("z") ? parseFloat(a.getAttribute("z")) : null,
                f = a.getAttribute("w") ? parseFloat(a.getAttribute("w")) : null;
                return null != f ? new Yb.Vec4(b, d, e, f) : null != e ? new Yb.Vec3(b, d, e) : new Yb.Vec2(b, d)
            }
            if (null != c) {
                var g = a.getAttribute("b") ? parseFloat(a.getAttribute("b")) : null,
                h = a.getAttribute("c") ? parseFloat(a.getAttribute("c")) : null,
                i = a.getAttribute("d") ? parseFloat(a.getAttribute("d")) : null;
                return null != i ? new Yb.Face4(c, g, h, i) : new Yb.Face3(c, g, h)
            }
            return null
        },
        arrayStyleValue: function(a, b) {
            var c = [];
            if (a.indexOf(",")) {
                if (c = a.split(","), "string" === b) return c;
                if ("number" === b) {
                    for (var d = [], e = 0; e < c.length; e++) d.push(parseFloat(c[e]));
                    return d
                }
                if ("color" === b) {
                    for (var f = [], e = 0; e < c.length; e++) f.push(new Yb.Color(c[e]));
                    return f
                }
            }
        },
        deserializeValue: function(a, b, c) {
            if (a.hasAttribute("@none")) return null;
            var d = "s" === a.nodeName,
            e = d && -1 !== a.textContent.indexOf(",");
            if ("string" === b) return e ? this.arrayStyleValue(a.textContent, b) : a.textContent;
            if ("color" === b) return e ? this.arrayStyleValue(a.textContent, b) : a.textContent;
            if ("number" === b) return e ? this.arrayStyleValue(a.textContent, b) : parseFloat(a.textContent);
            if ("boolean" === b) return "true" === a.textContent;
            if ("int" === b) return parseInt(a.textContent);
            if ("point" === b) return this.deserializePoint(a);
            if ("vec2" === b) {
                var f = parseFloat(a.getAttribute("x")),
                g = parseFloat(a.getAttribute("y"));
                if (!isNaN(f) && !isNaN(g) || !d) return new Yb.Vec2(f, g);
                b = "list.point"
            }
            if ("vec3" === b) {
                var f = parseFloat(a.getAttribute("x")),
                g = parseFloat(a.getAttribute("y")),
                h = parseFloat(a.getAttribute("z"));
                return new Yb.Vec3(f, g, h)
            }
            if ("data" === b) {
                var i = a.getAttribute("ref"),
                j = this.refMap[i];
                return j ? j: this.idMap[i]
            }
            var k, l, m, n;
            if ("list.point" === b) {
                var o = new kc,
                p = a.getElementsByTagName("p");
                for (k = p.length, n = 0; k > n; n++) {
                    var q = p[n];
                    o.add(this.deserializePoint(q))
                }
                return d ? o._as: o
            }
            if ("list.string" === b) {
                var r = new kc;
                for (m = a.getElementsByTagName("s"), k = m.length, n = 0; k > n; n++) r.add(m[n].textContent);
                return r
            }
            if ("list.number" === b) {
                for (l = new kc, m = a.getElementsByTagName("s"), k = m.length, n = 0; k > n; n++) l.add(parseFloat(m[n].textContent));
                return l
            }
            if ("array.string" === b) return a.textContent.split(",");
            if ("array.number" === b) {
                for (l = a.textContent.split(","), k = l.length, n = 0; k > n; n++) l[n] = parseFloat(l[n]);
                return l
            }
            return "rectangle" === b ? {
                x: parseFloat(a.getAttribute("x")),
                y: parseFloat(a.getAttribute("y")),
                width: parseFloat(a.getAttribute("w")),
                height: parseFloat(a.getAttribute("h"))
            }: a.textContent
        }
    }),
    Yb.addMethod(Yb.Data, {
        serializeXml: function(a, b) {
            if (this.__SizePropeties && this.__SizePropeties.length) {
                var c, d;
                for (c = 0, d = this.__SizePropeties.length; d > c; c++) this.serializePropertyXml(a, this.__SizePropeties[c], b)
            } else this.serializePropertyXml(a, "materialSize", b),
            this.vertices && this.vertices.length && this.serializePropertyXml(a, "vertices", b),
            this.faces && this.faces.length && this.serializePropertyXml(a, "faces", b),
            this.uvs && this.uvs.length && this.serializePropertyXml(a, "uvs", b);
            if (a.settings.isClientSerializable && this._clientMap) for (var e in this._clientMap) this.serializeClientXml(a, e, b);
            this.serializePropertyXml(a, "name", b),
            this.serializePropertyXml(a, "parent", b)
        },
        serializePropertyXml: function(a, b, c) {
            a.serializePropertyXml(this, b, c)
        },
        serializeClientXml: function(a, b, c) {
            a.serializeClientXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            var c, d, e, f, g = b.getElementsByTagName("p"),
            h = g.length;
            for (c = 0; h > c; c++) d = g[c],
            d.hasAttribute("n") && this.deserializePropertyXml(a, d, d.getAttribute("n"));
            if (a.settings.isClientSerializable) for (e = b.getElementsByTagName("c"), h = e.length, c = 0; h > c; c++) f = e[c],
            f.hasAttribute("n") && this.deserializeClientXml(a, f, f.getAttribute("n"))
        },
        deserializePropertyXml: function(a, b, c) {
            a.deserializePropertyXml(this, b, c)
        },
        deserializeClientXml: function(a, b, c) {
            a.deserializeClientXml(this, b, c)
        }
    }),
    Yb.addMethod(Yb.Element, {
        serializeXml: function(a, b) {
            if (a.settings.isStyleSerializable && this.styleMap) for (var c in this.styleMap) this.isSideStyle(c) || this.serializeStyleXml(a, c, b);
            this.serializePropertyXml(a, "position", b),
            this.serializePropertyXml(a, "rotation", b),
            this.serializePropertyXml(a, "scale", b),
            Yb.Element.superClass.serializeXml.call(this, a, b),
            this._alarmState.getHighestNativeAlarmSeverity() && "alarmstate" === a.settings.getPropertyType("alarmState") && (a.xmlString += "	<p n='alarmState'>\n", Yb.AlarmSeverity.forEach(function(b) {
                var c = this.getNewAlarmCount(b);
                c > 0 && (a.xmlString += "		<n n='" + b.name + "' c='" + c + "'/>\n")
            },
            this._alarmState), Yb.AlarmSeverity.forEach(function(b) {
                var c = this.getAcknowledgedAlarmCount(b);
                c > 0 && (a.xmlString += "		<a n='" + b.name + "' c='" + c + "'/>\n")
            },
            this._alarmState), a.xmlString += "	</p>\n")
        },
        serializeStyleXml: function(a, b, c) {
            a.serializeStyleXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            if (Yb.Element.superClass.deserializeXml.call(this, a, b), a.settings.isStyleSerializable) {
                var c, d, e = b.getElementsByTagName("s"),
                f = e.length;
                for (c = 0; f > c; c++) d = e[c],
                d.hasAttribute("n") && this.deserializeStyleXml(a, d, d.getAttribute("n"))
            }
        },
        deserializeStyleXml: function(a, b, c) {
            a.deserializeStyleXml(this, b, c)
        },
        deserializePropertyXml: function(a, b, c) {
            if ("alarmState" === c) {
                if ("alarmstate" === a.settings.getPropertyType("alarmState")) {
                    var d, e, f, g = b.getElementsByTagName("n");
                    for (e = 0; e < g.length; e++) f = g[e],
                    d = twaver.AlarmSeverity.getByName(f.getAttribute("n")),
                    this._alarmState.setNewAlarmCount(d, parseInt(f.getAttribute("c")));
                    for (g = b.getElementsByTagName("a"), e = 0; e < g.length; e++) f = g[e],
                    d = twaver.AlarmSeverity.getByName(f.getAttribute("n")),
                    this._alarmState.setAcknowledgedAlarmCount(d, parseInt(f.getAttribute("c")))
                }
            } else Yb.Element.superClass.deserializePropertyXml.call(this, a, b, c)
        }
    }),
    Yb.addMethod(Yb.DataBox, {
        serializeXml: function(a, b) {
            if (a.settings.isClientSerializable && this._clientMap) for (var c in this._clientMap) this.serializeClientXml(a, c, b);
            this.serializePropertyXml(a, "name", b)
        },
        serializePropertyXml: function(a, b, c) {
            a.serializePropertyXml(this, b, c)
        },
        serializeClientXml: function(a, b, c) {
            a.serializeClientXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            var c, d, e, f, g = b.getElementsByTagName("p"),
            h = g.length;
            for (c = 0; h > c; c++) d = g[c],
            d.hasAttribute("n") && this.deserializePropertyXml(a, d, d.getAttribute("n"));
            if (a.settings.isClientSerializable) for (e = b.getElementsByTagName("c"), h = e.length, c = 0; h > c; c++) f = e[c],
            f.hasAttribute("n") && this.deserializeClientXml(a, f, f.getAttribute("n"))
        },
        deserializePropertyXml: function(a, b, c) {
            a.deserializePropertyXml(this, b, c)
        },
        deserializeClientXml: function(a, b, c) {
            a.deserializeClientXml(this, b, c)
        }
    }),
    Yb.JsonSerializer = function(a, b, c) {
        this.dataBox = a,
        this.settings = b ? b: new Yb.SerializationSettings,
        this.filterFunction = c,
        this.ref = 0,
        this.refMap = {},
        this.idMap = {},
        this.jsonObject = {}
    },
    Yb.extend(Yb.JsonSerializer, Object, {
        constructor: Yb.JsonSerializer,
        className: "TGL.JsonSerializer",
        serialize: function() {
            return this.jsonObject = {
                v: Yb.version,
                platform: "html5"
            },
            this.serializeBody(),
            JSON.stringify(this.jsonObject)
        },
        serializeBody: function() {
            if (this.ref = 0, this.dataBox.getRoots().forEach(this.initRefs, this), this.settings.isDataBoxSerializable) {
                var a = {
                    "class": this.dataBox.getClassName(),
                    p: {},
                    s: {},
                    c: {}
                };
                this.jsonObject.dataBox = a,
                this.dataBox.serializeJson(this, this.dataBox.newInstance(), a),
                tc.isEmptyObject(a.p) && delete a.p,
                tc.isEmptyObject(a.s) && delete a.s,
                tc.isEmptyObject(a.c) && delete a.c
            }
            this.jsonObject.datas = [],
            this.dataBox.getRoots().forEach(this.serializeData, this)
        },
        initRefs: function(a) {
            if (this.refMap[a.getId()] = this.ref++, a.getChildren().forEach(this.initRefs, this), a instanceof Yb.ComboNode) for (var b = 0; b < a.combos.length; b++) {
                var c = a.combos[b];
                this.refMap[c.getId()] || (this.refMap[c.getId()] = this.ref++)
            }
        },
        isSerializable: function(a) {
            return this.dataBox.contains(a) ? this.filterFunction && !this.filterFunction(a) ? !1 : !0 : !1
        },
        serializeData: function(a) {
            if (this.isSerializable(a)) {
                var b = a.newInstance(),
                c = this.refMap[a.getId()],
                d = {
                    "class": a.getClassName(),
                    ref: c,
                    p: {},
                    s: {},
                    c: {}
                };
                this.settings.getPropertyType("id") && (this.jsonObject.id = a.getId()),
                this.jsonObject.datas.push(d),
                a.serializeJson(this, b, d),
                tc.isEmptyObject(d.p) && delete d.p,
                tc.isEmptyObject(d.s) && delete d.s,
                tc.isEmptyObject(d.c) && delete d.c
            }
            a.getChildren().forEach(this.serializeData, this)
        },
        serializeDataValue: function(a) {
            var b = a.newInstance(),
            c = this.refMap[a.getId()],
            d = {
                "class": a.getClassName(),
                ref: c,
                p: {},
                s: {},
                c: {}
            };
            return a.serializeJson(this, b, d),
            tc.isEmptyObject(d.p) && delete d.p,
            tc.isEmptyObject(d.s) && delete d.s,
            tc.isEmptyObject(d.c) && delete d.c,
            d
        },
        getPropertyType: function(a, b) {
            var c = this.settings.getPropertyType(b);
            return c || (a.__bool && -1 != a.__bool.indexOf(b) ? c = "boolean": a.__SizePropeties && -1 != a.__SizePropeties.indexOf(b) && (c = "number")),
            c
        },
        getStyleType: function(a, b) {
            a.isSideStyle(b) && (b = b.substr(b.indexOf(".") + 1));
            var c = this.settings.getStyleType(b);
            return c
        },
        serializePropertyJson: function(a, b, c, d) {
            var e = this.getPropertyType(a, b);
            if (e) {
                var f = Yb.getValue(a, b, e),
                g = Yb.getValue(c, b, e);
                f !== g && (f && f.equals ? !f.equals(g) && this.serializeValue(b, f, g, e, d.p) : this.serializeValue(b, f, g, e, d.p))
            }
        },
        serializeStyleJson: function(a, b, c, d) {
            var e = this.getStyleType(a, b);
            if (e) {
                var f = a.getStyle(b),
                g = c.getStyle(b);
                b.startsWith("m.") && (f = this.flattenArray(f), g = this.flattenArray(g)),
                b.endsWith(".image") && (f = this.encodeURI(f), g = this.encodeURI(g)),
                f != g && (f && f.equals ? !f.equals(g) && this.serializeValue(b, f, g, e, d.s) : this.serializeValue(b, f, g, e, d.s))
            }
        },
        serializeClientJson: function(a, b, c, d) {
            var e = this.settings.getClientType(b);
            if (null != e) {
                var f = a.getClient(b),
                g = c.getClient(b);
                f != g && (f && f.equals ? !f.equals(g) && this.serializeValue(b, f, g, e, d.c) : this.serializeValue(b, f, g, e, d.c))
            }
        },
        serializeValue: function(a, b, c, d, e) {
            if (null == b) e[a] = null;
            else if (b instanceof kc) e[a] = b._as;
            else if ("data" === d) {
                var f = this.refMap[b.getId()];
                null != f && (e[a] = f)
            } else if ("data.list" === d) {
                for (var g = [], h = 0; h < b.length; h++) g.push(this.serializeDataValue(b[h]));
                e[a] = g
            } else if ("serializeabe.list" === d) {
                for (var g = [], h = 0; h < b.length; h++) g.push(b[h].serializeJsonValue());
                e[a] = g
            } else b.serializeJsonValue ? e[a] = b.serializeJsonValue() : e[a] = b
        },
        deserialize: function(a, b) {
            Yb.isDeserializing = !0,
            this.jsonObject = JSON.parse(a),
            this.refMap = {},
            this.idMap = {};
            var c, d = new kc,
            e = new kc,
            f = this.jsonObject.datas.length;
            null != this.deserializeStartCreateData && this.deserializeStartCreateData(f);
            for (var g = 0; f > g; g++) {
                var h = this.jsonObject.datas[g],
                i = h["class"],
                j = this.settings.getPropertyType("id");
                if (j && null != h.id) {
                    if ("remove" === h.action) {
                        this.dataBox.removeById(h.id);
                        continue
                    }
                    c = this.dataBox.getDataById(h.id),
                    c || (c = Yb.newInstance(i, h.id))
                } else c = Yb.newInstance(i);
                null != h.ref && (this.refMap[h.ref] = c),
                d.add(c),
                e.add(h),
                this.idMap[c.getId()] = c,
                this.deserializeCreateData && this.deserializeCreateData(g, f)
            }
            for (this.dataBox.forEach(function(a) {
                this.idMap[a.getId()] = a
            },
            this), f = d.size(), this.deserializeStartFillData && this.deserializeStartFillData(f), g = 0; f > g; g++) c = d.get(g),
            c.deserializeJson(this, e.get(g)),
            this.deserializeFillData && this.deserializeFillData(g, f);
            for (this.deserializeStartAddData && this.deserializeStartAddData(f), g = 0; f > g; g++) c = d.get(g),
            this.dataBox.containsById(c.getId()) || (b && !c.getParent() && c.setParent(b), "TGL.Entity" === c.getClassName() && (c.computed = !1, c.computeNodeData()), this.dataBox.add(c), this.deserializeAddData && this.deserializeAddData(g, f));
            this.settings.isDataBoxSerializable && this.jsonObject.dataBox && this.dataBox.deserializeJson(this, this.jsonObject.dataBox),
            Yb.isDeserializing = !1
        },
        deserializePropertyJson: function(a, b, c) {
            var d = this.getPropertyType(a, c);
            d && Yb.setValue(a, c, this.deserializeValue(b, d))
        },
        deserializeStyleJson: function(a, b, c) {
            var d = this.getStyleType(a, c);
            if (d) {
                var e = this.deserializeValue(b, d);
                e._as && (e = e._as),
                a.setStyle(c, e)
            }
        },
        deserializeClientJson: function(a, b, c) {
            var d = this.settings.getClientType(c);
            d && a.setClient(c, this.deserializeValue(b, d))
        },
        getClassName: function(a) {
            return null != a ? a["class"] ? a["class"] : a.w !== e && a.x !== e && a.y !== e && a.z !== e ? "TGL.Vec4": a.x !== e && a.y !== e && a.z !== e ? "TGL.Vec3": a.x !== e && a.y !== e ? "TGL.Vec2": a.a !== e && a.b !== e && a.c !== e && a.d !== e ? "TGL.Face4": a.a !== e && a.b !== e && a.c !== e ? "TGL.Face3": void 0 : void 0
        },
        translateJson: function(a) {
            if (null != a) {
                if (null != this.getClassName(a)) {
                    var b = Yb.newInstance(this.getClassName(a));
                    if (b.deserializeJsonValue) b.deserializeJsonValue(a);
                    else for (var c in a) b[c] = a[c];
                    return b
                }
                if (a instanceof Array) for (var d = 0; d < a.length; d++) a[d] = this.translateJson(a[d]);
                return a
            }
        },
        isChinese: function(a) {
            return a = a || "",
            escape(a).indexOf("%u") > 0
        },
        encodeURI: function(a) {
            if (a instanceof Array) {
                for (var b = 0; b < a.length; b++) a[b] = this.encodeURI(a[b]);
                return a
            }
            return "string" == typeof a && this.isChinese(a) ? encodeURI(a) : a
        },
        flattenArray: function(a) {
            if (a instanceof Array) {
                for (var b = 0; b < a.length - 1; b++) if (a[b] != a[b + 1]) {
                    if (!a[b] || !a[b].equals) return a;
                    if (!a[b].equals(a[b + 1])) return a
                }
                return a[0]
            }
            return a
        },
        deserializeValue: function(a, b) {
            if ("data" === b) {
                var c = this.refMap[a];
                return c ? c: this.idMap[a]
            }
            if ("data.list" === b) {
                for (var d, f, g = [], h = 0; h < a.length; h++) d = a[h],
                f = Yb.newInstance(d["class"]),
                null != d.ref && (this.refMap[d.ref] = f),
                f.deserializeJson(this, d),
                g.push(f);
                return g
            }
            if ("color" === b && a.r != e) {
                var i = new Yb.Color;
                return i.setRGB(a.r, a.g, a.b),
                i
            }
            if ("TGL.Path" === a["class"]) {
                var j = new Yb.Path;
                return j.deserializeJsonValue(a),
                j
            }
            if (a instanceof Array) {
                for (var h = 0; h < a.length; h++) a[h] = this.translateJson(a[h]);
                return a
            }
            return null != this.getClassName(a) ? this.translateJson(a) : a
        }
    }),
    Yb.addMethod(Yb.DataBox, {
        serializeJson: function(a, b, c) {
            if (a.settings.isClientSerializable && this._clientMap) for (var d in this._clientMap) this.serializeClientJson(a, d, b, c);
            this.serializePropertyJson(a, "name", b, c)
        },
        serializePropertyJson: function(a, b, c, d) {
            a.serializePropertyJson(this, b, c, d)
        },
        serializeClientJson: function(a, b, c, d) {
            a.serializeClientJson(this, b, c, d)
        },
        deserializeJson: function(a, b) {
            var c;
            for (c in b.p) this.deserializePropertyJson(a, b.p[c], c);
            if (a.settings.isClientSerializable) for (c in b.c) this.deserializeClientJson(a, b.c[c], c)
        },
        deserializePropertyJson: function(a, b, c) {
            a.deserializePropertyJson(this, b, c)
        },
        deserializeClientJson: function(a, b, c) {
            a.deserializeClientJson(this, b, c)
        }
    }),
    Yb.addMethod(Yb.Data, {
        serializeJson: function(a, b, c) {
            if (this.__SizePropeties && this.__SizePropeties.length) {
                var d, e;
                for (d = 0, e = this.__SizePropeties.length; e > d; d++) this.serializePropertyJson(a, this.__SizePropeties[d], b, c)
            } else this.materialSize && this.serializePropertyJson(a, "materialSize", b, c),
            this instanceof Yb.Entity && (this.vertices && this.vertices.length && this.serializePropertyJson(a, "vertices", b, c), this.faces && this.faces.length && this.serializePropertyJson(a, "faces", b, c), this.uvs && this.uvs.length && this.serializePropertyJson(a, "uvs", b, c), this.uv2s && this.uv2s.length && this.serializePropertyJson(a, "uv2s", b, c));
            if (a.settings.isClientSerializable && this._clientMap) for (var f in this._clientMap) this.serializeClientJson(a, f, b, c);
            this.serializePropertyJson(a, "name", b, c),
            this.serializePropertyJson(a, "parent", b, c)
        },
        serializePropertyJson: function(a, b, c, d) {
            a.serializePropertyJson(this, b, c, d)
        },
        serializeClientJson: function(a, b, c, d) {
            a.serializeClientJson(this, b, c, d)
        },
        deserializeJson: function(a, b) {
            var c;
            for (c in b.p) this.deserializePropertyJson(a, b.p[c], c);
            if (a.settings.isClientSerializable) for (c in b.c) this.deserializeClientJson(a, b.c[c], c)
        },
        deserializePropertyJson: function(a, b, c) {
            a.deserializePropertyJson(this, b, c)
        },
        deserializeClientJson: function(a, b, c) {
            a.deserializeClientJson(this, b, c)
        }
    }),
    Yb.addMethod(Yb.Element, {
        serializeJson: function(a, b, c) {
            if (a.settings.isStyleSerializable && this.styleMap) for (var d in this.styleMap) this.isSideStyle(d) || this.serializeStyleJson(a, d, b, c);
            if (Yb.Element.superClass.serializeJson.call(this, a, b, c), this.serializePropertyJson(a, "position", b, c), this.serializePropertyJson(a, "rotation", b, c), this.serializePropertyJson(a, "scale", b, c), this._alarmState.getHighestNativeAlarmSeverity() && "alarmstate" === a.settings.getPropertyType("alarmState")) {
                var e = {
                    n: {},
                    a: {}
                };
                c.p.alarmState = e,
                Yb.AlarmSeverity.forEach(function(a) {
                    var b = this.getNewAlarmCount(a);
                    b > 0 && (e.n[a.name] = b)
                },
                this._alarmState),
                Yb.AlarmSeverity.forEach(function(a) {
                    var b = this.getAcknowledgedAlarmCount(a);
                    b > 0 && (e.a[a.name] = b)
                },
                this._alarmState),
                tc.isEmptyObject(e.n) && delete e.n,
                tc.isEmptyObject(e.a) && delete e.a,
                tc.isEmptyObject(e) && delete c.p.alarmState
            }
        },
        serializeStyleJson: function(a, b, c, d) {
            a.serializeStyleJson(this, b, c, d)
        },
        deserializeJson: function(a, b) {
            if (Yb.Element.superClass.deserializeJson.call(this, a, b), a.settings.isStyleSerializable) for (var c in b.s) this.deserializeStyleJson(a, b.s[c], c)
        },
        deserializeStyleJson: function(a, b, c) {
            a.deserializeStyleJson(this, b, c)
        },
        deserializePropertyJson: function(a, b, c) {
            if ("alarmState" === c) {
                if ("alarmstate" === a.settings.getPropertyType("alarmState")) {
                    var d;
                    for (d in b.n) this._alarmState.setNewAlarmCount(twaver.AlarmSeverity.getByName(d), b.n[d]);
                    for (d in b.a) this._alarmState.setAcknowledgedAlarmCount(twaver.AlarmSeverity.getByName(d), b.a[d])
                }
            } else Yb.Element.superClass.deserializePropertyJson.call(this, a, b, c)
        }
    }),
    Yb.addMethod(Yb.Light, {
        serializeJson: function(a, b, c) {
            if (Yb.Light.superClass.serializeJson.call(this, a, b, c), this.serializePropertyJson(a, "color", b, c), this.serializePropertyJson(a, "ambient", b, c), this.serializePropertyJson(a, "diffuse", b, c), this.serializePropertyJson(a, "specular", b, c), this.serializePropertyJson(a, "castShadow", b, c), this.serializePropertyJson(a, "onlyShadow", b, c), b.__accessor && b.__accessor.length) for (var d = 0; d < b.__accessor.length; d++) this.serializePropertyJson(a, b.__accessor[d], b, c)
        }
    });
    var pd = Yb.Animate = function(a) {
        var b = this;
        b.type = null == a.type ? "number": a.type,
        b.delay = null == a.delay ? 0 : a.delay,
        b.dur = null == a.dur ? 1e3: a.dur,
        b.interval = null == a.interval ? 0 : a.interval,
        b.finish = null == a.finish ? b.delay + b.dur + b.interval: a.finish,
        b.repeat = null == a.repeat ? 1 : a.repeat,
        b.reverse = null == a.reverse ? !0 : a.reverse,
        b.easing = null == a.easing ? "easeNone": a.easing,
        b.onUpdate = a.onUpdate,
        b.onDone = a.onDone,
        b.onStop = a.onStop,
        b.onPlay = a.onPlay,
        b.attr = a.attr,
        b.source = a.source,
        b.filter = a.filter,
        b.from = a.from,
        b.to = a.to,
        b.start = null,
        b.time = 0,
        b.total = 0,
        b.count = 0,
        b.started = !1,
        b.stopped = !1,
        b.id = rd++
    };
    Yb.extend(Yb.Animate, Object, {
        play: function() {
            return Qb(this)
        },
        stop: function(a) {
            return Tb(this, a)
        },
        clone: function() {
            return new pd(this)
        },
        chain: function(a) {
            var b, c = this;
            return c.onDone ? (b = c.onDone, c.onDone = function() {
                b.call(c),
                a.play()
            }) : c.onDone = function() {
                a.play()
            },
            c
        }
    });
    var qd = {},
    rd = 1,
    sd = !1; !
    function td(a) {
        requestAnimationFrame(td),
        sd && (sd = !1, Vb(a))
    } (0)
} (window),
!
function(a, b) {
    function c(a, b, c) {
        null != a && ("number" == typeof a ? this.fromNumber(a, b, c) : null == b && "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b))
    }
    function d() {
        return new c(null)
    }
    function e(a, b, c, d, e, f) {
        for (; --f >= 0;) {
            var g = b * this[a++] + c[d] + e;
            e = Math.floor(g / 67108864),
            c[d++] = 67108863 & g
        }
        return e
    }
    function f(a, b, c, d, e, f) {
        for (var g = 32767 & b,
        h = b >> 15; --f >= 0;) {
            var i = 32767 & this[a],
            j = this[a++] >> 15,
            k = h * i + j * g;
            i = g * i + ((32767 & k) << 15) + c[d] + (1073741823 & e),
            e = (i >>> 30) + (k >>> 15) + h * j + (e >>> 30),
            c[d++] = 1073741823 & i
        }
        return e
    }
    function g(a, b, c, d, e, f) {
        for (var g = 16383 & b,
        h = b >> 14; --f >= 0;) {
            var i = 16383 & this[a],
            j = this[a++] >> 14,
            k = h * i + j * g;
            i = g * i + ((16383 & k) << 14) + c[d] + e,
            e = (i >> 28) + (k >> 14) + h * j,
            c[d++] = 268435455 & i
        }
        return e
    }
    function h(a) {
        return dc.charAt(a)
    }
    function j(a, b) {
        var c = ec[a.charCodeAt(b)];
        return null == c ? -1 : c
    }
    function k(a) {
        for (var b = this.t - 1; b >= 0; --b) a[b] = this[b];
        a.t = this.t,
        a.s = this.s
    }
    function l(a) {
        this.t = 1,
        this.s = 0 > a ? -1 : 0,
        a > 0 ? this[0] = a: -1 > a ? this[0] = a + DV: this.t = 0
    }
    function m(a) {
        var b = d();
        return b.fromInt(a),
        b
    }
    function n(a, b) {
        var d;
        if (16 == b) d = 4;
        else if (8 == b) d = 3;
        else if (256 == b) d = 8;
        else if (2 == b) d = 1;
        else if (32 == b) d = 5;
        else {
            if (4 != b) return void this.fromRadix(a, b);
            d = 2
        }
        this.t = 0,
        this.s = 0;
        for (var e = a.length,
        f = !1,
        g = 0; --e >= 0;) {
            var h = 8 == d ? 255 & a[e] : j(a, e);
            0 > h ? "-" == a.charAt(e) && (f = !0) : (f = !1, 0 == g ? this[this.t++] = h: g + d > this.DB ? (this[this.t - 1] |= (h & (1 << this.DB - g) - 1) << g, this[this.t++] = h >> this.DB - g) : this[this.t - 1] |= h << g, g += d, g >= this.DB && (g -= this.DB))
        }
        8 == d && 0 != (128 & a[0]) && (this.s = -1, g > 0 && (this[this.t - 1] |= (1 << this.DB - g) - 1 << g)),
        this.clamp(),
        f && c.ZERO.subTo(this, this)
    }
    function o() {
        for (var a = this.s & this.DM; this.t > 0 && this[this.t - 1] == a;)--this.t
    }
    function p(a) {
        if (this.s < 0) return "-" + this.negate().toString(a);
        var b;
        if (16 == a) b = 4;
        else if (8 == a) b = 3;
        else if (2 == a) b = 1;
        else if (32 == a) b = 5;
        else {
            if (4 != a) return this.toRadix(a);
            b = 2
        }
        var c, d = (1 << b) - 1,
        e = !1,
        f = "",
        g = this.t,
        i = this.DB - g * this.DB % b;
        if (g-->0) for (i < this.DB && (c = this[g] >> i) > 0 && (e = !0, f = h(c)); g >= 0;) b > i ? (c = (this[g] & (1 << i) - 1) << b - i, c |= this[--g] >> (i += this.DB - b)) : (c = this[g] >> (i -= b) & d, 0 >= i && (i += this.DB, --g)),
        c > 0 && (e = !0),
        e && (f += h(c));
        return e ? f: "0"
    }
    function q() {
        var a = d();
        return c.ZERO.subTo(this, a),
        a
    }
    function r() {
        return this.s < 0 ? this.negate() : this
    }
    function s(a) {
        var b = this.s - a.s;
        if (0 != b) return b;
        var c = this.t;
        if (b = c - a.t, 0 != b) return b;
        for (; --c >= 0;) if (0 != (b = this[c] - a[c])) return b;
        return 0
    }
    function t(a) {
        var b, c = 1;
        return 0 != (b = a >>> 16) && (a = b, c += 16),
        0 != (b = a >> 8) && (a = b, c += 8),
        0 != (b = a >> 4) && (a = b, c += 4),
        0 != (b = a >> 2) && (a = b, c += 2),
        0 != (b = a >> 1) && (a = b, c += 1),
        c
    }
    function u() {
        return this.t <= 0 ? 0 : this.DB * (this.t - 1) + t(this[this.t - 1] ^ this.s & this.DM)
    }
    function v(a, b) {
        var c;
        for (c = this.t - 1; c >= 0; --c) b[c + a] = this[c];
        for (c = a - 1; c >= 0; --c) b[c] = 0;
        b.t = this.t + a,
        b.s = this.s
    }
    function w(a, b) {
        for (var c = a; c < this.t; ++c) b[c - a] = this[c];
        b.t = Math.max(this.t - a, 0),
        b.s = this.s
    }
    function x(a, b) {
        var c, d = a % this.DB,
        e = this.DB - d,
        f = (1 << e) - 1,
        g = Math.floor(a / this.DB),
        h = this.s << d & this.DM;
        for (c = this.t - 1; c >= 0; --c) b[c + g + 1] = this[c] >> e | h,
        h = (this[c] & f) << d;
        for (c = g - 1; c >= 0; --c) b[c] = 0;
        b[g] = h,
        b.t = this.t + g + 1,
        b.s = this.s,
        b.clamp()
    }
    function y(a, b) {
        b.s = this.s;
        var c = Math.floor(a / this.DB);
        if (c >= this.t) return void(b.t = 0);
        var d = a % this.DB,
        e = this.DB - d,
        f = (1 << d) - 1;
        b[0] = this[c] >> d;
        for (var g = c + 1; g < this.t; ++g) b[g - c - 1] |= (this[g] & f) << e,
        b[g - c] = this[g] >> d;
        d > 0 && (b[this.t - c - 1] |= (this.s & f) << e),
        b.t = this.t - c,
        b.clamp()
    }
    function z(a, b) {
        for (var c = 0,
        d = 0,
        e = Math.min(a.t, this.t); e > c;) d += this[c] - a[c],
        b[c++] = d & this.DM,
        d >>= this.DB;
        if (a.t < this.t) {
            for (d -= a.s; c < this.t;) d += this[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d += this.s
        } else {
            for (d += this.s; c < a.t;) d -= a[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d -= a.s
        }
        b.s = 0 > d ? -1 : 0,
        -1 > d ? b[c++] = this.DV + d: d > 0 && (b[c++] = d),
        b.t = c,
        b.clamp()
    }
    function A(a, b) {
        var d = this.abs(),
        e = a.abs(),
        f = d.t;
        for (b.t = f + e.t; --f >= 0;) b[f] = 0;
        for (f = 0; f < e.t; ++f) b[f + d.t] = d.am(0, e[f], b, f, 0, d.t);
        b.s = 0,
        b.clamp(),
        this.s != a.s && c.ZERO.subTo(b, b)
    }
    function B(a) {
        for (var b = this.abs(), c = a.t = 2 * b.t; --c >= 0;) a[c] = 0;
        for (c = 0; c < b.t - 1; ++c) {
            var d = b.am(c, b[c], a, 2 * c, 0, 1); (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1)
        }
        a.t > 0 && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1)),
        a.s = 0,
        a.clamp()
    }
    function C(a, b, e) {
        var f = a.abs();
        if (! (f.t <= 0)) {
            var g = this.abs();
            if (g.t < f.t) return null != b && b.fromInt(0),
            void(null != e && this.copyTo(e));
            null == e && (e = d());
            var h = d(),
            i = this.s,
            j = a.s,
            k = this.DB - t(f[f.t - 1]);
            k > 0 ? (f.lShiftTo(k, h), g.lShiftTo(k, e)) : (f.copyTo(h), g.copyTo(e));
            var l = h.t,
            m = h[l - 1];
            if (0 != m) {
                var n = m * (1 << this.F1) + (l > 1 ? h[l - 2] >> this.F2: 0),
                o = this.FV / n,
                p = (1 << this.F1) / n,
                q = 1 << this.F2,
                r = e.t,
                s = r - l,
                u = null == b ? d() : b;
                for (h.dlShiftTo(s, u), e.compareTo(u) >= 0 && (e[e.t++] = 1, e.subTo(u, e)), c.ONE.dlShiftTo(l, u), u.subTo(h, h); h.t < l;) h[h.t++] = 0;
                for (; --s >= 0;) {
                    var v = e[--r] == m ? this.DM: Math.floor(e[r] * o + (e[r - 1] + q) * p);
                    if ((e[r] += h.am(0, v, e, s, 0, l)) < v) for (h.dlShiftTo(s, u), e.subTo(u, e); e[r] < --v;) e.subTo(u, e)
                }
                null != b && (e.drShiftTo(l, b), i != j && c.ZERO.subTo(b, b)),
                e.t = l,
                e.clamp(),
                k > 0 && e.rShiftTo(k, e),
                0 > i && c.ZERO.subTo(e, e)
            }
        }
    }
    function D(a) {
        var b = d();
        return this.abs().divRemTo(a, null, b),
        this.s < 0 && b.compareTo(c.ZERO) > 0 && a.subTo(b, b),
        b
    }
    function E(a) {
        this.m = a
    }
    function F(a) {
        return a.s < 0 || a.compareTo(this.m) >= 0 ? a.mod(this.m) : a
    }
    function G(a) {
        return a
    }
    function H(a) {
        a.divRemTo(this.m, null, a)
    }
    function I(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function J(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function K() {
        if (this.t < 1) return 0;
        var a = this[0];
        if (0 == (1 & a)) return 0;
        var b = 3 & a;
        return b = b * (2 - (15 & a) * b) & 15,
        b = b * (2 - (255 & a) * b) & 255,
        b = b * (2 - ((65535 & a) * b & 65535)) & 65535,
        b = b * (2 - a * b % this.DV) % this.DV,
        b > 0 ? this.DV - b: -b
    }
    function L(a) {
        this.m = a,
        this.mp = a.invDigit(),
        this.mpl = 32767 & this.mp,
        this.mph = this.mp >> 15,
        this.um = (1 << a.DB - 15) - 1,
        this.mt2 = 2 * a.t
    }
    function M(a) {
        var b = d();
        return a.abs().dlShiftTo(this.m.t, b),
        b.divRemTo(this.m, null, b),
        a.s < 0 && b.compareTo(c.ZERO) > 0 && this.m.subTo(b, b),
        b
    }
    function N(a) {
        var b = d();
        return a.copyTo(b),
        this.reduce(b),
        b
    }
    function O(a) {
        for (; a.t <= this.mt2;) a[a.t++] = 0;
        for (var b = 0; b < this.m.t; ++b) {
            var c = 32767 & a[b],
            d = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM;
            for (c = b + this.m.t, a[c] += this.m.am(0, d, a, b, 0, this.m.t); a[c] >= a.DV;) a[c] -= a.DV,
            a[++c]++
        }
        a.clamp(),
        a.drShiftTo(this.m.t, a),
        a.compareTo(this.m) >= 0 && a.subTo(this.m, a)
    }
    function P(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function Q(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function R() {
        return 0 == (this.t > 0 ? 1 & this[0] : this.s)
    }
    function S(a, b) {
        if (a > 4294967295 || 1 > a) return c.ONE;
        var e = d(),
        f = d(),
        g = b.convert(this),
        h = t(a) - 1;
        for (g.copyTo(e); --h >= 0;) if (b.sqrTo(e, f), (a & 1 << h) > 0) b.mulTo(f, g, e);
        else {
            var i = e;
            e = f,
            f = i
        }
        return b.revert(e)
    }
    function T(a, b) {
        var c;
        return c = 256 > a || b.isEven() ? new E(b) : new L(b),
        this.exp(a, c)
    }
    function U() {
        var a = d();
        return this.copyTo(a),
        a
    }
    function V() {
        if (this.s < 0) {
            if (1 == this.t) return this[0] - this.DV;
            if (0 == this.t) return - 1
        } else {
            if (1 == this.t) return this[0];
            if (0 == this.t) return 0
        }
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
    }
    function W() {
        return 0 == this.t ? this.s: this[0] << 24 >> 24
    }
    function X() {
        return 0 == this.t ? this.s: this[0] << 16 >> 16
    }
    function Y(a) {
        return Math.floor(Math.LN2 * this.DB / Math.log(a))
    }
    function Z() {
        return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
    }
    function $(a) {
        if (null == a && (a = 10), 0 == this.signum() || 2 > a || a > 36) return "0";
        var b = this.chunkSize(a),
        c = Math.pow(a, b),
        e = m(c),
        f = d(),
        g = d(),
        h = "";
        for (this.divRemTo(e, f, g); f.signum() > 0;) h = (c + g.intValue()).toString(a).substr(1) + h,
        f.divRemTo(e, f, g);
        return g.intValue().toString(a) + h
    }
    function _(a, b) {
        this.fromInt(0),
        null == b && (b = 10);
        for (var d = this.chunkSize(b), e = Math.pow(b, d), f = !1, g = 0, h = 0, i = 0; i < a.length; ++i) {
            var k = j(a, i);
            0 > k ? "-" == a.charAt(i) && 0 == this.signum() && (f = !0) : (h = b * h + k, ++g >= d && (this.dMultiply(e), this.dAddOffset(h, 0), g = 0, h = 0))
        }
        g > 0 && (this.dMultiply(Math.pow(b, g)), this.dAddOffset(h, 0)),
        f && c.ZERO.subTo(this, this)
    }
    function aa(a, b, d) {
        if ("number" == typeof b) if (2 > a) this.fromInt(1);
        else for (this.fromNumber(a, d), this.testBit(a - 1) || this.bitwiseTo(c.ONE.shiftLeft(a - 1), ia, this), this.isEven() && this.dAddOffset(1, 0); ! this.isProbablePrime(b);) this.dAddOffset(2, 0),
        this.bitLength() > a && this.subTo(c.ONE.shiftLeft(a - 1), this);
        else {
            var e = new Array,
            f = 7 & a;
            e.length = (a >> 3) + 1,
            b.nextBytes(e),
            f > 0 ? e[0] &= (1 << f) - 1 : e[0] = 0,
            this.fromString(e, 256)
        }
    }
    function ba() {
        var a = this.t,
        b = new Array;
        b[0] = this.s;
        var c, d = this.DB - a * this.DB % 8,
        e = 0;
        if (a-->0) for (d < this.DB && (c = this[a] >> d) != (this.s & this.DM) >> d && (b[e++] = c | this.s << this.DB - d); a >= 0;) 8 > d ? (c = (this[a] & (1 << d) - 1) << 8 - d, c |= this[--a] >> (d += this.DB - 8)) : (c = this[a] >> (d -= 8) & 255, 0 >= d && (d += this.DB, --a)),
        0 != (128 & c) && (c |= -256),
        0 == e && (128 & this.s) != (128 & c) && ++e,
        (e > 0 || c != this.s) && (b[e++] = c);
        return b
    }
    function ca(a) {
        return 0 == this.compareTo(a)
    }
    function da(a) {
        return this.compareTo(a) < 0 ? this: a
    }
    function ea(a) {
        return this.compareTo(a) > 0 ? this: a
    }
    function fa(a, b, c) {
        var d, e, f = Math.min(a.t, this.t);
        for (d = 0; f > d; ++d) c[d] = b(this[d], a[d]);
        if (a.t < this.t) {
            for (e = a.s & this.DM, d = f; d < this.t; ++d) c[d] = b(this[d], e);
            c.t = this.t
        } else {
            for (e = this.s & this.DM, d = f; d < a.t; ++d) c[d] = b(e, a[d]);
            c.t = a.t
        }
        c.s = b(this.s, a.s),
        c.clamp()
    }
    function ga(a, b) {
        return a & b
    }
    function ha(a) {
        var b = d();
        return this.bitwiseTo(a, ga, b),
        b
    }
    function ia(a, b) {
        return a | b
    }
    function ja(a) {
        var b = d();
        return this.bitwiseTo(a, ia, b),
        b
    }
    function ka(a, b) {
        return a ^ b
    }
    function la(a) {
        var b = d();
        return this.bitwiseTo(a, ka, b),
        b
    }
    function ma(a, b) {
        return a & ~b
    }
    function na(a) {
        var b = d();
        return this.bitwiseTo(a, ma, b),
        b
    }
    function oa() {
        for (var a = d(), b = 0; b < this.t; ++b) a[b] = this.DM & ~this[b];
        return a.t = this.t,
        a.s = ~this.s,
        a
    }
    function pa(a) {
        var b = d();
        return 0 > a ? this.rShiftTo( - a, b) : this.lShiftTo(a, b),
        b
    }
    function qa(a) {
        var b = d();
        return 0 > a ? this.lShiftTo( - a, b) : this.rShiftTo(a, b),
        b
    }
    function ra(a) {
        if (0 == a) return - 1;
        var b = 0;
        return 0 == (65535 & a) && (a >>= 16, b += 16),
        0 == (255 & a) && (a >>= 8, b += 8),
        0 == (15 & a) && (a >>= 4, b += 4),
        0 == (3 & a) && (a >>= 2, b += 2),
        0 == (1 & a) && ++b,
        b
    }
    function sa() {
        for (var a = 0; a < this.t; ++a) if (0 != this[a]) return a * this.DB + ra(this[a]);
        return this.s < 0 ? this.t * this.DB: -1
    }
    function ta(a) {
        for (var b = 0; 0 != a;) a &= a - 1,
        ++b;
        return b
    }
    function ua() {
        for (var a = 0,
        b = this.s & this.DM,
        c = 0; c < this.t; ++c) a += ta(this[c] ^ b);
        return a
    }
    function va(a) {
        var b = Math.floor(a / this.DB);
        return b >= this.t ? 0 != this.s: 0 != (this[b] & 1 << a % this.DB)
    }
    function wa(a, b) {
        var d = c.ONE.shiftLeft(a);
        return this.bitwiseTo(d, b, d),
        d
    }
    function xa(a) {
        return this.changeBit(a, ia)
    }
    function ya(a) {
        return this.changeBit(a, ma)
    }
    function za(a) {
        return this.changeBit(a, ka)
    }
    function Aa(a, b) {
        for (var c = 0,
        d = 0,
        e = Math.min(a.t, this.t); e > c;) d += this[c] + a[c],
        b[c++] = d & this.DM,
        d >>= this.DB;
        if (a.t < this.t) {
            for (d += a.s; c < this.t;) d += this[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d += this.s
        } else {
            for (d += this.s; c < a.t;) d += a[c],
            b[c++] = d & this.DM,
            d >>= this.DB;
            d += a.s
        }
        b.s = 0 > d ? -1 : 0,
        d > 0 ? b[c++] = d: -1 > d && (b[c++] = this.DV + d),
        b.t = c,
        b.clamp()
    }
    function Ba(a) {
        var b = d();
        return this.addTo(a, b),
        b
    }
    function Ca(a) {
        var b = d();
        return this.subTo(a, b),
        b
    }
    function Da(a) {
        var b = d();
        return this.multiplyTo(a, b),
        b
    }
    function Ea() {
        var a = d();
        return this.squareTo(a),
        a
    }
    function Fa(a) {
        var b = d();
        return this.divRemTo(a, b, null),
        b
    }
    function Ga(a) {
        var b = d();
        return this.divRemTo(a, null, b),
        b
    }
    function Ha(a) {
        var b = d(),
        c = d();
        return this.divRemTo(a, b, c),
        new Array(b, c)
    }
    function Ia(a) {
        this[this.t] = this.am(0, a - 1, this, 0, 0, this.t),
        ++this.t,
        this.clamp()
    }
    function Ja(a, b) {
        if (0 != a) {
            for (; this.t <= b;) this[this.t++] = 0;
            for (this[b] += a; this[b] >= this.DV;) this[b] -= this.DV,
            ++b >= this.t && (this[this.t++] = 0),
            ++this[b]
        }
    }
    function Ka() {}
    function La(a) {
        return a
    }
    function Ma(a, b, c) {
        a.multiplyTo(b, c)
    }
    function Na(a, b) {
        a.squareTo(b)
    }
    function Oa(a) {
        return this.exp(a, new Ka)
    }
    function Pa(a, b, c) {
        var d = Math.min(this.t + a.t, b);
        for (c.s = 0, c.t = d; d > 0;) c[--d] = 0;
        var e;
        for (e = c.t - this.t; e > d; ++d) c[d + this.t] = this.am(0, a[d], c, d, 0, this.t);
        for (e = Math.min(a.t, b); e > d; ++d) this.am(0, a[d], c, d, 0, b - d);
        c.clamp()
    }
    function Qa(a, b, c) {--b;
        var d = c.t = this.t + a.t - b;
        for (c.s = 0; --d >= 0;) c[d] = 0;
        for (d = Math.max(b - this.t, 0); d < a.t; ++d) c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b);
        c.clamp(),
        c.drShiftTo(1, c)
    }
    function Ra(a) {
        this.r2 = d(),
        this.q3 = d(),
        c.ONE.dlShiftTo(2 * a.t, this.r2),
        this.mu = this.r2.divide(a),
        this.m = a
    }
    function Sa(a) {
        if (a.s < 0 || a.t > 2 * this.m.t) return a.mod(this.m);
        if (a.compareTo(this.m) < 0) return a;
        var b = d();
        return a.copyTo(b),
        this.reduce(b),
        b
    }
    function Ta(a) {
        return a
    }
    function Ua(a) {
        for (a.drShiftTo(this.m.t - 1, this.r2), a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); a.compareTo(this.r2) < 0;) a.dAddOffset(1, this.m.t + 1);
        for (a.subTo(this.r2, a); a.compareTo(this.m) >= 0;) a.subTo(this.m, a)
    }
    function Va(a, b) {
        a.squareTo(b),
        this.reduce(b)
    }
    function Wa(a, b, c) {
        a.multiplyTo(b, c),
        this.reduce(c)
    }
    function Xa(a, b) {
        var c, e, f = a.bitLength(),
        g = m(1);
        if (0 >= f) return g;
        c = 18 > f ? 1 : 48 > f ? 3 : 144 > f ? 4 : 768 > f ? 5 : 6,
        e = 8 > f ? new E(b) : b.isEven() ? new Ra(b) : new L(b);
        var h = new Array,
        i = 3,
        j = c - 1,
        k = (1 << c) - 1;
        if (h[1] = e.convert(this), c > 1) {
            var l = d();
            for (e.sqrTo(h[1], l); k >= i;) h[i] = d(),
            e.mulTo(l, h[i - 2], h[i]),
            i += 2
        }
        var n, o, p = a.t - 1,
        q = !0,
        r = d();
        for (f = t(a[p]) - 1; p >= 0;) {
            for (f >= j ? n = a[p] >> f - j & k: (n = (a[p] & (1 << f + 1) - 1) << j - f, p > 0 && (n |= a[p - 1] >> this.DB + f - j)), i = c; 0 == (1 & n);) n >>= 1,
            --i;
            if ((f -= i) < 0 && (f += this.DB, --p), q) h[n].copyTo(g),
            q = !1;
            else {
                for (; i > 1;) e.sqrTo(g, r),
                e.sqrTo(r, g),
                i -= 2;
                i > 0 ? e.sqrTo(g, r) : (o = g, g = r, r = o),
                e.mulTo(r, h[n], g)
            }
            for (; p >= 0 && 0 == (a[p] & 1 << f);) e.sqrTo(g, r),
            o = g,
            g = r,
            r = o,
            --f < 0 && (f = this.DB - 1, --p)
        }
        return e.revert(g)
    }
    function Ya(a) {
        var b = this.s < 0 ? this.negate() : this.clone(),
        c = a.s < 0 ? a.negate() : a.clone();
        if (b.compareTo(c) < 0) {
            var d = b;
            b = c,
            c = d
        }
        var e = b.getLowestSetBit(),
        f = c.getLowestSetBit();
        if (0 > f) return b;
        for (f > e && (f = e), f > 0 && (b.rShiftTo(f, b), c.rShiftTo(f, c)); b.signum() > 0;)(e = b.getLowestSetBit()) > 0 && b.rShiftTo(e, b),
        (e = c.getLowestSetBit()) > 0 && c.rShiftTo(e, c),
        b.compareTo(c) >= 0 ? (b.subTo(c, b), b.rShiftTo(1, b)) : (c.subTo(b, c), c.rShiftTo(1, c));
        return f > 0 && c.lShiftTo(f, c),
        c
    }
    function Za(a) {
        if (0 >= a) return 0;
        var b = this.DV % a,
        c = this.s < 0 ? a - 1 : 0;
        if (this.t > 0) if (0 == b) c = this[0] % a;
        else for (var d = this.t - 1; d >= 0; --d) c = (b * c + this[d]) % a;
        return c
    }
    function $a(a) {
        var b = a.isEven();
        if (this.isEven() && b || 0 == a.signum()) return c.ZERO;
        for (var d = a.clone(), e = this.clone(), f = m(1), g = m(0), h = m(0), i = m(1); 0 != d.signum();) {
            for (; d.isEven();) d.rShiftTo(1, d),
            b ? (f.isEven() && g.isEven() || (f.addTo(this, f), g.subTo(a, g)), f.rShiftTo(1, f)) : g.isEven() || g.subTo(a, g),
            g.rShiftTo(1, g);
            for (; e.isEven();) e.rShiftTo(1, e),
            b ? (h.isEven() && i.isEven() || (h.addTo(this, h), i.subTo(a, i)), h.rShiftTo(1, h)) : i.isEven() || i.subTo(a, i),
            i.rShiftTo(1, i);
            d.compareTo(e) >= 0 ? (d.subTo(e, d), b && f.subTo(h, f), g.subTo(i, g)) : (e.subTo(d, e), b && h.subTo(f, h), i.subTo(g, i))
        }
        return 0 != e.compareTo(c.ONE) ? c.ZERO: i.compareTo(a) >= 0 ? i.subtract(a) : i.signum() < 0 ? (i.addTo(a, i), i.signum() < 0 ? i.add(a) : i) : i
    }
    function _a(a) {
        var b, c = this.abs();
        if (1 == c.t && c[0] <= fc[fc.length - 1]) {
            for (b = 0; b < fc.length; ++b) if (c[0] == fc[b]) return ! 0;
            return ! 1
        }
        if (c.isEven()) return ! 1;
        for (b = 1; b < fc.length;) {
            for (var d = fc[b], e = b + 1; e < fc.length && gc > d;) d *= fc[e++];
            for (d = c.modInt(d); e > b;) if (d % fc[b++] == 0) return ! 1
        }
        return c.millerRabin(a)
    }
    function ab(a) {
        var b = this.subtract(c.ONE),
        e = b.getLowestSetBit();
        if (0 >= e) return ! 1;
        var f = b.shiftRight(e);
        a = a + 1 >> 1,
        a > fc.length && (a = fc.length);
        for (var g = d(), h = 0; a > h; ++h) {
            g.fromInt(fc[Math.floor(Ib.Util.random() * fc.length)]);
            var i = g.modPow(f, this);
            if (0 != i.compareTo(c.ONE) && 0 != i.compareTo(b)) {
                for (var j = 1; j++<e && 0 != i.compareTo(b);) if (i = i.modPowInt(2, this), 0 == i.compareTo(c.ONE)) return ! 1;
                if (0 != i.compareTo(b)) return ! 1
            }
        }
        return ! 0
    }
    function bb() {
        this.i = 0,
        this.j = 0,
        this.S = new Array
    }
    function cb(a) {
        var b, c, d;
        for (b = 0; 256 > b; ++b) this.S[b] = b;
        for (c = 0, b = 0; 256 > b; ++b) c = c + this.S[b] + a[b % a.length] & 255,
        d = this.S[b],
        this.S[b] = this.S[c],
        this.S[c] = d;
        this.i = 0,
        this.j = 0
    }
    function db() {
        var a;
        return this.i = this.i + 1 & 255,
        this.j = this.j + this.S[this.i] & 255,
        a = this.S[this.i],
        this.S[this.i] = this.S[this.j],
        this.S[this.j] = a,
        this.S[a + this.S[this.i] & 255]
    }
    function eb() {
        return new bb
    }
    function fb(a) {
        ic[jc++] ^= 255 & a,
        ic[jc++] ^= a >> 8 & 255,
        ic[jc++] ^= a >> 16 & 255,
        ic[jc++] ^= a >> 24 & 255,
        jc >= kc && (jc -= kc)
    }
    function gb() {
        fb((new Date).getTime())
    }
    function hb() {
        if (null == hc) {
            for (gb(), hc = eb(), hc.init(ic), jc = 0; jc < ic.length; ++jc) ic[jc] = 0;
            jc = 0
        }
        return hc.next()
    }
    function ib(a) {
        var b;
        for (b = 0; b < a.length; ++b) a[b] = hb()
    }
    function jb() {}
    function kb(a, b) {
        return new c(a, b)
    }
    function lb(a, b) {
        if (b < a.length + 11) return null;
        for (var d = new Array,
        e = a.length - 1; e >= 0 && b > 0;) {
            var f = a.charCodeAt(e--);
            128 > f ? d[--b] = f: f > 127 && 2048 > f ? (d[--b] = 63 & f | 128, d[--b] = f >> 6 | 192) : (d[--b] = 63 & f | 128, d[--b] = f >> 6 & 63 | 128, d[--b] = f >> 12 | 224)
        }
        d[--b] = 0;
        for (var g = new jb,
        h = new Array; b > 2;) {
            for (h[0] = 0; 0 == h[0];) g.nextBytes(h);
            d[--b] = h[0]
        }
        return d[--b] = 2,
        d[--b] = 0,
        new c(d)
    }
    function mb() {
        this.n = null,
        this.e = 0,
        this.d = null,
        this.p = null,
        this.q = null,
        this.dmp1 = null,
        this.dmq1 = null,
        this.coeff = null
    }
    function nb(a, b) {
        this.n = kb(a, 16),
        this.e = parseInt(b, 16)
    }
    function ob(a) {
        return a.modPowInt(this.e, this.n)
    }
    function pb(a) {
        var b = lb(a, this.n.bitLength() + 7 >> 3);
        if (null == b) return null;
        var c = this.doPrivate(b);
        if (null == c) return null;
        var d = c.toString(16);
        return 0 == (1 & d.length) ? d: "0" + d
    }
    function qb(a, b) {
        for (var c = a.toByteArray(), d = 0; d < c.length && 0 == c[d];)++d;
        if (c.length - d != b - 1 || 2 != c[d]) return null;
        for (++d; 0 != c[d];) if (++d >= c.length) return null;
        for (var e = ""; ++d < c.length;) {
            var f = 255 & c[d];
            128 > f ? e += String.fromCharCode(f) : f > 191 && 224 > f ? (e += String.fromCharCode((31 & f) << 6 | 63 & c[d + 1]), ++d) : (e += String.fromCharCode((15 & f) << 12 | (63 & c[d + 1]) << 6 | 63 & c[d + 2]), d += 2)
        }
        return e
    }
    function rb(a, b, c) {
        this.n = kb(a, 16),
        this.e = parseInt(b, 16),
        this.d = kb(c, 16)
    }
    function sb(a, b, c, d, e, f, g, h) {
        this.n = kb(a, 16),
        this.e = parseInt(b, 16),
        this.d = kb(c, 16),
        this.p = kb(d, 16),
        this.q = kb(e, 16),
        this.dmp1 = kb(f, 16),
        this.dmq1 = kb(g, 16),
        this.coeff = kb(h, 16)
    }
    function tb(a) {
        if (null == this.p || null == this.q) return a.modPow(this.d, this.n);
        for (var b = a.mod(this.p).modPow(this.dmp1, this.p), c = a.mod(this.q).modPow(this.dmq1, this.q); b.compareTo(c) < 0;) b = b.add(this.p);
        return b.subtract(c).multiply(this.coeff).mod(this.p).multiply(this.q).add(c)
    }
    function ub(a) {
        var b = kb(a, 16),
        c = this.doPublic(b);
        return null == c ? null: qb(c, this.n.bitLength() + 7 >> 3)
    }
    function vb(a, b, c) {
        var d = 0,
        e = 0,
        f = b.split("\n"),
        g = 2 * a.measureText("e").width;
        return f.forEach(function(b) {
            if (c) {
                var f, h, i, j, k, l = b.split(" "),
                m = l.length,
                n = "";
                for (i = 0; m > i; i++) if (f = l[i] + (i === m - 1 ? "": " "), h = n + f, j = a.measureText(h).width, c > j) n = h;
                else if (j == c) n = "",
                e += g;
                else {
                    for (k = 0; k < f.length; k++) if (h = n + f.substr(0, k + 1), a.measureText(h).width > c) {
                        n = f.substring(k, f.length),
                        e += g;
                        break
                    }
                    for (; n.length > 0 && a.measureText(n).width > c;) for (k = 0; k < n.length; k++) if (h = n.substr(0, k + 1), a.measureText(h).width > c) {
                        n = n.substring(k, n.length),
                        e += g;
                        break
                    }
                }
            } else j = a.measureText(b).width,
            d = j > d ? j: d;
            e += g
        }),
        d = c ? c: d,
        {
            w: d,
            h: e
        }
    }
    function wb(a, b, c, d) {
        var e, f = a.animate,
        g = d._now,
        h = d._shapeDataIndex,
        i = c._animates;
        if (i || (i = c._animates = {}), h.length) for (var j = 0; j < h.length; j++) {
            e = h[j];
            var k = i[e];
            k || (k = i[e] = {}),
            i = k
        } else e = h;
        var l = i[e];
        l || (l = i[e] = {},
        f.forEach(function(e) {
            var f, h = e.attr,
            i = l[h];
            e = {
                attr: h,
                to: e.to,
                type: e.type || "number",
                delay: e.delay || 0,
                dur: e.dur || 1e3,
                interval: e.interval || 0,
                finish: e.finish,
                repeat: e.repeat || 1,
                reverse: null == e.reverse ? !0 : e.reverse,
                onDone: e.onDone,
                easing: e.easing,
                trigger: null == e.to,
                start: g,
                time: 0,
                total: 0,
                count: 0,
                started: !1,
                stopped: !1,
                current: null
            },
            Array.isArray(e.dur) && (e.groupDur = e.dur.slice(0, e.dur.length - 1), e.dur = e.dur[e.dur.length - 1], e.groupDurTotal = e.groupDur.reduce(function(a, b, c) {
                return e.groupDur[c] = a + b
            },
            0), e.groupIndex = 0, e.groupTime = 0, e.groupStart = g),
            null == e.finish && (e.finish = e.delay + e.dur + e.interval),
            i ? Array.isArray(i) ? (i.push(e), i = i[i.length - 2]) : l[h] = [i, e] : (f = Yc(c, b, a, h, d), l[h] = e),
            i && (f = i.to, "group_set" === i.type && (f = f[f.length - 1])),
            e.from = f,
            e.trigger || (e.started = !0, Fb(e), Gb(e))
        })),
        f = l,
        Object.keys(f).forEach(function(e) {
            var h = f[e];
            if (Array.isArray(h)) {
                var i = h[h.length - 1];
                i.count + 1 === i.repeat ? h.forEach(function(e) {
                    xb(e, a, b, c, d, !0)
                }) : i.count + 1 < i.repeat && (i.total >= i.finish && h.forEach(function(a) {
                    a.trigger || (a.started = !0),
                    a.stopped = !1,
                    a.time = 0,
                    a.start = g,
                    a.total = 0,
                    "group_set" === a.type && (a.groupIndex = 0, a.groupTime = 0, a.groupStart = g)
                }), h.forEach(function(e) {
                    xb(e, a, b, c, d, !1)
                }))
            } else xb(h, a, b, c, d, !0)
        })
    }
    function xb(a, b, c, d, e, f) {
        if (a.trigger) {
            var g = Yc(d, c, b, a.attr, e, null, !1);
            if (!a.started) {
                if (g === a.from) return;
                a.started = !0,
                a.start = e._now,
                a.to = g,
                Fb(a),
                Gb(a)
            }
            a.started && g !== a.to && (a.start = e._now, a.from = a.current, a.to = g, a.time = 0, a.total = 0, a.count = 0, Fb(a), Gb(a))
        }
        if (a.started && !a.stopped) {
            var h = e._now,
            i = h - a.start;
            if (i >= a.delay && (a.total = i, i -= a.delay, a.time = i > a.dur ? a.dur: i, "group_set" === a.type && (a.groupTime = h - a.groupStart, a.groupStart === a.start && (a.groupTime -= a.delay), a.groupTime >= a.groupDur[a.groupIndex] && a.groupIndex++, a.groupTime >= a.groupDurTotal && (a.groupIndex = 0, a.groupTime = a.groupTime - a.groupDurTotal, a.groupStart = h)), a.total >= a.finish)) if (a.count++, "group_set" === a.type, a.count >= a.repeat) a.time = a.dur,
            a.stopped = !0,
            a.trigger && (a.from = a.to, a.to = null, a.start = null, a.time = 0, a.total = 0, a.count = 0, a.started = !1, a.stopped = !1),
            a.onDone && a.onDone.call(c, d, e);
            else if (f && (a.time = 0, a.start = h, a.total = 0, a.reverse)) {
                var j = a.from;
                a.from = a.to,
                a.to = j,
                Gb(a)
            }
            e && !e._invalidate && (e._invalidate = !0)
        }
    }
    function yb(a) {
        if (!hd[a.id]) {
            if (jd = !0, hd[a.id] = a, null == a.from && a.attr && a.source) {
                var b;
                a.from = (b = a.attr.match(/^S[:@](.*)/i)) ? a.source.getStyle(b[1]) : (b = a.attr.match(/^C[:@](.*)/i)) ? a.source.getClient(b[1]) : Ib.Util.getValue(a.source, a.attr)
            }
            Fb(a),
            Gb(a)
        }
        return a.resume(),
        a
    }
    function zb(a, b) {
        return hd[a.id] && (null == b && (b = !0), b && Eb(a, a.to), a.onStop && a.onStop(), a.time = 0, a.total = 0, a.start = null, a.count = 0, a.started = !1, a.stopped = !1, a.paused = !1, a.pausedTime = null, a.pausedTotal = 0, a._oldSpeed = null, a._speedTotal = 0, a._speedTime = null, a._percent = 0, a._percentSet = null, a._percentDiff = 0, delete hd[a.id]),
        a
    }
    function Ab(a) {
        null == a && (a = !0),
        Object.keys(hd).forEach(function(b) {
            var c = hd[b];
            c && (a && Eb(c, c.to), c.onStop && c.onStop())
        }),
        hd = {}
    }
    function Bb() {
        Object.keys(hd).forEach(function(a) {
            var b = hd[a];
            b && b.pause()
        })
    }
    function Cb() {
        Object.keys(hd).forEach(function(a) {
            var b = hd[a];
            b && b.resume()
        })
    }
    function Db(a) {
        Object.keys(hd).forEach(function(b) {
            var c = hd[b];
            if (c && (null == c.start && (c._speedTime = c.start = a), null != c._percentSet && (c._percentDiff += (c._percentSet - c._percent) * c.finish), !c.paused || (c.pausedTime || (c.pausedTime = a), null != c._percentSet))) {
                if (null == c._percentSet && c.pausedTime && (c.pausedTotal += (a - c.pausedTime) * (c._oldSpeed || c._speed), c.pausedTime = null), c._oldSpeed && !c.pausedTime && (c._speedTotal = (a - c._speedTime) * c._oldSpeed - c.pausedTotal + c._percentDiff + c._speedTotal, c._percentDiff = 0, c.pausedTotal = 0, c._speedTime = a, c._oldSpeed = null), c.total = (a - c._speedTime) * c._speed - c.pausedTotal + c._percentDiff + c._speedTotal, null != c._percentSet && c.pausedTime && (c.total -= (a - c.pausedTime) * (c._oldSpeed || c._speed)), c._percent = c.total >= c.finish ? 1 : c.total / c.finish, c.total > c.delay) {
                    c.time = c.total - c.delay;
                    var d = !1;
                    if (c.time >= c.dur && (c.time = c.dur, d = !0), !c.stopped && Eb(c, Hb(c)), c.stopped = d, c.total >= c.finish) if (c.count++, c.count >= c.repeat) zb(c, !1),
                    c.onDone && c.onDone();
                    else if (c.time = 0, c.total = 0, c.start = null, c.stopped = !1, c.reverse) {
                        var e = c.from;
                        c.from = c.to,
                        c.to = e,
                        Gb(c)
                    }
                }
                c.paused || !jd && (jd = !0),
                null != c._percentSet && (c._percentSet = null)
            }
        })
    }
    function Eb(a, b) {
        if (a.started || (a.started = !0, a.onPlay && a.onPlay()), a.filter && (b = a.filter(b)), a.attr && a.source) {
            var c; (c = a.attr.match(/^S[:@](.*)/i)) ? a.source.setStyle(c[1], b) : (c = a.attr.match(/^C[:@](.*)/i)) ? a.source.setClient(c[1], b) : Ib.Util.setValue(a.source, a.attr, b)
        }
        a.onUpdate && a.onUpdate(b)
    }
    function Fb(a) {
        var b = a.type,
        c = a.from,
        d = a.to;
        "number" === b ? (a.from = c || 0, a.to = d || 0) : "point" === b ? (c ? c.length && (a.from = {
            x: c[0],
            y: c[1]
        }) : a.from = "scale" === a.attr ? {
            x: 1,
            y: 1
        }: {
            x: 0,
            y: 0
        },
        d ? d.length && (a.to = {
            x: d[0],
            y: d[1]
        }) : a.to = "scale" === a.attr ? {
            x: 1,
            y: 1
        }: {
            x: 0,
            y: 0
        }) : "rect" === b ? (c ? c.length && (a.from = {
            x: c[0],
            y: c[1],
            w: c[2],
            h: c[3]
        }) : a.from = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        },
        d ? d.length && (a.to = {
            x: d[0],
            y: d[1],
            w: d[2],
            h: d[3]
        }) : a.to = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        }) : "color" === b && (a.from = sd(c), a.to = sd(d)),
        a.current = a.from
    }
    function Gb(a) {
        var b = a.type,
        c = a.from,
        d = a.to;
        "number" === b ? a.delta = d - c: "point" === b ? a.delta = {
            x: d.x - c.x,
            y: d.y - c.y
        }: "rect" === b ? a.delta = {
            x: d.x - c.x,
            y: d.y - c.y,
            w: d.w - c.w,
            h: d.h - c.h
        }: "color" === b && (a.delta = {
            r: d.r - c.r,
            g: d.g - c.g,
            b: d.b - c.b,
            a: d.a - c.a
        })
    }
    function Hb(a, b) {
        var c = a.type,
        d = a.delta,
        e = a.from,
        f = a.time,
        g = a.dur,
        h = kd[a.easing || "easeNone"];
        return h || (h = kd.easeNone),
        "number" === c ? b = h(f, e, d, g) : "point" === c ? b = {
            x: h(f, e.x, d.x, g),
            y: h(f, e.y, d.y, g)
        }: "rect" === c ? b = {
            x: h(f, e.x, d.x, g),
            y: h(f, e.y, d.y, g),
            w: h(f, e.w, d.w, g),
            h: h(f, e.h, d.h, g)
        }: "color" === c ? b = "rgba(" + Math.floor(h(f, e.r, d.r, g)) + "," + Math.floor(h(f, e.g, d.g, g)) + "," + Math.floor(h(f, e.b, d.b, g)) + "," + Math.floor(h(f, e.a, d.a, g)) + ")": "set" === c ? a.time && (b = a.to) : "group_set" === c && (b = a.to[a.groupIndex]),
        a.current = b,
        b
    }
    var Ib = {};
    Ib._isInitializing = !1;
    var Jb = {
        isDeserializing: !1,
        isCalculatingBus: !1,
        images: {},
        registerImage: function(a, b, c, d, e) {
            Jb.images[a] = new Ib.ImageAsset(a, b, c, d, e),
            yd(a)
        },
        getRegisteredImageNames: function() {
            return Object.keys(Jb.images)
        },
        unregisterImage: function(a) {
            delete Jb.images[a]
        },
        getImageAsset: function(a) {
            return Jb.images[a]
        },
        showVersion: function(a) {
            Jb.isCtrlDown(a) && a.shiftKey && 76 == a.keyCode && alert("TWaver HTML5 " + Ib.Util.getVersion() + "\n" + Kb)
        },
        callLater: function(a, b, c, d) {
            return setTimeout(function() {
                a.apply(b, c)
            },
            d || Dd.CALL_LATER_DELAY)
        },
        isEmptyObject: function(a) {
            for (var b in a) return ! 1;
            return ! 0
        },
        xml: function(b) {
            if (a.DOMParser) return (new DOMParser).parseFromString(b, "text/xml");
            var c = new ActiveXObject("Microsoft.XmlDOM");
            return c.async = !1,
            c.loadXml(b),
            c
        },
        num: function(a) {
            return "number" == typeof a && !isNaN(a) && isFinite(a)
        },
        getter: function(a) {
            var b = a.charAt(0).toUpperCase() + a.slice(1),
            c = /ble$/.test(a) || /ed$/.test(a) ? "is": "get";
            return c + b
        },
        setter: function(a) {
            var b = a.charAt(0).toUpperCase() + a.slice(1);
            return "set" + b
        },
        _id: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"],
        id: function() {
            for (var a = [], b = 0; 32 > b; b++) a[b] = this._id[Math.floor(16 * Ib.Util.random())];
            return a[12] = "4",
            a[16] = this._id[3 & a[16] | 8],
            a.join("")
        },
        keys: function(a) {
            var b = new nd;
            for (var c in a) b.add(c);
            return b
        },
        es: ["toString", "toLocaleString", "valueOf"],
        ip: function(a, b) {
            var c = "_" + b;
            a[Jb.getter(b)] = function() {
                return this[c]
            },
            a[Jb.setter(b)] = function(a) {
                var d = this[c];
                this[c] = a,
                this.firePropertyChange(b, d, a)
            }
        },
        validateLicense: function(a) {
            Kb = a,
            nc()
        },
        ibool: function(a, b) {
            var c = "_" + b,
            d = b.charAt(0).toUpperCase() + b.slice(1);
            a["is" + d] = function() {
                return this[c]
            },
            a[Jb.setter(b)] = function(a) {
                var d = this[c];
                this[c] = a,
                this.firePropertyChange(b, d, a)
            }
        },
        getValue: function(a, b, c) {
            var d = b.charAt(0).toUpperCase() + b.slice(1),
            e = "get" + d,
            f = "is" + d;
            return c ? "boolean" === c ? a[f]() : a[e]() : a[e] ? a[e]() : a[f] ? a[f]() : a[b]
        },
        setValue: function(a, b, c) {
            a["set" + b.charAt(0).toUpperCase() + b.slice(1)](c)
        },
        clone: function(a) {
            if (!a) return null;
            var b = {};
            for (var c in a) b[c] = a[c];
            return b
        },
        cloneRect: function(a) {
            return a ? {
                x: a.x,
                y: a.y,
                width: a.width,
                height: a.height
            }: null
        },
        classCache: {},
        getClass: function(b) {
            var c = Jb.classCache[b];
            if (!c) {
                var d = b.split("."),
                e = d.length;
                c = a;
                for (var f = 0; e > f; f++) c = c[d[f]],
                c || "twaver" === d[f] && (c = Ib);
                Jb.classCache[b] = c
            }
            return c
        },
        newInstance: function(b) {
            var c = Jb.getClass(b);
            if (!c) return a[b];
            var d = arguments.length,
            e = arguments;
            if (1 === d) return new c;
            if (2 === d) return new c(e[1]);
            if (3 === d) return new c(e[1], e[2]);
            if (4 === d) return new c(e[1], e[2], e[3]);
            if (5 === d) return new c(e[1], e[2], e[3], e[4]);
            if (6 === d) return new c(e[1], e[2], e[3], e[4], e[5]);
            if (7 === d) return new c(e[1], e[2], e[3], e[4], e[5], e[6]);
            if (8 === d) return new c(e[1], e[2], e[3], e[4], e[5], e[6], e[7]);
            throw "don't support args more than 7"
        },
        addMethod: function(a, b) {
            var c = a.prototype;
            for (var d in b) c[d] = b[d]
        },
        ext: function(a, b, c) {
            var d;
            if ("string" == typeof a && (d = a, a = Jb.getClass(a)), b) {
                var e = function() {};
                e.prototype = b.prototype,
                a.prototype = new e,
                a.prototype.constructor = a,
                a.superClass = b.prototype,
                b.prototype.constructor == Object.prototype.constructor && (b.prototype.constructor = b)
            }
            if (d && (a.prototype.getClassName = function() {
                return d
            }), c) {
                var f = a.prototype;
                for (var g in c) Rb.ext(g, f, c);
                for (var h = Jb.es.length,
                i = 0; h > i; i++) g = Jb.es[i],
                c.hasOwnProperty(g) && !c.propertyIsEnumerable(g) && (f[g] = c[g])
            }
        },
        setViewBounds: function(a, b) {
            if (a) if (a.adjustBounds) a.adjustBounds(b);
            else {
                var c = a.style; ! c && a.getView() && (c = a.getView().style),
                c && (c.position = "absolute", c.left = b.x + "px", c.top = b.y + "px", c.width = b.width + "px", c.height = b.height + "px")
            }
        },
        getImageSrc: function(a) {
            var b = Jb.getImageAsset(a);
            return b ? b.getSrc() ? b.getSrc() : b.getImage().getAttribute("src") : a
        },
        nextColorCount: 0,
        nextColor: function() {
            return Jb.nextColorCount >= Dd.COLORS.length && (Jb.nextColorCount = 0),
            Dd.COLORS[Jb.nextColorCount++]
        },
        isCtrlDown: function(a) {
            return a.ctrlKey || a.metaKey
        },
        isShiftDown: function(a) {
            return a.shiftKey
        },
        isAltDown: function(a) {
            return a.altKey
        },
        setText: function(a, b, c) {
            c ? Qb.isFirefox ? a.textContent = b: a.innerText = b: a.innerHTML = b
        },
        fillDescendant: function(a, b) {
            b.add(a),
            a.hasChildren() && a.getChildren().forEach(function(a) {
                Jb.fillDescendant(a, b)
            })
        }
    },
    Kb = (Date, "l=1.0\ntype=1\ngis=1\n3d=0\nstart=2015-10-21\nend=2016-10-31\nnote=This license applies to the evaluation version of TWaver. The License is limited to noncommercial use. Noncommercial use relates only to educational, research, personal or evaluation purposes. Any other use is commercial use. You may not use the Software in connection with any business activities.And You are not permitted to modify the software or attempt to decipher, decompile, disassemble or reverse engineer this Software.\nsignature=2e5ea3fc421c82faefdd5adb7f4cc1292bb315bf7a6ae5f14eaf81bf518344eb30899e3f2e8d1905d281d303ccf9f944ed98ee268cb7052503c879d9bc2479b2285d51fca10e872a7971c3f17b8494b31ef2e7b0988f6ff5c57d5a869f3af37d994321a3dcad3eba0adc0d83c84f50e9d71022bafaffb04a645aa1de657bb8ba49ae0ecb2f9838aaa9d601cdcc49e3ed7770fa84e0cd341dfdad6895ed1535c920f96075a6df4b045500f7d9ea7dfd85ad6c7ef697818090543728102de1c1151a8def3f01b092df43ec585d98f98f26731caf61b294b80e8fb5723b52fbd1301b34036a1a6e2b42bb5a30fe4fc51f569f4544443dd6cbe6ee5983f96cc71038688b4e38630ea6b93e45f6316560da5f6cd77c425eb90b3efb31b2f2ff23856da7d44b52b24c91de9a45064acba360cb3eeb6174a9b1fc4482cf77985e49a336029c2ed2b70d4336b71afca09cb3a086859c708f42680d5431f8ad1230b93b6b343c6237337c62af3242da3cc635a0ca623f822f2a2044e9e6c4598b2761ecc44348e47ec8d989e74526cf7fc34fb229621d761f708a32387c8a4e3f4a1b049be86dd7546559b7bfaa4da0fcd7b6f414bbdbcf8a80b8ef0f7947ae150a0a5027fd33b79ab5f85bfb7760ea6fb79da60d1f12386826f363a6e8b63d0fb3f6319c2f74314fc75a2de2156052418c8581a3565f645ccdf2e0429a9f7e413cd917c1250483f72408d6ccfff0e418bd280696d34358d30236319fda6e1802ad00f015978f4a2db435feb68b8875f962fe9518de30fd841b9dd5f5c394cd5705268e7748f1874880ea25f05b667b3e390b251cd7a1ae9a2ed33963b6088cd771d7be3d1daacf4b6c2a1ba5f822d4319c652e9f29c01a9ef9f76f9811fe258daf3feb5e");
    a.twaver = Ib,
    a._twaver = Jb,
    Ib.animate = {},
    Ib.network = {},
    Ib.network.interaction = {},
    Ib.controls = {},
    Ib.charts = {},
    Ib.layout = {};
    var Lb, Mb, Nb = a.navigator,
    Ob = a.document,
    Pb = a.Image;
    a.document || (Mb = !0, Lb = require("canvas"), Pb = Lb.Image, Nb = {
        userAgent: ""
    },
    Ob = {});
    var Qb = function() {
        var a = {},
        b = Nb.userAgent.toLowerCase();
        return a.isOpera = /opera/.test(b),
        a.isIE = /msie/.test(b) || /trident/.test(b) || /edge/.test(b),
        a.isFirefox = /firefox/i.test(b),
        a.isChrome = /chrome/i.test(b),
        a.isSafari = !a.isChrome && /safari/i.test(b),
        a.isIPhone = /iphone/.test(b),
        a.isIPod = /ipod/.test(b),
        a.isIPad = /ipad/.test(b),
        a.isAndroid = /android/i.test(b),
        a.isWebOS = /webos/i.test(b),
        a.isMSToucheable = a.isIE && (Nb.msMaxTouchPoints && Nb.msMaxTouchPoints > 1 || Nb.maxTouchPoints && Nb.maxTouchPoints > 1),
        a.isTouchable = "ontouchend" in Ob || a.isMSToucheable,
        a
    } ();
    Jb.ua = Qb;
    var Rb = {
        __accessor: function(a, b) {
            for (var c = b.__accessor,
            d = c.length,
            e = 0; d > e; e++) Jb.ip(a, c[e])
        },
        __bool: function(a, b) {
            for (var c = b.__bool,
            d = c.length,
            e = 0; d > e; e++) Jb.ibool(a, c[e])
        },
        __client: function(a, b) {
            a.getClient = function(a) {
                return this._clientMap[a]
            },
            a.setClient = function(a, b) {
                var c = this._clientMap[a];
                return null == b ? delete this._clientMap[a] : this._clientMap[a] = b,
                this.firePropertyChange("C:" + a, c, b) && this.onClientChanged(a, c, b),
                this
            },
            a.getClientProperties = function() {
                return Jb.keys(this._clientMap)
            },
            a.getClientMap = function() {
                return this._clientMap
            },
            a.onClientChanged = function(a, b, c) {}
        },
        __style: function(a, c) {
            a.getStyle = function(a, c) {
                var d = this._styleMap[a];
                return c === b && (c = !0),
                null == d && c ? Ib.Styles.getStyle(a) : d
            },
            a.setStyle = function(a, b) {
                var c = this._styleMap[a];
                return null == b ? delete this._styleMap[a] : this._styleMap[a] = b,
                this.firePropertyChange("S:" + a, c, b) && this.onStyleChanged(a, c, b),
                this
            },
            a.getStyleProperties = function() {
                return Jb.keys(this._styleMap)
            },
            a.onStyleChanged = function(a, b, c) {}
        },
        __new: function(a, b) {
            a.newInstance = function() {
                var a = Jb.getClass(this.getClassName());
                if (!a) return null;
                var b = arguments.length,
                c = arguments;
                if (0 === b) return new a;
                if (1 === b) return new a(c[0]);
                if (2 === b) return new a(c[0], c[1]);
                if (3 === b) return new a(c[0], c[1], c[2]);
                if (4 === b) return new a(c[0], c[1], c[2], c[3]);
                if (5 === b) return new a(c[0], c[1], c[2], c[3], c[4]);
                if (6 === b) return new a(c[0], c[1], c[2], c[3], c[4], c[5]);
                if (7 === b) return new a(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
                throw "don't support args more than 7"
            }
        },
        __property: function(a, b) {
            a.getValue = function(a, b) {
                return "accessor" === this._propertyType ? Jb.getValue(a, this._propertyName) : "style" === this._propertyType && a.getStyle ? a.getStyle(this._propertyName) : "client" === this._propertyType && a.getClient ? a.getClient(this._propertyName) : "field" === this._propertyType ? a[this._propertyName] : null
            },
            a.setValue = function(a, b, c) {
                if ("accessor" === this._propertyType) a[Jb.setter(this._propertyName)](b);
                else {
                    if ("style" === this._propertyType && a.setStyle) return a.setStyle(this._propertyName, b);
                    if ("client" === this._propertyType && a.setClient) return a.setClient(this._propertyName, b);
                    "field" === this._propertyType && (a[this._propertyName] = b)
                }
            }
        },
        map: {
            __accessor: 1,
            __bool: 1,
            __client: 1,
            __style: 1,
            __new: 1,
            __tree: 1,
            __property: 1
        },
        ext: function(a, b, c) {
            1 === Rb.map[a] ? Rb[a](b, c) : b[a] = c[a]
        }
    };
    Jb.extend = Rb;
    var Sb = Jb.Matrix = function(a, b, c, d, e, f) {
        this.setMatrix(a, b, c, d, e, f)
    };
    Sb.identity = function() {
        return new Sb(1, 0, 0, 1, 0, 0)
    },
    Sb.prototype.setMatrix = function(a, b, c, d, e, f) {
        this._m11 = a,
        this._m12 = b,
        this._m21 = c,
        this._m22 = d,
        this._offsetX = e,
        this._offsetY = f,
        this._type = 0,
        0 != this._m21 || 0 != this._m12 ? this._type = 4 : ((1 != this._m11 || 1 != this._m22) && (this._type = 2), (0 != this._offsetX || 0 != this._offsetY) && (this._type |= 1), 0 == (3 & this._type) && (this._type = 0))
    },
    Sb.prototype.transform = function() {
        var a;
        if (a = 2 === arguments.length ? {
            x: arguments[0],
            y: arguments[1]
        }: arguments[0], !a || !Jb.num(a.x) || !Jb.num(a.y)) throw "arguments should contain x, y";
        switch (this._type) {
        case 0:
            return {
                x:
                a.x,
                y: a.y
            };
        case 1:
            return {
                x:
                this._offsetX + a.x,
                y: this._offsetY + a.y
            };
        case 2:
            return {
                x:
                a.x * this._m11,
                y: a.y * this._m22
            };
        case 3:
            return {
                x:
                a.x * this._m11 + this._offsetX,
                y: a.y * this._m22 + this._offsetY
            }
        }
        return {
            x: this._m11 * a.x + a.y * this._m21 + this._offsetX,
            y: this._m22 * a.y + a.x * this._m12 + this._offsetY
        }
    },
    Sb.prototype.translate = function(a, b) {
        this.multiply(new Sb(1, 0, 0, 1, a, b))
    },
    Sb.prototype.scale = function(a, b) {
        this.multiply(new Sb(a, 0, 0, b, 0, 0))
    },
    Sb.prototype.rotate = function(a, b, c) {
        a = a * Math.PI / 180;
        var d = Math.sin(a),
        e = Math.cos(a),
        f = b * (1 - e) + c * d,
        g = c * (1 - e) - b * d;
        this.multiply(new Sb(e, d, -d, e, f, g))
    },
    Sb.prototype.skew = function(a, b) {
        this.multiply(new Sb(1, Math.tan(b * Math.PI / 180), Math.tan(a * Math.PI / 180), 1, 0, 0))
    },
    Sb.prototype.multiply = function(a) {
        var b = this,
        c = a,
        d = b._type,
        e = c._type;
        if (0 != e) if (0 == d) b.setMatrix(c._m11, c._m12, c._m21, c._m22, c._offsetX, c._offsetY);
        else if (1 == e) b._offsetX += c._offsetX,
        b._offsetY += c._offsetY,
        4 != d && (b._type |= 1);
        else if (1 == d) {
            var f = b._offsetX,
            g = b._offsetY;
            b.setMatrix(c._m11, c._m12, c._m21, c._m22, c._offsetX, c._offsetY),
            b._offsetX = f * c._m11 + g * c._m21 + c._offsetX,
            b._offsetY = f * c._m12 + g * c._m22 + c._offsetY,
            b._type = 4 == e ? 4 : 3
        } else switch (d << 4 | e) {
        case 34:
            return b._m11 *= c._m11,
            void(b._m22 *= c._m22);
        case 35:
            return b._m11 *= c._m11,
            b._m22 *= c._m22,
            b._offsetX = c._offsetX,
            b._offsetY = c._offsetY,
            void(b._type = 3);
        case 36:
        case 52:
        case 66:
        case 67:
        case 68:
            return void b.setMatrix(b._m11 * c._m11 + b._m12 * c._m21, b._m11 * c._m12 + b._m12 * c._m22, b._m21 * c._m11 + b._m22 * c._m21, b._m21 * c._m12 + b._m22 * c._m22, b._offsetX * c._m11 + b._offsetY * c._m21 + c._offsetX, b._offsetX * c._m12 + b._offsetY * c._m22 + c._offsetY);
        case 50:
            return b._m11 *= c._m11,
            b._m22 *= c._m22,
            b._offsetX *= c._m11,
            void(b._offsetY *= c._m22);
        case 51:
            return b._m11 *= c._m11,
            b._m22 *= c._m22,
            b._offsetX = c._m11 * b._offsetX + c._offsetX,
            void(b._offsetY = c._m22 * b._offsetY + c._offsetY);
        default:
            console.log("Matrix multiply hit an invalid case: " + combinedType)
        }
    };
    var Tb = {
        getDistance: function(a, b) {
            var c = b.x - a.x,
            d = b.y - a.y;
            return Math.sqrt(c * c + d * d)
        },
        getCenterPoint: function(a, b) {
            return a && b ? {
                x: (a.x + b.x) / 2,
                y: (a.y + b.y) / 2
            }: null == b && a.width ? {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }: void 0
        },
        isPointInPolygon: function(a, b) {
            a = a._as ? a._as: a;
            var c = 0,
            d = 0,
            e = !1,
            f = a.length;
            for (c = 0, d = f - 1; f > c; d = c++) {
                var g = a[c],
                h = a[d];
                g.y > b.y != h.y > b.y && b.x < (h.x - g.x) * (b.y - g.y) / (h.y - g.y) + g.x && (e = !e)
            }
            return e
        },
        unionRect: function(a, b) {
            if (a && !b) return Jb.cloneRect(a);
            if (!a && b) return Jb.cloneRect(b);
            if (a && b) {
                var c = {};
                return c.x = Math.min(a.x, b.x),
                c.y = Math.min(a.y, b.y),
                c.width = Math.max(a.x + a.width, b.x + b.width) - c.x,
                c.height = Math.max(a.y + a.height, b.y + b.height) - c.y,
                c
            }
            return null
        },
        intersects: function(a, b) {
            if (!a || !b) return ! 1;
            var c = b.width,
            d = b.height,
            e = a.width,
            f = a.height;
            if (0 >= e || 0 >= f || 0 >= c || 0 >= d) return ! 1;
            var g = b.x,
            h = b.y,
            i = a.x,
            j = a.y;
            return e += i,
            f += j,
            c += g,
            d += h,
            (i > e || e > g) && (j > f || f > h) && (g > c || c > i) && (h > d || d > j)
        },
        intersection: function(a, b) {
            if (!a || !b) return ! 1;
            var c = b.x,
            d = b.y,
            e = a.x,
            f = a.y,
            g = c;
            g += b.width;
            var h = d;
            h += b.height;
            var i = e;
            i += a.width;
            var j = f;
            return j += a.height,
            e > c && (c = e),
            f > d && (d = f),
            g > i && (g = i),
            h > j && (h = j),
            g -= c,
            h -= d,
            0 === g || 0 === h ? null: {
                x: c,
                y: d,
                width: g,
                height: h
            }
        },
        contains: function(a, b) {
            var c = b.x,
            d = b.y,
            e = b.width,
            f = b.height,
            g = a.width,
            h = a.height;
            if (0 > (g | h | e | f)) return ! 1;
            var i = a.x,
            j = a.y;
            if (i > c || j > d) return ! 1;
            if (g += i, e += c, c >= e) {
                if (g >= i || e > g) return ! 1
            } else if (g >= i && e > g) return ! 1;
            if (h += j, f += d, d >= f) {
                if (h >= j || f > h) return ! 1
            } else if (h >= j && f > h) return ! 1;
            return ! 0
        },
        getLinePoints: function(a) {
            if (!a) return null;
            var b = new nd;
            return a.forEach(function(a) {
                b.addAll(a)
            }),
            b
        },
        getLineRect: function(a) {
            var b = Tb.getLinePoints(a);
            return Tb.getRect(b)
        },
        getRect: function(a, b) {
            if (!a) return null;
            a._as && (a = a._as);
            var c = a.length;
            if (0 >= c) return null;
            var d = a[0];
            b = b || {
                x: null,
                y: null,
                width: 0,
                height: 0
            };
            for (var e = 0; c > e; e++) if (d = a[e], d instanceof nd) Tb.getRect(d, b);
            else {
                null == b.x && (b.x = d.x, b.y = d.y);
                var f = Math.min(b.x, d.x),
                g = Math.min(b.y, d.y),
                h = Math.max(b.x + b.width, d.x),
                i = Math.max(b.y + b.height, d.y);
                b.x = f,
                b.y = g,
                b.width = h - f,
                b.height = i - g
            }
            return b
        },
        addPadding: function(a, b, c, d) {
            d = d || -1;
            var e = b.getStyle(c) * d;
            0 != e && Tb.grow(a, e, e),
            e = b.getStyle(c + ".left") * d,
            0 != e && (a.x -= e, a.width += e),
            e = b.getStyle(c + ".right") * d,
            0 != e && (a.width += e),
            e = b.getStyle(c + ".top") * d,
            0 != e && (a.y -= e, a.height += e),
            e = b.getStyle(c + ".bottom") * d,
            0 != e && (a.height += e),
            a.width < 0 && (a.width = -a.width, a.x -= a.width),
            a.height < 0 && (a.height = -a.height, a.y -= a.height)
        },
        grow: function(a, b, c) {
            if (null == a) return null;
            null == c && (c = b);
            var d = a.width + b + b;
            if (! (0 > d)) {
                var e = a.height + c + c;
                if (! (0 > e)) return a.x -= b,
                a.y -= c,
                a.width = d,
                a.height = e,
                a
            }
        },
        containsPoint: function(a, b, c) {
            return arguments.length < 3 && (c = b.y, b = b.x),
            !a || b < a.x || c < a.y || b > a.x + a.width || c > a.y + a.height ? !1 : !0
        },
        getHotSpot: function(a, b, c, d, e) {
            if ("oval" === e) {
                var f = .35;
                return {
                    x: a + .5 * c + c * f,
                    y: b + d / 2 - Math.sqrt(.25 - f * f) * d
                }
            }
            if ("circle" === e) {
                var g = a + c / 2,
                h = b + d / 2,
                i = Math.min(c, d) / 2;
                a = g - i,
                b = h - i,
                c = 2 * i,
                d = 2 * i;
                var j = c / 2,
                k = d / 2,
                l = j * k / Math.sqrt(j * j + k * k);
                return {
                    x: a + c / 2 + l,
                    y: b + d / 2 - l
                }
            }
            var m = {
                x: a + c,
                y: b
            };
            return c > 3 && (m.x -= 3),
            d > 3 && (m.y += 3),
            m
        },
        getCircleRect: function(a) {
            var b = Math.min(a.width, a.height) / 2;
            return {
                x: a.x + a.width / 2 - b,
                y: a.y + a.height / 2 - b,
                width: 2 * b,
                height: 2 * b
            }
        },
        getEllipsePoint: function(a, b) {
            if (!a || !b) return null;
            var c = a.x + a.width / 2,
            d = a.y + a.height / 2,
            e = b.x - c,
            f = b.y - d,
            g = a.width / 2,
            h = a.height / 2,
            i = Math.sqrt(1 / (1 / g / g + f * f / e / e / h / h));
            0 > e && (i = -i);
            var j;
            return j = 0 == e ? f > 0 ? h: -h: i * f / e,
            {
                x: c + i,
                y: d + j
            }
        },
        createMatrix: function(a, b, c) {
            var d = Math.sin(a),
            e = Math.cos(a),
            f = b * (1 - e) + c * d,
            g = c * (1 - e) - b * d;
            return new Sb(e, d, -d, e, f, g)
        },
        calculatePointInfoAlongLineBySegments: function(a, b, c, d, e) {
            return Tb.calculatePointInfoAlongLine(Tb.getPointObject(a, b), c, d, e)
        },
        calculatePointInfoAlongLine: function(a, c, d, e) {
            if (c = c === b ? !0 : c, d = d || 0, e = e || 0, !a || a.size() < 2) throw "must more than two points";
            if (!c) {
                var f = Tb.reversePath(a);
                return Tb.calculatePointInfoAlongLine(f, !0, d, e)
            }
            a._as && (a = a._as);
            var g, h, i, j, k, l = 0,
            m = 0,
            n = a.length;
            for (j = 0; n > j; j++) if (k = a[j], 0 != j) {
                if (0 >= d) {
                    i = Tb.calculatePointInfoOnStraightLine(Tb._getPoint(h), Tb._getControlPoint(k), d, e),
                    g = i;
                    break
                }
                if (m = Tb._getLength(k, h), l + m > d) {
                    i = Tb.getPathInfo(k, h, d - l, e, m),
                    g = i;
                    break
                }
                l += m,
                h = k
            } else h = k;
            if (null == g) {
                var o, p;
                h = a[n - 1],
                p = Tb._getPoint(h),
                h instanceof nd && (h = h._as),
                o = h instanceof Array ? Tb._getControlPoint(h) : Tb._getPoint(a[n - 2]);
                var q = Math.atan2(p.y - o.y, p.x - o.x);
                i = Tb.transformPoint(p, q, d - l, e),
                i.angle = q,
                g = i
            }
            return g
        },
        reversePath: function(a) {
            var b, c = new nd,
            d = null;
            a._as && (a = a._as);
            for (var e = a.length - 1; e >= 0; e--) b = a[e],
            c.add(Tb._getReversePath(b, d)),
            d = b;
            return c
        },
        _getPoint: function(a) {
            return a._as && (a = a._as),
            a instanceof Array ? a[a.length - 1] : a
        },
        _getControlPoint: function(a) {
            return a._as && (a = a._as),
            a instanceof Array ? a[a.length - 2] : a
        },
        _getReversePath: function(a, b) {
            var c = Tb._getPoint(a);
            return b && b._as && (b = b._as),
            null != b && b instanceof Array ? new nd(2 == b.length ? [b[0], c] : [b[1], b[0], c]) : c
        },
        _getLength: function(a, b) {
            var c = Tb._getPoint(b),
            d = Tb._getPoint(a);
            if (a instanceof nd && (a = a._as), a instanceof Array) return Tb.calculateCurveLength(c, a, 1);
            var e = d.y - c.y,
            f = d.x - c.x;
            return Math.sqrt(f * f + e * e)
        },
        getPathInfo: function(a, b, c, d, e) {
            var f, g = Tb._getPoint(b),
            h = Tb._getPoint(a);
            if (a instanceof nd && (a = a._as), a instanceof Array) {
                0 > e && (e = Tb._getLength(a, b));
                var i = c / e,
                j = Tb.calculatePointInfoOnCurveLine(g, a, i);
                g = j.point,
                f = j.angle,
                c = 0
            } else f = Math.atan2(h.y - g.y, h.x - g.x);
            return Tb.transformPoint(g, f, c, d)
        },
        transformPoint: function(a, b, c, d) {
            var e = {
                x: c,
                y: d
            },
            f = Tb.createMatrix(b, 0, 0);
            return e = f.transform(e),
            e.x += a.x,
            e.y += a.y,
            {
                point: e,
                angle: b
            }
        },
        calculatePointInfoOnStraightLine: function(a, b, c, d) {
            var e = Math.atan2(b.y - a.y, b.x - a.x);
            return Tb.transformPoint(a, e, c, d)
        },
        calculatePointInfoOnCurveLine: function(a, b, c) {
            if (0 > c || c > 1) throw "Illegal arguments";
            return b._as && (b = b._as),
            2 == b.length ? Tb._calculatePointInfoOnCurveLine2(a, b[0], b[1], c) : Tb._calculatePointInfoOnCurveLine3(a, b[0], b[1], b[2], c)
        },
        _calculatePointInfoOnCurveLine2: function(a, b, c, d) {
            var e = 2 * (a.x + c.x - 2 * b.x) * d + 2 * b.x - 2 * a.x,
            f = 2 * (a.y + c.y - 2 * b.y) * d + 2 * b.y - 2 * a.y,
            g = Math.atan2(f, e),
            h = (a.x + c.x - 2 * b.x) * d * d + (2 * b.x - 2 * a.x) * d + a.x,
            i = (a.y + c.y - 2 * b.y) * d * d + (2 * b.y - 2 * a.y) * d + a.y;
            return {
                point: {
                    x: h,
                    y: i
                },
                angle: g
            }
        },
        _calculatePointInfoOnCurveLine3: function(a, b, c, d, e) {
            var f, g, h;
            f = 1 - e,
            g = f * f * f,
            h = e * e * e;
            var i = g * a.x + 3 * e * f * f * b.x + 3 * e * e * f * c.x + h * d.x,
            j = g * a.y + 3 * e * f * f * b.y + 3 * e * e * f * c.y + h * d.y;
            return {
                point: {
                    x: i,
                    y: j
                },
                angle: Math.atan2(Tb._bezeSpeedY(a, b, c, d, e), Tb._bezeSpeedX(a, b, c, d, e))
            }
        },
        calculateCurveLength: function(a, b, c) {
            return b._as && (b = b._as),
            2 == b.length ? Tb._calculateCurveLength(a, b[0], b[1], c) : Tb._calculateBezierCurveLength(a, b[0], b[1], b[2], c)
        },
        _calculateCurveLength: function(a, b, c, d) {
            if (0 >= d || d > 1) return 0;
            var e = Math.floor(d * (Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) + Math.sqrt((c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y))) / 2),
            f = 0;
            0 >= e && (e = 1);
            for (var g, h, i = d / e,
            j = 0,
            k = 0; e > k; k++) j = i * k,
            g = 2 * (a.x + c.x - 2 * b.x) * j + 2 * b.x - 2 * a.x,
            h = 2 * (a.y + c.y - 2 * b.y) * j + 2 * b.y - 2 * a.y,
            g *= i,
            h *= i,
            f += Math.sqrt(g * g + h * h);
            return f
        },
        _calculateBezierCurveLength: function(a, b, c, d, e) {
            if (0 >= e || e > 1) return 0;
            var f = 1e4,
            g = Math.floor(f * e);
            if (1 == (1 & g) && g++, 0 == g) return 0;
            var h, i = Math.floor(g / 2),
            j = 0,
            k = 0,
            l = e / g;
            for (h = 0; i > h; h++) j += Tb._bezeSpeed(a, b, c, d, (2 * h + 1) * l);
            for (h = 1; i > h; h++) k += Tb._bezeSpeed(a, b, c, d, 2 * h * l);
            return (Tb._bezeSpeed(a, b, c, d, 0) + Tb._bezeSpeed(a, b, c, d, 1) + 2 * k + 4 * j) * l / 3
        },
        _bezeSpeedX: function(a, b, c, d, e) {
            var f = 1 - e;
            return - 3 * a.x * f * f + 3 * b.x * f * f - 6 * b.x * f * e + 6 * c.x * f * e - 3 * c.x * e * e + 3 * d.x * e * e
        },
        _bezeSpeedY: function(a, b, c, d, e) {
            var f = 1 - e;
            return - 3 * a.y * f * f + 3 * b.y * f * f - 6 * b.y * f * e + 6 * c.y * f * e - 3 * c.y * e * e + 3 * d.y * e * e
        },
        _bezeSpeed: function(a, b, c, d, e) {
            var f = Tb._bezeSpeedX(a, b, c, d, e),
            g = Tb._bezeSpeedY(a, b, c, d, e);
            return Math.sqrt(f * f + g * g)
        },
        getPointObject: function(a, b) {
            if (b && 0 != b.size()) {
                var c = new nd;
                b = b._as,
                a = a._as;
                var d, e, f = 0,
                g = b.length,
                h = a.length;
                for (d = 0; g > d && (e = b[d], f != h); d++)"cubicto" === e ? h - 2 > f && c.add([a[f++], a[f++], a[f++]]) : "quadto" === e ? h - 1 > f && c.add([a[f++], a[f++]]) : h > f && c.add(a[f++]);
                for (; h > f; f++) c.add(a[f]);
                return c
            }
            return a
        },
        calculateLineLength: function(a, b) {
            if (!a || a.size() < 2) return 0;
            if (b) return Tb.calculateLineLength(Tb.getPointObject(a, b));
            a = a._as;
            var c, d, e, f, g, h, i, j = a.length,
            k = 0;
            for (c = 0; j > c; c++) f = a[c],
            0 != c ? (e = f, e instanceof nd && (e = e._as), e instanceof Array ? (g = Tb.calculateCurveLength(d, e, 1), d = e[e.length - 1]) : (i = f.y - d.y, h = f.x - d.x, g = Math.sqrt(h * h + i * i), d = e), k += g) : d = f;
            return k
        },
        toDegrees: function(a) {
            return 180 * a / Math.PI
        },
        toRadians: function(a) {
            return a / 180 * Math.PI
        },
        getRadiansBetweenLines: function(a, b) {
            return Math.atan2(b.y - a.y, b.x - a.x)
        },
        getAngle: function(a, b) {
            return a.x === b.x ? b.y === a.y ? 0 : b.y > a.y ? Math.PI / 2 : -Math.PI / 2 : Math.atan((b.y - a.y) / (b.x - a.x))
        }
    };
    Jb.math = Tb;
    var Ub = {
        getPoints: function(a) {
            var b = new nd;
            return a.forEach(function(a) {
                b.add({
                    x: a.x,
                    y: a.y
                }),
                b.add({
                    x: a.x + a.width,
                    y: a.y + a.height
                }),
                b.add({
                    x: a.x + a.width,
                    y: a.y
                }),
                b.add({
                    x: a.x,
                    y: a.y + a.height
                })
            }),
            b
        },
        rectangle: function(a) {
            var b;
            return a.forEach(function(a) {
                b = Tb.unionRect(b, a)
            }),
            b
        },
        oval: function(a) {
            var b = Ub.rectangle(a),
            c = 0,
            d = b.height / b.width,
            e = d * d,
            f = b.x + b.width / 2,
            g = b.y + b.height / 2,
            h = Ub.getPoints(a);
            h.forEach(function(a) {
                var b = a.x - f,
                d = a.y - g,
                h = b * b + d * d / e;
                h > c && (c = h)
            }),
            c = Math.sqrt(c);
            var i = d * c;
            return {
                x: f - c,
                y: g - i,
                width: 2 * c,
                height: 2 * i
            }
        },
        circle: function(a) {
            var b = Ub.rectangle(a),
            c = 0,
            d = b.x + b.width / 2,
            e = b.y + b.height / 2,
            f = Ub.getPoints(a);
            return f.forEach(function(a) {
                var b = a.x - d,
                f = a.y - e,
                g = b * b + f * f;
                g > c && (c = g)
            }),
            c = Math.sqrt(c),
            {
                x: d - c,
                y: e - c,
                width: 2 * c,
                height: 2 * c
            }
        },
        roundrect: function(a) {
            var b = Ub.rectangle(a),
            c = Math.min(b.width, b.height) / 16;
            return Tb.grow(b, c, c),
            b
        },
        star: function(a) {
            var b = Ub.rectangle(a);
            return Tb.grow(b, b.width, b.height),
            b
        },
        triangle: function(a) {
            var b = Ub.rectangle(a);
            return b.x -= b.width / 2,
            b.width *= 2,
            b.y -= b.height,
            b.height *= 2,
            b
        },
        hexagon: function(a) {
            var b = Ub.rectangle(a);
            return b.x -= b.width / 2,
            b.width *= 2,
            b
        },
        pentagon: function(a) {
            var b = Ub.rectangle(a);
            return b.x -= b.width / 6,
            b.width += b.width / 3,
            b.y -= b.height / 4,
            b.height += b.height / 4,
            b
        },
        diamond: function(a) {
            var b = Ub.rectangle(a);
            return b.x -= b.width / 2,
            b.width += b.width,
            b.y -= b.height / 2,
            b.height += b.height,
            b
        }
    };
    Jb.group = Ub;
    var Vb = {
        "topleft.topleft": function(a, b) {
            return {
                x: a.x - b.width,
                y: a.y - b.height
            }
        },
        "topleft.topright": function(a, b) {
            return {
                x: a.x,
                y: a.y - b.height
            }
        },
        "top.top": function(a, b) {
            return {
                x: a.x + a.width / 2 - b.width / 2,
                y: a.y - b.height
            }
        },
        "topright.topleft": function(a, b) {
            return {
                x: a.x + a.width - b.width,
                y: a.y - b.height
            }
        },
        "topright.topright": function(a, b) {
            return {
                x: a.x + a.width,
                y: a.y - b.height
            }
        },
        topleft: function(a, b) {
            return {
                x: a.x - b.width / 2,
                y: a.y - b.height / 2
            }
        },
        top: function(a, b) {
            return {
                x: a.x - b.width / 2 + a.width / 2,
                y: a.y - b.height / 2
            }
        },
        topright: function(a, b) {
            return {
                x: a.x - b.width / 2 + a.width,
                y: a.y - b.height / 2
            }
        },
        "topleft.bottomleft": function(a, b) {
            return {
                x: a.x - b.width,
                y: a.y
            }
        },
        "topleft.bottomright": function(a, b) {
            return {
                x: a.x,
                y: a.y
            }
        },
        "top.bottom": function(a, b) {
            return {
                x: a.x + a.width / 2 - b.width / 2,
                y: a.y
            }
        },
        "topright.bottomleft": function(a, b) {
            return {
                x: a.x - b.width + a.width,
                y: a.y
            }
        },
        "topright.bottomright": function(a, b) {
            return {
                x: a.x + a.width,
                y: a.y
            }
        },
        "left.left": function(a, b) {
            return {
                x: a.x - b.width,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        left: function(a, b) {
            return {
                x: a.x - b.width / 2,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        "left.right": function(a, b) {
            return {
                x: a.x,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        center: function(a, b) {
            return {
                x: a.x + a.width / 2 - b.width / 2,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        "right.left": function(a, b) {
            return {
                x: a.x + a.width - b.width,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        right: function(a, b) {
            return {
                x: a.x + a.width - b.width / 2,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        "right.right": function(a, b) {
            return {
                x: a.x + a.width,
                y: a.y + a.height / 2 - b.height / 2
            }
        },
        "bottomleft.topleft": function(a, b) {
            return {
                x: a.x - b.width,
                y: a.y + a.height - b.height
            }
        },
        "bottomleft.topright": function(a, b) {
            return {
                x: a.x,
                y: a.y + a.height - b.height
            }
        },
        "bottom.top": function(a, b) {
            return {
                x: a.x + a.width / 2 - b.width / 2,
                y: a.y + a.height - b.height
            }
        },
        "bottomright.topleft": function(a, b) {
            return {
                x: a.x + a.width - b.width,
                y: a.y + a.height - b.height
            }
        },
        "bottomright.topright": function(a, b) {
            return {
                x: a.x + a.width,
                y: a.y + a.height - b.height
            }
        },
        bottomleft: function(a, b) {
            return {
                x: a.x - b.width / 2,
                y: a.y + a.height - b.height / 2
            }
        },
        bottom: function(a, b) {
            return {
                x: a.x + a.width / 2 - b.width / 2,
                y: a.y + a.height - b.height / 2
            }
        },
        bottomright: function(a, b) {
            return {
                x: a.x + a.width - b.width / 2,
                y: a.y + a.height - b.height / 2
            }
        },
        "bottomleft.bottomleft": function(a, b) {
            return {
                x: a.x - b.width,
                y: a.y + a.height
            }
        },
        "bottomleft.bottomright": function(a, b) {
            return {
                x: a.x,
                y: a.y + a.height
            }
        },
        "bottom.bottom": function(a, b) {
            return {
                x: a.x + a.width / 2 - b.width / 2,
                y: a.y + a.height
            }
        },
        "bottomright.bottomleft": function(a, b) {
            return {
                x: a.x + a.width - b.width,
                y: a.y + a.height
            }
        },
        "bottomright.bottomright": function(a, b) {
            return {
                x: a.x + a.width,
                y: a.y + a.height
            }
        },
        get: function(a, b, c) {
            if (!b) throw "refRect can not be null";
            c || (c = {
                width: 0,
                height: 0
            });
            var d = Vb[a];
            if (d) return d(b, c);
            throw "Can not resolve '" + a + "' position"
        }
    };
    Jb.position = Vb;
    var Wb = {
        preventDefault: function(a) {
            Dd.KEEP_DEFAULT_FUNCTION(a) || (a.preventDefault ? a.preventDefault() : a.preventManipulation ? a.preventManipulation() : a.returnValue = !1)
        },
        insertAfter: function(a, b) {
            return b ? b.parentNode.insertBefore(a, b.nextSibling) : a.parentNode.insertBefore(a, a.parentNode.firstChild),
            a
        },
        forEach: function(a, b, c) {
            if (Wb.isVisible(a)) {
                for (var d = a.childNodes.length,
                e = 0; d > e; e++) Wb.forEach(a.childNodes[e], b, c);
                c ? b.call(c, a) : b(a)
            }
        },
        setVisible: function(a, b) {
            a.style.display = b ? "block": "none"
        },
        isVisible: function(a) {
            return "style" in a && "none" !== a.style.display
        },
        release: function(a) {
            for (var b = a.childNodes.length,
            c = 0; b > c; c++) Wb.release(a.childNodes[c]);
            b > 0 && Wb.clear(a),
            a._pool && a._pool.release(a)
        },
        clear: function(a) {
            for (; a.firstChild;) a.removeChild(a.firstChild)
        },
        setZoom: function(a, b) {
            var c = a.style;
            if (c.setProperty) if (Qb.isFirefox) c.setProperty("-moz-transform", "scale(" + b + ")", null),
            c.setProperty("-moz-transform-origin", "0 0", null);
            else if (Qb.isOpera) c.setProperty("-o-transform", "scale(" + b + ")", null),
            c.setProperty("-o-transform-origin", "0 0", null);
            else if (Qb.isChrome || Qb.isSafari) {
                c.setProperty("-webkit-transform", "scale(" + b + ")", null),
                c.setProperty("-webkit-transform-origin", "0 0", null);
                var d = null;
                a._webkitInvaildateDiv ? d = a._webkitInvaildateDiv: (d = Ob.createElement("div"), a._webkitInvaildateDiv = d),
                d.parentNode && d.parentNode == a ? a.removeChild(d) : a.appendChild(d)
            } else Qb.isIE ? (c.setProperty("-ms-transform", "scale(" + b + ")", null), c.setProperty("-ms-transform-origin", "0 0", null)) : (c.setProperty("transform", "scale(" + b + ")", null), c.setProperty("transform-origin", "0 0", null))
        },
        setRotate: function(a, b) {
            var c = a.style;
            if (c.setProperty) if (Qb.isFirefox) c.setProperty("-moz-transform", "scale(" + b + ")", null),
            c.setProperty("-moz-transform-origin", "0 0", null);
            else if (Qb.isOpera) c.setProperty("-o-transform", "scale(" + b + ")", null),
            c.setProperty("-o-transform-origin", "0 0", null);
            else if (Qb.isChrome || Qb.isSafari) {
                c.setProperty("-webkit-transform", "scale(" + b + ")", null),
                c.setProperty("-webkit-transform-origin", "0 0", null);
                var d = null;
                a._webkitInvaildateDiv ? d = a._webkitInvaildateDiv: (d = Ob.createElement("div"), a._webkitInvaildateDiv = d),
                d.parentNode && d.parentNode == a ? a.removeChild(d) : a.appendChild(d)
            } else Qb.isIE ? (c.setProperty("-ms-transform", "scale(" + b + ")", null), c.setProperty("-ms-transform-origin", "0 0", null)) : (c.setProperty("transform", "scale(" + b + ")", null), c.setProperty("transform-origin", "0 0", null))
        },
        setCSSStyle: function(a, b, c) {
            a.style.setProperty(b, c, null)
        },
        removeCSSStyle: function(a, b) {
            a.style.removeProperty(b)
        },
        getCSSStyle: function(a, b) {
            return a.style.getPropertyValue(b)
        },
        setBorderRaidus: function(a, b) {
            Qb.isFirefox ? a.style.MozBorderRadius = b: a.style.borderRadius = b
        },
        createSelect: function(a, b) {
            var c, d, e, f = Ob.createElement("select");
            if (Array.isArray(a)) for (c = 0; c < a.length; c++) d = a[c],
            e = Ob.createElement("option"),
            e.innerHTML = d,
            e.setAttribute("value", d),
            d === b && e.setAttribute("selected", "true"),
            f.appendChild(e);
            else for (c = 0; c < a.values.length; c++) d = a.values[c],
            e = Ob.createElement("option"),
            e.innerHTML = a.map[d],
            e.setAttribute("value", d),
            d === b && e.setAttribute("selected", "true"),
            f.appendChild(e);
            return f
        },
        createImg: function(a) {
            var b = Ob.createElement("img");
            return b.style.position = "absolute",
            "string" == typeof a && b.setAttribute("src", a),
            b
        },
        createView: function(a, b) {
            var c = Ob.createElement("div");
            return c.style.position = Dd.VIEW_POSITION,
            c.style.fontSize = Dd.VIEW_FONT_SIZE,
            c.style.fontFamily = Dd.VIEW_FONT_FAMILY,
            c.style.cursor = "default",
            c.style.outline = "none",
            c.style.textAlign = "left",
            c.style.msTouchAction = "none",
            c.tabIndex = 0,
            b || (c.onmousedown = Wb.preventDefault),
            c.style.setProperty && (c.style.setProperty("-khtml-user-select", "none", null), c.style.setProperty("-webkit-user-select", "none", null), c.style.setProperty("-moz-user-select", "none", null), c.style.setProperty("-webkit-tap-highlight-color", "rgba(0, 0, 0, 0)", null)),
            a && (c.style.overflow = a),
            c
        },
        createDiv: function() {
            var a = Ob.createElement("div");
            return a.style.position = "absolute",
            a.style.msTouchAction = "none",
            a
        },
        createCanvas: function(a, b) {
            if (a = a || 0, b = b || 0, Mb) {
                var c = require("canvas");
                return new c(a, b)
            }
            var d = Ob.createElement("canvas");
            return d.style.position = "absolute",
            d.style.msTouchAction = "none",
            d.width = a,
            d.height = b,
            d
        },
        setCanvas: function(a, b, c, d, e) {
            2 === arguments.length && (c = b.y, d = b.width, e = b.height, b = b.x),
            a.style.left = b + "px",
            a.style.top = c + "px",
            a.setAttribute("width", d),
            a.setAttribute("height", e),
            a._viewRect = {
                x: b,
                y: c,
                width: d,
                height: e
            };
            var f = a.getContext("2d");
            return 0 !== f.shadowBlur && (f.shadowOffsetX = 0, f.shadowOffsetY = 0, f.shadowBlur = 0, f.shadowColor = "rgba(0,0,0,0.0)"),
            f.clearRect(0, 0, d, e),
            f.translate( - b, -c),
            f
        },
        setImg: function(a, b, c) {
            a.setAttribute("src", b),
            a.style.left = c.x + "px",
            a.style.top = c.y + "px",
            a.style.width = c.width + "px",
            a.style.height = c.height + "px",
            a._viewRect = Jb.clone(c)
        },
        setDiv: function(a, b, c, d, e) {
            d = Jb.num(d) ? d: 0,
            a.style.left = b.x - d + "px",
            a.style.top = b.y - d + "px",
            a.style.width = b.width + "px",
            a.style.height = b.height + "px",
            a._viewRect = Jb.clone(b),
            a.style.backgroundColor = c ? c: "",
            a.style.border = d > 0 ? d + "px " + e + " solid": ""
        },
        addEventListener: function(a, b, c, d) {
            var e = "_" + a + "_";
            if (!d[e]) {
                var f = function(a) {
                    f.instance[f.method](a)
                };
                f.method = b,
                f.instance = d,
                d[e] = f,
                c.addEventListener(a, f, !1)
            }
        },
        removeEventListener: function(a, b, c) {
            var d = "_" + a + "_",
            e = c[d];
            e && (b.removeEventListener(a, e, !1), delete c[d])
        },
        isValidEvent: function(a, b) {
            if (!b) return ! 1;
            if (b.target === a) if (Qb.isFirefox) {
                if (a.clientHeight < a.scrollHeight && b.layerX < 25) return ! 1;
                if (a.clientWidth < a.scrollWidth && b.layerY < 25) return ! 1
            } else if (b.offsetX > a.clientWidth || b.offsetY > a.clientHeight) return ! 1;
            return ! 0
        },
        getLogicalPoint: function(a, b, c, d) {
            c = c ? c: 1;
            var e, f = a.getBoundingClientRect();
            if (Qb.isTouchable && b.changedTouches && b.changedTouches.length > 0) {
                var g = b.changedTouches[0],
                h = Qb.isAndroid ? 0 : zc.scrollLeft(),
                i = Qb.isAndroid ? 0 : zc.scrollTop();
                e = {
                    x: (g.clientX + a.scrollLeft - f.left - h) / c,
                    y: (g.clientY + a.scrollTop - f.top - i) / c
                }
            } else {
                if (!Wb.isValidEvent(a, b)) return null;
                e = {
                    x: (b.clientX - f.left + a.scrollLeft) / c,
                    y: (b.clientY - f.top + a.scrollTop) / c
                }
            }
            return e
        },
        handle_mousedown: function(b, c) {
            Wb.target && Wb.handle_mouseup(c),
            a.addEventListener("mousemove", Wb.handle_mousemove, !1),
            a.addEventListener("mouseup", Wb.handle_mouseup, !1),
            Wb.target = b
        },
        handle_mousemove: function(a) {
            Wb.target.handle_mousemove && Wb.target.handle_mousemove(a),
            Wb.target.handleMouseMove && Wb.target.handleMouseMove(a)
        },
        handle_mouseup: function(b) {
            Wb.target.handle_mouseup && Wb.target.handle_mouseup(b),
            Wb.target.handleMouseUp && Wb.target.handleMouseUp(b),
            a.removeEventListener("mousemove", Wb.handle_mousemove, !1),
            a.removeEventListener("mouseup", Wb.handle_mouseup, !1),
            delete Wb.target
        },
        getClientPoint: function(a) {
            return {
                x: a.clientX,
                y: a.clientY
            }
        },
        windowWidth: function() {
            return "number" == typeof a.innerWidth ? a.innerWidth: Ob.documentElement && Ob.documentElement.clientWidth ? Ob.documentElement.clientWidth: Ob.body && Ob.body.clientWidth ? Ob.body.clientWidth: 0
        },
        windowHeight: function() {
            return "number" == typeof a.innerHeight ? a.innerHeight: Ob.documentElement && Ob.documentElement.clientHeight ? Ob.documentElement.clientHeight: Ob.body && Ob.body.clientHeight ? Ob.body.clientHeight: 0
        }
    };
    Jb.html = Wb;
    var Xb = {
        cache: {},
        g: Wb.createCanvas().getContext("2d"),
        getTextSize: function(a, b) {
            Xb.g.font = a ? a: Dd.FONT;
            var c = Xb.cache[Xb.g.font];
            c || (c = 2 * Xb.g.measureText("e").width + 4, Xb.cache[Xb.g.font] = c),
            b = b || "",
            b = String(b);
            for (var d, e = b.split("\n"), f = e.length, g = 0, h = f - 1; h >= 0; h--) d = Xb.g.measureText(e[h]).width,
            d > g && (g = d);
            return {
                width: g + 4,
                height: c * f
            }
        },
        drawText: function(a, c, d, e, f, g) {
            c = c || "",
            c = String(c),
            e || (e = Dd.FONT);
            var h = "center";
            g && (h = g),
            a.font = e,
            a.fillStyle = f,
            a.textAlign = h,
            a.textBaseline = "middle";
            var i, j, k = c.split("\n"),
            l = k.length,
            m = 0;
            d ? d.width === b ? (i = d.x, j = d.y) : (m = d.height / l, "left" == h ? i = d.x: "center" == h && (i = d.x + d.width / 2), j = d.y + m / 2) : (i = 0, j = 0),
            Qb.isOpera && (j -= 2);
            for (var n = 0; l > n; n++)"right" == h && (a.textAlign = "left", i = d.x + d.width - Xb.getTextSize(e, k[n]).width),
            a.fillText(k[n], i, j),
            j += m
        },
        drawArc: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p, q, r, s;
            if (Math.abs(e) > 2 * Math.PI && (e = 2 * Math.PI), m = Math.ceil(Math.abs(e) / (Math.PI / 4)), i = e / m, j = -i, k = -d, m > 0) {
                n = b + Math.cos(d) * f,
                o = c + Math.sin( - d) * g,
                h ? a.lineTo(n, o) : a.moveTo(n, o);
                for (var t = 0; m > t; t++) k += j,
                l = k - j / 2,
                p = b + Math.cos(k) * f,
                q = c + Math.sin(k) * g,
                r = b + Math.cos(l) * (f / Math.cos(j / 2)),
                s = c + Math.sin(l) * (g / Math.cos(j / 2)),
                a.quadraticCurveTo(r, s, p, q)
            }
        },
        dashedLine: function(a, b, c, d, e, f, g) {
            var h = f - d,
            i = g - e,
            j = Math.sqrt(h * h + i * i);
            if (0 != j) {
                h /= j,
                i /= j;
                for (var k = j,
                l = -c.offset,
                m = c.drawing,
                n = c.patternIndex; k > l;) l += b[n],
                l >= k && (c.offset = b[n] - (l - k), c.patternIndex = n, c.drawing = m, l = k),
                m ? a.lineTo(d + l * h, e + l * i) : a.moveTo(d + l * h, e + l * i),
                m = !m,
                n = (n + 1) % b.length
            }
        },
        drawLinePoints: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l = 0,
            m = 0,
            n = b.size();
            if (k = c && c.length > 0 ? new uc(a, c[0], c.length > 1 ? c[1] : c[0]) : a, d) for (m = 0, j = d.size(); j > m; m++) if (f = d.get(m), "moveto" === f && n > l) g = b.get(l++),
            k.moveTo(g.x, g.y);
            else if ("lineto" === f && n > l) g = b.get(l++),
            k.lineTo(g.x, g.y);
            else if ("cubicto" === f && n - 2 > l) g = b.get(l++),
            h = b.get(l++),
            i = b.get(l++),
            k.bezierCurveTo(g.x, g.y, h.x, h.y, i.x, i.y);
            else {
                if (! ("quadto" === f && n - 1 > l)) throw "Can not resolve segment '" + f + "'";
                g = b.get(l++),
                h = b.get(l++),
                k.quadraticCurveTo(g.x, g.y, h.x, h.y)
            } else this._drawLine(b, k);
            e && k.closePath()
        },
        _drawLine: function(a, b) {
            var c, d, e, f, g, h = 0,
            i = a.size();
            for (c = a.get(0), b.moveTo(c.x, c.y), h = 1; i > h; h++) g = a.get(h),
            g.size ? (f = g.size(), 2 === f ? (c = g.get(0), d = g.get(1), b.quadraticCurveTo(c.x, c.y, d.x, d.y)) : 3 === f && (c = g.get(0), d = g.get(1), e = g.get(2), b.bezierCurveTo(c.x, c.y, d.x, d.y, e.x, e.y))) : b.lineTo(g.x, g.y)
        },
        drawRoundRect: function(a, b, c, d, e, f, g, h, i) {
            6 === arguments.length && (g = f, h = f, i = f);
            var j = b + d,
            k = c + e,
            l = e > d ? 2 * d: 2 * e;
            f = l > f ? f: l,
            g = l > g ? g: l,
            h = l > h ? h: l,
            i = l > i ? i: l;
            var m = .292893218813453 * i,
            n = .585786437626905 * i;
            a.moveTo(j, k - i),
            a.quadraticCurveTo(j, k - n, j - m, k - m),
            a.quadraticCurveTo(j - n, k, j - i, k),
            m = .292893218813453 * h,
            n = .585786437626905 * h,
            a.lineTo(b + h, k),
            a.quadraticCurveTo(b + n, k, b + m, k - m),
            a.quadraticCurveTo(b, k - n, b, k - h),
            m = .292893218813453 * f,
            n = .585786437626905 * f,
            a.lineTo(b, c + f),
            a.quadraticCurveTo(b, c + n, b + m, c + m),
            a.quadraticCurveTo(b + n, c, b + f, c),
            m = .292893218813453 * g,
            n = .585786437626905 * g,
            a.lineTo(j - g, c),
            a.quadraticCurveTo(j - n, c, j - m, c + m),
            a.quadraticCurveTo(j, c + n, j, c + g),
            a.lineTo(j, k - i)
        },
        drawVector: function(a, b, c, d, e, f, g) {
            var h;
            4 === arguments.length ? (e = d.y, f = d.width, g = d.height, d = d.x) : 5 === arguments.length && "roundrect" === b && (h = {},
            h.topLeft = e, h.topRight = e, h.bottomLeft = e, h.bottomRight = e, e = d.y, f = d.width, g = d.height, d = d.x);
            var i = Xb["_" + b];
            i && (a.beginPath(), c && c.length > 0 && (a = new uc(a, c[0], c.length > 1 ? c[1] : c[0])), 5 === arguments.length && "roundrect" === b ? i(a, {
                x: d,
                y: e,
                width: f,
                height: g
            },
            h) : i(a, d, e, f, g))
        },
        _rectangle: function(a, b, c, d, e) {
            a.rect(b, c, d, e)
        },
        _circle: function(a, b, c, d, e) {
            var f = b + d / 2,
            g = c + e / 2,
            h = Math.min(d, e) / 2;
            a instanceof uc ? Xb.drawArc(a, f, g, 0, 2 * Math.PI, h, h, !1) : a.arc(f, g, h, 0, 2 * Math.PI, !0)
        },
        _oval: function(a, b, c, d, e) {
            if (a instanceof uc) Xb.drawArc(a, b + d / 2, c + e / 2, 0, 2 * Math.PI, d / 2, e / 2, !1);
            else {
                var f = .5522848,
                g = d / 2 * f,
                h = e / 2 * f,
                i = b + d,
                j = c + e,
                k = b + d / 2,
                l = c + e / 2;
                a.moveTo(b, l),
                a.bezierCurveTo(b, l - h, k - g, c, k, c),
                a.bezierCurveTo(k + g, c, i, l - h, i, l),
                a.bezierCurveTo(i, l + h, k + g, j, k, j),
                a.bezierCurveTo(k - g, j, b, l + h, b, l)
            }
        },
        _roundrect: function(a, b, c, d, e) {
            if (3 === arguments.length) {
                var f = c;
                c = b.y,
                d = b.width,
                e = b.height,
                b = b.x,
                f.topLeft ? Xb.drawRoundRect(a, b, c, d, e, f.topLeft) : Xb.drawRoundRect(a, b, c, d, e, Math.min(Math.min(d, e) / 4, 10))
            } else Xb.drawRoundRect(a, b, c, d, e, Math.min(Math.min(d, e) / 4, 10))
        },
        _star: function(a, b, c, d, e) {
            var f = 2 * d,
            g = 2 * e,
            h = b + d / 2,
            i = c + e / 2;
            a.moveTo(h - f / 4, i - g / 12),
            a.lineTo(b + .306 * d, c + .579 * e),
            a.lineTo(h - f / 6, i + g / 4),
            a.lineTo(b + d / 2, c + .733 * e),
            a.lineTo(h + f / 6, i + g / 4),
            a.lineTo(b + .693 * d, c + .579 * e),
            a.lineTo(h + f / 4, i - g / 12),
            a.lineTo(b + .611 * d, c + .332 * e),
            a.lineTo(h + 0, i - g / 4),
            a.lineTo(b + .388 * d, c + .332 * e),
            a.closePath()
        },
        _triangle: function(a, b, c, d, e) {
            a.moveTo(b + d / 2, c),
            a.lineTo(b + d, c + e),
            a.lineTo(b, c + e),
            a.closePath()
        },
        _hexagon: function(a, b, c, d, e) {
            a.moveTo(b, c + e / 2),
            a.lineTo(b + d / 4, c + e),
            a.lineTo(b + 3 * d / 4, +c + e),
            a.lineTo(b + d, c + e / 2),
            a.lineTo(b + 3 * d / 4, c),
            a.lineTo(b + d / 4, c),
            a.closePath()
        },
        _pentagon: function(a, b, c, d, e) {
            var f = 2 * d,
            g = 2 * e,
            h = b + d / 2,
            i = c + e / 2;
            a.moveTo(h - f / 4, i - g / 12),
            a.lineTo(h - f / 6, i + g / 4),
            a.lineTo(h + f / 6, i + g / 4),
            a.lineTo(h + f / 4, i - g / 12),
            a.lineTo(h + 0, i - g / 4),
            a.closePath()
        },
        _diamond: function(a, b, c, d, e) {
            a.moveTo(b + d / 2, c),
            a.lineTo(b, c + e / 2),
            a.lineTo(b + d / 2, c + e),
            a.lineTo(b + d, c + e / 2),
            a.closePath()
        },
        fill: function(a, b, c, d, e, f, g, h) {
            var i = Yb[c];
            a.fillStyle = i ? 5 === arguments.length ? i(a, b, d, e.x, e.y, e.width, e.height) : i(a, b, d, e, f, g, h) : b
        },
        createRadialGradient: function(a, b, c, d, e, f, g, h, i) {
            var j = a.createRadialGradient(d + f * h, e + g * i, Math.min(f, g) / 24, d + f / 2, e + g / 2, Math.max(f, g) / 2);
            return j.addColorStop(0, c),
            j.addColorStop(1, b),
            j
        },
        drawPath: function(a, b, c, d, e, f, g, h) {
            var i = a._element,
            j = a.getBodyRect();
            d && Tb.addPadding(j, i, c + ".padding", 1);
            var k = Jb.clone(j),
            l = i.getStyle(c + ".outline.width");
            l > 0 && Tb.grow(k, l / 2, l / 2);
            var m = a.setShadow(a, b, k);
            0 != i.getAngle() && (i instanceof Md || (j = i.getOriginalRect()), Ib.Util.rotateCanvas(m, j, i.getAngle()));
            var n, o = i.getStyle(c + ".fill");
            if (o) {
                n = a._innerColor && !vc.hasDefault(a._element) ? a._innerColor: i.getStyle(c + ".fill.color");
                var p = i.getStyle(c + ".gradient");
                p ? Xb.fill(m, n, p, i.getStyle(c + ".gradient.color"), j) : m.fillStyle = n
            }
            var q = i.getStyle(c + ".shape"),
            r = i.getStyle("group.shape.roundrect.radius");
            return o && (m.beginPath(), f ? Xb.drawLinePoints(m, f, null, g, h) : "roundrect" === q && "group" === c ? Xb.drawVector(m, q, null, j, r) : Xb.drawVector(m, q, null, j), m.fill()),
            l > 0 && (m.lineWidth = l, m.lineCap = i.getStyle(c + ".cap"), m.lineJoin = i.getStyle(c + ".join"), m.strokeStyle = i.getStyle(c + ".outline.color"), m.beginPath(), f ? Xb.drawLinePoints(m, f, e, g, h) : "roundrect" === q && "group" === c ? Xb.drawVector(m, q, e, j, r) : Xb.drawVector(m, q, e, j), m.stroke()),
            k
        },
        draw3DRect: function(a, b, c, d, e, f, g) {
            if (0 !== c) {
                arguments.length <= 4 && (g = d.height, f = d.width, e = d.y, d = d.x);
                var h = c > 0;
                c = Math.abs(c);
                var i, j;
                if (a.lineWidth = 1, a.lineCap = "square", 1 === c) i = Xb.brighter(b),
                j = Xb.darker(b),
                a.strokeStyle = h ? i: j,
                a.beginPath(),
                a.moveTo(d, e),
                a.lineTo(d, e + g),
                a.moveTo(d, e),
                a.lineTo(d + f, e),
                a.closePath(),
                a.stroke(),
                a.strokeStyle = h ? j: i,
                a.beginPath(),
                a.moveTo(d, e + g),
                a.lineTo(d + f, e + g),
                a.moveTo(d + f, e),
                a.lineTo(d + f, e + g),
                a.closePath(),
                a.stroke();
                else for (var k = 2 * c,
                l = 50 / k,
                m = 0; k > m; m++) i = Xb.brighter(b, 50 - m * l),
                j = Xb.darker(b, 50 - m * l),
                d += .5,
                e += .5,
                f -= 1,
                g -= 1,
                a.strokeStyle = h ? i: j,
                a.beginPath(),
                a.moveTo(d, e),
                a.lineTo(d, e + g),
                a.moveTo(d, e),
                a.lineTo(d + f, e),
                a.closePath(),
                a.stroke(),
                a.strokeStyle = h ? j: i,
                a.beginPath(),
                a.moveTo(d, e + g),
                a.lineTo(d + f, e + g),
                a.moveTo(d + f, e),
                a.lineTo(d + f, e + g),
                a.closePath(),
                a.stroke()
            }
        },
        brighter: function(a, b) {
            return b || (b = 50),
            Xb.adjustBrightness2(a, b)
        },
        darker: function(a, b) {
            return b || (b = 50),
            Xb.adjustBrightness2(a, -b)
        },
        adjustBrightness2: function(a, b) {
            var c, d, e;
            if (0 === b) return a;
            var f = sd(a);
            return 0 > b ? (b = (100 + b) / 100, c = Math.ceil(f.r * b), d = Math.ceil(f.g * b), e = Math.ceil(f.b * b)) : (b /= 100, c = f.r, d = f.g, e = f.b, c += (255 - c) * b, d += (255 - d) * b, e += (255 - e) * b, c = Math.min(Math.ceil(c), 255), d = Math.min(Math.ceil(d), 255), e = Math.min(Math.ceil(e), 255)),
            "rgba(" + c + "," + d + "," + e + ",1)"
        },
        getColorArray: function(a) {
            return rd.clearRect(0, 0, 1, 1),
            rd.fillStyle = a,
            rd.fillRect(0, 0, 1, 1),
            rd.getImageData(0, 0, 1, 1).data
        },
        hit: function(a, b, c, d) {
            if (!a) return ! 1;
            var e = a._viewRect;
            if (!e) return ! 1;
            if (b -= e.x, c -= e.y, 0 > b || 0 > c || b >= e.width || c >= e.height) return ! 1;
            try {
                for (var f = a.getContext("2d").getImageData(b, c, 1, 1), g = f.data, h = 0, i = g.length; i > h; h += 4) if (0 !== g[h + 3]) return ! 0
            } catch(j) {
                return ! 0
            }
            return ! 1
        },
        intersects: function(a, b) {
            if (!a) return ! 1;
            if (b = Tb.intersection(b, a._viewRect), !b) return ! 1;
            b.x -= a._viewRect.x,
            b.y -= a._viewRect.y;
            try {
                for (var c = a.getContext("2d").getImageData(b.x, b.y, b.width, b.height), d = c.data, e = 0, f = d.length; f > e; e += 4) if (0 !== d[e + 3]) return ! 0
            } catch(g) {}
            return ! 1
        },
        strokeRect: function(a, b, c, d) {
            b && (a.beginPath(), a.strokeStyle = c ? c: Ib.Util.randomColor(), a.lineWidth = d ? d: 2, a.strokeRect(b.x, b.y, b.width, b.height), a.stroke())
        }
    };
    Jb.g = Xb;
    var Yb = {
        "linear.southwest": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e + g, d + f, e);
            return h.addColorStop(0, c),
            h.addColorStop(1, b),
            h
        },
        "linear.southeast": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d + f, e + g, d, e);
            return h.addColorStop(0, c),
            h.addColorStop(1, b),
            h
        },
        "linear.northwest": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d + f, e + g, d, e);
            return h.addColorStop(0, b),
            h.addColorStop(1, c),
            h
        },
        "linear.northeast": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d + f, e, d, e + g);
            return h.addColorStop(0, c),
            h.addColorStop(1, b),
            h
        },
        "linear.north": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d, e + g);
            return h.addColorStop(0, c),
            h.addColorStop(1, b),
            h
        },
        "linear.south": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d, e + g);
            return h.addColorStop(0, b),
            h.addColorStop(1, c),
            h
        },
        "linear.west": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d + f, e);
            return h.addColorStop(0, c),
            h.addColorStop(1, b),
            h
        },
        "linear.east": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d + f, e);
            return h.addColorStop(0, b),
            h.addColorStop(1, c),
            h
        },
        "radial.center": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .5, .5)
        },
        "radial.southwest": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .25, .75)
        },
        "radial.southeast": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .75, .75)
        },
        "radial.northwest": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .25, .25)
        },
        "radial.northeast": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .75, .25)
        },
        "radial.north": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .5, .25)
        },
        "radial.south": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .5, .75)
        },
        "radial.west": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .25, .5)
        },
        "radial.east": function(a, b, c, d, e, f, g) {
            return Xb.createRadialGradient(a, b, c, d, e, f, g, .75, .5)
        },
        "spread.horizontal": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d + f, e);
            return h.addColorStop(0, b),
            h.addColorStop(.5, c),
            h.addColorStop(1, b),
            h
        },
        "spread.vertical": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d, e + g);
            return h.addColorStop(0, b),
            h.addColorStop(.5, c),
            h.addColorStop(1, b),
            h
        },
        "spread.diagonal": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d + f, e, d, e + g);
            return h.addColorStop(0, b),
            h.addColorStop(.5, c),
            h.addColorStop(1, b),
            h
        },
        "spread.antidiagonal": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e, d + f, e + g);
            return h.addColorStop(0, b),
            h.addColorStop(.5, c),
            h.addColorStop(1, b),
            h
        },
        "spread.north": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e - g / 4, d, e + g + g / 4);
            return h.addColorStop(0, b),
            h.addColorStop(1 / 3, c),
            h.addColorStop(2 / 3, b),
            h.addColorStop(1, c),
            h
        },
        "spread.south": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d, e - g / 4, d, e + g + g / 4);
            return h.addColorStop(0, c),
            h.addColorStop(1 / 3, b),
            h.addColorStop(2 / 3, c),
            h.addColorStop(1, b),
            h
        },
        "spread.west": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d - f / 4, e, d + f + f / 4, e);
            return h.addColorStop(0, b),
            h.addColorStop(1 / 3, c),
            h.addColorStop(2 / 3, b),
            h.addColorStop(1, c),
            h
        },
        "spread.east": function(a, b, c, d, e, f, g) {
            var h = a.createLinearGradient(d - f / 4, e, d + f + f / 4, e);
            return h.addColorStop(0, c),
            h.addColorStop(1 / 3, b),
            h.addColorStop(2 / 3, c),
            h.addColorStop(1, b),
            h
        }
    };
    Ib.Util = {
        getVersion: function() {
            return "5.3.6"
        },
        registerImage: function(a, b, c, d, e) {
            Jb.registerImage(a, b, c, d, e)
        },
        getRegisteredImageNames: function() {
            return Jb.getRegisteredImageNames()
        },
        unregisterImage: function(a) {
            Jb.unregisterImage(a)
        },
        getImageAsset: function(a) {
            return Jb.getImageAsset(a)
        },
        validateLicense: function(a) {
            Jb.validateLicense(a)
        },
        getLicense: function() {
            return Kb
        },
        isPermissionGIS: function() {
            return tc()
        },
        moveElements: function(a, b, c, d, e) {
            if ((0 !== b || 0 !== c) && a && !a.isEmpty()) {
                var f, g, h = Ib.animate.AnimateManager;
                h.endAnimate(),
                a = vc.filterMovingElements(a),
                d && (f = new nd, g = new nd),
                a.forEach(function(a) {
                    a instanceof Kd && (d ? (f.add(a), g.add({
                        x: a.getX() + b,
                        y: a.getY() + c
                    })) : a.translate(b, c))
                }),
                d ? h.start(new Ib.animate.AnimateLocation(f, g, e)) : e && e()
            }
        },
        isTypeOf: function(a, b) {
            if (a === b) return ! 0;
            for (var c = a.superClass; c;) {
                if (c === b.prototype) return ! 0;
                c = c.constructor.superClass
            }
            return ! 1
        },
        setFocus: function(a) {
            if (Ob.activeElement !== a) {
                var b, c, d, e = Ob.documentElement,
                f = Ob.body;
                e && (Qb.isIE || Qb.isOpera || e.scrollLeft || e.scrollTop) ? (b = e.scrollLeft, c = e.scrollTop, d = e) : f && (b = f.scrollLeft, c = f.scrollTop, d = f),
                a.focus(),
                d && (d.scrollLeft = b, d.scrollTop = c)
            }
        },
        isOpera: Qb.isOpera,
        isIE: Qb.isIE,
        isFirefox: Qb.isFirefox,
        isChrome: Qb.isChrome,
        isSafari: Qb.isSafari,
        isIPhone: Qb.isIPhone,
        isIPod: Qb.isIPod,
        isIPad: Qb.isIPad,
        isAndroid: Qb.isAndroid,
        isWebOS: Qb.isWebOS,
        isTouchable: Qb.isTouchable,
        ext: function(a, b, c) {
            Jb.ext(a, b, c)
        },
        getValue: function(a, b, c) {
            return Jb.getValue(a, b, c)
        },
        setValue: function(a, b, c) {
            Jb.setValue(a, b, c)
        },
        grow: function(a, b, c) {
            Tb.grow(a, b, c)
        },
        containsPoint: function(a, b, c) {
            return Tb.containsPoint.apply(null, arguments)
        },
        intersects: function(a, b) {
            return Tb.intersects(a, b)
        },
        getRect: function(a) {
            return Tb.getRect(a)
        },
        unionRect: function(a, b) {
            return Tb.unionRect(a, b)
        },
        createDiv: function() {
            return Wb.createDiv()
        },
        createCanvas: function() {
            return Wb.createCanvas()
        },
        setCanvas: function(a, b, c, d, e) {
            return Wb.setCanvas.apply(null, arguments)
        },
        drawVector: function(a, b, c, d, e, f, g) {
            Xb.drawVector.apply(null, arguments)
        },
        fill: function(a, b, c, d, e, f, g, h) {
            Xb.fill.apply(null, arguments)
        },
        getClass: function(a) {
            return Jb.getClass(a)
        },
        getAllClassNames: function() {
            var a, b = [];
            for (a in Jb.classCache) b.push(a);
            return b
        },
        newInstance: function(a) {
            return Jb.newInstance.apply(null, arguments)
        },
        isDeserializing: function() {
            return Jb.isDeserializing
        },
        addEventListener: function(a, b, c, d) {
            Wb.addEventListener(a, b, c, d)
        },
        removeEventListener: function(a, b, c) {
            Wb.removeEventListener(a, b, c)
        },
        drawArrow: function(a, b, c, d, e, f, g, h, i, j, k, l) {
            od.drawArrow.apply(null, arguments)
        },
        calculatePointAngleAlongLine: function(a, b, c, d, e) {
            return Tb.calculatePointInfoAlongLineBySegments(a, b, c, d, e)
        },
        getSubNetwork: function(a) {
            return vc.getSubNetwork(a)
        },
        transformPoint: function(a, b, c, d) {
            return Tb.transformPoint(a, b, c, d)
        },
        getToolTipDiv: function() {
            return Bc.getToolTipDiv()
        },
        showToolTip: function(a, b) {
            Bc.showToolTip(a, b)
        },
        hideToolTip: function() {
            Bc.hideToolTip()
        },
        resetToolTip: function() {
            Bc.resetToolTip()
        },
        setCSSStyle: function(a, b, c) {
            Wb.setCSSStyle(a, b, c)
        },
        removeCSSStyle: function(a, b) {
            Wb.removeCSSStyle(a, b)
        },
        getCSSStyle: function(a, b) {
            return Wb.getCSSStyle(a, b)
        },
        toDegrees: function(a) {
            return Tb.toDegrees(a)
        },
        toRadians: function(a) {
            return Tb.toDegrees(a)
        },
        getRadiansBetweenLines: function(a, b) {
            return Tb.getRadiansBetweenLines(a, b)
        },
        getElementsBounds: function(a, b) {
            var c = null;
            return a.forEach(function(a) {
                if (a.getRect) {
                    var d, e;
                    b && (e = b.getElementUI(a), e && (d = e.getViewRect())),
                    d || (d = a.getRect()),
                    c = c ? Ib.Util.unionRect(c, d) : d
                }
            }),
            c
        },
        getPointIndex: function(a, b, c) {
            if (c || (c = 10), a) for (var d = a.size(); d--; d >= 0) if (Tb.getDistance(a.get(d), b) <= c) return d;
            return - 1
        },
        registerVectorShape: function(a, b) {
            Jb.g["_" + a] = b
        },
        rotateCanvas: function(a, b, c) {
            a.translate(b.x + b.width / 2, b.y + b.height / 2),
            a.rotate(c * Math.PI / 180),
            a.translate( - (b.x + b.width / 2), -(b.y + b.height / 2))
        },
        registerShape: function(a, b) {
            fd(a, b)
        },
        registerDraw: function(a, b) {
            ed(a, b)
        },
        getFilterColor: function(a, b) {
            return td(a, b)
        },
        registerGifImage: function(a, b) {},
        parseVectorData: function(a) {
            return Ec(a)
        },
        getSharedLinks: function(a, b) {
            var c = a.getLinks(),
            d = b.getLinks();
            if (c && 0 != c.size() && d && 0 != d.size()) {
                var e = c.size() > d.size() ? c: d;
                return e.toList(function(c) {
                    return c.getFromNode() == a && c.getToNode() == b || c.getFromNode() == b && c.getToNode() == a
                })
            }
            return null
        },
        isSharedLinks: function(a, b) {
            var c = !1,
            d = a.getLinks(),
            e = b.getLinks();
            if (d && 0 != d.size() && e && 0 != e.size()) {
                var f = d.size() > e.size() ? d: e;
                f.forEach(function(d) {
                    return d.getFromNode() == a && d.getToNode() == b || d.getFromNode() == b && d.getToNode() == a ? (c = !0, !1) : !0
                })
            }
            return c
        },
        playAnimate: function(a) {
            return yb(a)
        },
        pauseAnimate: function(a) {
            a.pause()
        },
        resumeAnimate: function(a) {
            a.resume()
        },
        stopAnimate: function(a, b) {
            zb(a, b)
        },
        pauseAllAnimates: function() {
            Bb()
        },
        resumeAllAnimates: function() {
            Cb()
        },
        stopAllAnimates: function(a) {
            Ab(a)
        },
        randomColor: function() {
            return "#" + ("00000" + (16777216 * this.random() << 0).toString(16)).substr( - 6)
        },
        random: function() {
            return Math.random()
        },
        getHSVColor: function(a, c, d) {
            var e, f, g, h, i, j, k, l;
            switch (a && c === b && d === b && (c = a.s, d = a.v, a = a.h), h = Math.floor(6 * a), i = 6 * a - h, j = d * (1 - c), k = d * (1 - i * c), l = d * (1 - (1 - i) * c), h % 6) {
            case 0:
                e = d,
                f = l,
                g = j;
                break;
            case 1:
                e = k,
                f = d,
                g = j;
                break;
            case 2:
                e = j,
                f = d,
                g = l;
                break;
            case 3:
                e = j,
                f = k,
                g = d;
                break;
            case 4:
                e = l,
                f = j,
                g = d;
                break;
            case 5:
                e = d,
                f = j,
                g = k
            }
            var m = "#" + toHex(255 * e) + toHex(255 * f) + toHex(255 * g);
            return m
        },
        toHex: function(a) {
            var b = parseInt(a).toString(16);
            return 1 == b.length && (b = "0" + b),
            b
        },
        makeHighRes: function(b) {
            var c = b.getContext("2d"),
            d = a.devicePixelRatio || 1,
            e = c.webkitBackingStorePixelRatio || c.mozBackingStorePixelRatio || c.msBackingStorePixelRatio || c.oBackingStorePixelRatio || c.backingStorePixelRatio || 1,
            f = d / e;
            if (d !== e) {
                var g = b.width,
                h = b.height;
                b.width = Math.round(g * f),
                b.height = Math.round(h * f),
                b.style.width = g + "px",
                b.style.height = h + "px",
                c.scale(f, f)
            }
        },
        newFunction: function() {
            var a = arguments,
            b = a.length;
            return 1 === b ? Jb.newInstance("Function", a[0]) : 2 === b ? Jb.newInstance("Function", a[0], a[1]) : 3 === b ? Jb.newInstance("Function", a[0], a[1], a[2]) : 4 === b ? Jb.newInstance("Function", a[0], a[1], a[2], a[3]) : 5 === b ? Jb.newInstance("Function", a[0], a[1], a[2], a[3], a[4]) : 6 === b ? Jb.newInstance("Function", a[0], a[1], a[2], a[3], a[4], a[5]) : 7 === b ? Jb.newInstance("Function", a[0], a[1], a[2], a[3], a[4], a[5], a[6]) : 8 === b ? Jb.newInstance("Function", a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]) : null
        }
    },
    Jb.ext("twaver.Util", Object, {});
    var Zb, $b = 0xdeadbeefcafe,
    _b = 15715070 == (16777215 & $b);
    _b && "Microsoft Internet Explorer" == Nb.appName ? (c.prototype.am = f, Zb = 30) : _b && "Netscape" != Nb.appName ? (c.prototype.am = e, Zb = 26) : (c.prototype.am = g, Zb = 28),
    c.prototype.DB = Zb,
    c.prototype.DM = (1 << Zb) - 1,
    c.prototype.DV = 1 << Zb;
    var ac = 52;
    c.prototype.FV = Math.pow(2, ac),
    c.prototype.F1 = ac - Zb,
    c.prototype.F2 = 2 * Zb - ac;
    var bc, cc, dc = "0123456789abcdefghijklmnopqrstuvwxyz",
    ec = new Array;
    for (bc = "0".charCodeAt(0), cc = 0; 9 >= cc; ++cc) ec[bc++] = cc;
    for (bc = "a".charCodeAt(0), cc = 10; 36 > cc; ++cc) ec[bc++] = cc;
    for (bc = "A".charCodeAt(0), cc = 10; 36 > cc; ++cc) ec[bc++] = cc;
    E.prototype.convert = F,
    E.prototype.revert = G,
    E.prototype.reduce = H,
    E.prototype.mulTo = I,
    E.prototype.sqrTo = J,
    L.prototype.convert = M,
    L.prototype.revert = N,
    L.prototype.reduce = O,
    L.prototype.mulTo = Q,
    L.prototype.sqrTo = P,
    c.prototype.copyTo = k,
    c.prototype.fromInt = l,
    c.prototype.fromString = n,
    c.prototype.clamp = o,
    c.prototype.dlShiftTo = v,
    c.prototype.drShiftTo = w,
    c.prototype.lShiftTo = x,
    c.prototype.rShiftTo = y,
    c.prototype.subTo = z,
    c.prototype.multiplyTo = A,
    c.prototype.squareTo = B,
    c.prototype.divRemTo = C,
    c.prototype.invDigit = K,
    c.prototype.isEven = R,
    c.prototype.exp = S,
    c.prototype.toString = p,
    c.prototype.negate = q,
    c.prototype.abs = r,
    c.prototype.compareTo = s,
    c.prototype.bitLength = u,
    c.prototype.mod = D,
    c.prototype.modPowInt = T,
    c.ZERO = m(0),
    c.ONE = m(1),
    Ka.prototype.convert = La,
    Ka.prototype.revert = La,
    Ka.prototype.mulTo = Ma,
    Ka.prototype.sqrTo = Na,
    Ra.prototype.convert = Sa,
    Ra.prototype.revert = Ta,
    Ra.prototype.reduce = Ua,
    Ra.prototype.mulTo = Wa,
    Ra.prototype.sqrTo = Va;
    var fc = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
    gc = (1 << 26) / fc[fc.length - 1];
    c.prototype.chunkSize = Y,
    c.prototype.toRadix = $,
    c.prototype.fromRadix = _,
    c.prototype.fromNumber = aa,
    c.prototype.bitwiseTo = fa,
    c.prototype.changeBit = wa,
    c.prototype.addTo = Aa,
    c.prototype.dMultiply = Ia,
    c.prototype.dAddOffset = Ja,
    c.prototype.multiplyLowerTo = Pa,
    c.prototype.multiplyUpperTo = Qa,
    c.prototype.modInt = Za,
    c.prototype.millerRabin = ab,
    c.prototype.clone = U,
    c.prototype.intValue = V,
    c.prototype.byteValue = W,
    c.prototype.shortValue = X,
    c.prototype.signum = Z,
    c.prototype.toByteArray = ba,
    c.prototype.equals = ca,
    c.prototype.min = da,
    c.prototype.max = ea,
    c.prototype.and = ha,
    c.prototype.or = ja,
    c.prototype.xor = la,
    c.prototype.andNot = na,
    c.prototype.not = oa,
    c.prototype.shiftLeft = pa,
    c.prototype.shiftRight = qa,
    c.prototype.getLowestSetBit = sa,
    c.prototype.bitCount = ua,
    c.prototype.testBit = va,
    c.prototype.setBit = xa,
    c.prototype.clearBit = ya,
    c.prototype.flipBit = za,
    c.prototype.add = Ba,
    c.prototype.subtract = Ca,
    c.prototype.multiply = Da,
    c.prototype.divide = Fa,
    c.prototype.remainder = Ga,
    c.prototype.divideAndRemainder = Ha,
    c.prototype.modPow = Xa,
    c.prototype.modInverse = $a,
    c.prototype.pow = Oa,
    c.prototype.gcd = Ya,
    c.prototype.isProbablePrime = _a,
    c.prototype.square = Ea,
    bb.prototype.init = cb,
    bb.prototype.next = db;
    var hc, ic, jc, kc = 256;
    if (null == ic) {
        ic = new Array,
        jc = 0;
        var lc;
        if ("Netscape" == Nb.appName && Nb.appVersion < "5" && a.crypto) {
            var mc = a.crypto.random(32);
            for (lc = 0; lc < mc.length; ++lc) ic[jc++] = 255 & mc.charCodeAt(lc)
        }
        for (; kc > jc;) lc = Math.floor(65536 * Ib.Util.random()),
        ic[jc++] = lc >>> 8,
        ic[jc++] = 255 & lc;
        jc = 0,
        gb()
    }
    jb.prototype.nextBytes = ib,
    mb.prototype.doPublic = ob,
    mb.prototype.setPublic = nb,
    mb.prototype.encrypt = pb,
    mb.prototype.doPrivate = tb,
    mb.prototype.setPrivate = rb,
    mb.prototype.setPrivateEx = sb,
    mb.prototype.decrypt = ub;
    var nc = function() {
        oc.v(Kb)
    },
    oc = {},
    pc = "6a384c1259bdb5e731ec96b3174683f48a2c56a85e52e7a5bb20b58711ce50c1a294bd5e1d1752e766085e9ae94bae6d217c25dbb5fcdb86a8a9a7e180fa066723d00fcb85fcf7c9d29f8cc8859f53244a49c0bc30dcc45156daf8843ce1d24fe8ebc9a3c186bb26e9d0714041aef160304c1db8cc5728cf4acb39d29755f319",
    qc = "10001";
    oc.cross = function(a) {
        if (a) {
            for (var b = "",
            c = 0; c < a.length;) c + 1 < a.length ? (b += a[c + 1], b += a[c]) : b += a[c],
            c += 2;
            return b
        }
        return null
    },
    oc.reverse = function(a) {
        if (a) {
            for (var b = "",
            c = a.length; c > 0; c--) b += a[c - 1];
            return b
        }
        return null
    },
    oc.v = function(a) {
        if (a) {
            var b = oc;
            if (b.start = null, b.beginDate = null, b.end = null, b.endDate = null, b.gis = null, b["3D"] = null, b["3d"] = null, b.l = null, b.__li__ = null, a.indexOf("signature=") > 0) {
                var c = a.split("signature="),
                d = c[0],
                e = c[1],
                f = new mb;
                f.setPublic(pc, qc);
                for (var g = e,
                h = g.length,
                i = 256,
                j = 0,
                k = "",
                l = ""; h > j;) k = g.substr(j, i),
                l += f.decrypt(k),
                j += i;
                if (l === d) return b.i(a),
                !0
            }
        }
        return ! 1
    },
    oc.i = function(a) {
        var c = oc;
        c.__li__ = a;
        var d, e, f, g, h, i = a.split("\n");
        for (d = i.length - 1; d >= 0; d--) e = i[d],
        h = e.split("="),
        f = h[0],
        g = h[1],
        c[f] = g;
        c.start != b && (c.beginDate = new Date(Date.parse(c.start.replace(/-/g, "/")))),
        c.end != b && (c.endDate = new Date(Date.parse(c.end.replace(/-/g, "/"))));
        var j = c.gis;
        j != b && (j = parseInt(j)),
        j && (c._isPermissionGIS = !0);
        var k = c["3D"] || c["3d"];
        k != b && (k = parseInt(k)),
        k && (c._isPermission3D = !0),
        c["3D"] && (c._isPermission3D = !0),
        c.l != b && (c.version = c.l)
    };
    var rc = function(a) {
        return a.__li__ !== b && !a._isPermission3D
    },
    sc = function(a) {
        if (!rc(a)) return ! 0;
        var b = new Date;
        return null != a.beginDate && a.beginDate.getTime() - b.getTime() >= 0 || null != a.endDate && a.endDate.getTime() - b.getTime() <= 0
    },
    tc = function() {
        return sc(oc) ? !1 : oc._isPermissionGIS
    };
    oc.$z = function(a) {
        var b = new mb;
        b.setPublic(pc, qc);
        for (var c = a,
        d = c.length,
        e = 256,
        f = 0,
        g = "",
        h = ""; d > f;) g = c.substr(f, e),
        h += b.decrypt(g),
        f += e;
        return h
    },
    oc.twm = function(a) {
        var c = oc,
        d = c.$z("4cd18113d0c7046bfe51f7a3fbd41c2b7cf14dd785d6ea7cec9da17710d3acfb8ce0cb9cf10839f4bd51e88819de19cdc0db09278584396156fcb65abe0353ac49d01326b30efa0ea98a07da9f8ceeb7572fc1b37b5965ba6103ccba4913b62e36e49425c6ff21a2f008830c59cff8f29058769f858c8a9f0bab3eaea7fb8a9e"),
        e = this.type,
        f = this.markText,
        g = c.$z("648be38cd61c870e95ffc1ea0676af40736c1365015abc326e891a4de67b4de3d4b05da70b9aebedc83ec26ecf71eb74c72f42f6d9a4be2d507d2f67d2860b7b66e3ba1d565e15923f2db335ff922eef17c01b59818b583d5656412d6cc9d9ba70001c2c88e3efd492c6b13a07fda5f325b333138a2036f4696542ec137cc341");
        if (a[g] = c.__li__, "3" !== e || sc(oc) || f !== b) {
            a.__liLabel == b && (a.__liLabel = Ob.createElement("div")),
            c.startDate === b && (c.startDate = new Date);
            var h = (new Date).getTime() - c.startDate.getTime();
            if (! (3e5 > h)) {
                var i = sc(c) && h > 3e5,
                j = f;
                if (i ? j = c.$z("0dd629dbd0ce341ecdd447e35ddc3135a0b46916f7571a687f38ae665cf0ae095fee885e14329caa75112d8787508da17285b0897845d8ccae73e6a2727dd19f1ca335fe139d0e60d240f9ececc78f81c2c5667f51aeed4135b9c4bb436b8acb7cd418eeeb404bc4f3bcdedb481ac0edff7644435ce2b9f2bda78c892bd56d73") : "2" != e || j !== b && "" != j ? "1" != e || f || (j = d) : j = c.$z("644d54bf9c59afbd8a742a9e7e2731f23f149ccb7f04c3547548c50ac2d77faea108b55f1f6261e99869f1c06b84e8abdefdf45b5170048531421f3d528123972ba2f03d70f37c33f1341dc12f986e0089e42bab517e2a05b455d12d90991bbba9bc45c715a81943062ea5fa5408c8b1b9270d260cc5a67b38ecc4178ce512fc"), j !== b) {
                    var k = a,
                    l = k.__liLabel;
                    if (l.innerHTML = j, k._rootCanvas) l.type = e,
                    l.mark = f,
                    l.expired = i,
                    k._xyz = l;
                    else {
                        var m = 0,
                        n = 0;
                        l.style.position = "absolute";
                        var o = k.getView().style;
                        f != b && null != f && "" != f || "2" == e ? (m = 10 - k.getView().scrollLeft, n = 10 - k.getView().scrollTop) : (m = o.width.replace("px", "") / 2 - 50 - k.getView().scrollLeft, n = o.height.replace("px", "") / 2 - k.getView().scrollTop),
                        l.style.right = m + "px",
                        l.style.bottom = n + "px",
                        l.style.fontSize = "120%",
                        i && (k.getView().style.opacity = .1, l.style.color = "red", l.style.fontSize = "150%"),
                        k.getView().appendChild(l)
                    }
                }
            }
        }
    },
    Jb.validateLicense(Kb);
    var uc = function(a, b, c) {
        this.g = a,
        this.onLength = b,
        this.offLength = c,
        this.isLine = !0,
        this.overflow = 0,
        this.dashLength = b + c,
        this.pen = {
            x: 0,
            y: 0
        }
    };
    Jb.ext(uc, Object, {
        _curveaccuracy: 6,
        moveTo: function(a, b) {
            this.pen = {
                x: a,
                y: b
            },
            this.g.moveTo(a, b),
            this.start || (this.start = {
                x: a,
                y: b
            })
        },
        lineTo: function(a, b) {
            var c = a - this.pen.x,
            d = b - this.pen.y,
            e = Math.atan2(d, c),
            f = Math.cos(e),
            g = Math.sin(e),
            h = this.lineLength(this.pen.x, this.pen.y, a, b);
            if (this.overflow) {
                if (this.overflow > h) return this.isLine ? this._lineTo(a, b) : this.moveTo(a, b),
                void(this.overflow -= h);
                if (this.isLine ? this._lineTo(this.pen.x + f * this.overflow, this.pen.y + g * this.overflow) : this.moveTo(this.pen.x + f * this.overflow, this.pen.y + g * this.overflow), h -= this.overflow, this.overflow = 0, this.isLine = !this.isLine, !h) return
            }
            var i = Math.floor(h / this.dashLength);
            if (i) {
                for (var j = f * this.onLength,
                k = g * this.onLength,
                l = f * this.offLength,
                m = g * this.offLength,
                n = 0; i > n; n++) this.isLine ? (this._lineTo(this.pen.x + j, this.pen.y + k), this.moveTo(this.pen.x + l, this.pen.y + m)) : (this.moveTo(this.pen.x + l, this.pen.y + m), this._lineTo(this.pen.x + j, this.pen.y + k));
                h -= this.dashLength * i
            }
            this.isLine ? h > this.onLength ? (this._lineTo(this.pen.x + f * this.onLength, this.pen.y + g * this.onLength), this.moveTo(a, b), this.overflow = this.offLength - (h - this.onLength), this.isLine = !1) : (this._lineTo(a, b), h == this.onLength ? (this.overflow = 0, this.isLine = !this.isLine) : (this.overflow = this.onLength - h, this.moveTo(a, b))) : h > this.offLength ? (this.moveTo(this.pen.x + f * this.offLength, this.pen.y + g * this.offLength), this._lineTo(a, b), this.overflow = this.onLength - (h - this.offLength), this.isLine = !0) : (this.moveTo(a, b), h == this.offLength ? (this.overflow = 0, this.isLine = !this.isLine) : this.overflow = this.offLength - h)
        },
        quadraticCurveTo: function(a, b, c, d) {
            var e, f = this.pen.x,
            g = this.pen.y,
            h = this.curveLength(f, g, a, b, c, d),
            i = 0,
            j = 0;
            if (this.overflow) {
                if (this.overflow > h) return this.isLine ? this._curveTo(a, b, c, d) : this.moveTo(c, d),
                void(this.overflow -= h);
                if (i = this.overflow / h, e = this.curveSliceUpTo(f, g, a, b, c, d, i), this.isLine ? this._curveTo(e[2], e[3], e[4], e[5]) : this.moveTo(e[4], e[5]), this.overflow = 0, this.isLine = !this.isLine, !h) return
            }
            var k = h - h * i,
            l = Math.floor(k / this.dashLength),
            m = this.onLength / h,
            n = this.offLength / h;
            if (l) for (var o = 0; l > o; o++) this.isLine ? (j = i + m, e = this.curveSlice(f, g, a, b, c, d, i, j), this._curveTo(e[2], e[3], e[4], e[5]), i = j, j = i + n, e = this.curveSlice(f, g, a, b, c, d, i, j), this.moveTo(e[4], e[5])) : (j = i + n, e = this.curveSlice(f, g, a, b, c, d, i, j), this.moveTo(e[4], e[5]), i = j, j = i + m, e = this.curveSlice(f, g, a, b, c, d, i, j), this._curveTo(e[2], e[3], e[4], e[5])),
            i = j;
            k = h - h * i,
            this.isLine ? k > this.onLength ? (j = i + m, e = this.curveSlice(f, g, a, b, c, d, i, j), this._curveTo(e[2], e[3], e[4], e[5]), this.moveTo(c, d), this.overflow = this.offLength - (k - this.onLength), this.isLine = !1) : (e = this.curveSliceFrom(f, g, a, b, c, d, i), this._curveTo(e[2], e[3], e[4], e[5]), h == this.onLength ? (this.overflow = 0, this.isLine = !this.isLine) : (this.overflow = this.onLength - k, this.moveTo(c, d))) : k > this.offLength ? (j = i + n, e = this.curveSlice(f, g, a, b, c, d, i, j), this.moveTo(e[4], e[5]), e = this.curveSliceFrom(f, g, a, b, c, d, j), this._curveTo(e[2], e[3], e[4], e[5]), this.overflow = this.onLength - (k - this.offLength), this.isLine = !0) : (this.moveTo(c, d), k == this.offLength ? (this.overflow = 0, this.isLine = !this.isLine) : this.overflow = this.offLength - k)
        },
        bezierCurveTo: function(a, b, c, d, e, f) {
            this.pen = {
                x: e,
                y: f
            };
            var g = [this.onLength, this.offLength];
            this.g.setLineDash && this.g.setLineDash(g),
            this.g.lineDash = g,
            this.g.bezierCurveTo(a, b, c, d, e, f)
        },
        rect: function(a, b, c, d) {
            this.pen = {
                x: a,
                y: b
            },
            this.moveTo(a, b),
            this.lineTo(a, b + d),
            this.lineTo(a + c, b + d),
            this.lineTo(a + c, b),
            this.lineTo(a, b)
        },
        closePath: function() {
            this.lineTo(this.start.x, this.start.y)
        },
        lineLength: function(a, b, c, d) {
            var e = c - a,
            f = d - b;
            return Math.sqrt(e * e + f * f)
        },
        curveLength: function(a, b, c, d, e, f, g) {
            for (var h, i, j, k, l, m, n, o = 0,
            p = a,
            q = b,
            r = g > 0 ? g: this._curveaccuracy, s = 1; r >= s; s++) j = s / r,
            k = 1 - j,
            l = k * k,
            m = 2 * j * k,
            n = j * j,
            h = l * a + m * c + n * e,
            i = l * b + m * d + n * f,
            o += this.lineLength(p, q, h, i),
            p = h,
            q = i;
            return o
        },
        curveSlice: function(a, b, c, d, e, f, g, h) {
            if (0 == g) return this.curveSliceUpTo(a, b, c, d, e, f, h);
            if (1 == h) return this.curveSliceFrom(a, b, c, d, e, f, g);
            var i = this.curveSliceUpTo(a, b, c, d, e, f, h);
            return i.push(g / h),
            this.curveSliceFrom.apply(this, i)
        },
        curveSliceUpTo: function(a, b, c, d, e, f, g) {
            if (1 != g) {
                var h = c + (e - c) * g,
                i = d + (f - d) * g;
                c = a + (c - a) * g,
                d = b + (d - b) * g,
                e = c + (h - c) * g,
                f = d + (i - d) * g
            }
            return [a, b, c, d, e, f]
        },
        curveSliceFrom: function(a, b, c, d, e, f, g) {
            if (1 != g) {
                var h = a + (c - a) * g,
                i = b + (d - b) * g;
                c += (e - c) * g,
                d += (f - d) * g,
                a = h + (c - h) * g,
                b = i + (d - i) * g
            }
            return [a, b, c, d, e, f]
        },
        _lineTo: function(a, b) { (a != this.pen.x || b != this.pen.y) && (this.pen = {
                x: a,
                y: b
            },
            this.g.lineTo(a, b))
        },
        _curveTo: function(a, b, c, d) { (a != c || b != d || c != this.pen.x || d != this.pen.y) && (this.pen = {
                x: c,
                y: d
            },
            this.g.quadraticCurveTo(a, b, c, d))
        }
    }),
    Jb.DashedLine = uc;
    var vc = {
        DEFAULTS: {
            "default": 1,
            "default.vector": 1,
            "vector.default": 1
        },
        VECTORS: {
            vector: 1,
            "default.vector": 1,
            "vector.default": 1
        },
        hasDefault: function(a) {
            if (a instanceof Kd) {
                var b = a.getStyle("body.type");
                return 1 === vc.DEFAULTS[b]
            }
            return ! 0
        },
        hasVector: function(a) {
            if (a instanceof Kd) {
                var b = a.getStyle("body.type");
                return 1 === vc.VECTORS[b]
            }
            return ! 1
        },
        hasAgentLinks: function(a) {
            for (var b = a.getChildrenSize(), c = 0; b > c; c++) {
                var d = a.getChildAt(c);
                if (d instanceof Kd && vc.hasAgentLinks(d)) return ! 0
            }
            return a.hasAgentLinks()
        },
        getParents: function(a, b, c) {
            c || (c = !0);
            for (var d = new nd,
            e = a._parent; null != e && e !== b;) d.add(e, 0),
            e = e._parent;
            return c && null != e && e === b && d.add(e, 0),
            d
        },
        getSubNetwork: function(a) {
            if (!a) return null;
            if (a instanceof Ib.Link) {
                var b = a._fromAgent,
                c = a._toAgent;
                if (!b || !c) return null;
                var d = vc.getSubNetwork(b),
                e = vc.getSubNetwork(c);
                return d === e ? d: null
            }
            var f = a._parent;
            if (!f) return null;
            for (; f instanceof Ib.Link && !f.ISubNetwork;) f = f._parent;
            return f.ISubNetwork ? f: vc.getSubNetwork(f)
        },
        figureSameSubNetworkAgent: function(a) {
            if (!a) return null;
            for (var b = a._parent; b instanceof Md;) {
                if (! (b._parent instanceof Md)) return b.isExpanded() ? a: b;
                b.isExpanded() || (a = b),
                b = b._parent
            }
            return a
        },
        figureSpanSubNetworkAgent: function(a, b) {
            if (!a || !b) return null;
            var c = vc.getSubNetwork(a),
            d = vc.getSubNetwork(b);
            if (c != d) {
                for (; null != d && c != d;) d = vc.getSubNetwork(d);
                if (c === d) return a;
                var e = new nd;
                e.add(a, 0);
                for (var f = a._parent; f instanceof Kd && !b.isDescendantOf(f);) e.add(f, 0),
                f = f._parent;
                for (var g = e.size(), h = 0; g > h; h++) {
                    var i = e.get(h);
                    if (i instanceof Md && !i.isExpanded()) return i;
                    if (i.ISubNetwork) return i
                }
                return a
            }
            return a
        },
        figureFromAgent: function(a) {
            if (a.isLooped()) return a.getFromNode();
            var b = vc.figureSameSubNetworkAgent(a.getFromNode()),
            c = vc.figureSameSubNetworkAgent(a.getToNode());
            return b === c ? a.getFromNode() : vc.figureSpanSubNetworkAgent(b, c)
        },
        figureToAgent: function(a) {
            if (a.isLooped()) return a.getToNode();
            var b = vc.figureSameSubNetworkAgent(a.getFromNode()),
            c = vc.figureSameSubNetworkAgent(a.getToNode());
            return b === c ? a.getToNode() : vc.figureSpanSubNetworkAgent(c, b)
        },
        getBundleLinks: function(a, b) {
            if (!a || !b) return null;
            var c, d, e, f;
            if (a === b) {
                if (f = a.getLoopedLinks(), !f) return null;
                f = new nd(f)
            } else {
                var g = a.getAgentLinks(),
                h = b.getAgentLinks();
                if (!g || !h) return null;
                for (d = g.size(), c = 0; d > c; c++) e = g.get(c),
                h.contains(e) && (f || (f = new nd), f.add(e))
            }
            if (null != f) for (c = 0; c < f.size(); c++) e = f.get(c),
            e.getStyle("link.bundle.enable") || (e._setBundleLinks(null), f.removeAt(c), c--);
            return f
        },
        resetBundleLinks: function(a, b) {
            var c = vc.getBundleLinks(a, b);
            if (c && 0 !== c.size()) {
                var d = null;
                if (1 === c.size()) return d = c.get(0),
                void d._setBundleLinks(null);
                var e, f, g = new nd;
                for (e = 0; e < c.size(); e++) d = c.get(e),
                f = d.getStyle("link.bundle.id"),
                g.indexOf(f) < 0 && g.add(f);
                g.sort();
                var h, i, j = new nd;
                for (i = 0; i < g.size(); i++) {
                    f = g.get(i);
                    var k = new nd;
                    for (e = 0; e < c.size(); e++) d = c.get(e),
                    f === d.getStyle("link.bundle.id") && k.add(d);
                    h = new Ib.BundleLinks(k, j),
                    j.add(h)
                }
                for (i = 0; i < j.size(); i++) for (h = j.get(i), e = 0; e < h.getLinks().size(); e++) d = h.getLinks().get(e),
                d._setBundleLinks(h)
            }
        },
        moveElements: function(a, b, c, d) {
            for (var e = vc.filterMovingElements(a, d), f = e.size(), g = 0; f > g; g++) e.get(g).translate(b, c)
        },
        filterMovingElements: function(a, b) {
            for (var c = new nd,
            d = a.size(), e = 0; d > e; e++) {
                var f = a.get(e);
                if (f instanceof Kd && (!b || b(f))) {
                    for (var g = !0,
                    h = c.toArray(), i = 0; i < h.length; i++) {
                        var j = h[i];
                        g && j instanceof Ib.Follower && f instanceof Ib.Follower && f.isLoopedHostOn(j) ? g = !1 : j instanceof Ib.Follower && j.isHostOn(f) ? c.remove(j) : g && f instanceof Ib.Follower && j instanceof Kd && f.isHostOn(j) ? g = !1 : vc.isDescendantOfGroup(j, f) ? c.remove(j) : g && vc.isDescendantOfGroup(f, j) && (g = !1)
                    }
                    g && c.add(f)
                }
            }
            return c
        },
        isDescendantOfGroup: function(a, b) {
            if (! (a && b instanceof Md)) return ! 1;
            if (!b.hasChildren()) return ! 1;
            for (a = a._parent; a instanceof Md;) {
                if (a === b) return ! 0;
                a = a._parent
            }
            return ! 1
        }
    };
    Jb.element = vc;
    var wc = {
        between: function(a, b, c) {
            return c >= a && b >= c ? !0 : c >= b && a >= c ? !0 : !1
        },
        considerEast: function(a, b, c) {
            return b ? wc.between(b.x, c.x, a.x) ? c.x > b.x: Math.abs(b.x - a.x) > Math.abs(c.x - a.x) : !0
        },
        considerWest: function(a, b, c) {
            return b ? wc.between(b.x, c.x, a.x) ? c.x < b.x: Math.abs(b.x - a.x) > Math.abs(c.x - a.x) : !0
        },
        considerNorth: function(a, b, c) {
            return b ? wc.between(b.y, c.y, a.y) ? c.y < b.y: Math.abs(b.y - a.y) > Math.abs(c.y - a.y) : !0
        },
        considerSouth: function(a, b, c) {
            return b ? wc.between(b.y, c.y, a.y) ? c.y > b.y: Math.abs(b.y - a.y) > Math.abs(c.y - a.y) : !0
        },
        getHorizontalPoint: function(a, b, c) {
            return wc.between(b.x, c.x, a.x) ? {
                x: a.x,
                y: b.y
            }: Math.abs(a.x - b.x) < Math.abs(a.x - c.x) ? {
                x: b.x,
                y: b.y
            }: {
                x: c.x,
                y: c.y
            }
        },
        getVerticalPoint: function(a, b, c) {
            return wc.between(b.y, c.y, a.y) ? {
                x: b.x,
                y: a.y
            }: Math.abs(a.y - b.y) < Math.abs(a.y - c.y) ? {
                x: b.x,
                y: b.y
            }: {
                x: c.x,
                y: c.y
            }
        },
        getPoint: function(a, b, c, d, e) {
            var f = Math.abs(d.x - c.x) > Math.abs(d.y - c.y);
            if ("south" === e) return f && wc.considerSouth(b, a, c) ? wc.getHorizontalPoint(b, c, d) : null;
            if ("north" === e) return f && wc.considerNorth(b, a, c) ? wc.getHorizontalPoint(b, c, d) : null;
            if ("west" === e) return ! f && wc.considerWest(b, a, c) ? wc.getVerticalPoint(b, c, d) : null;
            if ("east" === e) return ! f && wc.considerEast(b, a, c) ? wc.getVerticalPoint(b, c, d) : null;
            if ("nearby" === e) {
                var g;
                return g = f ? wc.getHorizontalPoint(b, c, d) : wc.getVerticalPoint(b, c, d),
                !a || Tb.getDistance(a, b) > Tb.getDistance(g, b) ? g: null
            }
            return null
        },
        getBusPoint: function(a, b, c) {
            var d, e = a.size();
            if (e > 0) {
                for (var f = a.get(0), g = 1; e > g; g++) {
                    var h = a.get(g),
                    i = wc.getPoint(d, b, f, h, c);
                    i && (d = i),
                    f = h
                }
                d || (d = {
                    x: f.x,
                    y: f.y
                })
            }
            return d
        }
    };
    Jb.bus = wc;
    var xc = {
        createFromPoint: function(a, b) {
            var c = a._element;
            if (!c.getFromAgent()) return {
                x: 0,
                y: 0
            };
            var d, e = c.getStyle("link.from.position"),
            f = c.getStyle("link.from.xoffset"),
            g = c.getStyle("link.from.yoffset");
            if (a._network._edgeDetect) {
                var h = c.getFromAgent(),
                i = c.getToAgent(),
                j = h.getImage(),
                k = Jb.images[j],
                l = h.getCenterLocation(),
                m = i.getCenterLocation(),
                n = this._getPointAngleDegree(m.x, m.y, l.x, l.y),
                o = {
                    x: 0,
                    y: 0
                };
                if (k) {
                    var p = k._image;
                    if (p && cd(p) || p && Ib.Util.getImageAsset(j)._cache) return cd(p) ? k._edgeData || (k._edgeData = k._createEdgeData(p)) : "object" == typeof p && (k._edgeData || (k._edgeData = k._createEdgeData(Ib.Util.getImageAsset(j)._cache))),
                    o.x = k._edgeData[n].x + h.getRect().x,
                    o.y = k._edgeData[n].y + h.getRect().y,
                    o
                }
            }
            if (!Jb.isCalculatingBus) {
                if (Jb.isCalculatingBus = !0, c.getFromAgent() instanceof Ib.Bus) {
                    var q = c.getFromAgent();
                    if (vc.hasVector(q)) {
                        var r = b ? b._getElementZoomRect(a, q.getRect()) : q.getRect(),
                        s = q.getStyle("vector.shape");
                        if ("oval" === s) d = Tb.getEllipsePoint(r, xc.createToPoint(a));
                        else if ("circle" === s) d = Tb.getEllipsePoint(Tb.getCircleRect(r), xc.createToPoint(a));
                        else if ("rectangle" === s || "roundrect" === s) {
                            var t = new nd;
                            t.add({
                                x: q.x,
                                y: q.y
                            }),
                            t.add({
                                x: q.x + q.width,
                                y: q.y
                            }),
                            t.add({
                                x: q.x + q.width,
                                y: q.y + q.height
                            }),
                            t.add({
                                x: q.x,
                                y: q.y + q.height
                            }),
                            t.add({
                                x: q.x,
                                y: q.y
                            }),
                            t = b ? b._getShapeNodeZoomPoints(a, t) : t,
                            d = wc.getBusPoint(t, xc.createToPoint(a), q.getStyle("bus.style"))
                        }
                    } else {
                        var t = b ? b._getShapeNodeZoomPoints(a, q.getPoints()) : q.getPoints();
                        d = wc.getBusPoint(t, xc.createToPoint(a), q.getStyle("bus.style"))
                    }
                }
                Jb.isCalculatingBus = !1
            }
            return d ? (d.x += f, d.y += g) : d = a._network.getPosition(e, c.getFromAgent(), null, f, g, !0),
            d
        },
        createToPoint: function(a, b) {
            var c = a._element;
            if (!c.getToAgent()) return {
                x: 0,
                y: 0
            };
            var d, e = c.getStyle("link.to.position"),
            f = c.getStyle("link.to.xoffset"),
            g = c.getStyle("link.to.yoffset");
            if (a._network._edgeDetect) {
                var h = c.getFromAgent(),
                i = c.getToAgent(),
                j = i.getImage(),
                k = Jb.images[j],
                l = h.getLocation(),
                m = i.getCenterLocation(),
                n = this._getPointAngleDegree(l.x, l.y, m.x, m.y),
                o = {
                    x: 0,
                    y: 0
                };
                if (k) {
                    var p = k._image;
                    if (p && cd(p) || p && Ib.Util.getImageAsset(j)._cache) return cd(p) ? k._edgeData || (k._edgeData = k._createEdgeData(p)) : "object" == typeof p && (k._edgeData || (k._edgeData = k._createEdgeData(Ib.Util.getImageAsset(j)._cache))),
                    o.x = k._edgeData[n].x + i.getRect().x,
                    o.y = k._edgeData[n].y + i.getRect().y,
                    o
                }
            }
            if (!Jb.isCalculatingBus) {
                if (Jb.isCalculatingBus = !0, c.getToAgent() instanceof Ib.Bus) {
                    var q = c.getToAgent();
                    if (vc.hasVector(q)) {
                        var r = b ? b._getElementZoomRect(a, q.getRect()) : q.getRect(),
                        s = q.getStyle("vector.shape");
                        if ("oval" === s) d = Tb.getEllipsePoint(r, xc.createFromPoint(a));
                        else if ("circle" === s) d = Tb.getEllipsePoint(Tb.getCircleRect(r), xc.createFromPoint(a));
                        else if ("rectangle" === s || "roundrect" === s) {
                            var t = new nd;
                            t.add({
                                x: q.x,
                                y: q.y
                            }),
                            t.add({
                                x: q.x + q.width,
                                y: q.y
                            }),
                            t.add({
                                x: q.x + q.width,
                                y: q.y + q.height
                            }),
                            t.add({
                                x: q.x,
                                y: q.y + q.height
                            }),
                            t.add({
                                x: q.x,
                                y: q.y
                            }),
                            t = b ? b._getShapeNodeZoomPoints(a, t) : t,
                            d = wc.getBusPoint(t, xc.createFromPoint(a), q.getStyle("bus.style"))
                        }
                    } else {
                        var t = b ? b._getShapeNodeZoomPoints(a, q.getPoints()) : q.getPoints();
                        d = wc.getBusPoint(t, xc.createFromPoint(a), q.getStyle("bus.style"))
                    }
                }
                Jb.isCalculatingBus = !1
            }
            return d ? (d.x += f, d.y += g) : d = a._network.getPosition(e, c.getToAgent(), null, f, g, !0),
            d
        },
        fillLoopedPoints: function(a, b, c) {
            var d, e = xc.getBundleGap(a, !0),
            f = e,
            g = a.getStyle("link.looped.type"),
            h = a.getStyle("link.looped.direction");
            if ("north" === h) return "arc" === g ? xc.drawArc(b.x + b.width / 2, b.y, 0, Math.PI, e, e, !1, c) : (d = {
                x: b.x + b.width / 2,
                y: b.y
            },
            c.add({
                x: d.x + f,
                y: d.y
            }), c.add({
                x: d.x + f,
                y: d.y - e
            }), c.add({
                x: d.x - f,
                y: d.y - e
            }), c.add({
                x: d.x - f,
                y: d.y
            })),
            {
                x: b.x + b.width / 2,
                y: b.y - e
            };
            if ("northeast" === h) return "arc" === g ? xc.drawArc(b.x + b.width, b.y, 1.5 * Math.PI, 1.5 * Math.PI, e, e, !1, c) : (d = {
                x: b.x + b.width,
                y: b.y
            },
            c.add({
                x: d.x,
                y: d.y + f
            }), c.add({
                x: d.x + f,
                y: d.y + f
            }), c.add({
                x: d.x + f,
                y: d.y - e
            }), c.add({
                x: d.x - f,
                y: d.y - e
            }), c.add({
                x: d.x - f,
                y: d.y
            })),
            {
                x: b.x + b.width + .707 * e,
                y: b.y - .707 * e
            };
            if ("east" === h) return "arc" === g ? xc.drawArc(b.x + b.width, b.y + b.height / 2, 1.5 * Math.PI, Math.PI, e, e, !1, c) : (d = {
                x: b.x + b.width,
                y: b.y + b.height / 2
            },
            c.add({
                x: d.x,
                y: d.y - f
            }), c.add({
                x: d.x + e,
                y: d.y - f
            }), c.add({
                x: d.x + e,
                y: d.y + f
            }), c.add({
                x: d.x,
                y: d.y + f
            })),
            {
                x: b.x + b.width + e,
                y: b.y + b.height / 2
            };
            if ("southeast" === h) return "arc" === g ? xc.drawArc(b.x + b.width, b.y + b.height, Math.PI, 1.5 * Math.PI, e, e, !1, c) : (d = {
                x: b.x + b.width,
                y: b.y + b.height
            },
            c.add({
                x: d.x,
                y: d.y - f
            }), c.add({
                x: d.x + f,
                y: d.y - f
            }), c.add({
                x: d.x + f,
                y: d.y + e
            }), c.add({
                x: d.x - f,
                y: d.y + e
            }), c.add({
                x: d.x - f,
                y: d.y
            })),
            {
                x: b.x + b.width + .707 * e,
                y: b.y + b.height + .707 * e
            };
            if ("south" === h) return "arc" === g ? xc.drawArc(b.x + b.width / 2, b.y + b.height, Math.PI, Math.PI, e, e, !1, c) : (d = {
                x: b.x + b.width / 2,
                y: b.y + b.height
            },
            c.add({
                x: d.x - f,
                y: d.y
            }), c.add({
                x: d.x - f,
                y: d.y + e
            }), c.add({
                x: d.x + f,
                y: d.y + e
            }), c.add({
                x: d.x + f,
                y: d.y
            })),
            {
                x: b.x + b.width / 2,
                y: b.y + b.height + e
            };
            if ("southwest" === h) return "arc" === g ? xc.drawArc(b.x, b.y + b.height, .5 * Math.PI, 1.5 * Math.PI, e, e, !1, c) : (d = {
                x: b.x,
                y: b.y + b.height
            },
            c.add({
                x: d.x,
                y: d.y - f
            }), c.add({
                x: d.x - f,
                y: d.y - f
            }), c.add({
                x: d.x - f,
                y: d.y + e
            }), c.add({
                x: d.x + f,
                y: d.y + e
            }), c.add({
                x: d.x + f,
                y: d.y
            })),
            {
                x: b.x - .707 * e,
                y: b.y + b.height + .707 * e
            };
            if ("west" === h) return "arc" === g ? xc.drawArc(b.x, b.y + b.height / 2, .5 * Math.PI, Math.PI, e, e, !1, c) : (d = {
                x: b.x,
                y: b.y + b.height / 2
            },
            c.add({
                x: d.x,
                y: d.y - f
            }), c.add({
                x: d.x - e,
                y: d.y - f
            }), c.add({
                x: d.x - e,
                y: d.y + f
            }), c.add({
                x: d.x,
                y: d.y + f
            })),
            {
                x: b.x - e,
                y: b.y + b.height / 2
            };
            if ("northwest" === h) return "arc" === g ? xc.drawArc(b.x, b.y, 0, 1.5 * Math.PI, e, e, !1, c) : (d = {
                x: b.x,
                y: b.y
            },
            c.add({
                x: d.x,
                y: d.y + f
            }), c.add({
                x: d.x - f,
                y: d.y + f
            }), c.add({
                x: d.x - f,
                y: d.y - e
            }), c.add({
                x: d.x + f,
                y: d.y - e
            }), c.add({
                x: d.x + f,
                y: d.y
            })),
            {
                x: b.x - .707 * e,
                y: b.y - .707 * e
            };
            throw "Can not resolve link looped direction '" + h + "'"
        },
        drawArc: function(a, b, c, d, e, f, g, h) {
            var i, j, k, l, m, n, o, p, q, r, s;
            if (Math.abs(d) > 2 * Math.PI && (d = 2 * Math.PI), m = Math.ceil(Math.abs(d) / (Math.PI / 4)), i = d / m, j = -i, k = -c, m > 0) {
                n = a + Math.cos(c) * e,
                o = b + Math.sin( - c) * f,
                h.add({
                    x: n,
                    y: o
                });
                for (var t = 0; m > t; t++) {
                    k += j,
                    l = k - j / 2,
                    p = a + Math.cos(k) * e,
                    q = b + Math.sin(k) * f,
                    r = a + Math.cos(l) * (e / Math.cos(j / 2)),
                    s = b + Math.sin(l) * (f / Math.cos(j / 2));
                    var u = new nd;
                    u.add({
                        x: r,
                        y: s
                    }),
                    u.add({
                        x: p,
                        y: q
                    }),
                    h.add(u)
                }
            }
        },
        fillBundlePoints: function(a, c, d, e, f, g) {
            var h;
            if (a._element.getBundleCount(), a._element.getBundleIndex(), a.getStyle("link.bundle.expanded"), "parallel" !== c && 0 === (h = xc.getBundleGap(a, !1))) return f.add(d),
            f.add(e),
            Tb.getCenterPoint(d, e);
            h === b && (h = xc.getBundleGap(a, !1));
            var i = xc.getBundleOffset(a),
            j = Tb.getDistance(d, e);
            if (g) {
                var k = g.getSizeZoom();
                i *= k,
                h *= k
            } ("arc" === c || "triangle" === c) && f.add({
                x: 0,
                y: 0
            }),
            "arc" === c && f.add({
                x: 0,
                y: h
            }),
            f.add({
                x: i,
                y: h
            }),
            f.add({
                x: j - i,
                y: h
            }),
            "arc" === c && f.add({
                x: j,
                y: h
            }),
            ("arc" === c || "triangle" === c) && f.add({
                x: j,
                y: 0
            });
            for (var l = Math.atan2(e.y - d.y, e.x - d.x), m = Tb.createMatrix(l, 0, 0), n = 0, o = f.size(); o > n; n++) {
                var p = f.get(n);
                p = m.transform(p),
                p.x += d.x,
                p.y += d.y,
                f.set(n, p)
            }
            if ("arc" === c) {
                var q = Tb.getCenterPoint(f.get(2), f.get(3)),
                r = new nd;
                return r.add(f.get(1)),
                r.add(f.get(2)),
                f.set(1, r),
                r = new nd,
                r.add(f.get(4)),
                r.add(f.get(5)),
                f.set(4, r),
                f.removeAt(5),
                f.removeAt(2),
                q
            }
            return xc.calculateCenterPoint(f)
        },
        calculateCenterPoint: function(a) {
            var b = a.size();
            if (null == a || 1 > b) return {
                x: 0,
                y: 0
            };
            if (b % 2 === 0) {
                var c = b / 2,
                d = a.get(c - 1),
                e = a.get(c);
                return {
                    x: (d.x + e.x) / 2,
                    y: (d.y + e.y) / 2
                }
            }
            return a.get((b - 1) / 2)
        },
        getBundleOffset: function(a) {
            var b = Tb.getDistance(a.getFromPoint(), a.getToPoint()),
            c = a.getStyle("link.bundle.offset");
            return b > 2 * c ? c: b / 2
        },
        getBundleGap: function(a, b) {
            var c = a._element;
            if (!c.getBundleLinks()) return b ? c.getStyle("link.looped.gap") : 0;
            for (var d = b ? "link.looped.gap": "link.bundle.gap", e = null, f = 0, g = 0, h = c.getBundleLinks().getSiblings(), i = 0, j = c.getStyle("link.bundle.independent"), k = c.getStyle("link.bundle.group.gap"), l = 0, m = h.size(); m > l; l++) {
                var n = h.get(l);
                if (!j || n === c.getBundleLinks()) {
                    for (var o = 0,
                    p = n.getLinks().size(); p > o; o++) {
                        var q = n.getLinks().get(o);
                        if (j === q.getStyle("link.bundle.independent") && a._network.isVisible(q)) {
                            if (null == e) e = q,
                            i = q.getStyle(d);
                            else {
                                var r = q.getStyle(d);
                                g += i / 2 + r / 2,
                                i = r
                            }
                            q === c && (f = g + k / 2)
                        }
                    }
                    g += k
                }
            }
            if (b) return g - f + i;
            var s = f - g / 2;
            return null != e && c.getFromAgent() !== e.getFromAgent() && (s = -s),
            s
        },
        isTargetPriority: function(a, b, c) {
            if (a) {
                if (b.height < c.height) return b.height + c.height < Math.max(b.y + b.height, c.y + c.height) - Math.min(b.y, c.y) + b.height / 2
            } else if (b.width < c.width) return b.width + c.width < Math.max(b.x + b.width, c.x + c.width) - Math.min(b.x, c.x) + b.width / 2;
            return ! 0
        },
        calculateOrthogonalAndFlexionalLinkPoints: function(a, b, c, d) {
            var e = xc.isHorizontal(a, b, c, d),
            f = new nd;
            if (xc.isFlexionalTypeLink(a)) xc.flexional(e, b, c, f, d.getStyle("link.extend"));
            else {
                xc.orthogonal(a, b, c, f, e, d);
                var g = xc.isSplitByPercent(a, d),
                h = g ? xc.calculateSplitValueByPercent(a, e, b, c, d.getStyle("link.split.percent")) : d.getStyle("link.split.value");
                0 === h && (e = !e)
            }
            var i;
            0 === f.size() ? xc.isTargetPriority(e, b, c) ? (i = {
                x: c.x + c.width / 2,
                y: c.y + c.height / 2
            },
            f.add(xc.rectanglePerimeter(b, !0, i)), f.add(xc.rectanglePerimeter(c, !1, f.get(f.size() - 1)))) : (i = {
                x: b.x + b.width / 2,
                y: b.y + b.height / 2
            },
            i = xc.rectanglePerimeter(c, !1, i), f.add(xc.rectanglePerimeter(b, !0, i)), f.add(i)) : (i = f.get(0), f.add(xc.rectanglePerimeter(b, !0, i), 0), f.add(xc.rectanglePerimeter(c, !1, f.get(f.size() - 1))));
            var j = f.size();
            if (2 > j) return f;
            for (var k = f.get(0), l = 1; j - 1 > l; l++) {
                var m = f.get(l);
                m.x === k.x && m.y === k.y && (f.remove(m), j--, l--),
                k = m
            }
            return f
        },
        isHorizontal: function(a, b, c, d) {
            if (a) {
                if ("flexional.horizontal" === a || "orthogonal.horizontal" === a || "orthogonal.H.V" === a || "extend.left" === a || "extend.right" === a) return ! 0;
                if ("flexional.vertical" === a || "orthogonal.vertical" === a || "orthogonal.V.H" === a || "extend.top" === a || "extend.bottom" === a) return ! 1
            }
            var e = xc.calculateXGap(b, c),
            f = xc.calculateYGap(b, c);
            return e >= f
        },
        flexional: function(a, b, c, d, e) {
            a ? xc.flexionalHorizontal(b, c, d, e) : xc.flexionalVertical(b, c, d, e)
        },
        isSplitByPercent: function(a, b) {
            return b.getStyle("link.split.by.percent")
        },
        isExtendTypeLink: function(a) {
            return a && ("extend.top" === a || "extend.left" === a || "extend.bottom" === a || "extend.right" === a)
        },
        isFlexionalTypeLink: function(a) {
            return a && ("flexional" === a || "flexional.horizontal" === a || "flexional.vertical" === a)
        },
        calculateControlPoint: function(a, b, c, d, e) {
            if ("orthogonal.H.V" === a || "orthogonal.V.H" === a) return {
                x: d.x + d.width / 2,
                y: d.y + d.height / 2
            };
            var f;
            if (xc.isExtendTypeLink(a)) {
                var g = Math.min(c.y, d.y),
                h = Math.min(c.x, d.x),
                i = Math.max(c.y + c.height, d.y + d.height),
                j = Math.max(c.x + c.width, d.x + d.width);
                if (f = e.getStyle("link.extend"), "extend.top" === a) return {
                    x: (h + j) / 2,
                    y: g - f
                };
                if ("extend.left" === a) return {
                    x: h - f,
                    y: (g + i) / 2
                };
                if ("extend.bottom" === a) return {
                    x: (h + j) / 2,
                    y: i + f
                };
                if ("extend.right" === a) return {
                    x: j + f,
                    y: (g + i) / 2
                }
            }
            var k = xc.isSplitByPercent(a, e);
            if (f = k ? xc.calculateSplitValueByPercent(a, b, c, d, e.getStyle("link.split.percent")) : e.getStyle("link.split.value"), f === Number.NEGATIVE_INFINITY || f === Number.POSITIVE_INFINITY) return {
                x: d.x + d.width / 2,
                y: d.y + d.height / 2
            };
            if (0 === f) return {
                x: c.x + c.width / 2,
                y: c.y + c.height / 2
            };
            if (b) {
                var l = c.x + c.x + c.width < d.x + d.x + d.width;
                return {
                    x: xc.calculateSplitLocation(l, f, c.x, c.width),
                    y: c.y + c.height / 2
                }
            }
            var m = c.y + c.y + c.height < d.y + d.y + d.height;
            return {
                x: c.x + c.width / 2,
                y: xc.calculateSplitLocation(m, f, c.y, c.height)
            }
        },
        calculateGap: function(a, b, c, d) {
            var e = Math.max(b, d) - Math.min(a, c);
            return e - (b - a + d - c)
        },
        calculateXGap: function(a, b) {
            var c = Math.max(a.x + a.width, b.x + b.width) - Math.min(a.x, b.x);
            return c - a.width - b.width
        },
        calculateYGap: function(a, b) {
            var c = Math.max(a.y + a.height, b.y + b.height) - Math.min(a.y, b.y);
            return c - a.height - b.height
        },
        calculateSplitValueByPercent: function(a, b, c, d, e) {
            var f = xc.calculateSplitGapByPercent(e, b, c, d);
            return f * e
        },
        calculateSplitGapByPercent: function(a, b, c, d, e) {
            return b ? xc._calculateSplitGapByPercent(a, c.x, c.x + c.width, d.x, d.x + d.width) : xc._calculateSplitGapByPercent(a, c.y, c.y + c.height, d.y, d.y + d.height)
        },
        _calculateSplitGapByPercent: function(a, b, c, d, e) {
            var f = xc.calculateGap(b, c, d, e),
            g = d + e > b + c;
            if (f > 0) {
                if (1 === a) return f + (e - d) / 2;
                if (a >= 0 && 1 > a) return f;
                if (0 > a) return g ? d - b: c - e
            }
            return Math.abs(g && a > 0 || !g && 0 > a ? c - e: b - d)
        },
        calculateSplitPercentByControlPoint: function(a, b, c, d) {
            return b ? xc.calculateSplitPercent(a.x, c.x, c.x + c.width, d.x, d.x + d.width) : xc.calculateSplitPercent(a.y, c.y, c.y + c.height, d.y, d.y + d.height)
        },
        calculateSplitPercent: function(a, b, c, d, e) {
            if (a >= b && c >= a) return 0;
            var f = xc.calculateGap(b, c, d, e);
            if (f > 0 && a >= d && e >= a) return 1;
            var g = d + e > b + c;
            if (f > 0) {
                if (a > Math.min(c, e) && a < Math.max(b, d)) return Math.abs(a - (g ? c: b)) / f;
                if (g) {
                    if (b > a) return (a - b) / (d - b)
                } else if (a > c) return (c - a) / (c - e)
            }
            return a > c ? (g ? a - c: c - a) / Math.abs(c - e) : (g ? a - b: b - a) / Math.abs(b - d)
        },
        calculateSplitLocation: function(a, b, c, d) {
            return a === b > 0 ? c + d + Math.abs(b) : c - Math.abs(b)
        },
        calculateAngle: function(a, b) {
            if (0 !== a && 0 !== b) return Math.atan2(a, b);
            if (0 === a) {
                if (b > 0) return 0;
                if (0 > b) return Math.PI
            }
            return a > 0 ? Math.PI / 2 : -Math.PI / 2
        },
        drawCorner: function(a, b) {
            var c = a.size();
            if (! (3 > c)) {
                var d = b.getStyle("link.corner");
                if ("none" !== d) {
                    for (var e, f, g, h, i = b.getStyle("link.xradius"), j = b.getStyle("link.yradius"), k = a.get(0), l = a.get(1), m = 2; c > m; m++) {
                        var n = a.get(m),
                        o = l.x - k.x,
                        p = l.y - k.y,
                        q = n.x - l.x,
                        r = n.y - l.y,
                        s = 0 === p;
                        if (0 === o && 0 === r || 0 === p && 0 === q) if (s ? (e = Math.min(2 === m ? Math.abs(o) : Math.abs(o) / 2, i), f = Math.min(m === c - 1 ? Math.abs(r) : Math.abs(r) / 2, j), g = {
                            x: l.x - (o > 0 ? e: -e),
                            y: l.y
                        },
                        h = {
                            x: l.x,
                            y: l.y + (r > 0 ? f: -f)
                        }) : (e = Math.min(m === c - 1 ? Math.abs(q) : Math.abs(q) / 2, i), f = Math.min(2 === m ? Math.abs(p) : Math.abs(p) / 2, j), g = {
                            x: l.x,
                            y: l.y - (p > 0 ? f: -f)
                        },
                        h = {
                            x: l.x + (q > 0 ? e: -e),
                            y: l.y
                        }), a.remove(l), m--, c--, (g.x !== k.x || g.y !== k.y) && (a.add(g, m), m++, c++), "bevel" === d) a.add(h, m),
                        m++,
                        c++;
                        else if ("round" === d) {
                            var t = new nd;
                            t.add(l),
                            t.add(h),
                            a.add(t, m),
                            m++,
                            c++
                        }
                        k = l,
                        l = n
                    }
                    h && h.x === l.x && h.y === l.y && a.remove(l)
                }
            }
        },
        orthogonal: function(a, b, c, d, e, f) {
            var g = f.getStyle("link.control.point"),
            h = null == g;
            if (g) {
                var i = Tb.unionRect(b, c);
                Tb.containsPoint(i, g) || (e = xc.calculateIsHorizontalByControlPoint(g.x, g.y, i.y, i.x, i.y + i.height, i.x + i.width))
            } else g = xc.calculateControlPoint(a, e, b, c, f);
            e ? xc.sideToSide(b, c, g, d, h) : xc.topToBottom(b, c, g, d, h)
        },
        calculateIsHorizontalByControlPoint: function(a, b, c, d, e, f) {
            return c > b && c - b > d - a && c - b > a - f || b > e && b - e > d - a && b - e > a - f ? !1 : !0
        },
        contains: function(a, b, c) {
            return b >= a.x && b <= a.x + a.width && c >= a.y && c <= a.y + a.height
        },
        topToBottom: function(a, b, c, d, e) {
            var f = Math.max(a.y, b.y),
            g = Math.min(a.y + a.height, b.y + b.height),
            h = c ? c.y: g + (f - g) / 2,
            i = a.x + a.width / 2,
            j = b.x + b.width / 2;
            if (!e && c && (c.x >= a.x && c.x <= a.x + a.width && (i = c.x), c.x >= b.x && c.x <= b.x + b.width && (j = c.x)), xc.contains(b, i, h) || xc.contains(a, i, h) || d.add({
                x: i,
                y: h
            }), xc.contains(b, j, h) || xc.contains(a, j, h) || d.add({
                x: j,
                y: h
            }), 0 === d.size()) if (c) xc.contains(b, c.x, h) || xc.contains(a, c.x, h) || d.add({
                x: c.x,
                y: h
            });
            else {
                var k = Math.max(a.x, b.x),
                l = Math.min(a.x + a.width, b.x + b.width);
                d.add({
                    x: k + (l - k) / 2,
                    y: h
                })
            }
        },
        sideToSide: function(a, b, c, d, e) {
            var f = Math.max(a.x, b.x),
            g = Math.min(a.x + a.width, b.x + b.width),
            h = c ? c.x: g + (f - g) / 2,
            i = a.y + a.height / 2,
            j = b.y + b.height / 2;
            if (!e && c && (c.y >= a.y && c.y <= a.y + a.height && (i = c.y), c.y >= b.y && c.y <= b.y + b.height && (j = c.y)), xc.contains(b, h, i) || xc.contains(a, h, i) || d.add({
                x: h,
                y: i
            }), xc.contains(b, h, j) || xc.contains(a, h, j) || d.add({
                x: h,
                y: j
            }), 0 === d.size()) if (c) xc.contains(b, h, c.y) || xc.contains(a, h, c.y) || d.add({
                x: h,
                y: c.y
            });
            else {
                var k = Math.max(a.y, b.y),
                l = Math.min(a.y + a.height, b.y + b.height);
                d.add({
                    x: h,
                    y: k + (l - k) / 2
                })
            }
        },
        flexionalHorizontal: function(a, b, c, d) {
            var e = b.x + b.width < a.x,
            f = a.x + a.width < b.x,
            g = e ? a.x: a.x + a.width,
            h = a.y + a.height / 2,
            i = f ? b.x: b.x + b.width,
            j = b.y + b.height / 2,
            k = d,
            l = e ? -k: k,
            m = {
                x: g + l,
                y: h
            };
            l = f ? -k: k;
            var n = {
                x: i + l,
                y: j
            };
            if (e === f) {
                var o = e ? Math.min(g, i) - d: Math.max(g, i) + d;
                c.add({
                    x: o,
                    y: h
                }),
                c.add({
                    x: o,
                    y: j
                })
            } else if (m.x < n.x === e) {
                var p = h + (j - h) / 2;
                c.add(m),
                c.add({
                    x: m.x,
                    y: p
                }),
                c.add({
                    x: n.x,
                    y: p
                }),
                c.add(n)
            } else c.add(m),
            c.add(n)
        },
        flexionalVertical: function(a, b, c, d) {
            var e = b.y + b.height < a.y,
            f = a.y + a.height < b.y,
            g = a.x + a.width / 2,
            h = e ? a.y: a.y + a.height,
            i = b.x + b.width / 2,
            j = f ? b.y: b.y + b.height,
            k = d,
            l = e ? -k: k,
            m = {
                x: g,
                y: h + l
            };
            l = f ? -k: k;
            var n = {
                x: i,
                y: j + l
            };
            if (e === f) {
                var o = e ? Math.min(h, j) - d: Math.max(h, j) + d;
                c.add({
                    x: g,
                    y: o
                }),
                c.add({
                    x: i,
                    y: o
                })
            } else if (m.y < n.y === e) {
                var p = g + (i - g) / 2;
                c.add(m),
                c.add({
                    x: p,
                    y: m.y
                }),
                c.add({
                    x: p,
                    y: n.y
                }),
                c.add(n)
            } else c.add(m),
            c.add(n)
        },
        rectanglePerimeter: function(a, b, c) {
            var d = a.x + a.width / 2,
            e = a.y + a.height / 2,
            f = c.x - d,
            g = c.y - e,
            h = Math.atan2(g, f),
            i = {
                x: 0,
                y: 0
            },
            j = Math.PI,
            k = Math.PI / 2,
            l = k - h,
            m = Math.atan2(a.height, a.width);
            return - j + m > h || h > j - m ? (i.x = a.x, i.y = e - a.width * Math.tan(h) / 2) : -m > h ? (i.y = a.y, i.x = d - a.height * Math.tan(l) / 2) : m > h ? (i.x = a.x + a.width, i.y = e + a.width * Math.tan(h) / 2) : (i.y = a.y + a.height, i.x = d + a.height * Math.tan(l) / 2),
            c.x >= a.x && c.x <= a.x + a.width ? i.x = c.x: c.y >= a.y && c.y <= a.y + a.height && (i.y = c.y),
            c.x < a.x ? i.x = a.x: c.x > a.x + a.width && (i.x = a.x + a.width),
            c.y < a.y ? i.y = a.y: c.y > a.y + a.height && (i.y = a.y + a.height),
            i
        },
        isSplitTypeLink: function(a) {
            return a && ("orthogonal" === a || "orthogonal.horizontal" === a || "orthogonal.vertical" === a)
        },
        isOrthogonalOrFlexionalLink: function(a) {
            if (a instanceof Ib.ShapeLink) return ! 1;
            if (a.isLooped()) return ! 1;
            var b = a.getStyle("link.type");
            return xc.isOrthogonalOrFlexionalType(b)
        },
        isOrthogonalLink: function(a) {
            if (a instanceof Ib.ShapeLink) return ! 1;
            if (a.isLooped()) return ! 1;
            var b = a.getStyle("link.type");
            return xc.isOrthogonalType(b)
        },
        isOrthogonalOrFlexionalType: function(a) {
            return "orthogonal" === a || "orthogonal.horizontal" === a || "orthogonal.H.V" === a || "orthogonal.vertical" === a || "orthogonal.V.H" === a || "extend.top" === a || "extend.left" === a || "extend.bottom" === a || "extend.right" === a || "flexional" === a || "flexional.horizontal" === a || "flexional.vertical" === a
        },
        isOrthogonalType: function(a) {
            return "orthogonal" === a || "orthogonal.horizontal" === a || "orthogonal.H.V" === a || "orthogonal.vertical" === a || "orthogonal.V.H" === a || "extend.top" === a || "extend.left" === a || "extend.bottom" === a || "extend.right" === a
        },
        hasControlPoint: function(a) {
            return "orthogonal" === a || "orthogonal.horizontal" === a || "orthogonal.vertical" === a || "extend.bottom" === a || "extend.left" === a || "extend.right" === a || "extend.top" === a
        },
        getControlPoint: function(a, b, c) {
            if (!a) throw "link can't be null";
            var d = a.getStyle("link.type");
            if (!xc.hasControlPoint(d)) return null;
            var e = a.getStyle("link.control.point");
            if (e) return e;
            var f, g;
            if (null == b ? (f = a.getFromAgent().getRect(), g = a.getToAgent().getRect()) : (f = xc.getLinkSourceBounds(b, c), g = xc.getLinkTargetBounds(b, c)), null == f || null == g) return null;
            var h = xc.isHorizontal(d, f, g, a);
            return xc.calculateControlPoint(a.getStyle("link.type"), h, f, g, a)
        },
        getSplitValueByControlPoint: function(a, b, c, d, e) {
            if ("extend.top" === b) return Math.min(c.y, d.y) - a.y;
            if ("extend.left" === b) return Math.min(c.x, d.x) - a.x;
            if ("extend.bottom" === b) return a.y - Math.max(c.y + c.height, d.y + d.height);
            if ("extend.right" === b) return a.x - Math.max(c.x + c.width, d.x + d.width);
            var f;
            if (e) {
                var g = c.x + c.x + c.width < d.x + d.x + d.width;
                return f = g ? a.x - c.x + c.width: c.x - a.x,
                f > 0 ? f: f > -c.width ? 0 : f + c.width
            }
            var h = c.y + c.y + c.height < d.y + d.y + d.height;
            return f = h ? a.y - c.y - c.height: c.y - a.y,
            f > 0 ? f: f > -c.height ? 0 : f + c.height
        },
        isHorizontalByControlPoint: function(a, b, c, d, e) {
            var f = Tb.unionRect(c, d);
            return Tb.containsPoint(f, a) ? xc.isHorizontal(b, c, d, e) : xc.calculateIsHorizontalByControlPoint(a.x, a.y, f.y, f.x, f.y + f.height, f.x + f.width)
        },
        setParamsByControlPoint: function(a, b, c, d, e) {
            var f = xc.isHorizontalByControlPoint(a, d, b, c, e),
            g = e.getStyle("link.control.point");
            if ((g || "orthogonal" === d || "orthogonal.horizontal" === d || "orthogonal.vertical" === d) && e.setStyle("link.type", f ? "orthogonal.horizontal": "orthogonal.vertical"), g) return void e.setStyle("link.control.point", a);
            var h = xc.getSplitValueByControlPoint(a, d, b, c, f);
            if (xc.isExtendTypeLink(d)) return void e.setStyle("link.extend", h);
            var i = xc.isSplitByPercent(d, e);
            return i ? 0 === h ? void e.setStyle("link.split.percent", 0) : void e.setStyle("link.split.percent", xc.calculateSplitPercentByControlPoint(a, f, b, c)) : void e.setStyle("link.split.value", h)
        },
        getLinkNodeBounds: function(a, b, c, d, e, f) {
            if (f) {
                var g = f.getLocationZoom();
                f.getSizeZoom(a)
            }
            if (null == a) return null;
            var h;
            if (d) f ? (h = a.getZoomBodyRect(), h.x += b, h.y += c) : (h = a.getBodyRect(), h.x += b, h.y += c);
            else {
                var i = a.getNetwork().getPosition(e, a, null, b, c);
                h = f ? {
                    x: i.x * g,
                    y: i.y * g,
                    width: 1,
                    height: 1
                }: {
                    x: i.x,
                    y: i.y,
                    width: 1,
                    height: 1
                }
            }
            return h
        },
        getLinkSourceBounds: function(a, b) {
            var c = a._element,
            d = a.getNetwork().getElementUI(c.getFromAgent());
            if (null == d) return null;
            var e = c.getStyle("link.from.position"),
            f = c.getStyle("link.from.xoffset"),
            g = c.getStyle("link.from.yoffset"),
            h = c.getStyle("link.from.at.edge");
            return xc.getLinkNodeBounds(d, f, g, h, e, b)
        },
        getLinkTargetBounds: function(a, b) {
            var c = a._element,
            d = a.getNetwork().getElementUI(c.getToAgent());
            if (null == d) return null;
            var e = c.getStyle("link.to.position"),
            f = c.getStyle("link.to.xoffset"),
            g = c.getStyle("link.to.yoffset"),
            h = c.getStyle("link.to.at.edge");
            return xc.getLinkNodeBounds(d, f, g, h, e, b)
        },
        orthogonalAndFlexional: function(a, b, c) {
            var d = xc.getLinkSourceBounds(a, c);
            if (null == d) return null;
            var e = xc.getLinkTargetBounds(a, c);
            if (null == e) return null;
            var f = xc.calculateOrthogonalAndFlexionalLinkPoints(b, d, e, a._element);
            return xc.offsetLink(a, f),
            a.setHotSpot(xc.calculateCenterPoint(f)),
            "flexional" !== b && xc.drawCorner(f, a._element),
            f
        },
        offsetLink: function(a, b) {
            var c = a._element,
            d = c.isBundleAgent();
            if (!d) {
                var e = xc.getBundleGap(a, !1);
                if (0 !== e) for (var f, g, h = !1,
                i = !1,
                j = b.get(0), k = Jb.clone(j), l = 1, m = b.size(); m > l; l++) {
                    var n = b.get(l),
                    o = n.x - k.x,
                    p = n.y - k.y;
                    k = Jb.clone(n),
                    g = xc.calculateAngle(o, p),
                    0 === o ? ((g - f) % Math.PI === 0 && (g - f) % (2 * Math.PI) !== 0 && (h = !h, h && (p = -p)), (g - f) % Math.PI !== 0 && (j.x += 0 > p ? e: -e), n.x += 0 > p ? e: -e) : 0 === p && ((g - f) % Math.PI === 0 && (g - f) % (2 * Math.PI) !== 0 && (i = !i, i && (o = -o)), f && (g - f) % Math.PI === 0 || (j.y -= 0 > o ? e: -e), n.y -= 0 > o ? e: -e),
                    f = g,
                    j = n
                }
            }
        },
        _getPointAngleDegree: function(a, b, c, d) {
            var e = c - a,
            f = d - b,
            g = Math.atan2(f, e);
            return g = g / Math.PI * 180,
            g = parseInt(g) + 180,
            g %= 360
        }
    };
    Jb.link = xc;
    var yc = {
        findMoveToBottomDatas: function(a, b, c) {
            for (var d = 0; d < c.size(); d++) {
                var e = c.get(d);
                a.contains(e) && b.add(e)
            }
            for (d = 0; d < c.size(); d++) e = c.get(d),
            yc.findMoveToBottomDatas(a, b, e.getChildren())
        },
        findMoveToTopDatas: function(a, b, c) {
            for (var d = 0; d < c.size(); d++) {
                var e = c.get(c.size() - 1 - d);
                a.contains(e) && b.add(e)
            }
            for (d = 0; d < c.size(); d++) e = c.get(d),
            yc.findMoveToTopDatas(a, b, e.getChildren())
        },
        findMoveUpDatas: function(a, b, c) {
            for (var d = !1,
            e = 0; e < c.size(); e++) {
                var f = c.get(e);
                a.contains(f) ? d && b.add(f) : d = !0
            }
            for (e = 0; e < c.size(); e++) f = c.get(e),
            yc.findMoveUpDatas(a, b, f.getChildren())
        },
        findMoveDownDatas: function(a, b, c) {
            for (var d = !1,
            e = 0; e < c.size(); e++) {
                var f = c.get(c.size() - 1 - e);
                a.contains(f) ? d && b.add(f) : d = !0
            }
            for (e = 0; e < c.size(); e++) f = c.get(e),
            yc.findMoveDownDatas(a, b, f.getChildren())
        },
        doLayout: function(a, b) {
            b = b || {},
            b.type = b.type || "round",
            b.animate = b.animate || !0,
            b.elements = b.elements || new Ib.List,
            b.repulsion = b.repulsion || 1,
            b.expandGroup = b.expandGroup || !1;
            var c = new Ib.layout.AutoLayouter(a.getElementBox());
            c.getElements = function() {}
        }
    };
    Jb.box = yc;
    var zc = {
        scrollLeft: function() {
            return zc._filterResults(a.pageXOffset ? a.pageXOffset: 0, Ob.documentElement ? Ob.documentElement.scrollLeft: 0, Ob.body ? Ob.body.scrollLeft: 0)
        },
        scrollTop: function() {
            return zc._filterResults(a.pageYOffset ? a.pageYOffset: 0, Ob.documentElement ? Ob.documentElement.scrollTop: 0, Ob.body ? Ob.body.scrollTop: 0)
        },
        _filterResults: function(a, b, c) {
            var d = a ? a: 0;
            return b && (!d || d > b) && (d = b),
            c && (!d || d > c) ? c: d
        },
        isSingleTouch: function(a) {
            return a.touches && 1 == a.touches.length
        },
        isMultiTouch: function(a) {
            return a.touches && a.touches.length > 1
        },
        getDistance: function(a) {
            if (!zc.isMultiTouch(a)) return 0;
            var b = a.touches[0],
            c = a.touches[1];
            return Math.sqrt(Math.pow(b.clientX - c.clientX, 2) + Math.pow(b.clientY - c.clientY, 2))
        }
    };
    Jb.touch = zc;
    var Ac = {
        _string: function(a, b, c, d) {
            var e = c._stringPool.get();
            e.style.whiteSpace = "nowrap",
            e.style.verticalAlign = "middle",
            e.style.padding = "0px 2px",
            Jb.setText(e, a, d),
            e.setAttribute("title", a),
            b.appendChild(e)
        },
        _boolean: function(a, b, c) {
            var d = c._booleanPool.get();
            b._editInfo ? (d._editInfo = b._editInfo, delete b._editInfo, d.disabled = !1) : d.disabled = !0,
            d.keepDefault = !0,
            d.type = "checkbox",
            d.style.margin = "0px 2px",
            d.style.verticalAlign = "middle",
            d.checked = a,
            b.appendChild(d),
            "" === b.style.textAlign && (b.style.textAlign = "center")
        },
        _color: function(a, b, c) {
            var d = c._colorPool.get();
            d.style.width = "100%",
            d.style.height = "100%",
            d.style.backgroundColor = a,
            d.setAttribute("title", a),
            b.appendChild(d)
        },
        render: function(a, b, c, d, e) {
            if (null != b) {
                var f = Ac["_" + a];
                f ? f(b, c, d, e) : "boolean" == typeof b ? Ac._boolean(b, c, d, e) : Ac._string(b, c, d, e)
            }
        }
    };
    Jb.render = Ac;
    var Bc = {
        toolTipDiv: null,
        getToolTipDiv: function() {
            if (!Bc.toolTipDiv) {
                Bc.toolTipDiv = Ob.createElement("div");
                var a = Dd,
                b = Bc.toolTipDiv.style;
                b.position = "absolute",
                b.color = a.TOOLTIP_COLOR,
                b.background = a.TOOLTIP_BACKGROUND,
                b.fontSize = a.TOOLTIP_FONT_SIZE,
                b.padding = a.TOOLTIP_PADDING,
                b.border = a.TOOLTIP_BORDER,
                b.borderRadius = a.TOOLTIP_BORDER_RADIUS,
                b.boxShadow = a.TOOLTIP_BOX_SHADOW,
                b.zIndex = a.TOOLTIP_ZINDEX,
                b.setProperty && b.setProperty("-webkit-box-shadow", a.TOOLTIP_BOX_SHADOW, null)
            }
            return Bc.toolTipDiv
        },
        isToolTipVisible: function() {
            return Bc.getToolTipDiv().parentNode ? !0 : !1
        },
        hideToolTip: function() {
            if (Bc._clearTimeout(), Bc._clearDismiss(), Bc.isToolTipVisible()) {
                var a = Bc.getToolTipDiv();
                a.parentNode && a.parentNode.removeChild(a)
            }
        },
        showToolTip: function(a, b) {
            return a && b ? void(Bc.isToolTipVisible() || Bc._reshow_timeout ? Bc._showToolTip(a, b) : (Bc._clearTimeout(), Bc._show_timeout = setTimeout(function() {
                Bc._showToolTip(a, b)
            },
            Dd.TOOLTIP_INITIAL_DELAY))) : void Bc.hideToolTip()
        },
        _showToolTip: function(a, b) {
            var c, d, e;
            a.target ? (c = a.clientX, d = a.clientY) : (c = a.x, d = a.y),
            e = Bc.getToolTipDiv(),
            Wb.clear(e),
            b instanceof Element ? e.appendChild(b) : e.innerHTML = b,
            e.style.left = c + Dd.TOOLTIP_XOFFSET + "px",
            e.style.top = d + Dd.TOOLTIP_YOFFSET + "px",
            e.parentNode || Ob.body.appendChild(e),
            Bc._clearDismiss(),
            Bc._dismiss_timeout = setTimeout(Bc.hideToolTip, Dd.TOOLTIP_DISMISS_DELAY),
            Bc._clearReshow(),
            Bc._reshow_timeout = setTimeout(Bc._clearReshow, Dd.TOOLTIP_RESHOW_DELAY)
        },
        _clearDismiss: function() {
            Bc._dismiss_timeout && (clearTimeout(Bc._dismiss_timeout), Bc._dismiss_timeout = null)
        },
        _clearReshow: function() {
            Bc._reshow_timeout && (clearTimeout(Bc._reshow_timeout), Bc._reshow_timeout = null)
        },
        _clearTimeout: function() {
            Bc._show_timeout && (clearTimeout(Bc._show_timeout), Bc._show_timeout = null)
        },
        resetToolTip: function() {
            Bc.hideToolTip(),
            Bc.toolTipDiv = null
        }
    };
    Jb.popup = Bc;
    var Cc = {
        handleClicked: function(a, b, c) {
            if (Qb.isTouchable || 0 === b.button) if (c) {
                var d = Dc(c);
                d && d.onClick && d.onClick(c, a),
                a.onClickElement(c, b),
                a.fireInteractionEvent({
                    kind: "clickElement",
                    event: b,
                    element: c
                })
            } else a.onClickBackground(b),
            a.fireInteractionEvent({
                kind: "clickBackground",
                event: b
            })
        },
        handleDoubleClicked: function(a, b, c) {
            if ((Qb.isTouchable || 0 === b.button) && !a.isEditingElement()) {
                if (c) {
                    var d = Dc(c);
                    d && d.onDoubleClick && d.onDoubleClick(c, a),
                    a.onDoubleClickElement(c, b),
                    a.fireInteractionEvent({
                        kind: "doubleClickElement",
                        event: b,
                        element: c
                    })
                } else a.onDoubleClickBackground(b),
                a.fireInteractionEvent({
                    kind: "doubleClickBackground",
                    event: b
                });
                c ? c instanceof Ib.Link && a.isDoubleClickToLinkBundle() ? c.ISubNetwork && a.isDoubleClickToSubNetwork() && !Jb.isCtrlDown(b) ? (a.isDoubleClickToEmptySubNetwork() || c.getChildrenSize() > 0) && a.setCurrentSubNetwork(c, a.isSubNetworkAnimate(),
                function() {
                    a.fireInteractionEvent({
                        kind: "enterSubNetwork",
                        event: b,
                        element: c
                    })
                }) : c.reverseBundleExpanded() && a.fireInteractionEvent({
                    kind: "bundleLink",
                    event: b,
                    element: c
                }) : c.ISubNetwork && a.isDoubleClickToSubNetwork() ? (a.isDoubleClickToEmptySubNetwork() || c.getChildrenSize() > 0) && a.setCurrentSubNetwork(c, a.isSubNetworkAnimate(),
                function() {
                    a.fireInteractionEvent({
                        kind: "enterSubNetwork",
                        event: b,
                        element: c
                    })
                }) : c instanceof Md && a.isDoubleClickToGroupExpand() && (c.reverseExpanded(), a.fireInteractionEvent({
                    kind: "expandGroup",
                    event: b,
                    element: c
                })) : a.isDoubleClickToUpSubNetwork() && a.upSubNetwork(a.isSubNetworkAnimate(),
                function() {
                    a.fireInteractionEvent({
                        kind: "upSubNetwork",
                        event: b
                    })
                })
            }
        },
        handleKeyDown: function(a, b) {
            Jb.isCtrlDown(b) && 65 == b.keyCode ? (a.isKeyboardSelectEnabled() && a.selectAll().size() > 0 && a.fireInteractionEvent({
                kind: "selectAll"
            }), Wb.preventDefault(b)) : 46 == b.keyCode ? (a.isKeyboardRemoveEnabled() && a.removeSelection() && a.fireInteractionEvent({
                kind: "removeElement"
            }), Wb.preventDefault(b)) : Jb.showVersion(b)
        },
        handleLongClicked: function(a, b, c) {
            if (Qb.isTouchable || 0 === b.button) if (c) {
                var d = Dc(c);
                d && d.onLongClick && d.onLongClick(c, a),
                a.onLongClickElement(c, b),
                a.fireInteractionEvent({
                    kind: "longClickElement",
                    event: b,
                    element: c
                })
            } else a.onLongClickBackground(b),
            a.fireInteractionEvent({
                kind: "longClickBackground",
                event: b
            })
        }
    },
    Dc = function(a) {
        if (a && a._image) {
            if ("object" == typeof a._image) return a._image;
            var b = Jb.getImageAsset(a._image);
            if (b) return b._image
        }
        return null
    };
    Jb.interaction = Cc;
    var Ec = function(a) {
        return a.trim()[0].match(/[mlhvcsqta]/i) ? Kc(a) : Gc(a)
    },
    Fc = {},
    Gc = function(a) {
        var b = Fc[a];
        return b ? b: (Fc[a] = b = [], a.trim().split(" ").forEach(function(a) {
            a = a.split(","),
            b.push(2 === a.length ? {
                x: parseFloat(a[0]),
                y: parseFloat(a[1])
            }: a[0])
        }), b)
    },
    Hc = {},
    Ic = /[mlhvcsqtaz][\d.,\-\s]*/gi,
    Jc = /-?(\d)+(\.(\d)+)?/g,
    Kc = function(a) {
        var b, c = Hc[a];
        return c ? c: (b = a.trim().match(Ic), Hc[a] = c = [], b && b.forEach(function(a) {
            var b, d = a[0],
            e = a.match(Jc),
            f = e && e.length;
            if (c.push(a = {
                c: d
            }), f) switch (e.forEach(function(a, b) {
                e[b] = parseFloat(a)
            }), d) {
            case "M":
            case "m":
            case "L":
            case "l":
                for (b = 0; f > b; b += 2) 0 !== b && c.push(a = {
                    c: "M" === d || "L" === d ? "L": "l"
                }),
                a.x = e[b],
                a.y = e[b + 1];
                break;
            case "H":
            case "h":
                for (b = 0; f > b; b++) 0 !== b && c.push(a = {
                    c: d
                }),
                a.x = e[b];
                break;
            case "V":
            case "v":
                for (b = 0; f > b; b++) 0 !== b && c.push(a = {
                    c: d
                }),
                a.y = e[b];
                break;
            case "C":
            case "c":
                for (b = 0; f > b; b += 6) 0 !== b && c.push(a = {
                    c: d
                }),
                a.x1 = e[b],
                a.y1 = e[b + 1],
                a.x2 = e[b + 2],
                a.y2 = e[b + 3],
                a.x = e[b + 4],
                a.y = e[b + 5];
                break;
            case "S":
            case "s":
                for (b = 0; f > b; b += 4) 0 !== b && c.push(a = {
                    c: d
                }),
                a.x2 = e[b],
                a.y2 = e[b + 1],
                a.x = e[b + 2],
                a.y = e[b + 3];
                break;
            case "Q":
            case "q":
                for (b = 0; f > b; b += 4) 0 !== b && c.push(a = {
                    c: d
                }),
                a.x1 = e[b],
                a.y1 = e[b + 1],
                a.x = e[b + 2],
                a.y = e[b + 3];
                break;
            case "T":
            case "t":
                for (b = 0; f > b; b += 2) 0 !== b && c.push(a = {
                    c: d
                }),
                a.x = e[b],
                a.y = e[b + 1]
            }
        }), c)
    },
    Lc = function(a, b) {
        var c, d, e, f, g, h, i, j, k, l, m, n, o = a.transform && Mc(a.transform);
        return o && o.length && (c = Sb.identity(), o.forEach(function(a) {
            var b = a[0];
            "matrix" === b ? c.multiply(new Sb(a[1], a[2], a[3], a[4], a[5], a[6])) : "translate" === b ? c.translate(a[1] || 0, a[2] || 0) : "scale" === b ? c.scale(a[1] || 1, a[2] || a[1] || 1) : "rotate" === b ? c.rotate(a[1] || 0, a[2] || 0, a[3] || 0) : "skewX" === b ? c.skew(a[1] || 0, 0) : "skewY" === b && c.skew(0, a[1] || 0);
        })),
        "linear" === a.type ? (f = a.x1 || 0, g = a.y1 || 0, h = a.x2 || 0, i = a.y2 || 0, c && (d = c.transform(f, g), f = d.x, g = d.y, d = c.transform(h, i), h = d.x, i = d.y), e = b.createLinearGradient(f, g, h, i)) : "radial" === a.type && (j = a.fx || 0, k = a.fy || 0, l = a.cx || 0, m = a.cy || 0, n = a.r || 0, null == a.fx && (j = l), null == a.fy && (k = m), e = b.createRadialGradient(j, k, 0, l, m, n)),
        e && a.stop && a.stop.length && a.stop.forEach(function(a) {
            e.addColorStop(parseFloat(a.offset), td(a.color, b._color))
        }),
        e
    },
    Mc = function(a) {
        return a.replace(/[\s\r\t\n]+/gm, " ").trim().replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/).map(function(a) {
            return a.replace(")", "").trim().split(/\s*\(\s*|\s+,?\s*|,\s*/).map(function(a, b) {
                return 0 === b ? a: parseFloat(a)
            })
        })
    },
    Nc = function(a, b, c, d, e, f, g) {
        var h, i, j, k, l = 1;
        "object" != typeof b && (i = b, h = Jb.images[b], b = h && h.getImage()),
        cd(b) ? a.drawImage(h ? h.getImage(c) : b, Math.round(d.x), Math.round(d.y), d.width, d.height) : b && "object" == typeof b && (a._data = e, a._view = f, i ? (j = d.width / (b.w && Yc(e, b, b, "w") || e.getWidth()), k = d.height / (b.h && Yc(e, b, b, "h") || e.getHeight()), f && (l = f.getSizeZoom ? f.getSizeZoom() * f.getGraphicsZoom() : f.getZoom()), !h._cache || Math.max(j * l, k * l) > 1 ? Oc(a, b, c, d, e, f, g) : a.drawImage(c ? h.getImage(c) : h._cache, Math.round(d.x), Math.round(d.y), d.width, d.height)) : Oc(a, b, c, d, e, f, g), a._data = null, a._view = null)
    },
    Oc = function(a, b, c, d, e, f, g) {
        var h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A = e && e.getStyle("image.state");
        if (p = a._vector, w = a._color, q = a._fill, r = a._pattern, s = a._lineWidth, t = a._alpha, u = a._sx, v = a._sy, m = b, Yc(e, m, m, "visible", f) !== !1) {
            for (a._color = c, h = Yc(e, m, m, "v", f), i = h && h.length, y = m.w && Yc(e, m, m, "w") || e.getWidth(), z = m.h && Yc(e, m, m, "h") || e.getHeight(), n = d.width / y, o = d.height / z, g === !0 ? (a._fill = null, a._pattern = null, a._lineWidth = null, a._alpha = null) : (a._sx = n, a._sy = o), a.save(), a.translate(d.x + d.width / 2, d.y + d.height / 2), (1 !== n || 1 !== o) && a.scale(n, o), m.origin && a.translate((m.origin.x - .5) * y, (m.origin.y - .5) * z), a._vector = m, m.clip && (a.beginPath(), m.clip === !0 ? a.rect( - (m.origin ? m.origin.x: .5) * y, -(m.origin ? m.origin.y: .5) * z, y, z) : m.clip.length ? m.clip.forEach(function(b) {
                a.drawShape(b)
            }) : a.drawShape(m.clip), a.clip()), Tc(e, m, m, a, f), j = 0, i = h.length; i > j; j++) l = h[j],
            a._shapeData = l,
            f && (f._shapeDataIndex = j, l.animate && wb(l, m, e, f)),
            x = Yc(e, m, l, "state", f),
            Yc(e, m, l, "visible", f) === !1 || x && !(Array.isArray(x) ? x.indexOf(A) >= 0 : x === A) || (k = Qc[l.shape], k && (a.save(), "vector" === l.shape || "g" === l.shape ? k(a, l, e, f) : Tc(e, m, l, a, f,
            function() {
                k(a, l, e, f)
            }), a.restore())),
            f && (f._shapeDataIndex = null),
            a._shapeData = null;
            a.restore(),
            a._vector = p,
            a._shapeData = null,
            a._color = w,
            a._fill = q,
            a._pattern = r,
            a._lineWidth = s,
            a._alpha = t,
            a._sx = u,
            a._sy = v
        }
    },
    Pc = function(a, b, c, d, e) {
        var f, g, h, i, j, k, l, m, n, o = a._vector,
        p = o.origin,
        q = o.w && Yc(d, o, o, "w") || d.getWidth(),
        r = o.h && Yc(d, o, o, "h") || d.getHeight();
        if ("string" == typeof b ? (n = Jb.images[b], n && (h = n.getWidth(), i = n.getHeight())) : (h = b.w && Yc(d, b, b, "w"), i = b.h && Yc(d, b, b, "h")), h && i && c) for (j = c.w / h * a._sx, k = c.h / i * a._sy, f = c.x - q / 2 * (a._sx - 1), g = c.y - r / 2 * (a._sy - 1), p && (f -= (p.x - .5) * q * (a._sx - 1), g -= (p.y - .5) * r * (a._sy - 1)), (1 !== a._sx || 1 !== a._sy) && (a.scale(1 / a._sx, 1 / a._sy), f += ((p ? p.x: .5) * q + c.x) * (a._sx - 1), g += ((p ? p.x: .5) * r + c.y) * (a._sy - 1)), c = {
            x: 0,
            y: 0,
            width: h,
            height: i
        },
        l = 0; j > l; l++) for (m = 0; k > m; m++) c.x = l * h + f,
        c.y = m * i + g,
        Nc(a, b, null, c, d, e, !0)
    },
    Qc = {
        line: function(a, b, c, d) {
            var e, f, g, h, i = Yc(c, a._vector, b, "p1", d),
            j = Yc(c, a._vector, b, "p2", d);
            i ? (e = Zc(i.length ? i[0] : i.x, a), f = $c(i.length ? i[1] : i.y, a)) : (e = Yc(c, a._vector, b, "x1", d, !0), f = Yc(c, a._vector, b, "y1", d, !1)),
            j ? (g = Zc(j.length ? j[0] : j.x, a), h = $c(j.length ? j[1] : j.y, a)) : (g = Yc(c, a._vector, b, "x2", d, !0), h = Yc(c, a._vector, b, "y2", d, !1)),
            a.moveTo(e, f),
            a.lineTo(g, h)
        },
        rect: function(a, b, c, d) {
            var e, f, g, h, i = Yc(c, a._vector, b, "rect", d),
            j = Yc(c, a._vector, b, "r", d);
            i ? (Array.isArray(i) ? (e = i[0], f = i[1], g = i[2], h = i[3]) : (e = i.x, f = i.y, g = i.w, h = i.h), e = Zc(e, a), f = $c(f, a), g = Zc(g, a), h = $c(h, a)) : (e = Yc(c, a._vector, b, "x", d, !0), f = Yc(c, a._vector, b, "y", d, !1), g = Yc(c, a._vector, b, "w", d, !0), h = Yc(c, a._vector, b, "h", d, !1)),
            a.drawRoundRect(e, f, g, h, j),
            (a._gradientFunc || a._pattern) && (a._rect = {
                x: e,
                y: f,
                w: g,
                h: h
            })
        },
        circle: function(a, b, c, d) {
            var e = Yc(c, a._vector, b, "cx", d, !0),
            f = Yc(c, a._vector, b, "cy", d, !1),
            g = a._vector.w && Yc(c, a._vector, a._vector, "w") || c.getWidth(),
            h = a._vector.h && Yc(c, a._vector, a._vector, "h") || c.getHeight(),
            i = _c(Yc(c, a._vector, b, "r", d), Math.min(g, h), b, a._vector),
            j = Yc(c, a._vector, b, "startAngle", d),
            k = Yc(c, a._vector, b, "endAngle", d),
            l = Yc(c, a._vector, b, "anticlockwise", d),
            m = Yc(c, a._vector, b, "close", d);
            null == j && (j = 0),
            null == k && (k = 360),
            null == l && (l = !1),
            m && a.moveTo(e, f),
            a.arc(e, f, i, j / 180 * Math.PI, k / 180 * Math.PI, l),
            m && a.closePath(),
            (a._gradientFunc || a._pattern) && (a._rect = {
                x: e - i,
                y: f - i,
                w: 2 * i,
                h: 2 * i
            })
        },
        ellipse: function(a, b, c, d) {
            var e = Yc(c, a._vector, b, "cx", d, !0),
            f = Yc(c, a._vector, b, "cy", d, !1),
            g = Yc(c, a._vector, b, "rx", d, !0),
            h = Yc(c, a._vector, b, "ry", d, !1),
            i = Yc(c, a._vector, b, "startAngle", d),
            j = Yc(c, a._vector, b, "endAngle", d),
            k = Yc(c, a._vector, b, "anticlockwise", d),
            l = Yc(c, a._vector, b, "close", d);
            null == i && (i = 0),
            null == j && (j = 360),
            null == k && (k = !1),
            l && a.moveTo(e, f),
            a.ellipse(e, f, g, h, 0, i / 180 * Math.PI, j / 180 * Math.PI, k),
            l && a.closePath(),
            (a._gradientFunc || a._pattern) && (a._rect = {
                x: e - g,
                y: f - h,
                w: 2 * g,
                h: 2 * h
            })
        },
        path: function(a, b, c, d) {
            var e = Yc(c, a._vector, b, "data", d);
            a.drawPath(e)
        },
        text: function(a, b, c, d) {
            var e = Yc(c, a._vector, b, "text", d),
            f = Yc(c, a._vector, b, "x", d, !0),
            g = Yc(c, a._vector, b, "y", d, !1),
            h = Yc(c, a._vector, b, "w", d, !0);
            if (null != e) {
                e = String(e);
                var i = e.split("\n"),
                j = 2 * a.measureText("e").width,
                k = vb(a, e, h);
                g -= (k.h / j - 1) / 2 * j,
                i.forEach(function(b) {
                    if (h) {
                        var c, d, e, i, k, l = b.split(" "),
                        m = l.length,
                        n = "";
                        for (e = 0; m > e; e++) if (c = l[e] + (e === m - 1 ? "": " "), d = n + c, i = a.measureText(d).width, h > i) n = d;
                        else if (i == h) a.fillText(n, f, g),
                        n = "",
                        g += j;
                        else {
                            for (k = 0; k < c.length; k++) if (d = n + c.substr(0, k + 1), a.measureText(d).width > h) {
                                a.fillText(d.substring(0, d.length - 1), f, g),
                                n = c.substring(k, c.length),
                                g += j;
                                break
                            }
                            for (; n.length > 0 && a.measureText(n).width > h;) for (k = 0; k < n.length; k++) if (d = n.substr(0, k + 1), a.measureText(d).width > h) {
                                a.fillText(n.substr(0, k), f, g),
                                n = n.substring(k, n.length),
                                g += j;
                                break
                            }
                        }
                        a.fillText(n, f, g)
                    } else a.fillText(b, f, g);
                    g += j
                })
            }
        },
        draw: function(a, b, c, d) {
            var e, f, g = b.draw;
            "string" == typeof g && ((e = g.match(Wc)) ? (f = "with(data) { " + e[1] + " }", g = Ib.Util.newFunction("g", "data", "view", f)) : g = dd[g]),
            "function" == typeof g && g.call(a._vector, a, c, d)
        },
        vector: function(a, b, c, d) {
            var e, f, g, h, i, j, k, l, m, n, o, p, q, r = a._vector,
            s = Yc(c, r, b, "name", d),
            t = Yc(c, r, b, "x", d, !0),
            u = Yc(c, r, b, "y", d, !1),
            v = Yc(c, r, b, "w", d),
            w = Yc(c, r, b, "h", d);
            if ("string" == typeof s ? (l = Jb.images[s], k = l && l._image) : k = s, k) if (cd(k)) null != v && null != w ? a.drawImage(k, t, u, Zc(v, a), $c(w, a)) : a.drawImage(k, t, u);
            else {
                for (m = Yc(c, k, k, "v", d), n = m && m.length, o = k.w && Yc(c, k, k, "w"), p = k.h && Yc(c, k, k, "h"), null != v && null != w ? (v = Zc(v, a), w = $c(w, a)) : (v = o, w = p), a.save(), h = a._lineWidth, i = a._fill, j = a._alpha, Tc(c, k, k, a, d), Tc(c, r, b, a, d), a.translate(t, u), a.scale(v / o, w / p), k.origin && a.translate((k.origin.x - .5) * o, (k.origin.y - .5) * p), k.clip && (a.beginPath(), k.clip === !0 ? a.rect( - (k.origin ? k.origin.x: .5) * o, -(k.origin ? k.origin.y: .5) * p, o, p) : k.clip.length ? k.clip.forEach(function(b) {
                    a.drawShape(b)
                }) : a.drawShape(k.clip), a.clip()), q = a._shapeData, a._vector = k, e = 0; n > e; e++) f = m[e],
                a._shapeData = f,
                d && (d._shapeDataIndex.length ? d._shapeDataIndex.push(e) : d._shapeDataIndex = [d._shapeDataIndex, e], f.animate && wb(f, r, c, d)),
                Yc(c, k, f, "visible", d) !== !1 && (g = Qc[f.shape], g && (a.save(), "vector" === f.shape || "g" === f.shape ? g(a, f, c, d) : Tc(c, k, f, a, d,
                function() {
                    g(a, f, c, d)
                }), a.restore())),
                d && d._shapeDataIndex.pop();
                a._vector = r,
                a._shapeData = q,
                a._lineWidth = h,
                a._fill = i,
                a._alpha = j,
                a.restore()
            }
        },
        g: function(a, b, c, d) {
            var e, f, g, h, i, j = Yc(c, a._vector, b, "v", d);
            j && j.length && (a.save(), f = a._lineWidth, g = a._fill, h = a._alpha, i = a._shapeData, Tc(c, a._vector, b, a, d), j.forEach(function(b) {
                Yc(c, a._vector, b, "visible", d) !== !1 && (e = Qc[b.shape], e && (a.save(), a._shapeData = b, "vector" === b.shape || "g" === b.shape ? e(a, b, c, d) : Tc(c, a._vector, b, a, d,
                function() {
                    e(a, b, c, d)
                }), a.restore()))
            }), a._lineWidth = f, a._fill = g, a._alpha = h, a._shapeData = i, a.restore())
        }
    };
    Qc.image = Qc.vector;
    var Rc = Object.keys(Qc),
    Sc = {
        M: function(a, b) {
            return a.moveTo(b.x, b.y),
            a._path_start = b,
            a._rect && bd(a._rect, b.x, b.y),
            b
        },
        m: function(a, b, c) {
            return c && (b = {
                x: c.x + b.x,
                y: c.y + b.y
            }),
            a.moveTo(b.x, b.y),
            a._path_start = b,
            a._rect && bd(a._rect, b.x, b.y),
            b
        },
        Z: function(a) {
            return a.closePath(),
            a._path_start
        },
        z: function(a) {
            return a.closePath(),
            a._path_start
        },
        L: function(a, b) {
            return a.lineTo(b.x, b.y),
            a._rect && bd(a._rect, b.x, b.y),
            b
        },
        l: function(a, b, c) {
            var d = {
                x: c.x + b.x,
                y: c.y + b.y
            };
            return a.lineTo(d.x, d.y),
            a._rect && bd(a._rect, d.x, d.y),
            d
        },
        H: function(a, b, c) {
            var d = {
                x: b.x,
                y: c.y
            };
            return a.lineTo(d.x, d.y),
            a._rect && bd(a._rect, d.x, d.y),
            d
        },
        h: function(a, b, c) {
            var d = {
                x: c.x + b.x,
                y: c.y
            };
            return a.lineTo(d.x, d.y),
            a._rect && bd(a._rect, d.x, d.y),
            d
        },
        V: function(a, b, c) {
            var d = {
                x: c.x,
                y: b.y
            };
            return a.lineTo(d.x, d.y),
            a._rect && bd(a._rect, d.x, d.y),
            d
        },
        v: function(a, b, c) {
            var d = {
                x: c.x,
                y: c.y + b.y
            };
            return a.lineTo(d.x, d.y),
            a._rect && bd(a._rect, d.x, d.y),
            d
        },
        Q: function(a, b) {
            return a._preQ_x = b.x1,
            a._preQ_y = b.y1,
            a.quadraticCurveTo(b.x1, b.y1, b.x, b.y),
            a._rect && (bd(a._rect, b.x1, b.y1), bd(a._rect, b.x, b.y)),
            b
        },
        q: function(a, b, c) {
            var d = {
                x: c.x + b.x,
                y: c.y + b.y
            },
            e = a._preQ_x = c.x + b.x1,
            f = a._preQ_y = c.y + b.y1;
            return a.quadraticCurveTo(e, f, d.x, d.y),
            a._rect && (bd(a._rect, e, f), bd(a._rect, d.x, d.y)),
            d
        },
        T: function(a, b, c) {
            var d = a._preQ_x = 2 * c.x - a._preQ_x,
            e = a._preQ_y = 2 * c.y - a._preQ_y;
            return a.quadraticCurveTo(d, e, b.x, b.y),
            a._rect && (bd(a._rect, d, e), bd(a._rect, b.x, b.y)),
            b
        },
        t: function(a, b, c) {
            var d = {
                x: c.x + b.x,
                y: c.y + b.y
            },
            e = a._preQ_x = 2 * c.x - a._preQ_x,
            f = a._preQ_y = 2 * c.y - a._preQ_y;
            return a.quadraticCurveTo(e, f, d.x, d.y),
            a._rect && (bd(a._rect, e, f), bd(a._rect, d.x, d.y)),
            d
        },
        C: function(a, b) {
            return a._preC_x = b.x2,
            a._preC_y = b.y2,
            a.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y),
            a._rect && (bd(a._rect, b.x1, b.y1), bd(a._rect, b.x2, b.y2), bd(a._rect, b.x, b.y)),
            b
        },
        c: function(a, b, c) {
            var d = {
                x: c.x + b.x,
                y: c.y + b.y
            },
            e = c.x + b.x1,
            f = c.y + b.y1,
            g = a._preC_x = c.x + b.x2,
            h = a._preC_y = c.y + b.y2;
            return a.bezierCurveTo(e, f, g, h, d.x, d.y),
            a._rect && (bd(a._rect, e, f), bd(a._rect, g, h), bd(a._rect, d.x, d.y)),
            d
        },
        S: function(a, b, c) {
            var d = 2 * c.x - a._preC_x,
            e = 2 * c.y - a._preC_y;
            return a._preC_x = b.x2,
            a._preC_y = b.y2,
            a.bezierCurveTo(d, e, b.x2, b.y2, b.x, b.y),
            a._rect && (bd(a._rect, d, e), bd(a._rect, b.x2, b.y2), bd(a._rect, b.x, b.y)),
            b
        },
        s: function(a, b, c) {
            var d = {
                x: c.x + b.x,
                y: c.y + b.y
            },
            e = 2 * c.x - a._preC_x,
            f = 2 * c.y - a._preC_y,
            g = a._preC_x = c.x + b.x2,
            h = a._preC_y = c.y + b.y2;
            return a.bezierCurveTo(e, f, g, h, d.x, d.y),
            a._rect && (bd(a._rect, e, f), bd(a._rect, g, h), bd(a._rect, d.x, d.y)),
            d
        }
    },
    Tc = function(a, b, c, d, e, f) {
        var g, h, i, j, k, l, m, n, o, p, q, r, s, t = Yc(a, b, c, "line", e),
        u = Yc(a, b, c, "fill", e),
        v = Yc(a, b, c, "fillRule", e) || "nonzero",
        w = Yc(a, b, c, "gradient", e),
        x = Yc(a, b, c, "gradientColor", e),
        y = Yc(a, b, c, "pattern", e),
        z = Yc(a, b, c, "font", e),
        A = Yc(a, b, c, "textAlign", e) || "center",
        B = Yc(a, b, c, "textBaseline", e) || "middle",
        C = Yc(a, b, c, "translate", e),
        D = Yc(a, b, c, "rotate", e),
        E = Yc(a, b, c, "rotateOrigin", e),
        F = Yc(a, b, c, "scale", e),
        G = Yc(a, b, c, "transform", e),
        H = Yc(a, b, c, "alpha", e),
        I = d._lineWidth,
        J = d._fill,
        K = d._pattern,
        L = d._alpha,
        M = d._gradientFunc;
        if (t ? (g = t.color, h = t.width, i = t.cap, j = t.join, k = t.miterLimit, l = t.dash, m = t.dashOffset) : (g = Yc(a, b, c, "lineColor", e), h = Yc(a, b, c, "lineWidth", e), i = Yc(a, b, c, "lineCap", e), j = Yc(a, b, c, "lineJoin", e), k = Yc(a, b, c, "miterLimit", e), l = Yc(a, b, c, "lineDash", e), m = Yc(a, b, c, "lineDashOffset", e)), null != g && (d.strokeStyle = td(g, d._color)), null != h && (d.lineWidth = d._lineWidth = e && e.getSizeZoom ? h / e.getSizeZoom() : h), null != i && (d.lineCap = i), null != j && (d.lineJoin = j), null != k && (d.miterLimit = k), null != l && (d.lineDash = l, d.setLineDash(l)), null != m && (d.lineDashOffset = m), y ? d._pattern = y: (u && (d.fillStyle = d._fill = td(u, d._color)), w && ("string" == typeof w ? o = Yb[w] : (o = Yb[w.type], w.color && (x = w.color), o || (w = Lc(w, d))), d._gradientFunc = o)), null != z && (d.font = z), null != A && (d.textAlign = A), null != B && (d.textBaseline = B), Uc(a, b, c, d, e), null != G)"string" == typeof G && (G = Mc(G)),
        G.length && G.forEach(function(a) {
            var b = a[0];
            "matrix" === b ? d.transform(a[1], a[2], a[3], a[4], a[5], a[6]) : "translate" === b ? d.translate(a[1] || 0, a[2] || 0) : "scale" === b ? d.scale(a[1] || 1, a[2] || a[1] || 1) : "rotate" === b ? a.length > 2 ? (d.translate(a[2], a[3]), d.rotate(a[1]), d.translate( - a[2], -a[3])) : d.rotate(a[1]) : "skewX" === b ? d.transform(1, 0, Math.tan(a[1] * Math.PI / 180), 1, 0, 0) : "skewY" === b && d.transform(1, Math.tan(a[1] * Math.PI / 180), 0, 1, 0, 0)
        });
        else {
            if (null != C && (Array.isArray(C) ? (r = C[0], s = C[1]) : "object" == typeof C ? (r = C.x, s = C.y) : (r = C, s = 0), r = Zc(r, d), s = $c(s, d), (0 !== r || 0 !== s) && d.translate(r, s)), null != D && D % 360 !== 0) {
                var N, O;
                E && (Array.isArray(E) ? (N = E[0], O = E[1]) : "object" == typeof E ? (N = E.x, O = E.y) : N = O = E, N = Zc(N, d), O = $c(O, d), (0 !== N || 0 !== O) && d.translate(N, O)),
                d.rotate(D * Math.PI / 180),
                E && (0 !== N || 0 !== O) && d.translate( - N, -O)
            }
            null != F && (Array.isArray(F) ? (p = F[0], q = F[1]) : "object" == typeof F ? (p = F.x, q = F.y) : p = q = F, (1 !== p || 1 !== q) && d.scale(p, q))
        }
        null != H && (d.globalAlpha = d._alpha = null != L ? L * H: H),
        f && (d.beginPath(), f(), n = d._rect || c.rect, d._pattern ? (d._lineWidth > 0 && d.stroke(), d.clip(), Pc(d, d._pattern, n, a, e)) : (o && n && (w = o(d, td(u || "#000000", d._color), td(x || "#FFFFFF", d._color), n.x, n.y, n.w, n.h)), w && (d.fillStyle = d._fill = w), d._fill && d.fill(v), d._lineWidth > 0 && d.stroke()), d._lineWidth = I, d._fill = J, d._pattern = K, d._alpha = L, d._gradientFunc = M, d._rect = null)
    },
    Uc = function(a, b, c, d, e) {
        var f, g, h, i, j = Yc(a, b, c, "shadow", e);
        j ? (f = j.offsetX, g = j.offsetY, h = j.blur, i = j.color) : (f = Yc(a, b, c, "shadowOffsetX", e), g = Yc(a, b, c, "shadowOffsetY", e), h = Yc(a, b, c, "shadowBlur", e), i = Yc(a, b, c, "shadowColor", e)),
        null != f && (d.shadowOffsetX = f),
        null != g && (d.shadowOffsetY = g),
        null != h && (d.shadowBlur = h),
        null != i && (d.shadowColor = i)
    },
    Vc = /<%=([\s\S]+?)%>/,
    Wc = /<%([\s\S]+?)%>/,
    Xc = new RegExp([Vc.source, Wc.source].join("|")),
    Yc = function(a, c, d, e, f, g, h) {
        var i, j, k, l, m, n = d[e],
        o = typeof n;
        if ("string" === o && (i = n.match(Xc)) ? (j = "with(data) { " + (i[1] ? "return " + i[1] : i[2]) + " }", k = Ib.Util.newFunction("data", "view", j), n = k.call(c, a, f)) : "function" === o && (n = n.call(c, a, f)), g === !0 ? (l = c.w && Yc(a, c, c, "w") || a.getWidth(), (d.rel === !0 || d.rel === b && c.rel) && 1 >= n && n >= -1 ? n *= l: "string" == typeof n && (n = parseInt(n) / 100 * l), n = n || 0) : g === !1 && (m = c.h && Yc(a, c, c, "h") || a.getHeight(), (d.rel === !0 || d.rel === b && c.rel) && 1 >= n && n >= -1 ? n *= m: "string" == typeof n && (n = parseInt(n) / 100 * m), n = n || 0), h !== !1 && f && a && d.animate && a._animates) {
            var p, q = a._animates,
            r = f._shapeDataIndex;
            if (r.length) for (var s = 0; s < r.length; s++) p = r[s],
            q = q[p];
            else p = r;
            var t = q[p],
            u = t[e];
            if (u) if (Array.isArray(u)) for (var s = u.length - 1; s >= 0; s--) {
                var v = u[s];
                if ((v.stopped || v.time > 0) && v.started) return Hb(v, n)
            } else if (u.started) return Hb(u, n)
        }
        return n
    },
    Zc = function(a, c) {
        if (!a) return 0;
        var d = c._vector.w && Yc(c._data, c._vector, c._vector, "w") || c._data.getWidth();
        return (c._shapeData && c._shapeData.rel === !0 || (!c._shapeData || c._shapeData.rel === b) && c._vector.rel) && 1 >= a && a >= -1 ? a * d: "string" == typeof a ? parseInt(a) / 100 * d: a
    },
    $c = function(a, c) {
        if (!a) return 0;
        var d = c._vector.h && Yc(c._data, c._vector, c._vector, "h") || c._data.getHeight();
        return (c._shapeData && c._shapeData.rel === !0 || (!c._shapeData || c._shapeData.rel === b) && c._vector.rel) && 1 >= a && a >= -1 ? a * d: "string" == typeof a ? parseInt(a) / 100 * d: a
    },
    _c = function(a, c, d, e) {
        return a ? (d.rel === !0 || d.rel === b && e.rel) && 1 >= a && a >= -1 ? a * c: "string" == typeof a ? parseInt(a) / 100 * c: a: 0
    },
    ad = (a.CanvasRenderingContext2D || Lb.Context2d).prototype;
    ad.drawShape = function(a) {
        var b = this,
        c = b._vector,
        d = b._shapeData,
        e = b._data,
        f = b._view,
        g = Qc[a.shape];
        g && (b.save(), b._shapeData = a, "vector" === a.shape || "g" === a.shape ? g(b, a, e, f) : Tc(e, c, a, b, f,
        function() {
            g(b, a, e, f)
        }), b._shapeData = d, b.restore())
    },
    ad.drawPath = function(a) {
        var b, c, d, e, f, g, h, i, j, k, l, m, n = this;
        if ("string" == typeof a && (a = Ec(a)), j = a ? a.length: 0, !(1 >= j)) {
            if ((n._gradientFunc || n._pattern) && (n._rect = k = {
                x: 0,
                y: 0,
                w: 0,
                h: 0
            }), b = a && a[0] && a[0].c, b || (c = a && a[0] && null != a[0].x, d = "z" === a[j - 1] || "Z" === a[j - 1], d && j--), b) {
                for (e = 0; j > e; e++) g = a[e],
                h = Sc[g.c],
                h && (f = h(n, g, f));
                n._path_start = null,
                n._preC_x = null,
                n._preC_y = null,
                n._preQ_x = null,
                n._preQ_y = null
            } else if (c) {
                for (i = a[0], l = Zc(i.x, n), m = $c(i.y, n), n.moveTo(l, m), k && bd(k, l, m), e = 1; j > e; e++) i = a[e],
                l = Zc(i.x, n),
                m = $c(i.y, n),
                n.lineTo(l, m),
                k && bd(k, l, m);
                d && n.closePath()
            } else {
                for (l = Zc(a[0], n), m = $c(a[1], n), n.moveTo(l, m), k && bd(k, l, m), e = 2; j > e; e += 2) l = Zc(a[e], n),
                m = $c(a[e + 1], n),
                n.lineTo(l, m),
                k && bd(k, l, m);
                d && n.closePath()
            }
            return a
        }
    };
    var bd = function(a, b, c) {
        var d = Math.min(a.x, b),
        e = Math.max(a.x + a.w, b),
        f = Math.min(a.y, c),
        g = Math.max(a.y + a.h, c);
        a.x = d,
        a.y = f,
        a.w = e - d,
        a.h = g - f
    };
    ad._fillPath = function(a, b) {
        var c = this;
        c.beginPath(),
        c.fillStyle = a,
        c.drawPath(b),
        c.fill()
    },
    ad._fillRect = function(a, b, c, d, e) {
        var f = this;
        f.beginPath(),
        f.fillStyle = a,
        f.rect(b, c, d, e),
        f.fill()
    },
    ad.ellipse || (ad.ellipse = function(a, b, c, d) {
        var e = this,
        f = .5522848,
        g = c * f,
        h = d * f,
        i = a + c,
        j = b + d,
        k = a - c,
        l = b - d;
        e.moveTo(k, b),
        e.bezierCurveTo(k, b - h, a - g, l, a, l),
        e.bezierCurveTo(a + g, l, i, b - h, i, b),
        e.bezierCurveTo(i, b + h, a + g, j, a, j),
        e.bezierCurveTo(a - g, j, k, b + h, k, b)
    }),
    ad.drawRoundRect = function(a, b, c, d, e) {
        var f = this;
        if (!e) return void f.rect(a, b, c, d);
        var g, h, i, j;
        if (Array.isArray(e)) if (1 === e.length) g = h = i = j = e[0];
        else if (2 === e.length) g = h = e[0],
        i = j = e[1];
        else {
            if (4 !== e.length) return void f.rect(a, b, c, d);
            g = e[0],
            h = e[1],
            i = e[2],
            j = e[3]
        } else g = h = i = j = e;
        var k = a + c,
        l = b + d,
        m = d > c ? 2 * c: 2 * d;
        g = m > g ? g: m,
        h = m > h ? h: m,
        i = m > i ? i: m,
        j = m > j ? j: m;
        var n = .292893218813453 * j,
        o = .585786437626905 * j;
        f.moveTo(k, l - j),
        f.quadraticCurveTo(k, l - o, k - n, l - n),
        f.quadraticCurveTo(k - o, l, k - j, l),
        n = .292893218813453 * i,
        o = .585786437626905 * i,
        f.lineTo(a + i, l),
        f.quadraticCurveTo(a + o, l, a + n, l - n),
        f.quadraticCurveTo(a, l - o, a, l - i),
        n = .292893218813453 * g,
        o = .585786437626905 * g,
        f.lineTo(a, b + g),
        f.quadraticCurveTo(a, b + o, a + n, b + n),
        f.quadraticCurveTo(a + o, b, a + g, b),
        n = .292893218813453 * h,
        o = .585786437626905 * h,
        f.lineTo(k - h, b),
        f.quadraticCurveTo(k - o, b, k - n, b + n),
        f.quadraticCurveTo(k, b + o, k, b + h),
        f.lineTo(k, l - j)
    };
    var cd = function(a) {
        return Lb ? a instanceof Lb || a instanceof Pb: a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement
    },
    dd = {},
    ed = function(a, b) {
        "function" == typeof b && (dd[a] = b)
    },
    fd = function(a, b) {
        "function" == typeof b && Rc.indexOf(a) < 0 && (Qc[a] = b)
    }; !
    function() {
        for (var b = ["webkit", "moz"], c = 0; c < b.length && !a.requestAnimationFrame; ++c) {
            var d = b[c];
            a.requestAnimationFrame = a[d + "RequestAnimationFrame"],
            a.cancelAnimationFrame = a[d + "CancelAnimationFrame"] || a[d + "CancelRequestAnimationFrame"]
        }
        if (/iP(ad|hone|od).*OS 6/.test(a.navigator.userAgent) || !a.requestAnimationFrame || !a.cancelAnimationFrame) {
            var e = 0;
            a.requestAnimationFrame = function(a) {
                var b = Date.now(),
                c = Math.max(e + 16, b);
                return setTimeout(function() {
                    a(e = c)
                },
                c - b)
            },
            a.cancelAnimationFrame = clearTimeout
        }
    } ();
    var gd = Ib.Animate = function(a) {
        var b = this;
        b.type = null == a.type ? "number": a.type,
        b.delay = null == a.delay ? 0 : a.delay,
        b.dur = null == a.dur ? 1e3: a.dur,
        b.interval = null == a.interval ? 0 : a.interval,
        b.finish = null == a.finish ? b.delay + b.dur + b.interval: a.finish,
        null == a.finish ? b.finish = b.delay + b.dur + b.interval: (b.finish = a.finish, b.interval = b.finish - b.delay - b.dur),
        b.repeat = null == a.repeat ? 1 : a.repeat,
        b.reverse = null == a.reverse ? !0 : a.reverse,
        b.easing = null == a.easing ? "easeNone": a.easing,
        b.onUpdate = a.onUpdate,
        b.onDone = a.onDone,
        b.onStop = a.onStop,
        b.onPlay = a.onPlay,
        b.attr = a.attr,
        b.source = a.source,
        b.filter = a.filter,
        b.from = a.from,
        b.to = a.to,
        b.start = null,
        b.time = 0,
        b.total = 0,
        b.count = 0,
        b.started = !1,
        b.stopped = !1,
        b.paused = !1,
        b.pausedTime = null,
        b.pausedTotal = 0,
        b._speed = 1,
        b._oldSpeed = null,
        b._speedTotal = 0,
        b._speedTime = null,
        b._percent = 0,
        b._percentSet = null,
        b._percentDiff = 0,
        b.id = id++
    };
    Jb.ext("twaver.Animate", Object, {
        play: function() {
            return yb(this)
        },
        stop: function(a) {
            return zb(this, a)
        },
        pause: function() {
            this.stopped || (this.paused = !0)
        },
        resume: function() {
            this.paused && (this.paused = !1, jd = !0)
        },
        isPaused: function() {
            return this.paused
        },
        percent: function(a) {
            return null == a ? this._percentSet || this._percent: (this._percentSet = 0 > a ? 0 : a > 100 ? 100 : a, this.paused && (jd = !0), this.started || (this.play(), this.pause()), this)
        },
        speed: function(a) {
            return null == a ? this._speed: (a = 0 > a ? 1 : a, a !== this.speed && (this.stopped || (this._oldSpeed = this._speed), this._speed = a), this)
        },
        clone: function() {
            return new gd(this)
        },
        chain: function(a) {
            var b, c = this;
            return c.next = a,
            a.pre = c,
            c.onDone ? (b = c.onDone, c.onDone = function() {
                b.call(c),
                a.play()
            }) : c.onDone = function() {
                a.play()
            },
            c
        }
    });
    var hd = {},
    id = 1,
    jd = !1; !
    function Hf(a) {
        requestAnimationFrame(Hf),
        jd && (jd = !1, Db(a))
    } (0);
    var kd = {
        easeNone: function(a, b, c, d) {
            return c * a / d + b
        },
        easeIn: function(a, b, c, d) {
            return c * (a /= d) * a + b
        },
        easeOut: function(a, b, c, d) {
            return - c * (a /= d) * (a - 2) + b
        },
        easeBoth: function(a, b, c, d) {
            return (a /= d / 2) < 1 ? c / 2 * a * a + b: -c / 2 * (--a * (a - 2) - 1) + b
        },
        easeInStrong: function(a, b, c, d) {
            return c * (a /= d) * a * a * a + b
        },
        easeOutStrong: function(a, b, c, d) {
            return - c * ((a = a / d - 1) * a * a * a - 1) + b
        },
        easeBothStrong: function(a, b, c, d) {
            return (a /= d / 2) < 1 ? c / 2 * a * a * a * a + b: -c / 2 * ((a -= 2) * a * a * a - 2) + b
        },
        elasticIn: function(a, b, c, d, e, f) {
            var g;
            return 0 === a ? b: 1 === (a /= d) ? b + c: (f || (f = .3 * d), !e || e < Math.abs(c) ? (e = c, g = f / 4) : g = f / (2 * Math.PI) * Math.asin(c / e), -(e * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a * d - g) * Math.PI / f)) + b)
        },
        elasticOut: function(a, b, c, d, e, f) {
            var g;
            return 0 === a ? b: 1 === (a /= d) ? b + c: (f || (f = .3 * d), !e || e < Math.abs(c) ? (e = c, g = f / 4) : g = f / (2 * Math.PI) * Math.asin(c / e), e * Math.pow(2, -10 * a) * Math.sin(2 * (a * d - g) * Math.PI / f) + c + b)
        },
        elasticBoth: function(a, b, c, d, e, f) {
            var g;
            return 0 === a ? b: 2 === (a /= d / 2) ? b + c: (f || (f = .3 * d * 1.5), !e || e < Math.abs(c) ? (e = c, g = f / 4) : g = f / (2 * Math.PI) * Math.asin(c / e), 1 > a ? -.5 * e * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a * d - g) * Math.PI / f) + b: e * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a * d - g) * Math.PI / f) * .5 + c + b)
        },
        backIn: function(a, c, d, e, f) {
            return f === b && (f = 1.70158),
            a === e && (a -= .001),
            d * (a /= e) * a * ((f + 1) * a - f) + c
        },
        backOut: function(a, b, c, d, e) {
            return "undefined" == typeof e && (e = 1.70158),
            c * ((a = a / d - 1) * a * ((e + 1) * a + e) + 1) + b
        },
        backBoth: function(a, b, c, d, e) {
            return "undefined" == typeof e && (e = 5.70158),
            (a /= d / 2) < 1 ? c / 2 * a * a * (((e *= 1.525) + 1) * a - e) + b: c / 2 * ((a -= 2) * a * (((e *= 1.525) + 1) * a + e) + 2) + b
        },
        bounceIn: function(a, b, c, d) {
            return c - kd.bounceOut(d - a, 0, c, d) + b
        },
        bounceOut: function(a, b, c, d) {
            return (a /= d) < 1 / 2.75 ? 7.5625 * c * a * a + b: 2 / 2.75 > a ? c * (7.5625 * (a -= 1.5 / 2.75) * a + .75) + b: 2.5 / 2.75 > a ? c * (7.5625 * (a -= 2.25 / 2.75) * a + .9375) + b: c * (7.5625 * (a -= 2.625 / 2.75) * a + .984375) + b
        },
        bounceBoth: function(a, b, c, d) {
            return d / 2 > a ? .5 * kd.bounceIn(2 * a, 0, c, d) + b: .5 * kd.bounceOut(2 * a - d, 0, c, d) + .5 * c + b
        }
    },
    ld = {
        draw: function(a, b) {
            var c = null == b.getCurrentSubNetwork() ? b.getElementBox() : b.getCurrentSubNetwork(),
            d = c.getStyle("background.type");
            "image" == d ? this.drawImage(a, c, b) : "vector" == d ? this.drawVector(a, c) : "image.vector" == d ? (this.drawImage(a, c, b), this.drawVector(a, c)) : "vector.image" == d && (this.drawVector(a, c), this.drawImage(a, c, b))
        },
        drawImage: function(a, b, c) {
            var d = b.getStyle("background.image"),
            e = Jb.getImageAsset(d);
            if (null != e) {
                var f = {
                    x: 0,
                    y: 0,
                    width: a.canvas.width,
                    height: a.canvas.height
                };
                "none" == b.getStyle("background.image.stretch") && (f.width = e.getWidth(), f.height = e.getHeight());
                var g = b.getStyle("background.image.padding");
                if (g && Tb.grow(f, g, g), "tile" == b.getStyle("background.image.stretch")) {
                    if (cd(e.getImage())) for (var h = 0; h < f.width; h += e.getWidth()) for (var i = 0; i < f.height; i += e.getHeight()) a.drawImage(e.getImage(), h, i)
                } else("fill" == b.getStyle("background.image.stretch") || "none" == b.getStyle("background.image.stretch")) && Nc(a, e.getImage(), null, f, b, c)
            }
        },
        drawVector: function(a, b) {
            var c = {
                x: 0,
                y: 0,
                width: a.canvas.width,
                height: a.canvas.height
            },
            d = b.getStyle("background.outline.width"),
            e = (b.getStyle("background.outline.color"), b.getStyle("background.vector.fill")),
            f = b.getStyle("background.vector.fill.color"),
            g = b.getStyle("background.vector.padding"),
            h = b.getStyle("background.vector.shape"),
            i = b.getStyle("background.vector.pattern");
            g && Tb.grow(c, g, g);
            var j = b.getStyle("background.vector.gradient");
            e && (j ? Xb.fill(a, f, j, b.getStyle("background.vector.gradient.color"), c) : a.fillStyle = f, Xb.drawVector(a, h, i, c), a.fill()),
            d > 0 && (a.lineWidth = d, a.strokeStyle = b.getStyle("background.outline.color"), Xb.drawVector(a, h, i, c), a.stroke())
        }
    },
    md = Ib.UndoManager = function(a) {
        var b = this;
        b._list = [],
        b._cursor = -1,
        b._suspended = !1,
        b._dispatcher = new Ib.EventDispatcher,
        b._box = a,
        b._enabled = !1,
        b._limit = 100
    };
    md._IGNORE_PROPERTIES = {
        alarmState: 1,
        propagateSeverity: 1,
        enablePropagation: 1,
        children: 1,
        fromAgent: 1,
        toAgent: 1,
        bundleLinks: 1
    },
    Jb.ext("twaver.UndoManager", Object, {
        setEnabled: function(a) {
            var b = this,
            c = b._box;
            b._enabled != a && (a ? (c.addDataBoxChangeListener(b._handleDataBoxChange, b, !0), c.addDataPropertyChangeListener(b._handleDataPropertyChange, b, !0)) : (c.removeDataBoxChangeListener(b._handleDataBoxChange, b), c.removeDataPropertyChangeListener(b._handleDataPropertyChange, b))),
            b._enabled = a
        },
        isEnabled: function() {
            return this._enabled
        },
        undo: function() {
            var a, b, c, d = this,
            e = d._list;
            if (d.canUndo()) {
                if (a = e[d._cursor--], d._suspended = !0, a.length) for (c = a.length, b = c - 1; b >= 0; b--) a[b].undo();
                else a.undo();
                d._suspended = !1,
                d._fire({
                    kind: "undo",
                    action: a
                })
            }
        },
        redo: function() {
            var a, b = this,
            c = b._list;
            b.canRedo() && (a = c[++b._cursor], b._suspended = !0, a.length ? a.forEach(function(a) {
                a.redo()
            }) : a.redo(), b._suspended = !1, b._fire({
                kind: "redo",
                action: a
            }))
        },
        canUndo: function() {
            return this._cursor >= 0
        },
        canRedo: function() {
            return this._cursor < this._list.length - 1
        },
        _add: function(a) {
            var b = this,
            c = b._batch,
            d = b._list;
            c ? c.push(a) : (b._cursor !== d.length - 1 && d.splice(b._cursor + 1, d.length), 0 !== b._limit && d.length === b._limit && d.splice(0, 1), d.push(a), b._cursor = d.length - 1, b._fire({
                kind: "add",
                action: a
            }))
        },
        _handleDataBoxChange: function(a) {
            if (!this._suspended) {
                var b = this,
                c = b._box,
                d = a.kind,
                e = a.data;
                "add" === d ? b._add({
                    undo: function() {
                        var a = this;
                        a.parent = e.getParent(),
                        a.host = e.getHost && e.getHost(),
                        e.getFromNode && (a.fromNode = e.getFromNode(), a.toNode = e.getToNode()),
                        c.remove(e)
                    },
                    redo: function() {
                        var a = this;
                        a.parent && e.setParent(a.parent),
                        e.getHost && a.host && e.setHost(a.host),
                        e.getFromNode && (a.fromNode && e.setFromNode(a.fromNode), a.toNode && e.setToNode(a.toNode)),
                        c.add(e)
                    }
                }) : "remove" === d && b._add({
                    undo: function() {
                        c.add(e)
                    },
                    redo: function() {
                        c.remove(e)
                    }
                })
            }
        },
        _handleDataPropertyChange: function(a) {
            if (!this._suspended) {
                var b = this,
                c = a.property,
                d = c.substr(0, 2),
                e = a.source,
                f = a.oldValue,
                g = a.newValue;
                "C:" === d ? (c = c.substr(2), b._add({
                    undo: function() {
                        e.setClient(c, f)
                    },
                    redo: function() {
                        e.setClient(c, g)
                    }
                })) : "S:" === d ? (c = c.substr(2), b._add({
                    undo: function() {
                        e.setStyle(c, f)
                    },
                    redo: function() {
                        e.setStyle(c, g)
                    }
                })) : md._IGNORE_PROPERTIES[c] || b._add({
                    undo: function() {
                        e[Jb.setter(c)](f)
                    },
                    redo: function() {
                        e[Jb.setter(c)](g)
                    }
                })
            }
        },
        size: function() {
            return this._list.length
        },
        getCursor: function() {
            return this._cursor
        },
        _fire: function(a) {
            this._dispatcher.fire(a)
        },
        on: function(a, b, c) {
            this._dispatcher.add(a, b, c)
        },
        off: function(a, b) {
            this._dispatcher.remove(a, b)
        },
        isSuspended: function() {
            return this._suspended
        },
        setSuspended: function(a) {
            this._suspended = a
        },
        getLimit: function() {
            return this._limit
        },
        setLimit: function(a) {
            var b, c, d = this,
            e = d._list;
            return 0 > a && (a = 0),
            a !== d._limit && (b = e.length - a, a > 0 && b > 0 && (c = d._cursor + 1, d._cursor -= b, d._cursor < -1 && (d._cursor = -1), c > 0 && e.splice(0, c), b -= c, b > 0 && e.splice(e.length - b, b)), d._limit = a, d._fire({
                kind: "change"
            })),
            d
        },
        clear: function() {
            var a = this;
            return a._list = [],
            a._cursor = -1,
            a._fire({
                kind: "clear"
            }),
            a
        },
        batch: function(a, b) {
            var c = this;
            return c.startBatch(),
            a.call(b),
            c.endBatch(),
            c
        },
        startBatch: function() {
            var a = this;
            return a._batch || (a._batch = []),
            a
        },
        endBatch: function() {
            var a, b = this;
            return b._batch && (a = b._batch, b._batch = null, a.length && b._add(a)),
            b
        }
    }),
    Ib.Pool = function(a, b) {
        this.func = "string" == typeof a ?
        function() {
            return Ob.createElement(a)
        }: a,
        this.tagName = a,
        null != b && (this.redundancy = b)
    },
    Jb.ext("twaver.Pool", Object, {
        redundancy: 2,
        currentIndex: -1,
        get: function() {
            if (this.currentIndex++, this.currentIndex === this.size()) {
                var a = this.func();
                return a._pool = this,
                a.style.margin = "0px",
                a.style.padding = "0px",
                this.list || (this.list = new nd),
                this.list.add(a),
                a
            }
            return this.list.get(this.currentIndex)
        },
        release: function(a) {
            this.list && this.list.remove(a) >= 0 && (delete a._selectData, delete a._expandData, delete a._checkData, delete a._editInfo, delete a.keepDefault, a.style.margin = "0px", a.style.padding = "0px", a.style.backgroundColor = "", a.removeAttribute("title"), "img" === this.tagName && a.removeAttribute && (a.removeAttribute("width"), a.removeAttribute("height"), a.removeAttribute("src")), this.list.add(a), this.currentIndex--)
        },
        reset: function() {
            this.currentIndex = -1
        },
        clear: function() {
            if (this.list) for (; this.redundancy + this.currentIndex < this.list.size() - 1;) delete this.list.removeAt(this.list.size() - 1)._pool
        },
        size: function() {
            return this.list ? this.list.size() : 0
        }
    });
    var nd = function() {
        if (this._as = [], 1 === arguments.length) {
            var a = arguments[0];
            if (a instanceof nd && (a = a._as), a instanceof Array) for (var b = a.length,
            c = 0; b > c; c++) this._as.push(a[c]);
            else a === !1 ? (this._duplicatable = !1, this._map = {}) : null != a && this._as.push(a)
        } else if (arguments.length > 1) for (b = arguments.length, c = 0; b > c; c++) this._as.push(arguments[c])
    };
    Ib.List = nd,
    Jb.ext("twaver.List", Object, {
        _duplicatable: !0,
        size: function() {
            return this._as.length
        },
        isEmpty: function() {
            return 0 === this._as.length
        },
        add: function(a, c) {
            if (!this._duplicatable) {
                if (this._map[a._id]) return;
                this._map[a._id] = !0
            }
            return c === b ? this._as.push(a) : this._as.splice(c, 0, a)
        },
        addAll: function(a) {
            if (a instanceof nd && (a = a._as), a instanceof Array) for (var b = a.length,
            c = 0; b > c; c++) this.add(a[c]);
            else this.add(a)
        },
        get: function(a) {
            return this._as[a]
        },
        remove: function(a) {
            if (!this._duplicatable && !this._map[a && a._id]) return - 1;
            var b = this._as.indexOf(a);
            return b >= 0 && b < this._as.length && this.removeAt(b),
            b
        },
        removeAt: function(a) {
            var b = this._as.splice(a, 1)[0];
            return ! this._duplicatable && b && delete this._map[b._id],
            b
        },
        set: function(a, b) {
            var c = this._as[a];
            if (c === b) return b;
            if (!this._duplicatable) {
                if (this._map[b._id]) throw "duplicate item:" + b;
                delete this._map[c._id],
                this._map[b._id] = !0
            }
            return this._as[a] = b,
            c
        },
        clear: function() {
            return this._duplicatable || (this._map = {}),
            this._as.splice(0, this._as.length)
        },
        contains: function(a) {
            return this._duplicatable ? this.indexOf(a) >= 0 : !!this._map[a && a._id]
        },
        indexOf: function(a) {
            return this._as.indexOf(a)
        },
        forEach: function(a, b) {
            for (var c = this._as.length,
            d = 0; c > d; d++) {
                var e = this._as[d];
                b ? a.call(b, e) : a(e)
            }
        },
        forEachReverse: function(a, b) {
            for (var c = this._as.length,
            d = c - 1; d >= 0; d--) {
                var e = this._as[d];
                b ? a.call(b, e) : a(e)
            }
        },
        toArray: function(a, b) {
            if (a) {
                for (var c = [], d = this._as.length, e = 0; d > e; e++) {
                    var f = this._as[e];
                    b ? a.call(b, f) && c.push(f) : a(f) && c.push(f)
                }
                return c
            }
            return this._as.concat()
        },
        toList: function(a, b) {
            if (a) {
                for (var c = new nd,
                d = this._as.length,
                e = 0; d > e; e++) {
                    var f = this._as[e];
                    b ? a.call(b, f) && c.add(f) : a(f) && c.add(f)
                }
                return c
            }
            return new nd(this)
        },
        sort: function(a) {
            return a ? this._as.sort(a) : this._as.sort(),
            this
        },
        toString: function() {
            return this._as.toString()
        }
    });
    var od = {
        shapeMap: {},
        init: function() {
            od.register("arrow.standard", od.createStandardArrow()),
            od.register("arrow.delta", od.createDeltaArrow()),
            od.register("arrow.diamond", od.createDiamondArrow()),
            od.register("arrow.short", od.createShortArrow()),
            od.register("arrow.slant", od.createSlantArrow()),
            od.register("arrow.doubledelta", od.createDoubleDeltaArrow()),
            od.register("arrow.tee", od.createTeeArrow()),
            od.register("arrow.box", od.createBoxArrow()),
            od.register("arrow.dot", od.createDotArrow()),
            od.register("arrow.tail", od.createTailArrow())
        },
        createStandardArrow: function() {
            var a = new nd;
            return a.add({
                x: -1,
                y: -5 / 9
            }),
            a.add({
                x: -.75,
                y: 0
            }),
            a.add({
                x: -1,
                y: 5 / 9
            }),
            a.add({
                x: 0,
                y: 0
            }),
            a.add({
                x: -1,
                y: -5 / 9
            }),
            {
                points: a
            }
        },
        createDeltaArrow: function() {
            var a = new nd;
            return a.add({
                x: -1,
                y: -5 / 9
            }),
            a.add({
                x: -1,
                y: 5 / 9
            }),
            a.add({
                x: 0,
                y: 0
            }),
            a.add({
                x: -1,
                y: -5 / 9
            }),
            {
                points: a
            }
        },
        createDoubleDeltaArrow: function() {
            var a = new nd;
            return a.add({
                x: -1,
                y: -5 / 9
            }),
            a.add({
                x: -1,
                y: 5 / 9
            }),
            a.add({
                x: -.5,
                y: 0
            }),
            a.add({
                x: -.5,
                y: -5 / 9
            }),
            a.add({
                x: 0,
                y: 0
            }),
            a.add({
                x: -.5,
                y: 5 / 9
            }),
            a.add({
                x: -.5,
                y: 0
            }),
            a.add({
                x: -1,
                y: -5 / 9
            }),
            {
                points: a
            }
        },
        createTeeArrow: function() {
            var a = new nd;
            return a.add({
                x: -1 / 9,
                y: -5 / 9
            }),
            a.add({
                x: -1 / 9,
                y: 5 / 9
            }),
            a.add({
                x: 0,
                y: 5 / 9
            }),
            a.add({
                x: 0,
                y: -5 / 9
            }),
            a.add({
                x: -1 / 9,
                y: -5 / 9
            }),
            {
                points: a
            }
        },
        createBoxArrow: function() {
            var a = new nd;
            return a.add({
                x: -10 / 9,
                y: -5 / 9
            }),
            a.add({
                x: -10 / 9,
                y: 5 / 9
            }),
            a.add({
                x: 0,
                y: 5 / 9
            }),
            a.add({
                x: 0,
                y: -5 / 9
            }),
            a.add({
                x: -10 / 9,
                y: -5 / 9
            }),
            {
                points: a
            }
        },
        createDotArrow: function() {
            var a = {},
            b = new Ib.List;
            return b.add({
                x: -.5,
                y: 0
            }),
            a.points = b,
            a.draw = function(a, b) {
                if (a && b && b.points && !(b.points.size() <= 0)) {
                    var c = b.points._as,
                    d = c[0],
                    e = Math.min(b.width, b.height) / 2;
                    a.save(),
                    a.beginPath(),
                    a.arc(d.x, d.y, e, 0, 2 * Math.PI, !1),
                    a.closePath(),
                    a.restore()
                }
            },
            a
        },
        createTailArrow: function() {
            for (var a = {},
            b = new Ib.List,
            c = 30,
            d = -c / 2; c / 2 > d; d++) b.add({
                x: -d / 9,
                y: 0
            });
            return a.points = b,
            a.draw = function(a, b) {
                if (a && b && b.points && !(b.points.size() <= 0)) for (var c = b.points._as,
                d = b.shadow,
                e = b.shadowColor,
                f = b.shadowXOffset,
                g = b.shadowYOffset,
                h = b.shadowBlur,
                e = b.shadowColor,
                i = c.length - 4,
                j = Math.min(b.width, b.height) / 2, k = 0; i > k; k++) {
                    var l = k / i,
                    m = c[k],
                    n = .4 * j;
                    a.save(),
                    a.restore(),
                    a.beginPath(),
                    a.globalAlpha = l * l,
                    d && (a.shadowOffsetX = f, a.shadowOffsetY = g, a.shadowBlur = h, a.shadowColor = e),
                    a.arc(m.x, m.y, n, 0, 2 * Math.PI, !1),
                    a.closePath(),
                    a.fill()
                }
            },
            a
        },
        createDiamondArrow: function() {
            var a = new nd;
            return a.add({
                x: -7 / 12,
                y: 5 / 9
            }),
            a.add({
                x: -14 / 12,
                y: 0
            }),
            a.add({
                x: -7 / 12,
                y: -5 / 9
            }),
            a.add({
                x: 0,
                y: 0
            }),
            a.add({
                x: -7 / 12,
                y: 5 / 9
            }),
            {
                points: a
            }
        },
        createShortArrow: function() {
            var a = new nd;
            return a.add({
                x: -8 / 12,
                y: 6 / 9
            }),
            a.add({
                x: -5 / 12,
                y: 0
            }),
            a.add({
                x: -8 / 12,
                y: -6 / 9
            }),
            a.add({
                x: 0,
                y: 0
            }),
            a.add({
                x: -8 / 12,
                y: 6 / 9
            }),
            {
                points: a
            }
        },
        createSlantArrow: function() {
            var a = new nd;
            return a.add({
                x: -1,
                y: -5 / 9
            }),
            a.add({
                x: -6.5 / 12,
                y: 0
            }),
            a.add({
                x: -.75,
                y: 4 / 9
            }),
            a.add({
                x: 0,
                y: 0
            }),
            a.add({
                x: -1,
                y: -5 / 9
            }),
            {
                points: a
            }
        },
        register: function(a, b) {
            od.shapeMap[a] = b
        },
        getShape: function(a) {
            if (a) return od.shapeMap[a];
            throw "shape type can't be null"
        },
        getArrowRect: function(a, b, c, d, e, f, g, h, i) {
            var j = od.getShape(d);
            if (j && j.points && !(j.points && j.points.size() <= 0)) {
                if (g > 0 && 1 > g) {
                    var k;
                    k = a.getLineLength ? a.getLineLength() : a._element.getLineLength(),
                    g *= k
                } else a.getLineLength && (g += od.calculateArrowXOffsetAtEdge(b, a, c, i));
                i && (g *= i.getLocationZoom(), h *= i.getLocationZoom());
                var l, m, n, o = Tb.calculatePointInfoAlongLine(b, c, g, h),
                p = o.point,
                q = o.angle,
                r = j.points._as,
                s = r.length,
                t = new nd;
                for (n = new Sb(e, 0, 0, f, p.x, p.y), l = 0; s > l; l++) t.add(n.transform(r[l]));
                for (n = Tb.createMatrix(q + Math.PI, p.x, p.y), l = 0; s > l; l++) m = t.get(l),
                m instanceof nd && (m = m._as),
                m instanceof Array ? (m[0] = n.transform(m[0]), m[1] = n.transform(m[1])) : t.set(l, n.transform(m));
                return Tb.getLineRect(t)
            }
        },
        drawArrow: function(a, b, c, d, e, f, g, h, i, j, k, l, m) {
            i = i || 0,
            j = j || 0,
            k = k || 0;
            var n = m._element.getStyle("arrow.from.shadow"),
            o = m._element.getStyle("arrow.from.shadow.color"),
            p = m._element.getStyle("arrow.from.shadow.xoffset"),
            q = m._element.getStyle("arrow.from.shadow.yoffset"),
            r = m._element.getStyle("arrow.from.shadow.blur"),
            s = k >= 0 && l;
            if (g || s) {
                var t = od.getShape(f);
                if (t && t.points && !(t.points && t.points.size() <= 0)) {
                    var u = Tb.calculatePointInfoAlongLine(d, e, i, j),
                    v = u.point,
                    w = u.angle;
                    g && (a.fillStyle = h),
                    a.beginPath(),
                    s && (a.lineWidth = k, a.strokeStyle = l),
                    od._drawArrow(a, t, w, v, b, c, l, o, n, p, q, r),
                    n && (a.shadowOffsetX = p, a.shadowOffsetY = q, a.shadowBlur = r, a.shadowColor = o),
                    g && a.fill(),
                    s && a.stroke()
                }
            }
        },
        _drawArrow: function(a, b, c, d, e, f, g, h, i, j, k, l) {
            if (b.draw) {
                for (var m = new Ib.List,
                n = 0; n < b.points._as.length; n++) m.add(b.points.get(n));
                m.add({
                    x: -1,
                    y: -.5
                }),
                m.add({
                    x: -1,
                    y: .5
                }),
                m.add({
                    x: 0,
                    y: .5
                }),
                m.add({
                    x: 0,
                    y: -.5
                }),
                m = m._as;
                var n, o, p, q = m.length,
                r = new nd;
                p = new Sb(e, 0, 0, f, d.x, d.y);
                for (var n = 0; q > n; n++) r.add(p.transform(m[n]));
                r = r._as,
                p = Tb.createMatrix(c + Math.PI, d.x, d.y);
                for (var s = new nd,
                n = 0; q > n; n++) s.add(p.transform(r[n]));
                b.draw && b.draw(a, {
                    points: s,
                    width: e,
                    height: f,
                    shadowColor: h,
                    shadow: i,
                    shadowXOffset: j,
                    shadowYOffset: k,
                    shadowBlur: l
                })
            } else {
                var n, o, p, m = b.points._as,
                q = m.length,
                r = new nd;
                for (p = new Sb(e, 0, 0, f, d.x, d.y), n = 0; q > n; n++) r.add(p.transform(m[n]));
                r = r._as,
                p = Tb.createMatrix(c + Math.PI, d.x, d.y);
                var t = r[0];
                for (t = p.transform(t), a.moveTo(t.x, t.y), n = 1; q > n; n++) o = r[n],
                o instanceof nd && (o = o._as),
                o instanceof Array ? (o[0] = p.transform(o[0]), o[1] = p.transform(o[1]), a.quadraticCurveTo(o[0].x, o[0].y, o[1].x, o[1].y)) : (o = p.transform(o), a.lineTo(o.x, o.y))
            }
        },
        drawLinkArrow: function(a, b, c, d) {
            c.size() < 2 || (a._element.getStyle("arrow.from") && od._drawFromArrow(a, b, c, d), a._element.getStyle("arrow.to") && od._drawToArrow(a, b, c, d))
        },
        _drawFromArrow: function(a, b, c, d) {
            var e = a._element,
            f = e.getStyle("arrow.from.fill"),
            g = e.getStyle("arrow.from.outline.width");
            if (e.getStyle("arrow.from.shadow.color"), f || g >= 0) {
                var h = e.getStyle("arrow.from.width"),
                i = e.getStyle("arrow.from.height"),
                j = e.getStyle("arrow.from.xoffset");
                if (j > 0 && 1 > j) {
                    var k;
                    k = a.getLineLength ? a.getLineLength() : a._element.getLineLength(),
                    j *= k
                } else a.getLineLength && (j += od.calculateArrowXOffsetAtEdge(c, a, !0, d));
                var l = e.getStyle("arrow.from.yoffset"),
                m = e.getStyle("arrow.from.shape");
                j = a._network._edgeDetect ? 0 : j,
                l = a._network._edgeDetect ? 0 : l,
                d && (j *= d.getLocationZoom(), l *= d.getLocationZoom()),
                od.drawArrow(b, h, i, c, !0, m, f, e.getStyle("arrow.from.color"), j, l, g, e.getStyle("arrow.from.outline.color"), a)
            }
        },
        _drawToArrow: function(a, b, c, d) {
            var e = a._element,
            f = e.getStyle("arrow.to.fill"),
            g = e.getStyle("arrow.to.outline.width");
            if (f || g >= 0) {
                var h = e.getStyle("arrow.to.width"),
                i = e.getStyle("arrow.to.height"),
                j = e.getStyle("arrow.to.xoffset");
                if (j > 0 && 1 > j) {
                    var k;
                    k = a.getLineLength ? a.getLineLength() : a._element.getLineLength(),
                    j *= k
                } else a.getLineLength && (j += od.calculateArrowXOffsetAtEdge(c, a, !1));
                var l = e.getStyle("arrow.to.yoffset"),
                m = e.getStyle("arrow.to.shape");
                d && (j *= d.getLocationZoom(), l *= d.getLocationZoom()),
                j = a._network._edgeDetect ? 0 : j,
                l = a._network._edgeDetect ? 0 : l,
                od.drawArrow(b, h, i, c, !1, m, f, e.getStyle("arrow.to.color"), j, l, g, e.getStyle("arrow.to.outline.color"), a)
            }
        },
        calculateArrowXOffsetAtEdge: function(a, b, c, d) {
            if (null == a || a.size() < 2) return 0;
            var e = b._element,
            f = e.getStyle(c ? "arrow.from.at.edge": "arrow.to.at.edge");
            if (!f) return 0;
            var g = b._network.getElementUI(c ? e.getFromAgent() : e.getToAgent());
            if (!g) return 0;
            if (d) var h = g.getZoomBodyRect();
            else var h = g._bodyRect;
            if (null == h) return 0;
            for (var i = Tb._getPoint(a.get(c ? 0 : a.size() - 1)), j = 0, k = b.getLineLength(); od._containsByInt(h, Math.floor(i.x), Math.floor(i.y), !1) && k > j;) i = Tb.calculatePointInfoAlongLine(a, c, j++).point;
            return j
        },
        _containsByInt: function(a, c, d, e) {
            return e = e === b ? !0 : e,
            e ? c >= Math.floor(a.x) && c <= Math.floor(a.x + a.width) && d >= Math.floor(a.y) && d <= Math.floor(a.y + a.height) : c > Math.floor(a.x) && c < Math.floor(a.x + a.width) && d > Math.floor(a.y) && d < Math.floor(a.y + a.height)
        }
    };
    od.init(),
    Jb.arrow = od,
    Ib.EventDispatcher = function() {},
    Jb.ext("twaver.EventDispatcher", null, {
        contains: function(a, b) {
            if (this._ls) for (var c, d = 0,
            e = this._ls.size(); e > d; d++) if (c = this._ls.get(d), a === c.l && b === c.s) return ! 0;
            return ! 1
        },
        add: function(a, b, c) {
            var d = {
                l: a,
                s: b,
                a: c
            };
            this._ls || (this._ls = new nd),
            this._f ? (this._addPendings || (this._addPendings = new nd), this._addPendings.add(d)) : d.a ? this._ls.add(d, 0) : this._ls.add(d)
        },
        remove: function(a, b) {
            this._ls && (this._f ? (this._removePendings || (this._removePendings = new nd), this._removePendings.add({
                l: a,
                s: b
            })) : this._remove(a, b))
        },
        _remove: function(a, b) {
            for (var c, d = 0,
            e = this._ls.size(); e > d; d++) if (c = this._ls.get(d), c.l === a && c.s === b) return void this._ls.removeAt(d)
        },
        fire: function(a) {
            if (this._ls) {
                var b, c, d = this._ls.size();
                for (this._f = !0, b = 0; d > b; b++) c = this._ls.get(b),
                c.s ? c.l.call(c.s, a) : c.l(a);
                if (this._f = !1, this._removePendings) {
                    for (d = this._removePendings.size(), b = 0; d > b; b++) c = this._removePendings.get(b),
                    this._remove(c.l, c.s);
                    delete this._removePendings
                }
                if (this._addPendings) {
                    for (d = this._addPendings.size(), b = 0; d > b; b++) c = this._addPendings.get(b),
                    c.a ? this._ls.add(c, 0) : this._ls.add(c);
                    delete this._addPendings
                }
            }
        }
    }),
    Ib.ImageAsset = function(a, b, c, d, e) {
        this._name = a,
        this._width = c,
        this._height = d,
        this._svg = e,
        this._edgeData,
        "string" == typeof b ? this._src = b: "function" == typeof b ? this._func = b: cd(b) ? this._image = b: "object" == typeof b && (this._image = b, this._width = b.w || b.width, this._height = b.h || b.height, b.cache !== !1 && zd(b) && (xd(a, b), this._cache = Cd(b)))
    },
    Jb.ext("twaver.ImageAsset", Object, {
        getName: function() {
            return this._name
        },
        getSrc: function() {
            return this._src
        },
        isSvg: function() {
            return this._svg
        },
        getImage: function(a, b, c) {
            if (!a || !this._image) return this._image;
            this._map || (this._map = {});
            var d;
            d = this._svg && 3 === arguments.length ? a + "," + b + "," + c: a;
            var e = this._map[d];
            return e ? e: (e = ud(this._cache || this._image, sd(a), this._svg ? b: this.getWidth(), this._svg ? c: this.getHeight()), this._map[d] = e, e)
        },
        getWidth: function() {
            return this._width
        },
        getHeight: function() {
            return this._height
        },
        getFunction: function() {
            return this._func
        },
        _createEdgeData: function(a) {
            var b = 300,
            c = b / a.width;
            a.height < a.width && (c = b / a.height);
            var d = Math.floor(a.width * c),
            e = Math.floor(a.height * c);
            this.tempCanvas || (this.tempCanvas = Ob.createElement("canvas"), this.ctx = this.tempCanvas.getContext("2d")),
            this.tempCanvas.width = d,
            this.tempCanvas.height = e,
            this.ctx.clearRect(0, 0, d, e),
            this.ctx.drawImage(a, 0, 0, d, e);
            for (var f = this.ctx.getImageData(0, 0, d, e), g = !0, h = [], i = 0, j = d, k = e; k > i; i++) for (var l = 0; j > l; l++) {
                var m = 4 * (i * j + l),
                n = this._isTransparentPoint(f.data, m),
                o = g != n || !n && (0 == l || l == j - 1);
                if (o) {
                    var p = n ? 1 : 0;
                    h.push({
                        x: l - p,
                        y: i
                    })
                }
                g = n
            }
            g = !0;
            for (var l = 0,
            j = d,
            k = e; j > l; l++) for (var i = 0; k > i; i++) {
                var m = 4 * (i * j + l),
                n = this._isTransparentPoint(f.data, m),
                o = g != n || !n && (0 == i || i == k - 1);
                if (o) {
                    var p = n ? 1 : 0;
                    h.push({
                        x: l,
                        y: i - p
                    })
                }
                g = n
            }
            for (var q = j / 2,
            r = k / 2,
            s = [], t = 0; 360 > t; t++) s.push({
                x: q,
                y: r,
                dist: 0
            });
            for (var t = 0,
            u = h.length; u > t; t++) {
                var v = h[t],
                w = this._getPointAngleDegree(v.x, v.y, q, r),
                x = this._getPointDist(v.x, v.y, q, r);
                s[w].dist < x && (s[w] = {
                    x: v.x,
                    y: v.y,
                    dist: x
                })
            }
            for (var t = 0,
            u = s.length; u > t; t++) {
                var o = s[t];
                o.x = o.x / c,
                o.y = o.y / c,
                delete o.dist
            }
            return s
        },
        _isTransparentPoint: function(a, b) {
            return a[b] + a[b + 1] + a[b + 2] + a[b + 3] == 0
        },
        _getPointAngleDegree: function(a, b, c, d) {
            var e = c - a,
            f = d - b,
            g = Math.atan2(f, e);
            return g = g / Math.PI * 180,
            g = parseInt(g) + 180,
            g %= 360
        },
        _getPointDist: function(a, b, c, d) {
            var e = c - a,
            f = d - b;
            return Math.sqrt(e * e + f * f)
        }
    });
    var pd = {},
    qd = Wb.createCanvas();
    qd.width = 1,
    qd.height = 1;
    var rd = qd.getContext("2d"),
    sd = function(a) {
        a = a || "black";
        var b, c = pd[a];
        return c || (rd.clearRect(0, 0, 1, 1), rd.fillStyle = a, rd.fillRect(0, 0, 1, 1), b = rd.getImageData(0, 0, 1, 1).data, c = pd[a] = {
            r: b[0],
            g: b[1],
            b: b[2],
            a: b[3]
        }),
        c
    },
    td = function(a, b) {
        if (!b) return a;
        if (b = sd(b), a = sd(a), Dd.PIXEL_FILTER_FUNCTION) {
            var c = Dd.PIXEL_FILTER_FUNCTION(a, b);
            return "rgba(" + c.r + "," + c.g + "," + c.b + "," + a.a + ")"
        }
        return null
    },
    ud = function(a, b, c, d) {
        var e = Wb.createCanvas(c, d),
        f = e.getContext("2d");
        f.drawImage(a, 0, 0, c, d);
        try {
            for (var g = f.getImageData(0, 0, c, d), h = g.data, i = 0, j = h.length; j > i; i += 4) {
                var k = {
                    r: h[i + 0],
                    g: h[i + 1],
                    b: h[i + 2]
                },
                l = Dd.PIXEL_FILTER_FUNCTION(k, b);
                h[i + 0] = l.r,
                h[i + 1] = l.g,
                h[i + 2] = l.b
            }
            f.putImageData(g, 0, 0)
        } catch(m) {
            return a
        }
        return e
    },
    vd = {},
    wd = function(a, b) {
        if (a) {
            var c = typeof a;
            "string" === c && (a.match(Xc) || Jb.images[a] || (vd[a] || (vd[a] = [])).push(b))
        }
    },
    xd = function(a, b) {
        b.pattern && wd(b.pattern, a),
        b.v && b.v.forEach(function(b) {
            b.pattern && wd(b.pattern, a)
        })
    },
    yd = function(a) {
        var b = vd[a];
        b && (b.forEach(function(a) {
            var b = Jb.images[a];
            b._cache = Cd(b._image)
        }), delete vd[a])
    },
    zd = function(a) {
        return a.w && a.h ? Ad(a) : !1
    },
    Ad = function(a) {
        return ! Object.keys(a).some(function(b) {
            if (/^on/.test(b)) return ! 1;
            var c = a[b],
            d = Bd(c);
            return d || "v" !== b || (d = c.some(function(a) {
                if ("draw" === a.shape) return ! 0;
                if ("vector" === a.shape) {
                    var b = Jb.images[a.name];
                    if (b && !b._cache) return ! 0
                }
                var c = Object.keys(a).some(function(b) {
                    return "state" === b || "animate" === b ? !0 : Bd(a[b])
                });
                return c ? !0 : "g" === a.shape && a.v && a.v.length ? !Ad(a) : !1
            })),
            d
        })
    },
    Bd = function(a) {
        var b = typeof a;
        return "string" === b && a.match(Xc) || "function" === b
    },
    Cd = function(a) {
        var b = Wb.createCanvas(a.w, a.h),
        c = b.getContext("2d");
        return Oc(c, a, null, {
            x: 0,
            y: 0,
            width: a.w,
            height: a.h
        }),
        b
    },
    Dd = {
        COLORS: ["#6495ED", "#FFFF00", "#00FFFF", "#FF0000", "#7FFF00", "#E0A580", "#5FC0CB", "#FA00F0", "#A1BC50", "#FFD700", "#4169E1", "#E5A5F5", "#1E90FF", "#696969", "#FF6347", "#00BFEF", "#FFD700", "#80E090", "#5F9EA0", "#A000FF", "#7FAF00", "#228BA2", "#FF00FF", "#7FFFD4", "#800000", "#0000CD", "#20B2AA", "#D2691E", "#6495BD", "#DC143C", "#F0A8AF", "#008B8B", "#800080", "#B8860B", "#4B0082", "#00FF00", "#FFA500", "#FF4500", "#FFFF00", "#9ACD32", "#00008B", "#FF1493", "#ADFF2F", "#4682B4", "#00C0B1"],
        CALL_LATER_DELAY: 17,
        SCROLL_BAR_WIDTH: 17,
        SELECT_COLOR: "#C2CFF1",
        FOCUS_ON_CLICK: !0,
        VIEW_POSITION: "absolute",
        VIEW_FONT_SIZE: "12px",
        VIEW_FONT_FAMILY: "arial, tahoma, helvetica, sans-serif",
        TOOLTIP_BACKGROUND: "lightyellow",
        TOOLTIP_FONT_SIZE: "12px",
        TOOLTIP_COLOR: "black",
        TOOLTIP_PADDING: "4px 8px",
        TOOLTIP_BORDER: "1px solid gray",
        TOOLTIP_BORDER_RADIUS: "6px",
        TOOLTIP_XOFFSET: 12,
        TOOLTIP_YOFFSET: 12,
        TOOLTIP_BOX_SHADOW: "0px 0px 3px #AAA",
        TOOLTIP_ZINDEX: 1e5,
        TOOLTIP_INITIAL_DELAY: 750,
        TOOLTIP_RESHOW_DELAY: 500,
        TOOLTIP_DISMISS_DELAY: 4e3,
        ZOOM_MAX: 5,
        ZOOM_MIN: .1,
        ZOOM_INCREMENT: 1.3,
        ZOOM_ANIMATE: !0,
        COLUMN_INNER_TEXT: !0,
        COLUMN_WIDTH: 80,
        COLUMN_HORIZONTAL_ALIGN: "",
        COLUMN_PROPERTY_TYPE: "accessor",
        COLUMN_VALUE_TYPE: "string",
        COLUMN_EDITABLE: !1,
        COLUMN_SORTABLE: !0,
        COLUMN_VISIBLE: !0,
        COLUMN_RESIZABLE: !0,
        COLUMN_MOVABLE: !0,
        COLUMN_RENDER_CELL: null,
        COLUMN_RENDER_HEADER: null,
        PROPERTY_INNER_TEXT: !0,
        PROPERTY_HORIZONTAL_ALIGN: "",
        PROPERTY_PROPERTY_TYPE: "accessor",
        PROPERTY_VALUE_TYPE: "string",
        PROPERTY_EDITABLE: !1,
        PROPERTY_CATEGORY_NAME: null,
        PROPERTY_RENDER_NAME: null,
        PROPERTY_RENDER_VALUE: null,
        PROPERTY_RENDER_EDITOR: null,
        TAB_WIDTH: 100,
        TAB_CLOSABLE: !1,
        TAB_RESIZABLE: !0,
        TAB_MOVABLE: !0,
        TAB_DISABLED: !1,
        TAB_VISIBLE: !0,
        ACCORDION_EXPAND_ICON: "expand_icon",
        ACCORDION_COLLAPSE_ICON: "collapse_icon",
        ACCORDION_TITLE_HEIGHT: 20,
        ACCORDION_TITLE_BACKGROUND: "#EBEBEB",
        ACCORDION_BORDER_BOTTOM_COLOR: "lightgray",
        ACCORDION_ICON_POSITION: "left",
        TITLEPANE_TITLE_HEIGHT: 20,
        TITLEPANE_TITLE_BACKGROUND: "#DDD",
        TITLEPANE_TITLE_HORIZONTAL_ALIGN: "left",
        BORDERPANE_HGAP: 0,
        BORDERPANE_VGAP: 0,
        CHARTPANE_TITLE_HEIGHT: 20,
        CHARTPANE_TITLE_HORIZONTAL_ALIGN: "center",
        CHARTPANE_LEGEND_ORIENTATION: "bottom",
        CHARTPANE_LEGEND_WIDTH: 80,
        LEGENDPANE_ICON_WIDTH: 10,
        LEGENDPANE_ICON_HEIGHT: 10,
        LEGENDPANE_ICON_RADIUS: 0,
        LEGENDPANE_ROW_HEIGHT: 20,
        LEGENDPANE_ORIENTATION: "horizontal",
        LEGENDPANE_HIDDEN_COLOR: "#BABBBC",
        LEGENDPANE_SELECT_BACKGROUND_COLOR: "#00007D",
        LEGENDPANE_SELECT_FOREGROUND_COLOR: "#FFFFFF",
        CHART_TOOLTIP_ENABLED: !0,
        CHART_SELECT_TOLERANCE: 0,
        CHART_XGAP: 6,
        CHART_YGAP: 6,
        CHART_XZOOM_ENABLED: !0,
        CHART_YZOOM_ENABLED: !0,
        CHART_XTRANSLATE_ENABLED: !0,
        CHART_YTRANSLATE_ENABLED: !0,
        CHART_DOUBLE_CLICK_TO_RESET: !0,
        CHART_VALUE_VISIBLE: !0,
        CHART_VALUE_FONT: null,
        CHART_BACKGROUND_VISIBLE: !1,
        CHART_BACKGROUND_FILL: !0,
        CHART_BACKGROUND_FILL_COLOR: "rgba(50,50,50,0.11)",
        CHART_BACKGROUND_OUTLINE_WIDTH: 1,
        CHART_BACKGROUND_OUTLINE_COLOR: "rgba(50,50,50,0.11)",
        CHART_BACKGROUND_GRADIENT: "linear.north",
        CHART_BACKGROUND_GRADIENT_COLOR: "#FFFFFF",
        PIECHART_TYPE: "oval",
        PIECHART_START_ANGLE: 0,
        PIECHART_SELECT_OFFSET: 5,
        PIECHART_SHADOW_OFFSET: 1,
        PIECHART_SHADOW_COLOR: "#C2CFF1",
        PIECHART_LINE_RATE: .5,
        PIECHART_DONUT_RATE: .5,
        PIECHART_VALUE_POSITION: .5,
        BARCHART_TYPE: "default",
        BARCHART_UPPER_LIMIT: null,
        BARCHART_LOWER_LIMIT: 0,
        BARCHART_XAXIS_LINE_COLOR: "#808080",
        BARCHART_XAXIS_LINE_WIDTH: 1,
        BARCHART_XAXIS_TEXT_COLOR: "#000000",
        BARCHART_XAXIS_TEXT_FONT: null,
        BARCHART_YAXIS_LINE_COLOR: "#808080",
        BARCHART_YAXIS_LINE_WIDTH: 1,
        BARCHART_YAXIS_TEXT_COLOR: "#000000",
        BARCHART_YAXIS_TEXT_FONT: null,
        BARCHART_XSCALE_TEXT_FONT: null,
        BARCHART_XSCALE_TEXT_COLOR: "#000000",
        BARCHART_XSCALE_TEXT_ORIENTATION: "horizontal",
        BARCHART_YSCALE_TEXT_VISIBLE: !0,
        BARCHART_YSCALE_TEXT_COLOR: "#000000",
        BARCHART_YSCALE_TEXT_FONT: null,
        BARCHART_YSCALE_LINE_COLOR: "#808080",
        BARCHART_YSCALE_LINE_WIDTH: .3,
        BARCHART_YSCALE_VALUE_GAP: 0,
        BARCHART_YSCALE_PIXEL_GAP: 20,
        BARCHART_YSCALE_MIN_TEXT_VISIBLE: !1,
        LINECHART_INTERRUPTABLE: !0,
        LINECHART_UPPER_LIMIT: null,
        LINECHART_LOWER_LIMIT: null,
        LINECHART_XAXIS_LINE_COLOR: "#808080",
        LINECHART_XAXIS_LINE_WIDTH: 1,
        LINECHART_XAXIS_TEXT_COLOR: "#000000",
        LINECHART_XAXIS_TEXT_FONT: null,
        LINECHART_YAXIS_LINE_COLOR: "#808080",
        LINECHART_YAXIS_LINE_WIDTH: 1,
        LINECHART_YAXIS_TEXT_COLOR: "#000000",
        LINECHART_YAXIS_TEXT_FONT: null,
        LINECHART_XSCALE_TEXT_FONT: null,
        LINECHART_XSCALE_TEXT_COLOR: "#000000",
        LINECHART_XSCALE_TEXT_ORIENTATION: "horizontal",
        LINECHART_XSCALE_LINE_COLOR: "#808080",
        LINECHART_XSCALE_LINE_WIDTH: .3,
        LINECHART_YSCALE_TEXT_VISIBLE: !0,
        LINECHART_YSCALE_TEXT_COLOR: "#000000",
        LINECHART_YSCALE_TEXT_FONT: null,
        LINECHART_YSCALE_LINE_COLOR: "#808080",
        LINECHART_YSCALE_LINE_WIDTH: .3,
        LINECHART_YSCALE_VALUE_GAP: 0,
        LINECHART_YSCALE_PIXEL_GAP: 20,
        LINECHART_YSCALE_MIN_TEXT_VISIBLE: !1,
        LINECHART_VALUESPANCOUNT: 1,
        BUBBLECHART_UPPER_LIMIT: null,
        BUBBLECHART_LOWER_LIMIT: null,
        BUBBLECHART_XAXIS_UPPER_LIMIT: null,
        BUBBLECHART_XAXIS_LOWER_LIMIT: null,
        BUBBLECHART_XAXIS_LINE_COLOR: "#808080",
        BUBBLECHART_XAXIS_LINE_WIDTH: 1,
        BUBBLECHART_XAXIS_TEXT_COLOR: "#000000",
        BUBBLECHART_XAXIS_TEXT_FONT: null,
        BUBBLECHART_YAXIS_LINE_COLOR: "#808080",
        BUBBLECHART_YAXIS_LINE_WIDTH: 1,
        BUBBLECHART_YAXIS_TEXT_COLOR: "#000000",
        BUBBLECHART_YAXIS_TEXT_FONT: null,
        BUBBLECHART_XSCALE_TEXT_FONT: null,
        BUBBLECHART_XSCALE_TEXT_COLOR: "#000000",
        BUBBLECHART_XSCALE_TEXT_ORIENTATION: "horizontal",
        BUBBLECHART_XSCALE_LINE_COLOR: "#808080",
        BUBBLECHART_XSCALE_LINE_WIDTH: .3,
        BUBBLECHART_YSCALE_TEXT_VISIBLE: !0,
        BUBBLECHART_YSCALE_TEXT_COLOR: "#000000",
        BUBBLECHART_YSCALE_TEXT_FONT: null,
        BUBBLECHART_YSCALE_LINE_COLOR: "#808080",
        BUBBLECHART_YSCALE_LINE_WIDTH: .3,
        BUBBLECHART_YSCALE_VALUE_GAP: 0,
        BUBBLECHART_YSCALE_PIXEL_GAP: 20,
        BUBBLECHART_YSCALE_MIN_TEXT_VISIBLE: !1,
        BUBBLECHART_SELECT_SHADOW_COLOR: "#000000",
        BUBBLECHART_SELECT_SHADOW_OFFSET: 3,
        RADARCHART_AXIS_TEXT_FONT: null,
        RADARCHART_AXIS_TEXT_COLOR: "#000000",
        RADARCHART_AXIS_TEXT_VISIBLE: !0,
        RADARCHART_SCALE_TEXT_FONT: null,
        RADARCHART_SCALE_TEXT_COLOR: "#000000",
        RADARCHART_SCALE_TEXT_VISIBLE: !0,
        RADARCHART_AXIS_VISIBLE: !0,
        RADARCHART_AXIS_LINE_COLOR: "#808080",
        RADARCHART_AXIS_LINE_WIDTH: 3,
        RADARCHART_AXIS_START_ANGLE: 0,
        RADARCHART_RING_VISIBLE: !0,
        RADARCHART_RING_TYPE: "line",
        RADARCHART_RING_LINE_COLOR: "#808080",
        RADARCHART_RING_LINE_WIDTH: 1,
        RADARCHART_SCALE_COUNT: 5,
        RADARCHART_SCALE_MAXVALUE: 1,
        RADARCHART_SCALE_MINVALUE: 0,
        RADARCHART_ANCHOR_VISIBLE: !0,
        RADARCHART_AREA_FILL: !0,
        RADARCHART_AREA_FILL_ALPHA: .2,
        RADARCHART_AREA_SELECT_FILL_ALPHA: .5,
        DIALCHART_UPPER_LIMIT: 100,
        DIALCHART_LOWER_LIMIT: 0,
        DIALCHART_START_ANGLE: 0,
        DIALCHART_END_ANGLE: 360,
        DIALCHART_INNER_RADIUS: .8,
        DIALCHART_COLOR_RANGE_FILL_COLOR: "#808080",
        DIALCHART_OUTLINE_WIDTH: 0,
        DIALCHART_OUTLINE_COLOR: "#808080",
        DIALCHART_SCALE_INSIDE: !0,
        DIALCHART_MAJOR_SCALE_COUNT: 11,
        DIALCHART_MAJOR_SCALE_LINE_WIDTH: 2,
        DIALCHART_MAJOR_SCALE_LINE_LENGTH: 8,
        DIALCHART_MAJOR_SCALE_LINE_COLOR: "#000000",
        DIALCHART_MINOR_SCALE_COUNT: 4,
        DIALCHART_MINOR_SCALE_LINE_WIDTH: 1,
        DIALCHART_MINOR_SCALE_LINE_LENGTH: 4,
        DIALCHART_MINOR_SCALE_LINE_COLOR: "#000000",
        DIALCHART_SCALE_TEXT_VISIBLE: !0,
        DIALCHART_SCALE_UPPER_LIMIT_TEXT_VISIBLE: !0,
        DIALCHART_SCALE_LOWER_LIMIT_TEXT_VISIBLE: !0,
        DIALCHART_SCALE_TEXT_FONT: null,
        DIALCHART_SCALE_TEXT_COLOR: "#000000",
        DIALCHART_PIVOT_RADIUS: 10,
        DIALCHART_PIVOT_FILL: !0,
        DIALCHART_PIVOT_FILL_COLOR: "#808080",
        DIALCHART_PIVOT_OUTLINE_WIDTH: 0,
        DIALCHART_PIVOT_OUTLINE_COLOR: "#808080",
        DIALCHART_VALUE_POSITION: .5,
        DIALCHART_INNER_DARKER_RADIUS: 10,
        DIALCHART_OUTER_BRIGHTER_RADIUS: 10,
        DIALCHART_SELECT_SHADOW_COLOR: "#000000",
        DIALCHART_SELECT_SHADOW_OFFSET: 3,
        TABPANE_TAB_GAP: 1,
        TABPANE_TAB_RADIUS: 0,
        TABPANE_TAB_HEIGHT: 24,
        TABPANE_TAB_ORIENTATION: "top",
        TABPANE_RESIZE_TOLERANCE: 3,
        TABPANE_TAB_BACKGROUND: "#EBEBEB",
        TABPANE_DISABLED_COLOR: "#BABBBC",
        TABPANE_SELECT_BACKGROUND: "white",
        TABPANE_MOVE_BACKGROUND: "rgba(184,211,240,0.7)",
        TABPANE_INSERT_BACKGROUND: "orange",
        TABPANE_HORIZONTAL_ALIGN: "center",
        TABPANE_CLOSE_ICON: "close_icon",
        TABPANE_SELECT_NEXT_ON_CLOSE: !0,
        TABPANE_SELECT_NEXT_ON_INVISIBLE: !0,
        LISTBASE_INNER_TEXT: !0,
        LIST_ROW_HEIGHT: 19,
        LIST_INDENT: 2,
        LIST_ROW_LINE_WIDTH: 0,
        LIST_ROW_LINE_COLOR: "#DDD",
        LIST_MAKE_VISIBLE_ON_SELECTED: !0,
        LIST_KEYBOARD_REMOVE_ENABLED: !0,
        LIST_KEYBOARD_SELECT_ENABLED: !0,
        TREE_ROW_HEIGHT: 19,
        TREE_INDENT: 16,
        TREE_ROW_LINE_WIDTH: 0,
        TREE_ROW_LINE_COLOR: "#DDD",
        TREE_MAKE_VISIBLE_ON_SELECTED: !0,
        TREE_KEYBOARD_REMOVE_ENABLED: !0,
        TREE_KEYBOARD_SELECT_ENABLED: !0,
        TREE_EXPAND_ICON: "expand_icon",
        TREE_COLLAPSE_ICON: "collapse_icon",
        TREE_LINE_TYPE: "none",
        TREE_LINE_THICKNESS: 2,
        TREE_LINE_COLOR: "#000000",
        TREE_LINE_ALPHA: 1,
        TREE_LINE_DASH: [4, 2],
        TREE_TOOLTIP_ENABLED: !0,
        TABLE_ROW_HEIGHT: 19,
        TABLE_ROW_LINE_WIDTH: 1,
        TABLE_ROW_LINE_COLOR: "#DDD",
        TABLE_COLUMN_LINE_WIDTH: 1,
        TABLE_COLUMN_LINE_COLOR: "#DDD",
        TABLE_MAKE_VISIBLE_ON_SELECTED: !0,
        TABLE_KEYBOARD_REMOVE_ENABLED: !0,
        TABLE_KEYBOARD_SELECT_ENABLED: !0,
        TABLE_EDITABLE: !1,
        TABLEHEADER_HEIGHT: 24,
        TABLEHEADER_RESIZE_TOLERANCE: 3,
        TABLEHEADER_BACKGROUND: "#EBEBEB",
        TABLEHEADER_MOVE_BACKGROUND: "rgba(184,211,240,0.7)",
        TABLEHEADER_INSERT_BACKGROUND: "orange",
        TABLEHEADER_COLUMN_LINE_COLOR: "#DDD",
        TABLEHEADER_SORT_DESC_ICON: "sort_desc",
        TABLEHEADER_SORT_ASC_ICON: "sort_asc",
        TABLEHEADER_SORT_ICON_POSITION: "98% 50%",
        TREETABLE_ROW_HEIGHT: 19,
        TREETABLE_INDENT: 16,
        TREETABLE_ROW_LINE_WIDTH: 1,
        TREETABLE_ROW_LINE_COLOR: "#DDD",
        TREETABLE_COLUMN_LINE_WIDTH: 1,
        TREETABLE_COLUMN_LINE_COLOR: "#DDD",
        TREETABLE_MAKE_VISIBLE_ON_SELECTED: !0,
        TREETABLE_KEYBOARD_REMOVE_ENABLED: !0,
        TREETABLE_KEYBOARD_SELECT_ENABLED: !0,
        TREETABLE_EXPAND_ICON: "expand_icon",
        TREETABLE_COLLAPSE_ICON: "collapse_icon",
        TREETABLE_EDITABLE: !1,
        PROPERTYSHEET_AUTO_ADJUSTABLE: !0,
        PROPERTYSHEET_INDENT: 16,
        PROPERTYSHEET_ROW_HEIGHT: 19,
        PROPERTYSHEET_ROW_LINE_WIDTH: 1,
        PROPERTYSHEET_COLUMN_LINE_WIDTH: 1,
        PROPERTYSHEET_BORDER_COLOR: "#EBEBEB",
        PROPERTYSHEET_EXPAND_ICON: "expand_icon",
        PROPERTYSHEET_COLLAPSE_ICON: "collapse_icon",
        PROPERTYSHEET_PROPERTY_NAME_WIDTH: 100,
        PROPERTYSHEET_PROPERTY_NAME_HORIZONTAL_ALIGN: "",
        PROPERTYSHEET_SUM_WIDTH: 200,
        PROPERTYSHEET_RESIZE_TOLERANCE: 3,
        PROPERTYSHEET_EDITABLE: !1,
        PROPERTYSHEET_CATEGORIZABLE: !0,
        PROPERTYSHEET_EXPAND_CATEGORY: !0,
        POPUPMENU_SUBNENU_ENABLE_ICON: "submenu_enable_icon",
        POPUPMENU_SUBNENU_DISABLE_ICON: "submenu_disable_icon",
        POPUPMENU_CHECKBOX_SELECTED_ICON: "checkbox_selected_icon",
        POPUPMENU_CHECKBOX_UNSELECTED_ICON: "checkbox_unselected_icon",
        POPUPMENU_RADIOBUTTON_SELECTED_ICON: "radiobutton_selected_icon",
        POPUPMENU_RADIOBUTTON_UNSELECTED_ICON: "radiobutton_unselected_icon",
        SPLITPANE_ORIENTATION: "horizontal",
        SPLITPANE_POSITION: .5,
        SPLITPANE_DIVIDER_WIDTH: 6,
        SPLITPANE_DIVIDER_BACKGROUND: "#CCCCFF",
        SPLITPANE_DIVIDER_OPACITY: .5,
        SPLITPANE_MASK_BACKGROUND: "",
        NODE_WIDTH: 50,
        NODE_HEIGHT: 50,
        IMAGE_NODE: "node_image",
        IMAGE_GROUP: "group_image",
        IMAGE_SUBNETWORK: "subnetwork_image",
        ICON_DATABOX: "databox_icon",
        ICON_DATA: "data_icon",
        ICON_NODE: "node_icon",
        ICON_LINK: "link_icon",
        ICON_GROUP: "group_icon",
        ICON_SUBNETWORK: "subnetwork_icon",
        ICON_GRID: "grid_icon",
        ICON_BUS: "bus_icon",
        ICON_SHAPENODE: "shapenode_icon",
        ICON_SHAPELINK: "shapelink_icon",
        ICON_LINKSUBNETWORK: "linksubnetwork_icon",
        ICON_SHAPESUBNETWORK: "shapesubnetwork_icon",
        LAYER_DEFAULT_ID: "default",
        LAYER_DEFAULT_NAME: "default",
        ATTACHMENT_POINTER_LENGTH: 10,
        ATTACHMENT_POINTER_WIDTH: 8,
        ATTACHMENT_CORNER_RADIUS: 5,
        ATTACHMENT_CONTENT_WIDTH: 30,
        ATTACHMENT_CONTENT_HEIGHT: 20,
        ATTACHMENT_POSITION: "topright.topright",
        ATTACHMENT_XOFFSET: 0,
        ATTACHMENT_YOFFSET: 0,
        ATTACHMENT_PADDING: 0,
        ATTACHMENT_PADDING_LEFT: 0,
        ATTACHMENT_PADDING_RIGHT: 0,
        ATTACHMENT_PADDING_TOP: 0,
        ATTACHMENT_PADDING_BOTTOM: 0,
        ATTACHMENT_DIRECTION: "right",
        ATTACHMENT_FILL: !1,
        ATTACHMENT_FILL_COLOR: "#000000",
        ATTACHMENT_GRADIENT: null,
        ATTACHMENT_GRADIENT_COLOR: "#FFFFFF",
        ATTACHMENT_OUTLINE_WIDTH: -1,
        ATTACHMENT_OUTLINE_COLOR: "#000000",
        ATTACHMENT_CAP: "butt",
        ATTACHMENT_JOIN: "miter",
        ATTACHMENT_SHADOWABLE: !0,
        NETWORK_TOOLTIP_ENABLED: !0,
        NETWORK_SELECT_MODE: "mix",
        NETWORK_MAKE_VISIBLE_ON_SELECTED: !0,
        NETWORK_NO_AGENT_LINK_VISIBLE: !1,
        NETWORK_REMOVE_ELEMENTUI_ON_INVISIBLE: !1,
        NETWORK_SUBNETWORK_ANIMATE: !0,
        NETWORK_SENDTOTOP_ON_SELECTED: !0,
        NETWORK_KEYBOARD_REMOVE_ENABLED: !0,
        NETWORK_KEYBOARD_SELECT_ENABLED: !0,
        NETWORK_RECT_SELECT_ENABLED: !0,
        NETWORK_DOUBLECLICK_TO_SUBNETWORK: !0,
        NETWORK_DOUBLECLICK_TO_UPSUBNETWORK: !0,
        NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK: !0,
        NETWORK_DOUBLECLICK_TO_LINKBUNDLE: !0,
        NETWORK_DOUBLECLICK_TO_GROUPEXPAND: !0,
        NETWORK_SELECT_OUTLINE_COLOR: "#2877A8",
        NETWORK_SELECT_OUTLINE_WIDTH: 1,
        NETWORK_SELECT_FILL_COLOR: "rgba(184,211,240,0.4)",
        NETWORK_LAZYMOVE_OUTLINE_COLOR: "#2877A8",
        NETWORK_LAZYMOVE_OUTLINE_WIDTH: 1,
        NETWORK_LAZYMOVE_FILL_COLOR: "rgba(184,211,240,0.4)",
        NETWORK_LAZYMOVE_FILL: !0,
        NETWORK_LAZYMOVE_ANIMATE: !0,
        NETWORK_RESIZE_POINT_SIZE: 3,
        NETWORK_RESIZE_POINT_FILL_COLOR: "#FFFFFF",
        NETWORK_RESIZE_POINT_OUTLINE_COLOR: "#000000",
        NETWORK_RESIZE_POINT_OUTLINE_WIDTH: 1,
        NETWORK_RESIZE_LINE_COLOR: "#000000",
        NETWORK_RESIZE_LINE_WIDTH: 1,
        NETWORK_RESIZE_ANIMATE: !0,
        NETWORK_EDIT_POINT_SIZE: 3,
        NETWORK_EDIT_POINT_FILL_COLOR: "#FFFF00",
        NETWORK_EDIT_POINT_OUTLINE_COLOR: "#000000",
        NETWORK_EDIT_POINT_OUTLINE_WIDTH: 1,
        NETWORK_EDIT_LINE_COLOR: "rgba(184,211,240,0.7)",
        NETWORK_EDIT_LINE_WIDTH: 2,
        NETWORK_ROTATE_POINT_SIZE: 5,
        NETWORK_ROTATE_POINT_FILL_COLOR: "#FFFF00",
        NETWORK_ROTATE_POINT_OFFSET: 15,
        NETWORK_ROTATE_POINT_OUTLINE_WIDTH: 1,
        NETWORK_ROTATE_POINT_OUTLINE_COLOR: "rgba(0,0,0,1)",
        NETWORK_ROTATE_SCALE_FILL_COLOR: "rgb(227,166,103)",
        NETWORK_ROTATE_SCALE_FONT_COLOR: "#FFFFFF",
        NETWORK_ROTATE_SCALE_WIDTH: 30,
        NETWORK_ROTATE_SCALE_HEIGHT: 20,
        NETWORK_LIMIT_ELEMENT_INPOSITIVE_LOCATION: !0,
        NETWORK_LINK_FLOW_STEPPING: 3,
        NETWORK_LINK_FLOW_COLOR: "#FF0000",
        NETWORK_LINK_FLOW_INTERVAL: 600,
        NETWORK_SELECTION_TOLERANCE: 2,
        NETWORK_TRANSPARENT_SELECTION_ENABLE: !1,
        SHOW_ALARM_IN_ATTACHMENT_DIV: !0,
        SHOW_LABEL_IN_ATTACHMENT_DIV: !1,
        SHOW_LABEL2_IN_ATTACHMENT_DIV: !1,
        SHOW_ICON_IN_ATTACHMENT_DIV: !1,
        SHOW_EDIT_IN_ATTACHMENT_DIV: !1,
        OVERVIEW_FILL_COLOR: "rgba(184,211,240,0.4)",
        OVERVIEW_OUTLINE_COLOR: "#B8D3F0",
        OVERVIEW_OUTLINE_WIDTH: 1,
        OVERVIEW_SELECT_COLOR: "#0000FF",
        OVERVIEW_SELECT_WIDTH: 1,
        OVERVIEW_PADDING: 1,
        OVERVIEW_ANIMATE: !0,
        OVERVIEW_MAX_PACKING_WIDTH: -1,
        OVERVIEW_MAX_PACKING_HEIGHT: -1,
        TOUCH_MOVE_THRESHOLD: 5,
        TOUCH_RECT_SELECT_THRESHOLD: 20,
        TOUCH_ZOOM_THRESHOLD: 30,
        LINK_BUNDLE_AGENT_FUNCTION: null,
        IS_LINK_ADJUSTED_TO_BOTTOM: !1,
        ELEMENTUI_FUNCTION: function(a, b) {
            var c = b.getElementUIClass();
            return c ? new c(a, b) : null
        },
        CANVASUI_FUNCTION: function(a, b) {
            var c = b.getCanvasUIClass();
            return c ? new c(a, b) : null
        },
        VECTORUI_FUNCTION: function(a, b) {
            var c = b.getVectorUIClass();
            return c ? new c(a, b) : null
        },
        KEEP_DEFAULT_FUNCTION: function(a) {
            return a.target.keepDefault || a.target.getAttribute("keepDefault") ? !0 : a.target.parentNode && (a.target.parentNode.keepDefault || a.target.parentNode.getAttribute("keepDefault")) ? !0 : a.shiftKey ? !0 : !1
        },
        SORT_FUNCTION: function(a, c) {
            if (a === c) return 0;
            if (null == a && null != c) return 1;
            if (null != a && null == c) return - 1;
            if (null == a && null == c) return 0;
            var d, e = typeof a,
            f = typeof c;
            return "string" === e && "string" === f && (d = a.localeCompare(c)),
            "number" === e && "number" === f && (d = a - c),
            d === b && (d = ("" + a).localeCompare("" + c)),
            d > 0 ? 1 : 0 > d ? -1 : 0
        },
        CENTER_LOCATION: !1,
        PIXEL_FILTER_FUNCTION: function(a, b) {
            if (!b) return a;
            var c = .3 * a.r + .59 * a.g + .11 * a.b;
            return {
                r: Math.floor(b.r * c / 255),
                g: Math.floor(b.g * c / 255),
                b: Math.floor(b.b * c / 255)
            }
        }
    }; !
    function() {
        var b = Dd;
        if (a.OverrideTWaverDefaults) for (var c in OverrideTWaverDefaults) b[c] = OverrideTWaverDefaults[c];
        b.FONT = b.VIEW_FONT_SIZE && b.VIEW_FONT_FAMILY ? b.VIEW_FONT_SIZE + " " + b.VIEW_FONT_FAMILY: Ob.createElement("canvas").getContext("2d").font,
        b.CHART_VALUE_FONT || (b.CHART_VALUE_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.BARCHART_XSCALE_TEXT_FONT || (b.BARCHART_XSCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.BARCHART_YSCALE_TEXT_FONT || (b.BARCHART_YSCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.BARCHART_XAXIS_TEXT_FONT || (b.BARCHART_XAXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.BARCHART_YAXIS_TEXT_FONT || (b.BARCHART_YAXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.LINECHART_XSCALE_TEXT_FONT || (b.LINECHART_XSCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.LINECHART_YSCALE_TEXT_FONT || (b.LINECHART_YSCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.LINECHART_XAXIS_TEXT_FONT || (b.LINECHART_XAXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.LINECHART_YAXIS_TEXT_FONT || (b.LINECHART_YAXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.BUBBLECHART_XAXIS_TEXT_FONT || (b.BUBBLECHART_XAXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.BUBBLECHART_YAXIS_TEXT_FONT || (b.BUBBLECHART_YAXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.BUBBLECHART_XSCALE_TEXT_FONT || (b.BUBBLECHART_XSCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.BUBBLECHART_YSCALE_TEXT_FONT || (b.BUBBLECHART_YSCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.RADARCHART_AXIS_TEXT_FONT || (b.RADARCHART_AXIS_TEXT_FONT = "12px " + b.VIEW_FONT_FAMILY),
        b.RADARCHART_SCALE_TEXT_FONT || (b.RADARCHART_SCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY),
        b.DIALCHART_SCALE_TEXT_FONT || (b.DIALCHART_SCALE_TEXT_FONT = "10px " + b.VIEW_FONT_FAMILY)
    } (),
    Ib.Defaults = Dd,
    Jb.ext("twaver.Defaults", Object, {}),
    Ib.Colors = {
        orange: "#EC6C00",
        orange_light: "#EF8200",
        orange_dark: "#EA5404",
        gray_light: "#666666",
        gray_dark: "#242424",
        green_light: "#57AB9A",
        green_dark: "#238475",
        blue_light: "#61B6D8",
        blue_dark: "#0089C1"
    },
    Ib.SerializationSettings = function() {
        var a = Ib.SerializationSettings;
        this.isDataBoxSerializable = a.isDataBoxSerializable,
        this.isLayerBoxSerializable = a.isLayerBoxSerializable,
        this.isStyleSerializable = a.isStyleSerializable,
        this.isClientSerializable = a.isClientSerializable,
        this.isImageSerializable = a.isImageSerializable,
        this._pm = Jb.clone(a._pm),
        this._sm = Jb.clone(a._sm),
        this._cm = Jb.clone(a._cm)
    },
    function() {
        var a = Ib.SerializationSettings;
        a.isDataBoxSerializable = !0,
        a.isLayerBoxSerializable = !0,
        a.isStyleSerializable = !0,
        a.isClientSerializable = !0,
        a.isImageSerializable = !0,
        a._pm = {},
        a._sm = {},
        a._cm = {},
        a.setPropertyType = function(b, c) {
            a._pm[b] = c
        },
        a.getPropertyType = function(b) {
            return a._pm[b]
        },
        a.setStyleType = function(b, c) {
            a._sm[b] = c
        },
        a.getStyleType = function(b) {
            return a._sm[b]
        },
        a.setClientType = function(b, c) {
            a._cm[b] = c
        },
        a.getClientType = function(b) {
            return a._cm[b]
        }
    } (),
    Jb.ext("twaver.SerializationSettings", Object, {
        setPropertyType: function(a, b) {
            this._pm[a] = b
        },
        getPropertyType: function(a) {
            return this._pm[a]
        },
        setStyleType: function(a, b) {
            this._sm[a] = b
        },
        getStyleType: function(a) {
            return this._sm[a]
        },
        setClientType: function(a, b) {
            this._cm[a] = b
        },
        getClientType: function(a) {
            return this._cm[a]
        }
    }),
    Ib.Styles = {
        _m: {},
        setStyle: function(a, b) {
            null == b ? delete Ib.Styles._m[a] : Ib.Styles._m[a] = b
        },
        getStyle: function(a) {
            return Ib.Styles._m[a]
        },
        getStyleProperties: function() {
            return Jb.keys(Ib.Styles._m)
        }
    },
    function() {
        var a = function(a, b) {
            Ib.SerializationSettings.setPropertyType(a, b)
        };
        a("name", "cdata"),
        a("name2", "cdata"),
        a("icon", "string"),
        a("toolTip", "cdata"),
        a("parent", "data"),
        a("layerId", "string"),
        a("alarmState", "alarmstate"),
        a("image", "string"),
        a("location", "point"),
        a("width", "number"),
        a("height", "number"),
        a("expanded", "boolean"),
        a("host", "data"),
        a("fromNode", "data"),
        a("toNode", "data"),
        a("points", "list.point"),
        a("segments", "list.string"),
        a("angle", "number"),
        a("visible", "boolean"),
        a = function(a, b, c) {
            null == c && (c = null != b ? typeof b: "string"),
            Ib.Styles.setStyle(a, b),
            Ib.SerializationSettings.setStyleType(a, c)
        },
        a("chart.color", null),
        a("chart.value", 0),
        a("chart.values", null, "list.number"),
        a("chart.value.color", "#000000"),
        a("chart.value.font", null),
        a("chart.line.width", 2),
        a("chart.marker.size", 6),
        a("chart.marker.shape", "circle"),
        a("chart.bubble.shape", "circle"),
        a("chart.names", null, "list.string"),
        a("chart.xaxis.values", null, "list.number"),
        a("chart.yaxis.values", null, "list.number"),
        a("dialchart.rear.extension", 0),
        a("dialchart.base.width", 5),
        a("dialchart.top.width", 0),
        a("dialchart.radius", .8),
        a("inner.color", null),
        a("outer.shape", "rectangle"),
        a("outer.color", null),
        a("outer.width", 2),
        a("outer.padding", 1),
        a("outer.padding.left", 0),
        a("outer.padding.right", 0),
        a("outer.padding.top", 0),
        a("outer.padding.bottom", 0),
        a("outer.cap", "butt"),
        a("outer.join", "miter"),
        a("outer.style", "border"),
        a("shadow.color", null),
        a("shadow.xoffset", 3),
        a("shadow.yoffset", 3),
        a("shadow.blur", 6),
        a("select.style", "shadow"),
        a("select.color", "rgba(0, 0, 0, 0.7)"),
        a("select.shape", "rectangle"),
        a("select.width", 2),
        a("select.padding", 2),
        a("select.padding.left", 0),
        a("select.padding.right", 0),
        a("select.padding.top", 0),
        a("select.padding.bottom", 0),
        a("select.cap", "butt"),
        a("select.join", "miter"),
        a("whole.alpha", 1),
        a("body.type", "default"),
        a("network.label", null, "cdata"),
        a("image.padding", 0),
        a("image.padding.left", 0),
        a("image.padding.right", 0),
        a("image.padding.top", 0),
        a("image.padding.bottom", 0),
        a("image.state", null),
        a("vector.shape", "rectangle"),
        a("vector.fill", !0),
        a("vector.fill.color", "#CCCCFF"),
        a("vector.outline.width", -1),
        a("vector.outline.pattern", null, "array.number"),
        a("vector.outline.color", "#5B5B5B"),
        a("vector.gradient", "none"),
        a("vector.gradient.color", "#FFFFFF"),
        a("vector.padding", 0),
        a("vector.padding.left", 0),
        a("vector.padding.right", 0),
        a("vector.padding.top", 0),
        a("vector.padding.bottom", 0),
        a("vector.cap", "butt"),
        a("vector.join", "miter"),
        a("vector.deep", 0),
        a("group.shape", "rectangle"),
        a("group.fill", !0),
        a("group.fill.color", "#CCCCFF"),
        a("group.outline.width", -1),
        a("group.outline.color", "#5B5B5B"),
        a("group.gradient", "none"),
        a("group.gradient.color", "#FFFFFF"),
        a("group.padding", 5),
        a("group.padding.left", 0),
        a("group.padding.right", 0),
        a("group.padding.top", 0),
        a("group.padding.bottom", 0),
        a("group.cap", "butt"),
        a("group.join", "miter"),
        a("group.deep", 1),
        a("group.shape.roundrect.radius", -1),
        a("label.alpha", 1),
        a("label.color", "#000000"),
        a("label.font", null),
        a("label.position", "bottom.bottom"),
        a("label.direction", "below"),
        a("label.corner.radius", 0),
        a("label.pointer.length", 0),
        a("label.pointer.width", 8),
        a("label.xoffset", 0),
        a("label.yoffset", 2),
        a("label.padding", 0),
        a("label.padding.left", 0),
        a("label.padding.right", 0),
        a("label.padding.top", 0),
        a("label.padding.bottom", 0),
        a("label.fill", !1),
        a("label.fill.color", "#C0C0C0"),
        a("label.gradient", "none"),
        a("label.gradient.color", "#FFFFFF"),
        a("label.outline.width", -1),
        a("label.outline.color", "#000000"),
        a("label.cap", "butt"),
        a("label.join", "miter"),
        a("label.shadowable", !0),
        a("label.align", "center"),
        a("link.label.rotatable", !1),
        a("label2.alpha", 1),
        a("label2.color", "#000000"),
        a("label2.font", null),
        a("label2.position", "top.top"),
        a("label2.direction", "below"),
        a("label2.corner.radius", 0),
        a("label2.pointer.length", 0),
        a("label2.pointer.width", 8),
        a("label2.xoffset", 0),
        a("label2.yoffset", -2),
        a("label2.padding", 0),
        a("label2.padding.left", 0),
        a("label2.padding.right", 0),
        a("label2.padding.top", 0),
        a("label2.padding.bottom", 0),
        a("label2.fill", !1),
        a("label2.fill.color", "#C0C0C0"),
        a("label2.gradient", "none"),
        a("label2.gradient.color", "#FFFFFF"),
        a("label2.outline.width", -1),
        a("label2.outline.color", "#000000"),
        a("label2.cap", "butt"),
        a("label2.join", "miter"),
        a("label2.shadowable", !0),
        a("link.label2.rotatable", !1),
        a("icons.names", null, "array.string"),
        a("icons.colors", null, "array.string"),
        a("icons.position", null, "array.string"),
        a("icons.orientation", null, "array.string"),
        a("icons.xoffset", [0], "array.number"),
        a("icons.yoffset", [0], "array.number"),
        a("icons.xgap", [1], "array.number"),
        a("icons.ygap", [1], "array.number"),
        a("alarm.alpha", 1),
        a("alarm.color", "#000000"),
        a("alarm.font", null),
        a("alarm.position", "hotspot"),
        a("alarm.direction", "aboveright"),
        a("alarm.corner.radius", 5),
        a("alarm.pointer.length", 10),
        a("alarm.pointer.width", 8),
        a("alarm.xoffset", 0),
        a("alarm.yoffset", 0),
        a("alarm.padding", 0),
        a("alarm.padding.left", 0),
        a("alarm.padding.right", 0),
        a("alarm.padding.top", 0),
        a("alarm.padding.bottom", 0),
        a("alarm.gradient", "none"),
        a("alarm.gradient.color", "#FFFFFF"),
        a("alarm.outline.width", -1),
        a("alarm.outline.color", "#000000"),
        a("alarm.cap", "butt"),
        a("alarm.join", "miter"),
        a("alarm.shadowable", !0),
        a("link.color", "#658DC1"),
        a("link.width", 3),
        a("link.cap", "butt"),
        a("link.join", "miter"),
        a("link.type", "arc"),
        a("link.pattern", null, "array.number"),
        a("link.extend", 20),
        a("link.control.point", null, "point"),
        a("link.bundle.id", 0),
        a("link.bundle.enable", !0),
        a("link.bundle.expanded", !0),
        a("link.bundle.independent", !1),
        a("link.bundle.offset", 20),
        a("link.bundle.gap", 12),
        a("link.bundle.group.gap", 0),
        a("link.looped.gap", 6),
        a("link.looped.direction", "northwest"),
        a("link.looped.type", "arc"),
        a("link.from.position", "center"),
        a("link.from.xoffset", 0),
        a("link.from.yoffset", 0),
        a("link.from.at.edge", !0),
        a("link.to.position", "center"),
        a("link.to.xoffset", 0),
        a("link.to.yoffset", 0),
        a("link.to.at.edge", !0),
        a("link.split.by.percent", !0),
        a("link.split.percent", .5),
        a("link.split.value", 20),
        a("link.corner", "round"),
        a("link.xradius", 8),
        a("link.yradius", 8),
        a("link.flow", !1),
        a("link.flow.converse", !1),
        a("link.handler.alpha", 1),
        a("link.handler.color", "#000000"),
        a("link.handler.font", null),
        a("link.handler.position", "topleft.topleft"),
        a("link.handler.direction", "below"),
        a("link.handler.corner.radius", 0),
        a("link.handler.pointer.length", 0),
        a("link.handler.pointer.width", 8),
        a("link.handler.xoffset", 0),
        a("link.handler.yoffset", 0),
        a("link.handler.padding", 0),
        a("link.handler.padding.left", 0),
        a("link.handler.padding.right", 0),
        a("link.handler.padding.top", 0),
        a("link.handler.padding.bottom", 0),
        a("link.handler.fill", !1),
        a("link.handler.fill.color", "#C0C0C0"),
        a("link.handler.gradient", "none"),
        a("link.handler.gradient.color", "#FFFFFF"),
        a("link.handler.outline.width", -1),
        a("link.handler.outline.color", "#000000"),
        a("link.handler.cap", "butt"),
        a("link.handler.join", "miter"),
        a("link.handler.shadowable", !0),
        a("follower.row.index", 0),
        a("follower.column.index", 0),
        a("follower.row.span", 1),
        a("follower.column.span", 1),
        a("follower.padding", 0),
        a("follower.padding.left", 0),
        a("follower.padding.right", 0),
        a("follower.padding.top", 0),
        a("follower.padding.bottom", 0),
        a("follower.fill.cell", !0),
        a("follower.cell.position", "center"),
        a("glow.blur", 20),
        a("grid.row.count", 1),
        a("grid.column.count", 1),
        a("grid.row.percents", null, "array.number"),
        a("grid.column.percents", null, "array.number"),
        a("grid.border", 1),
        a("grid.border.left", 0),
        a("grid.border.right", 0),
        a("grid.border.top", 0),
        a("grid.border.bottom", 0),
        a("grid.padding", 1),
        a("grid.padding.left", 0),
        a("grid.padding.right", 0),
        a("grid.padding.top", 0),
        a("grid.padding.bottom", 0),
        a("grid.fill", !0),
        a("grid.fill.color", "#C0C0C0"),
        a("grid.deep", 1),
        a("grid.cell.deep", -1),
        a("shapelink.type", "lineto"),
        a("shapenode.closed", !1),
        a("shapenode.pattern", null, "array.number"),
        a("bus.style", "nearby"),
        a("arrow.from", !1),
        a("arrow.from.fill", !0),
        a("arrow.from.shape", "arrow.standard"),
        a("arrow.from.color", "#000000"),
        a("arrow.from.xoffset", 0),
        a("arrow.from.yoffset", 0),
        a("arrow.from.width", 12),
        a("arrow.from.height", 9),
        a("arrow.from.outline.color", "#000000"),
        a("arrow.from.outline.width", -1),
        a("arrow.from.at.edge", !0),
        a("arrow.from.shadow", !1),
        a("arrow.from.shadow.color", "#000000"),
        a("arrow.from.shadow.xoffset", 0),
        a("arrow.from.shadow.yoffset", 0),
        a("arrow.from.shadow.blur", 16),
        a("arrow.to", !1),
        a("arrow.to.fill", !0),
        a("arrow.to.shape", "arrow.standard"),
        a("arrow.to.color", "#000000"),
        a("arrow.to.xoffset", 0),
        a("arrow.to.yoffset", 0),
        a("arrow.to.width", 12),
        a("arrow.to.height", 9),
        a("arrow.to.outline.color", "#000000"),
        a("arrow.to.outline.width", -1),
        a("arrow.to.at.edge", !0),
        a("background.image", null),
        a("background.type", "none"),
        a("background.outline.width", -1),
        a("background.outline.color", null),
        a("background.vector.padding", 0),
        a("background.image.padding", 0),
        a("background.image.stretch", "fill"),
        a("background.vector.fill", null),
        a("background.vector.fill.color", null),
        a("background.vector.gradient", !1),
        a("background.vector.gradient.color", null),
        a("background.vector.shape", "rectangle"),
        a("background.outline.pattern", null, "array.number"),
        a("attachment.label.style", "html"),
        a("attachment.label2.style", "html"),
        a("attachment.alarm.style", "html"),
        a("attachment.htmllabel.hyperlink", !1),
        a("attachment.htmllabel2.hyperlink", !1)
    } (),
    Jb.ext("twaver.Styles", Object, {}),
    Ib.PropertyChangeDispatcher = function() {
        this._dispatcher = new Ib.EventDispatcher
    },
    Jb.ext("twaver.PropertyChangeDispatcher", Object, {
        addPropertyChangeListener: function(a, b, c) {
            this._dispatcher.add(a, b, c)
        },
        removePropertyChangeListener: function(a, b) {
            this._dispatcher.remove(a, b)
        },
        firePropertyChange: function(a, b, c) {
            if (b == c) return ! 1;
            var d = {
                property: a,
                oldValue: b,
                newValue: c,
                source: this
            };
            return this._dispatcher.fire(d),
            this.onPropertyChanged(d),
            !0
        },
        onPropertyChanged: function(a) {}
    }),
    Ib.animate.Animate = function() {},
    Jb.ext("twaver.animate.Animate", Object, {
        current: 0,
        step: 8,
        delay: 4,
        finishFunction: null,
        shouldBeFinished: !1,
        getCurrentDelay: function() {
            return this.delay * this.current + 1
        },
        action: function(a) {}
    }),
    Ib.animate.AnimateProperty = function(a, b, c) {
        this.objects = a,
        this.newValues = b,
        this.finishFunction = c,
        this.oldValues = new nd;
        for (var d = this.objects.size(), e = 0; d > e; e++) {
            var f = this.objects.get(e);
            this.oldValues.add(this.getPropertyValue(f))
        }
    },
    Jb.ext("twaver.animate.AnimateProperty", Ib.animate.Animate, {
        action: function(a) {
            for (var b = this.objects.size(), c = 0; b > c; c++) {
                var d = this.objects.get(c),
                e = this.oldValues.get(c),
                f = this.newValues.get(c);
                this.currentAction(d, e, f, a)
            }
        },
        getPropertyValue: function(a) {},
        currentAction: function(a, b, c, d) {}
    }),
    Ib.animate.AnimateBounds = function(a, b, c) {
        this.node = a,
        this.newBounds = b,
        this.oldBounds = a.getRect(),
        this.finishFunction = c
    },
    Jb.ext("twaver.animate.AnimateBounds", Ib.animate.Animate, {
        shouldBeFinished: !0,
        action: function(a) {
            var b = this.oldBounds,
            c = this.newBounds;
            this.node.setLocation(b.x + (c.x - b.x) * a, b.y + (c.y - b.y) * a),
            this.node.setSize(b.width + (c.width - b.width) * a, b.height + (c.height - b.height) * a)
        }
    }),
    Ib.animate.AnimateCenterLocation = function(a, b, c) {
        Ib.animate.AnimateCenterLocation.superClass.constructor.call(this, a, b, c)
    },
    Jb.ext("twaver.animate.AnimateCenterLocation", Ib.animate.AnimateProperty, {
        getPropertyValue: function(a) {
            return a.getCenterLocation()
        },
        currentAction: function(a, b, c, d) {
            var e = b.x + (c.x - b.x) * d,
            f = b.y + (c.y - b.y) * d;
            a.setCenterLocation(e, f)
        }
    }),
    Ib.animate.AnimateLocation = function(a, b, c) {
        Ib.animate.AnimateLocation.superClass.constructor.call(this, a, b, c)
    },
    Jb.ext("twaver.animate.AnimateLocation", Ib.animate.AnimateProperty, {
        getPropertyValue: function(a) {
            return a.getLocation()
        },
        currentAction: function(a, b, c, d) {
            var e = b.x + (c.x - b.x) * d,
            f = b.y + (c.y - b.y) * d;
            a.setLocation(e, f)
        }
    }),
    Ib.animate.AnimateScrollPosition = function(a, b, c) {
        this.view = a,
        this.oldHorizontalOffset = a.scrollLeft,
        this.oldVerticalOffset = a.scrollTop,
        this.newHorizontalOffset = b,
        this.newVerticalOffset = c
    },
    Jb.ext("twaver.animate.AnimateScrollPosition", Ib.animate.Animate, {
        action: function(a) {
            this.view.scrollLeft = this.oldHorizontalOffset + (this.newHorizontalOffset - this.oldHorizontalOffset) * a,
            this.view.scrollTop = this.oldVerticalOffset + (this.newVerticalOffset - this.oldVerticalOffset) * a
        }
    }),
    Ib.animate.AnimateZoom = function(a, b, c) {
        this.view = a,
        this.oldZoom = a.getZoom(),
        this.newZoom = b,
        this.finishFunction = c
    },
    Jb.ext("twaver.animate.AnimateZoom", Ib.animate.Animate, {
        shouldBeFinished: !0,
        action: function(a) {
            this.view.setZoom(this.oldZoom + (this.newZoom - this.oldZoom) * a, !1)
        }
    }),
    Ib.animate.AnimateXZoom = function(a, b, c) {
        this.view = a,
        this.oldXZoom = a.getXZoom(),
        this.newXZoom = b,
        this.finishFunction = c
    },
    Jb.ext("twaver.animate.AnimateXZoom", Ib.animate.Animate, {
        shouldBeFinished: !0,
        action: function(a) {
            this.view.setXZoom(this.oldXZoom + (this.newXZoom - this.oldXZoom) * a, !1)
        }
    }),
    Ib.animate.AnimateYZoom = function(a, b, c) {
        this.view = a,
        this.oldYZoom = a.getYZoom(),
        this.newYZoom = b,
        this.finishFunction = c
    },
    Jb.ext("twaver.animate.AnimateYZoom", Ib.animate.Animate, {
        shouldBeFinished: !0,
        action: function(a) {
            this.view.setYZoom(this.oldYZoom + (this.newYZoom - this.oldYZoom) * a, !1)
        }
    }),
    Ib.animate.AnimateXYZoom = function(a, b, c, d) {
        this.view = a,
        this.oldXZoom = a.getXZoom(),
        this.newXZoom = b,
        this.oldYZoom = a.getYZoom(),
        this.newYZoom = c,
        this.finishFunction = d
    },
    Jb.ext("twaver.animate.AnimateXYZoom", Ib.animate.Animate, {
        shouldBeFinished: !0,
        action: function(a) {
            this.view.setXZoom(this.oldXZoom + (this.newXZoom - this.oldXZoom) * a, !1),
            this.view.setYZoom(this.oldYZoom + (this.newYZoom - this.oldYZoom) * a, !1)
        }
    }),
    Ib.animate.AnimateSubNetwork = function(a, b, c) {
        this.network = a,
        this.subNetwork = b,
        this.finishFunction = c
    },
    Jb.ext("twaver.animate.AnimateSubNetwork", Ib.animate.Animate, {
        shouldBeFinished: !0,
        action: function(a) {
            a > .5 ? (this.network.getView().style.opacity = 2 * a - 1, this.network._setCurrentSubNetwork(this.subNetwork)) : this.network.getView().style.opacity = 1 - 2 * a
        }
    }),
    Ib.animate.AnimateManager = {
        timer: null,
        animate: null,
        start: function(a, b) {
            var c = Ib.animate.AnimateManager;
            a.current < 0 && (a.current = 0),
            b ? Jb.callLater(c.startImpl, null, [a], b) : c.startImpl(a)
        },
        startImpl: function(a) {
            var b = Ib.animate.AnimateManager;
            b.animate && b.endAnimate(),
            b.animate = a,
            b.timer = setTimeout(b.tick, a.getCurrentDelay())
        },
        tick: function() {
            var a = Ib.animate.AnimateManager,
            b = a.animate;
            if (b) {
                if (b.current < 0) return void b.current++;
                b.current < b.step && (b.current++, b.action(b.current / b.step), a.timer = setTimeout(a.tick, b.getCurrentDelay())),
                b.current >= b.step && a.endAnimate()
            }
        },
        endAnimate: function() {
            var a = Ib.animate.AnimateManager;
            if (a.animate) {
                a.animate.shouldBeFinished && a.animate.current < a.animate.step && (a.animate.current = a.animate.step, a.animate.action(a.animate.current / a.animate.step));
                var b = a.animate.finishFunction;
                a.animate = null,
                a.timer && (clearTimeout(a.timer), a.timer = null),
                b && b()
            } else a.timer && (clearTimeout(a.timer), a.timer = null)
        }
    },
    Ib.DataBox = function(a) {
        Ib.DataBox.superClass.constructor.apply(this, arguments),
        1 === arguments.length && (this._name = a),
        this._dataList = new nd,
        this._dataMap = {},
        this._rootList = new nd,
        this._rootMap = {},
        this._clientMap = {},
        this._dataBoxChangeDispatcher = new Ib.EventDispatcher,
        this._dataPropertyChangeDispatcher = new Ib.EventDispatcher,
        this._hierarchyChangeDispatcher = new Ib.EventDispatcher,
        this._selectionModel = new Ib.SelectionModel(this)
    },
    Jb.ext("twaver.DataBox", Ib.PropertyChangeDispatcher, {
        IClient: !0,
        __client: 1,
        __new: 1,
        _limit: -1,
        _name: "DataBox",
        _icon: Dd.ICON_DATABOX,
        __accessor: ["name", "icon", "toolTip"],
        getSelectionModel: function() {
            return this._selectionModel
        },
        size: function() {
            return this._dataList.size()
        },
        isEmpty: function() {
            return this._dataList.isEmpty()
        },
        getLimit: function() {
            return this._limit
        },
        setLimit: function(a) {
            var b = this._limit;
            this._limit = a,
            this.firePropertyChange("limit", b, a),
            this._checkLimit()
        },
        _checkLimit: function() {
            this._limit >= 0 && this.size() > this._limit && this.removeFirst(this.size() - this._limit)
        },
        removeFirst: function(a) {
            for (0 === arguments.length && (a = 1); a > 0 && this._dataList.size() > 0;) {
                var b = this._dataList.get(0);
                this.remove(b),
                a--
            }
        },
        getSiblings: function(a) {
            if (!this.contains(a)) throw a + " dosen't belong to this dataBox";
            var b = a.getParent();
            return b ? b.getChildren() : this._rootList
        },
        getRoots: function() {
            return this._rootList
        },
        getSiblingIndex: function(a) {
            return a.getParent() ? a.getParent().getChildren().indexOf(a) : this._rootList.indexOf(a)
        },
        getDatas: function() {
            return this._dataList
        },
        getDataAt: function(a) {
            return this._dataList.get(a)
        },
        toDatas: function(a, b) {
            return this._dataList.toList(a, b)
        },
        forEach: function(a, b) {
            this._dataList.forEach(a, b)
        },
        forEachReverse: function(a, b) {
            this._dataList.forEachReverse(a, b)
        },
        forEachByDepthFirst: function(a, b, c) {
            if (b) this._depthFirst(a, b, c);
            else for (var d = this._rootList.size(), e = 0; d > e; e++) {
                var f = this._rootList.get(e);
                if (this._depthFirst(a, f, c) === !1) return
            }
        },
        _depthFirst: function(a, b, c) {
            for (var d = b.getChildrenSize(), e = 0; d > e; e++) {
                var f = b.getChildAt(e);
                if (this._depthFirst(a, f, c) === !1) return ! 1
            }
            if (c) {
                if (a.call(c, b) === !1) return ! 1
            } else if (a(b) === !1) return ! 1
        },
        forEachByBreadthFirst: function(a, b, c) {
            var d = new nd;
            for (b ? d.add(b) : this._rootList.forEach(d.add, d); d.size() > 0;) if (b = d.removeAt(0), b.getChildren().forEach(d.add, d), c) {
                if (a.call(c, b) === !1) return
            } else if (a(b) === !1) return
        },
        add: function(a, b) {
            if (a) {
                1 === arguments.length && (b = -1);
                var c = a.getId();
                if (this._dataMap.hasOwnProperty(c)) throw "Data with ID '" + c + "' already exists";
                this._dataBoxChangeDispatcher.fire({
                    kind: "preAdd",
                    data: a
                }),
                this._dataMap[c] = a,
                this._dataList.add(a),
                a.getParent() || (this._rootMap[c] = a, b >= 0 ? this._rootList.add(a, b) : this._rootList.add(a)),
                a.addPropertyChangeListener(this.handleDataPropertyChange, this, !0),
                this._dataBoxChangeDispatcher.fire({
                    kind: "add",
                    data: a
                }),
                this._checkLimit()
            }
        },
        remove: function(a) {
            this.removeById(a.getId())
        },
        removeSelection: function() {
            this._selectionModel.toSelection().forEach(function(a) {
                this.remove(a)
            },
            this)
        },
        removeById: function(a) {
            var b = this.getDataById(a);
            b && (this._dataBoxChangeDispatcher.fire({
                kind: "preRemove",
                data: b
            }), b instanceof Ib.Link && (b.setFromNode(null), b.setToNode(null)), b instanceof Kd && b.getLinks() && b.getLinks().toList().forEach(function(a) {
                this.remove(a)
            },
            this), b instanceof Kd && b.getFollowers() && b.getFollowers().toList().forEach(function(a) {
                a.setHost(null)
            }), b instanceof Ib.Follower && b.getHost() && b.setHost(null), b.toChildren().forEach(function(a) {
                this.remove(a)
            },
            this), b.getParent() && b.getParent().removeChild(b), this._dataList.remove(b), delete this._dataMap[a], this._rootMap[a] && (delete this._rootMap[a], this._rootList.remove(b)), this._dataBoxChangeDispatcher.fire({
                kind: "remove",
                data: b
            }), b.removePropertyChangeListener(this.handleDataPropertyChange, this))
        },
        clear: function() {
            if (this._dataList.size() > 0) {
                this._dataList.forEach(function(a) {
                    a.removePropertyChangeListener(this.handleDataPropertyChange, this)
                },
                this);
                var a = this._dataList.toList();
                this._dataList.clear(),
                this._dataMap = {},
                this._rootList.clear(),
                this._rootMap = {},
                this._dataBoxChangeDispatcher.fire({
                    kind: "clear",
                    datas: a
                })
            }
        },
        getDataById: function(a) {
            return this._dataMap[a]
        },
        containsById: function(a) {
            return this._dataMap.hasOwnProperty(a)
        },
        contains: function(a) {
            return a ? this._dataMap[a._id] === a: !1
        },
        moveTo: function(a, b) {
            if (!this.contains(a)) throw a + " dosen't belong to this dataBox";
            var c = this.getSiblings(a),
            d = c.indexOf(a);
            d === b || 0 > d || b >= 0 && b <= c.size() && (c.remove(a), b > c.size() && b--, c.add(a, b), this._hierarchyChangeDispatcher.fire({
                data: a,
                oldIndex: d,
                newIndex: b
            }))
        },
        moveUp: function(a) {
            var b = this.getSiblings(a);
            this.moveTo(a, b.indexOf(a) - 1)
        },
        moveDown: function(a) {
            var b = this.getSiblings(a);
            this.moveTo(a, b.indexOf(a) + 1)
        },
        moveToTop: function(a) {
            this.moveTo(a, 0)
        },
        moveToBottom: function(a) {
            var b = this.getSiblings(a);
            this.moveTo(a, b.size())
        },
        moveSelectionUp: function(a) {
            a || (a = this._selectionModel);
            var b = new nd;
            yc.findMoveUpDatas(a, b, this._rootList),
            b.forEach(this.moveUp, this)
        },
        moveSelectionDown: function(a) {
            a || (a = this._selectionModel);
            var b = new nd;
            yc.findMoveDownDatas(a, b, this._rootList),
            b.forEach(this.moveDown, this)
        },
        moveSelectionToTop: function(a) {
            a || (a = this._selectionModel);
            var b = new nd;
            yc.findMoveToTopDatas(a, b, this._rootList),
            b.forEach(this.moveToTop, this)
        },
        moveSelectionToBottom: function(a) {
            a || (a = this._selectionModel);
            var b = new nd;
            yc.findMoveToBottomDatas(a, b, this._rootList),
            b.forEach(this.moveToBottom, this)
        },
        handleDataPropertyChange: function(a) {
            var b = a.source;
            if ("parent" === a.property) {
                var c = b.getId();
                b.getParent() ? this._rootMap[c] && (delete this._rootMap[c], this._rootList.remove(b)) : this._rootMap[c] || (this._rootMap[c] = b, this._rootList.add(b))
            }
            this.onDataPropertyChanged(b, a),
            this._dataPropertyChangeDispatcher.fire(a)
        },
        onDataPropertyChanged: function(a, b) {},
        addDataBoxChangeListener: function(a, b, c) {
            this._dataBoxChangeDispatcher.add(a, b, c)
        },
        removeDataBoxChangeListener: function(a, b) {
            this._dataBoxChangeDispatcher.remove(a, b)
        },
        addDataPropertyChangeListener: function(a, b, c) {
            this._dataPropertyChangeDispatcher.add(a, b, c)
        },
        removeDataPropertyChangeListener: function(a, b) {
            this._dataPropertyChangeDispatcher.remove(a, b)
        },
        addHierarchyChangeListener: function(a, b, c) {
            this._hierarchyChangeDispatcher.add(a, b, c)
        },
        removeHierarchyChangeListener: function(a, b) {
            this._hierarchyChangeDispatcher.remove(a, b)
        },
        getRandomData: function(a) {
            if (a) {
                for (var b = new Ib.List,
                c = 0; c < this._dataList.size() - 1; c++) {
                    var d = this._dataList.get(c);
                    d instanceof a && b.add(d)
                }
                if (0 == b.size()) return null
            }
            var e = a ? b.get(parseInt(Ib.Util.random() * b.size())) : this._dataList.get(parseInt(Ib.Util.random() * this._dataList.size()));
            return e
        }
    }),
    Ib.ElementBox = function(a) {
        Ib.ElementBox.superClass.constructor.apply(this, arguments),
        this._styleMap = {},
        this._alarmBox = new Ib.AlarmBox(this),
        this._layerBox = new Ib.LayerBox(this),
        this._alarmStatePropagator = new Ib.AlarmStatePropagator(this),
        this._alarmStatePropagator.setEnable(!0),
        this._indexChangeDispatcher = new Ib.EventDispatcher,
        this._undoManager = new Ib.UndoManager(this)
    },
    Ib.ElementBox.IS_INTERESTED_ADJUSTELEMENTINDEX_PROPERTY = {
        fromAgent: 1,
        toAgent: 1,
        expanded: 1,
        parent: 1,
        host: 1
    },
    Jb.ext("twaver.ElementBox", Ib.DataBox, {
        IStyle: !0,
        __style: 1,
        _name: "ElementBox",
        add: function(a, b) {
            if (a) {
                if (!a.IElement) throw "Only IElement can be added into ElementBox";
                Ib.ElementBox.superClass.add.apply(this, arguments),
                this.adjustElementIndex(a)
            }
        },
        onDataPropertyChanged: function(a, b) {
            Ib.ElementBox.IS_INTERESTED_ADJUSTELEMENTINDEX_PROPERTY[b.property] && this.adjustElementIndex(a),
            Ib.ElementBox.superClass.onDataPropertyChanged.apply(this, arguments)
        },
        addIndexChangeListener: function(a, b, c) {
            this._indexChangeDispatcher.add(a, b, c)
        },
        removeIndexChangeListener: function(a, b) {
            this._indexChangeDispatcher.remove(a, b)
        },
        sendToTop: function(a) {
            if (this.contains(a)) {
                if (a !== this.getDatas().get(this.size() - 1)) {
                    var b = this.getDatas().indexOf(a);
                    this.getDatas().removeAt(b),
                    this.getDatas().add(a),
                    this._indexChangeDispatcher.fire({
                        element: a,
                        oldIndex: b,
                        newIndex: this.size() - 1
                    })
                }
                a instanceof Ib.Link && (a.getFromAgent() && !a.getFromAgent().isAdjustedToBottom() && this.sendToTop(a.getFromAgent()), a.getToAgent() && !a.getToAgent().isAdjustedToBottom() && this.sendToTop(a.getToAgent())),
                a instanceof Kd && a.getFollowers() && a.getFollowers().forEach(function(b) {
                    b.isRelatedTo(a) || a instanceof Ib.Follower && b.isLoopedHostOn(a) || this.sendToTop(b)
                },
                this),
                a.ISubNetwork || a instanceof Md && !a.isExpanded() || a.getChildren().forEach(function(a) {
                    a instanceof Ib.Link || this.sendToTop(a)
                },
                this)
            }
        },
        sendToBottom: function(a, b) {
            if (a !== b && this.contains(a) && (!b || this.contains(b))) {
                var c = this.getDatas().remove(a),
                d = 0;
                b && (d = this.getDatas().indexOf(b)),
                this.getDatas().add(a, d),
                c != d && (this._indexChangeDispatcher.fire({
                    element: a,
                    oldIndex: c,
                    newIndex: d
                }), !a.getParent() || a.getParent().ISubNetwork || a.getParent() instanceof Ib.Link || this.sendToBottom(a.getParent(), a))
            }
        },
        fireIndexChange: function(a, b, c) {
            this._indexChangeDispatcher.fire({
                element: a,
                oldIndex: b,
                newIndex: c
            })
        },
        adjustElementIndex: function(a) {
            this.contains(a) && (a.isAdjustedToBottom() ? (this.sendToBottom(a), a.getChildren().forEach(this.adjustElementIndex, this)) : this.sendToTop(a))
        },
        forEachByLayer: function(a, b, c) {
            var d = this.size(),
            e = this.getDatas();
            if (b) for (var f = 0; d > f; f++) {
                var g = e.get(f);
                if (this._layerBox.getLayerByElement(g) === b) if (c) {
                    if (a.call(c, g) === !1) return
                } else if (a(g) === !1) return
            } else this._layerBox.forEachByDepthFirst(function(b) {
                for (var f = 0; d > f; f++) {
                    var g = e.get(f);
                    if (this._layerBox.getLayerByElement(g) === b) if (c) {
                        if (a.call(c, g) === !1) return
                    } else if (a(g) === !1) return
                }
            },
            null, this)
        },
        forEachByLayerReverse: function(a, b, c) {
            var d = new nd;
            this.forEachByLayer(function(a) {
                d.add(a, 0)
            },
            b),
            d.forEach(a, c)
        },
        getLayerBox: function() {
            return this._layerBox
        },
        getAlarmBox: function() {
            return this._alarmBox
        },
        getAlarmStatePropagator: function() {
            return this._alarmStatePropagator
        },
        startBatch: function(a, b) {
            Ib._isInitializing = !0,
            Ib._bundleLinks = {},
            Ib._links = {},
            a.call(b);
            var c, d;
            for (var e in Ib._links) c = Ib._links[e],
            c._checkAgentNodeImpl();
            for (var e in Ib._bundleLinks) d = Ib._bundleLinks[e],
            vc.resetBundleLinks(d[0], d[1]);
            Ib._bundleLinks = null,
            Ib._links = null,
            Ib._isInitializing = !1
        },
        getUndoManager: function() {
            return this._undoManager
        }
    }),
    Ib.SelectionModel = function(a) {
        Ib.SelectionModel.superClass.constructor.apply(this, arguments),
        this._selectionMode = "multipleSelection",
        this._selectionList = new nd,
        this._selectionChangeDispatcher = new Ib.EventDispatcher,
        this._selectionMap = {},
        this._setDataBox(a)
    },
    Jb.ext("twaver.SelectionModel", Ib.PropertyChangeDispatcher, {
        getSelectionMode: function() {
            return this._selectionMode
        },
        setSelectionMode: function(a) {
            if (this._selectionMode !== a && ("noneSelection" === a || "singleSelection" === a || "multipleSelection" === a)) {
                this.clearSelection();
                var b = this._selectionMode;
                this._selectionMode = a,
                this.firePropertyChange("selectionMode", b, this._selectionMode)
            }
        },
        getDataBox: function() {
            return this._dataBox
        },
        _setDataBox: function(a) {
            if (!a) throw "dataBox can not be null";
            if (this._dataBox !== a) {
                this._dataBox && (this.clearSelection(), this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this));
                var b = this._dataBox;
                this._dataBox = a,
                this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this, !0),
                this.firePropertyChange("dataBox", b, this._dataBox)
            }
        },
        dispose: function() {
            this.clearSelection(),
            this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this)
        },
        handleDataBoxChange: function(a) {
            if ("remove" === a.kind) {
                var b = a.data;
                this.contains(b) && (this._selectionList.remove(b), delete this._selectionMap[b.getId()], this.fireSelectionChange("remove", new nd(b)))
            } else "clear" === a.kind && this.clearSelection()
        },
        getFilterFunction: function() {
            return this._filterFunction
        },
        setFilterFunction: function(a) {
            if (this._filterFunction !== a) {
                this.clearSelection();
                var b = this._filterFunction;
                this._filterFunction = a,
                this.firePropertyChange("filterFunction", b, this._filterFunction)
            }
        },
        fireSelectionChange: function(a, b, c) {
            c && (this._selectionList.forEach(function(a) {
                c.contains(a) ? c.remove(a) : c.add(a)
            }), b = c.toList()),
            this._selectionChangeDispatcher.fire({
                kind: a,
                datas: new nd(b)
            })
        },
        addSelectionChangeListener: function(a, b, c) {
            this._selectionChangeDispatcher.add(a, b, c)
        },
        removeSelectionChangeListener: function(a, b) {
            this._selectionChangeDispatcher.remove(a, b)
        },
        _filterList: function(a, b) {
            for (var c = new nd(a), d = 0; d < c.size(); d++) {
                var e = c.get(d); (this._filterFunction && !this._filterFunction(e) || b && this.contains(e) || !b && !this.contains(e) || !this._dataBox.contains(e)) && (c.removeAt(d), d--)
            }
            return c
        },
        appendSelection: function(a) {
            if ("noneSelection" !== this._selectionMode) {
                var b = this._filterList(a, !0);
                if (!b.isEmpty()) {
                    var c = null;
                    "singleSelection" === this._selectionMode && (c = new nd(this._selectionList), this._selectionList.clear(), this._selectionMap = {},
                    b = new nd(b.get(b.size() - 1)));
                    for (var d = 0; d < b.size(); d++) {
                        var e = b.get(d);
                        this._selectionList.add(e),
                        this._selectionMap[e.getId()] = e
                    }
                    this.fireSelectionChange("append", b, c)
                }
            }
        },
        removeSelection: function(a) {
            var b = this._filterList(a);
            if (0 !== b.size()) {
                for (var c = 0; c < b.size(); c++) {
                    var d = b.get(c);
                    this._selectionList.remove(d),
                    delete this._selectionMap[d.getId()]
                }
                this.fireSelectionChange("remove", b)
            }
        },
        toSelection: function(a, b) {
            return this._selectionList.toList(a, b)
        },
        getSelection: function() {
            return this._selectionList
        },
        setSelection: function(a) {
            if ("noneSelection" !== this._selectionMode && (0 !== this._selectionList.size() || null != a)) {
                var b = new nd(this._selectionList);
                this._selectionList.clear(),
                this._selectionMap = {};
                var c = this._filterList(a, !0);
                "singleSelection" === this._selectionMode && c.size() > 1 && (c = new nd(c.get(c.size() - 1)));
                for (var d = 0; d < c.size(); d++) {
                    var e = c.get(d);
                    this._selectionList.add(e),
                    this._selectionMap[e.getId()] = e
                }
                this.fireSelectionChange("set", null, b)
            }
        },
        clearSelection: function() {
            if (this._selectionList.size() > 0) {
                var a = this._selectionList.toList();
                this._selectionList.clear(),
                this._selectionMap = {},
                this.fireSelectionChange("clear", a)
            }
        },
        selectAll: function() {
            if ("noneSelection" !== this._selectionMode) {
                var a = this._dataBox.toDatas(),
                b = 0,
                c = null;
                if (this._filterFunction) for (b = 0; b < a.size(); b++) c = a.get(b),
                this._filterFunction(c) || (a.removeAt(b), b--);
                var d = new nd(this._selectionList);
                for (this._selectionList.clear(), this._selectionMap = {},
                "singleSelection" === this._selectionMode && a.size() > 1 && (a = new nd(a.get(a.size() - 1))), b = 0; b < a.size(); b++) c = a.get(b),
                this._selectionList.add(c),
                this._selectionMap[c.getId()] = c;
                this.fireSelectionChange("all", null, d)
            }
        },
        size: function() {
            return this._selectionList.size()
        },
        contains: function(a) {
            return a ? null != this._selectionMap[a.getId()] : !1
        },
        getLastData: function() {
            return this._selectionList.size() > 0 ? this._selectionList.get(this._selectionList.size() - 1) : null
        },
        getFirstData: function() {
            return this._selectionList.size() > 0 ? this._selectionList.get(0) : null
        },
        isSelectable: function(a) {
            return a ? "noneSelection" === this._selectionMode ? !1 : this._filterFunction && !this._filterFunction(a) ? !1 : !0 : !1
        }
    }),
    Ib.QuickFinder = function(a, b, c, d, e) {
        if (this._map = {},
        !a) throw "dataBox can not be null";
        if (!b) throw "propertyName can not be null";
        this._dataBox = a,
        this._propertyName = b,
        this._propertyType = c || "accessor",
        "accessor" === this._propertyType && (this._getter = Jb.getter(b)),
        this._valueFunction = d || this.getValue,
        this._filterFunction = e || this.isInterested,
        this._dataBox.forEach(this._addData, this),
        this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this, !0),
        this._dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this, !0)
    },
    Jb.ext("twaver.QuickFinder", Object, {
        _NULL_: "twaver-null-key",
        getValueFunction: function() {
            return this._valueFunction
        },
        getFilterFunction: function() {
            return this._filterFunction
        },
        handleDataBoxChange: function(a) {
            "add" === a.kind ? this._addData(a.data) : "remove" === a.kind ? this._removeData(a.data) : "clear" === a.kind && (this._map = {})
        },
        handleDataPropertyChange: function(a) {
            if (this._filterFunction.call(this, a.source)) {
                if ("accessor" === this._propertyType && this._propertyName === a.property);
                else if ("style" === this._propertyType && a.source.IStyle && "S:" + this._propertyName === a.property);
                else if ("client" !== this._propertyType || "C:" + this._propertyName !== a.property) return;
                var b = this._getMap(a.oldValue);
                b && b.remove(a.source),
                this._addData(a.source)
            }
        },
        _getMap: function(a) {
            return a = null == a ? this._NULL_: a,
            this._map[a]
        },
        find: function(a) {
            var b = this._getMap(a);
            return b ? b.toList() : new nd
        },
        findFirst: function(a) {
            var b = this._getMap(a);
            return ! b || b.isEmpty() ? null: b.get(0)
        },
        _addData: function(a) {
            if (this._filterFunction.call(this, a)) {
                var b = this._valueFunction.call(this, a),
                c = this._getMap(b);
                c || (c = new nd, b = null == b ? this._NULL_: b, this._map[b] = c),
                c.add(a)
            }
        },
        _removeData: function(a) {
            if (this._filterFunction.call(this, a)) {
                var b = this._valueFunction.call(this, a),
                c = this._getMap(b);
                c && (c.remove(a), c.isEmpty() && (b = null == b ? this._NULL_: b, delete this._map[b]))
            }
        },
        dispose: function() {
            this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this),
            this._dataBox.removeDataPropertyChangeListener(this.handleDataPropertyChange, this),
            delete this._dataBox
        },
        getDataBox: function() {
            return this._dataBox
        },
        getPropertyType: function() {
            return this._propertyType
        },
        getPropertyName: function() {
            return this._propertyName
        },
        isInterested: function(a) {
            return "style" === this._propertyType && !a.IStyle || "accessor" === this._propertyType && this._valueFunction === this.getValue && !a[this._getter] ? !1 : !0
        },
        getValue: function(a) {
            return "accessor" === this._propertyType ? a[this._getter]() : "style" === this._propertyType && a.getStyle ? a.getStyle(this._propertyName) : "client" === this._propertyType && a.getClient ? a.getClient(this._propertyName) : null
        }
    }),
    Ib.PropertyPropagator = function(a, b, c) {
        if (!a) throw "dataBox can not be null";
        if (!b) throw "propertyName can not be null";
        this._dataBox = a,
        this._propertyName = b,
        this._propertyType = c || "accessor",
        "accessor" === this._propertyType && (this._getter = Jb.getter(b), this._setter = Jb.setter(b)),
        this._enable = !1,
        this._isPropagating = !1
    },
    Jb.ext("twaver.PropertyPropagator", Object, {
        getDataBox: function() {
            return this._dataBox
        },
        getPropertyType: function() {
            return this._propertyType
        },
        getPropertyName: function() {
            return this._propertyName
        },
        isEnable: function() {
            return this._enable
        },
        setEnable: function(a) {
            this._enable !== a && (this._enable = a, this._enable ? (this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this), this._dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this), this._dataBox.forEach(function(a) {
                this.propagate(a)
            },
            this)) : (this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this), this._dataBox.removeDataPropertyChangeListener(this.handleDataPropertyChange, this)))
        },
        handleDataBoxChange: function(a) {
            a.data && this.propagate(a.data)
        },
        handleDataPropertyChange: function(a) {
            if (this.isInterestedProperty(a)) this.propagate(a.source);
            else if ("parent" === a.property) {
                var b = a.oldValue;
                b && this.propagate(b),
                this.propagate(a.source)
            }
        },
        isInterestedProperty: function(a) {
            return "accessor" === this._propertyType && this._propertyName === a.property ? !0 : "style" === this._propertyType && a.IElement && "S:" + this._propertyName === a.property ? !0 : "client" === this._propertyType && "C:" + this._propertyName === a.property ? !0 : !1
        },
        propagate: function(a) {
            a && !this._isPropagating && (this._isPropagating = !0, this.propagateToTop(a), this._isPropagating = !1)
        },
        propagateToTop: function(a) {
            for (this.propagateToParent(null, a); a && a.getParent();) this.propagateToParent(a, a.getParent()),
            a = a.getParent()
        },
        propagateToParent: function(a, b) {}
    }),
    Ib.AlarmStatePropagator = function(a) {
        Ib.AlarmStatePropagator.superClass.constructor.call(this, a, "alarmState")
    },
    Jb.ext("twaver.AlarmStatePropagator", Ib.PropertyPropagator, {
        handleDataPropertyChange: function(a) {
            "enablePropagation" === a.property ? this.propagate(a.source) : Ib.AlarmStatePropagator.superClass.handleDataPropertyChange.call(this, a)
        },
        propagateToParent: function(a, b) {
            var c = null;
            b.getChildren().forEach(function(a) {
                var b = a.getAlarmState().getHighestOverallAlarmSeverity();
                Ib.AlarmSeverity.compare(b, c) > 0 && (c = b)
            }),
            b.getAlarmState().setPropagateSeverity(c)
        }
    }),
    Ib.AlarmSeverity = function(a, b, c, d, e) {
        this.value = a,
        this.name = b,
        this.nickName = c,
        this.color = d,
        this.displayName = e
    },
    Jb.ext("twaver.AlarmSeverity", Object, {
        toString: function() {
            return this.displayName ? this.displayName: this.name
        }
    }),
    function() {
        var a = Ib.AlarmSeverity;
        a.severities = new nd,
        a._vm = {},
        a._nm = {},
        a._cp = function(a, b) {
            if (a && b) {
                var c = a.value - b.value;
                return c > 0 ? 1 : 0 > c ? -1 : 0
            }
            return a && !b ? 1 : !a && b ? -1 : 0
        },
        a.forEach = function(b, c) {
            a.severities.forEach(b, c)
        },
        a.getSortFunction = function() {
            return a._cp
        },
        a.setSortFunction = function(b) {
            a._cp = b,
            a.severities.sort(b)
        },
        a.add = function(b, c, d, e, f) {
            var g = new a(b, c, d, e, f);
            return a._vm[b] = g,
            a._nm[c] = g,
            a.severities.add(g),
            a.severities.sort(a._cp),
            g
        },
        a.remove = function(b) {
            var c = a._nm[b];
            return c && (delete a._nm[b], delete a._vm[c.value], a.severities.remove(c)),
            c
        },
        a.CRITICAL = a.add(500, "Critical", "C", "#FF0000"),
        a.MAJOR = a.add(400, "Major", "M", "#FFA000"),
        a.MINOR = a.add(300, "Minor", "m", "#FFFF00"),
        a.WARNING = a.add(200, "Warning", "W", "#00FFFF"),
        a.INDETERMINATE = a.add(100, "Indeterminate", "N", "#C800FF"),
        a.CLEARED = a.add(0, "Cleared", "R", "#00FF00"),
        a.isClearedAlarmSeverity = function(a) {
            return a ? 0 === a.value: !1
        },
        a.getByName = function(b) {
            return a._nm[b]
        },
        a.getByValue = function(b) {
            return a._vm[b]
        },
        a.clear = function() {
            a.severities.clear(),
            a._vm = {},
            a._nm = {}
        },
        a.compare = function(b, c) {
            return a._cp(b, c)
        }
    } (),
    Ib.AlarmState = function(a) {
        this._e = a,
        this._nm = {},
        this._am = {},
        this._ps = null,
        this._haa = null,
        this._hna = null,
        this._hoa = null,
        this._hta = null,
        this._hls = !1,
        this._aac = 0,
        this._nac = 0
    },
    Jb.ext("twaver.AlarmState", Object, {
        _ep: !0,
        _f: function() {
            this._c1(),
            this._c2(),
            this._c3(),
            this._c4(),
            this._c5(),
            this._c6(),
            this._c7(),
            this._e.firePropertyChange("alarmState", null, this)
        },
        getHighestAcknowledgedAlarmSeverity: function() {
            return this._haa
        },
        getHighestNewAlarmSeverity: function() {
            return this._hna
        },
        getHighestOverallAlarmSeverity: function() {
            return this._hoa
        },
        getHighestNativeAlarmSeverity: function() {
            return this._hta
        },
        hasLessSevereNewAlarms: function() {
            return this._hls
        },
        _c1: function() {
            var a = null;
            for (var b in this._am) b = Ib.AlarmSeverity.getByName(b),
            Ib.AlarmSeverity.isClearedAlarmSeverity(b) || 0 !== this.getAcknowledgedAlarmCount(b) && (a = a && Ib.AlarmSeverity.compare(a, b) > 0 ? a: b);
            this._haa = a
        },
        _c2: function() {
            var a = null;
            for (var b in this._nm) b = Ib.AlarmSeverity.getByName(b),
            Ib.AlarmSeverity.isClearedAlarmSeverity(b) || 0 !== this.getNewAlarmCount(b) && (a = a && Ib.AlarmSeverity.compare(a, b) > 0 ? a: b);
            this._hna = a
        },
        _c3: function() {
            if (!this._hna) return void(this._hls = !1);
            for (var a in this._nm) if (a = Ib.AlarmSeverity.getByName(a), !Ib.AlarmSeverity.isClearedAlarmSeverity(a) && 0 !== this.getNewAlarmCount(a) && Ib.AlarmSeverity.compare(this._hna, a) > 0) return void(this._hls = !0);
            this._hls = !1
        },
        _c4: function() {
            var a = this._haa,
            b = this._hna,
            c = this._ps;
            this._hoa = a,
            Ib.AlarmSeverity.compare(b, this._hoa) > 0 && (this._hoa = b),
            Ib.AlarmSeverity.compare(c, this._hoa) > 0 && (this._hoa = c)
        },
        _c5: function() {
            var a = this._haa,
            b = this._hna;
            this._hta = a,
            Ib.AlarmSeverity.compare(b, this._hta) > 0 && (this._hta = b)
        },
        increaseAcknowledgedAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._am[a.name];
                null == c && (c = 0),
                c += b,
                this._am[a.name] = c,
                this._f()
            }
        },
        increaseNewAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._nm[a.name];
                null == c && (c = 0),
                c += b,
                this._nm[a.name] = c,
                this._f()
            }
        },
        decreaseAcknowledgedAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._am[a.name];
                if (null == c && (c = 0), c -= b, 0 > c) throw "Alarm count can not be negative";
                this._am[a.name] = c,
                this._f()
            }
        },
        decreaseNewAlarm: function(a, b) {
            if (null == b && (b = 1), 0 !== b) {
                var c = this._nm[a.name];
                if (null == c && (c = 0), c -= b, 0 > c) throw "Alarm count can not be negative";
                this._nm[a.name] = c,
                this._f()
            }
        },
        acknowledgeAlarm: function(a) {
            this.decreaseNewAlarm(a, 1),
            this.increaseAcknowledgedAlarm(a, 1)
        },
        acknowledgeAllAlarms: function(a) {
            if (a) {
                var b = this.getNewAlarmCount(a);
                this.decreaseNewAlarm(a, b),
                this.increaseAcknowledgedAlarm(a, b)
            } else for (var c in this._nm) this.acknowledgeAllAlarms(Ib.AlarmSeverity.getByName(c))
        },
        _c6: function() {
            this._aac = 0;
            for (var a in this._am) a = Ib.AlarmSeverity.getByName(a),
            this._aac += this.getAcknowledgedAlarmCount(a)
        },
        getAcknowledgedAlarmCount: function(a) {
            if (a) {
                var b = this._am[a.name];
                return null == b ? 0 : b
            }
            return this._aac
        },
        getAlarmCount: function(a) {
            return this.getAcknowledgedAlarmCount(a) + this.getNewAlarmCount(a)
        },
        _c7: function() {
            this._nac = 0;
            for (var a in this._nm) a = Ib.AlarmSeverity.getByName(a),
            this._nac += this.getNewAlarmCount(a)
        },
        getNewAlarmCount: function(a) {
            if (a) {
                var b = this._nm[a.name];
                return null == b ? 0 : b
            }
            return this._nac
        },
        setNewAlarmCount: function(a, b) {
            this._nm[a.name] = b,
            this._f()
        },
        removeAllNewAlarms: function(a) {
            a ? delete this._nm[a] : this._nm = {},
            this._f()
        },
        setAcknowledgedAlarmCount: function(a, b) {
            this._am[a.name] = b,
            this._f()
        },
        removeAllAcknowledgedAlarms: function(a) {
            a ? delete this._am[a.name] : this._am = {},
            this._f()
        },
        isEmpty: function() {
            return null == this._hoa
        },
        clear: function() {
            this._am = {},
            this._nm = {},
            this._f()
        },
        getPropagateSeverity: function() {
            return this._ps
        },
        setPropagateSeverity: function(a) {
            if (this._ep || (a = null), this._ps !== a) {
                var b = this._ps;
                this._ps = a,
                this._f(),
                this._e.firePropertyChange("propagateSeverity", b, a)
            }
        },
        isEnablePropagation: function() {
            return this._ep
        },
        setEnablePropagation: function(a) {
            var b = this._ep;
            this._ep = a,
            this._e.firePropertyChange("enablePropagation", b, a) && (a || this.setPropagateSeverity(null))
        }
    }),
    Ib.AlarmBox = function(a) {
        if (!a) throw "elementBox can not be null.";
        Ib.AlarmBox.superClass.constructor.call(this),
        this._elementBox = a,
        this._alarmElementMapping = new Ib.AlarmElementMapping(this, a),
        this._elementBox.addDataBoxChangeListener(this.handleElementBoxChange, this, !0),
        this.addDataBoxChangeListener(this.handleAlarmBoxChange, this, !0),
        this.addDataPropertyChangeListener(this.handleAlarmPropertyChange, this, !0)
    },
    Jb.ext("twaver.AlarmBox", Ib.DataBox, {
        __accessor: ["removeAlarmWhenElementIsRemoved"],
        _name: "AlarmBox",
        _removeAlarmWhenAlarmIsCleared: !1,
        _removeAlarmWhenElementIsRemoved: !0,
        getElementBox: function() {
            return this._elementBox
        },
        isRemoveAlarmWhenAlarmIsCleared: function() {
            return this._removeAlarmWhenAlarmIsCleared
        },
        setRemoveAlarmWhenAlarmIsCleared: function(a) {
            var b = this._removeAlarmWhenAlarmIsCleared;
            this._removeAlarmWhenAlarmIsCleared = a,
            this.firePropertyChange("removeAlarmWhenAlarmIsCleared", b, a),
            a && this.toDatas(function(a) {
                return a.isCleared()
            }).forEach(this.remove, this)
        },
        getAlarmElementMapping: function() {
            return this._alarmElementMapping
        },
        setAlarmElementMapping: function(a) {
            if (!a) throw "alarmElementMapping can not be null";
            if (this._alarmElementMapping !== a) {
                var b = this._alarmElementMapping;
                this.getDatas().forEach(this._decreaseAlarmState, this),
                this._alarmElementMapping = a,
                this.getDatas().forEach(this._increaseAlarmState, this),
                this.firePropertyChange("alarmElementMapping", b, a)
            }
        },
        handleElementBoxChange: function(a) {
            "add" === a.kind ? this.handleElementAdded(a.data) : "remove" === a.kind ? (this.handleElementRemoved(a.data), this._removeAlarmWhenElementIsRemoved && this.removeAlarmsByElement(a.data)) : "clear" === a.kind && (a.datas.forEach(this.handleElementRemoved, this), this._removeAlarmWhenElementIsRemoved && this.clear())
        },
        handleAlarmBoxChange: function(a) {
            "add" === a.kind ? this._increaseAlarmState(a.data) : "remove" === a.kind ? this._decreaseAlarmState(a.data) : "clear" === a.kind && a.datas.forEach(this._decreaseAlarmState, this)
        },
        handleAlarmPropertyChange: function(a) {
            var b = a.source;
            b.isCleared() || ("alarmSeverity" === a.property ? this.handleAlarmSeverityChange(b, a) : "acked" === a.property && this.handleAckedChange(b, a)),
            "cleared" === a.property && (b.isCleared() ? (this._decreaseAlarmState(b, !0), this._removeAlarmWhenAlarmIsCleared && this.remove(b)) : this._increaseAlarmState(b, !0))
        },
        handleAckedChange: function(a, b) {
            if (a.getAlarmSeverity()) {
                var c = this.getCorrespondingElements(a);
                if (c) for (var d = 0; d < c.size(); d++) {
                    var e = c.get(d);
                    b.oldValue ? e.getAlarmState().decreaseAcknowledgedAlarm(a.getAlarmSeverity()) : e.getAlarmState().decreaseNewAlarm(a.getAlarmSeverity()),
                    b.newValue ? e.getAlarmState().increaseAcknowledgedAlarm(a.getAlarmSeverity()) : e.getAlarmState().increaseNewAlarm(a.getAlarmSeverity())
                }
            }
        },
        handleAlarmSeverityChange: function(a, b) {
            var c = b.oldValue,
            d = b.newValue,
            e = this.getCorrespondingElements(a);
            if (e) for (var f = 0; f < e.size(); f++) {
                var g = e.get(f);
                c && (a.isAcked() ? g.getAlarmState().decreaseAcknowledgedAlarm(c) : g.getAlarmState().decreaseNewAlarm(c)),
                d && (a.isAcked() ? g.getAlarmState().increaseAcknowledgedAlarm(d) : g.getAlarmState().increaseNewAlarm(d))
            }
        },
        getCorrespondingAlarms: function(a) {
            return this._alarmElementMapping.getCorrespondingAlarms(a)
        },
        getCorrespondingElements: function(a) {
            return this._alarmElementMapping.getCorrespondingElements(a)
        },
        handleElementAdded: function(a) {
            var b = this.getCorrespondingAlarms(a);
            if (b) for (var c = 0; c < b.size(); c++) {
                var d = b.get(c);
                if (!d.isCleared()) {
                    var e = d.getAlarmSeverity();
                    e && (d.isAcked() ? a.getAlarmState().increaseAcknowledgedAlarm(e) : a.getAlarmState().increaseNewAlarm(e))
                }
            }
        },
        _increaseAlarmState: function(a, b) {
            if (!a.isCleared() || b) {
                var c = a.getAlarmSeverity();
                if (c) {
                    var d = this.getCorrespondingElements(a);
                    if (d) for (var e = 0; e < d.size(); e++) {
                        var f = d.get(e);
                        a.isAcked() ? f.getAlarmState().increaseAcknowledgedAlarm(c) : f.getAlarmState().increaseNewAlarm(c)
                    }
                }
            }
        },
        _decreaseAlarmState: function(a, b) {
            if (!a.isCleared() || b) {
                var c = a.getAlarmSeverity();
                if (c) {
                    var d = this.getCorrespondingElements(a);
                    if (d) for (var e = 0; e < d.size(); e++) {
                        var f = d.get(e);
                        a.isAcked() ? f.getAlarmState().decreaseAcknowledgedAlarm(c) : f.getAlarmState().decreaseNewAlarm(c)
                    }
                }
            }
        },
        handleElementRemoved: function(a) {
            var b = this.getCorrespondingAlarms(a);
            b && b.forEach(function(b) { ! b.isCleared() && b.getAlarmSeverity() && (b.isAcked() ? a.getAlarmState().decreaseAcknowledgedAlarm(b.getAlarmSeverity()) : a.getAlarmState().decreaseNewAlarm(b.getAlarmSeverity()))
            })
        },
        removeAlarmsByElement: function(a) {
            var b = this.getCorrespondingAlarms(a);
            b && b.forEach(this.remove, this)
        },
        add: function(a, b) {
            if (!a.IAlarm) throw "Only IAlarm can be added into AlarmBox";
            this._removeAlarmWhenAlarmIsCleared && a.isCleared() || Ib.AlarmBox.superClass.add.apply(this, arguments)
        }
    }),
    Ib.AlarmElementMapping = function(a, b) {
        if (!b) throw "ElementBox can not be null";
        if (!a) throw "AlarmBox can not be null";
        this._elementBox = b,
        this._alarmBox = a,
        this._alarmsFinder = new Ib.QuickFinder(a, "elementId")
    },
    Jb.ext("twaver.AlarmElementMapping", Object, {
        getCorrespondingAlarms: function(a) {
            return this._alarmsFinder.find(a.getId())
        },
        getCorrespondingElements: function(a) {
            var b = this._elementBox.getDataById(a.getElementId());
            return new nd(b)
        },
        dispose: function() {
            this._alarmsFinder.dispose(),
            delete this._elementBox,
            delete this._alarmBox,
            delete this._alarmsFinder
        }
    }),
    Ib.AlarmStateStatistics = function(a) {
        Ib.AlarmStateStatistics.superClass.constructor.apply(this, arguments),
        this.sumNew = 0,
        this.sumAcked = 0,
        this.sumTotal = 0,
        this.severtiyMap = {},
        this.elementMap = {},
        this.setElementBox(a)
    },
    Jb.ext("twaver.AlarmStateStatistics", Ib.PropertyChangeDispatcher, {
        getElementBox: function() {
            return this._elementBox
        },
        setElementBox: function(a) {
            if (!a) throw "ElementBox can not be null";
            if (this._elementBox !== a) {
                var b = this._elementBox;
                b && (b.removeDataPropertyChangeListener(this.handleElementPropertyChange, this), b.removeDataBoxChangeListener(this.handleElementBoxChange, this), this.severtiyMap = {},
                this.elementMap = {}),
                this._elementBox = a,
                this.reset(),
                a.addDataPropertyChangeListener(this.handleElementPropertyChange, this),
                a.addDataBoxChangeListener(this.handleElementBoxChange, this),
                this.firePropertyChange("elementBox", b, a)
            }
        },
        dispose: function() {
            this._elementBox.removeDataPropertyChangeListener(this.handleElementPropertyChange, this),
            this._elementBox.removeDataBoxChangeListener(this.handleElementBoxChange, this),
            delete this._elementBox
        },
        handleElementPropertyChange: function(a) {
            "alarmState" === a.property && (this.increase(a.source), this.fireAlarmStateChange())
        },
        handleElementBoxChange: function(a) {
            "add" === a.kind ? (this.increase(a.data), this.fireAlarmStateChange()) : "remove" === a.kind ? (this.decrease(a.data), this.fireAlarmStateChange()) : "clear" === a.kind && (this.severtiyMap = {},
            this.elementMap = {},
            this.fireAlarmStateChange())
        },
        fireAlarmStateChange: function() {
            this.sumAcked = 0,
            this.sumNew = 0,
            this.sumTotal = 0,
            Ib.AlarmSeverity.forEach(function(a) {
                var b = this.getSumInfo(a);
                this.sumAcked += b.ackedCount,
                this.sumNew += b.newCount,
                this.sumTotal += b.totalCount
            },
            this),
            this.firePropertyChange("alarmState", !1, !0)
        },
        getNewAlarmCount: function(a) {
            if (!a) return this.sumNew;
            var b = this.getSumInfo(a);
            return b.newCount
        },
        getAcknowledgedAlarmCount: function(a) {
            if (!a) return this.sumAcked;
            var b = this.getSumInfo(a);
            return b.ackedCount
        },
        getTotalAlarmCount: function(a) {
            if (!a) return this.sumTotal;
            var b = this.getSumInfo(a);
            return b.totalCount
        },
        getSumInfo: function(a) {
            var b = this.severtiyMap[a.name];
            return b || (b = {},
            b.newCount = 0, b.ackedCount = 0, b.totalCount = 0, this.severtiyMap[a.name] = b),
            b
        },
        decrease: function(a) {
            var b = this.elementMap[a.getId()];
            b && (delete this.elementMap[a.getId()], Ib.AlarmSeverity.forEach(function(a) {
                var c = b[a.name],
                d = this.getSumInfo(a);
                d.newCount = d.newCount - c.newCount,
                d.ackedCount = d.ackedCount - c.ackedCount,
                d.totalCount = d.totalCount - c.totalCount
            },
            this))
        },
        increase: function(a) {
            if (this.decrease(a), !this._filterFunction || this._filterFunction(a)) {
                var b = {};
                this.elementMap[a.getId()] = b,
                Ib.AlarmSeverity.forEach(function(c) {
                    var d = {};
                    d.newCount = a.getAlarmState().getNewAlarmCount(c),
                    d.ackedCount = a.getAlarmState().getAcknowledgedAlarmCount(c),
                    d.totalCount = a.getAlarmState().getAlarmCount(c),
                    b[c.name] = d;
                    var e = this.getSumInfo(c);
                    e.newCount = e.newCount + d.newCount,
                    e.ackedCount = e.ackedCount + d.ackedCount,
                    e.totalCount = e.totalCount + d.totalCount
                },
                this)
            }
        },
        reset: function() {
            this.severtiyMap = {},
            this.elementMap = {},
            this._elementBox.forEach(this.increase, this),
            this.fireAlarmStateChange()
        },
        setFilterFunction: function(a) {
            var b = this._filterFunction;
            this._filterFunction = a,
            this.reset(),
            this.firePropertyChange("filterFunction", b, a)
        },
        getFilterFunction: function() {
            return _filterFunction
        }
    }),
    Ib.LayerBox = function(a) {
        Ib.LayerBox.superClass.constructor.call(this),
        this._elementBox = a,
        this._defaultLayer = new Ib.Layer(Dd.LAYER_DEFAULT_ID, Dd.LAYER_DEFAULT_NAME),
        this.add(this._defaultLayer)
    },
    Jb.ext("twaver.LayerBox", Ib.DataBox, {
        _name: "LayerBox",
        getElementBox: function() {
            return this._elementBox
        },
        getDefaultLayer: function() {
            return this._defaultLayer
        },
        add: function(a, b) {
            if (!a.ILayer) throw "Only ILayer can be added into LayerBox";
            Ib.LayerBox.superClass.add.apply(this, arguments)
        },
        removeById: function(a) {
            if (a === this._defaultLayer.getId()) throw "Cannot remove default layer";
            Ib.LayerBox.superClass.removeById.call(this, a)
        },
        getLayerByElement: function(a) {
            if (!a) return null;
            if (a._layerId === Dd.LAYER_DEFAULT_ID) return this._defaultLayer;
            var b = this.getDataById(a.getLayerId());
            return b ? b: this._defaultLayer
        },
        clear: function() {
            this.toDatas().forEach(function(a) {
                a != this._defaultLayer && this.removeById(a.getId())
            },
            this)
        }
    }),
    Ib.BundleLinks = function(a, b) {
        this._links = a,
        this._siblings = b;
        var c, d, e = Ib.Styles.getStyle("link.bundle.expanded");
        for (c = 0; c < a.size(); c++) {
            d = a.get(c);
            var f = d.getStyle("link.bundle.expanded", !1);
            if (null != f) {
                e = f;
                break
            }
        }
        if (null == e && (e = !0), Dd.LINK_BUNDLE_AGENT_FUNCTION) {
            var g = Dd.LINK_BUNDLE_AGENT_FUNCTION(a);
            null == g ? g = a.get(0) : g != a.get(0) && (a.remove(g), a.add(g, 0))
        }
        for (c = 0; c < a.size(); c++) a.get(c).setStyle("link.bundle.expanded", e)
    },
    Jb.ext("twaver.BundleLinks", Object, {
        getLinks: function() {
            return this._links
        },
        getSiblings: function() {
            return this._siblings
        },
        forEachSiblingLink: function(a, b) {
            this._siblings.forEach(function(c) {
                c.getLinks().forEach(a, b)
            })
        }
    });
    var Ed = {
        bitsToNum: function(a) {
            return a.reduce(function(a, b) {
                return 2 * a + b
            },
            0)
        },
        byteToBitArr: function(a) {
            for (var b = [], c = 7; c >= 0; c--) b.push( !! (a & 1 << c));
            return b
        },
        lzwDecode: function(a, b) {
            for (var c, d, e = 0,
            f = function(a) {
                for (var c = 0,
                d = 0; a > d; d++) b.charCodeAt(e >> 3) & 1 << (7 & e) && (c |= 1 << d),
                e++;
                return c
            },
            g = [], h = 1 << a, i = h + 1, j = a + 1, k = [], l = function() {
                k = [],
                j = a + 1;
                for (var b = 0; h > b; b++) k[b] = [b];
                k[h] = [],
                k[i] = null
            };;) if (d = c, c = f(j), c !== h) {
                if (c === i) break;
                if (c < k.length) d !== h && k.push(k[d].concat(k[c][0]));
                else {
                    if (c !== k.length) throw new Error("Invalid LZW code.");
                    k.push(k[d].concat(k[d][0]))
                }
                g.push.apply(g, k[c]),
                k.length === 1 << j && 12 > j && j++
            } else l();
            return g
        }
    },
    Fd = function(a) {
        this.data = a,
        this.len = this.data.length,
        this.pos = 0
    };
    Jb.ext(Fd, Object, {
        readByte: function() {
            if (this.pos >= this.data.length) throw new Error("Attempted to read past end of stream.");
            return 255 & this.data.charCodeAt(this.pos++)
        },
        readBytes: function(a) {
            for (var b = [], c = 0; a > c; c++) b.push(this.readByte());
            return b
        },
        read: function(a) {
            for (var b = "",
            c = 0; a > c; c++) b += String.fromCharCode(this.readByte());
            return b
        },
        readUnsigned: function() {
            var a = this.readBytes(2);
            return (a[1] << 8) + a[0]
        }
    });
    var Gd = function(a) {
        var b, c = a,
        d = null,
        e = null,
        f = null,
        g = 0,
        h = null,
        i = null,
        j = null;
        this.frames = [],
        this.size = {};
        var k = this,
        l = Ob.createElement("canvas");
        this.loaded = !1;
        var m = function() {
            d = null,
            e = null,
            h = f,
            f = null,
            i = null
        };
        this.doParse = function() {
            Hd(c, t)
        };
        var n = function(a) {
            b = a,
            k.size.width = b.width,
            k.size.height = b.height
        },
        o = function(a) {
            p(),
            m(),
            d = a.transparencyGiven ? a.transparencyIndex: null,
            e = a.delayTime,
            f = a.disposalMethod
        },
        p = function() {
            i && k.frames.push({
                data: i.getImageData(0, 0, b.width, b.height),
                delay: e
            })
        },
        q = function(a) {
            i || (i = l.getContext("2d"));
            var c = k.frames.length,
            e = a.lctFlag ? a.lct: b.gct;
            c > 0 && (3 === h ? i.putImageData(k.frames[g].data, 0, 0) : g = c - 1, 2 === h && (j || i.clearRect(j.leftPos, j.topPos, j.width, j.height)));
            var f = i.getImageData(a.leftPos, a.topPos, a.width, a.height);
            a.pixels.forEach(function(a, b) {
                a !== d && (f.data[4 * b + 0] = e[a][0], f.data[4 * b + 1] = e[a][1], f.data[4 * b + 2] = e[a][2], f.data[4 * b + 3] = 255)
            }),
            i.putImageData(f, a.leftPos, a.topPos),
            j = a
        },
        r = function() {},
        s = function(a) {
            return function(b) {
                a(b)
            }
        },
        t = {
            hdr: s(n),
            gce: s(o),
            com: s(r),
            app: {
                NETSCAPE: s(r)
            },
            img: s(q),
            eof: function(a) {
                p(),
                k.loaded = !0
            }
        }
    },
    Hd = function(a, b) {
        b || (b = {});
        var c = function(b) {
            for (var c = [], d = 0; b > d; d++) c.push(a.readBytes(3));
            return c
        },
        d = function() {
            var b, c;
            c = "";
            do b = a.readByte(),
            c += a.read(b);
            while (0 !== b);
            return c
        },
        e = function() {
            var d = {};
            if (d.sig = a.read(3), d.ver = a.read(3), "GIF" !== d.sig) throw new Error("Not a GIF file.");
            d.width = a.readUnsigned(),
            d.height = a.readUnsigned();
            var e = Ed.byteToBitArr(a.readByte());
            d.gctFlag = e.shift(),
            d.colorRes = Ed.bitsToNum(e.splice(0, 3)),
            d.sorted = e.shift(),
            d.gctSize = Ed.bitsToNum(e.splice(0, 3)),
            d.bgColor = a.readByte(),
            d.pixelAspectRatio = a.readByte(),
            d.gctFlag && (d.gct = c(1 << d.gctSize + 1)),
            b.hdr && b.hdr(d)
        },
        f = function(c) {
            var e = function(c) {
                var d = (a.readByte(), Ed.byteToBitArr(a.readByte()));
                c.reserved = d.splice(0, 3),
                c.disposalMethod = Ed.bitsToNum(d.splice(0, 3)),
                c.userInput = d.shift(),
                c.transparencyGiven = d.shift(),
                c.delayTime = a.readUnsigned(),
                c.transparencyIndex = a.readByte(),
                c.terminator = a.readByte(),
                b.gce && b.gce(c)
            },
            f = function(a) {
                a.comment = d(),
                b.com && b.com(a)
            },
            g = function(c) {
                a.readByte(),
                c.ptHeader = a.readBytes(12),
                c.ptData = d(),
                b.pte && b.pte(c)
            },
            h = function(c) {
                var e = function(c) {
                    a.readByte(),
                    c.unknown = a.readByte(),
                    c.iterations = a.readUnsigned(),
                    c.terminator = a.readByte(),
                    b.app && b.app.NETSCAPE && b.app.NETSCAPE(c)
                },
                f = function(a) {
                    a.appData = d(),
                    b.app && b.app[a.identifier] && b.app[a.identifier](a)
                };
                switch (a.readByte(), c.identifier = a.read(8), c.authCode = a.read(3), c.identifier) {
                case "NETSCAPE":
                    e(c);
                    break;
                default:
                    f(c)
                }
            },
            i = function(a) {
                a.data = d(),
                b.unknown && b.unknown(a)
            };
            switch (c.label = a.readByte(), c.label) {
            case 249:
                c.extType = "gce",
                e(c);
                break;
            case 254:
                c.extType = "com",
                f(c);
                break;
            case 1:
                c.extType = "pte",
                g(c);
                break;
            case 255:
                c.extType = "app",
                h(c);
                break;
            default:
                c.extType = "unknown",
                i(c)
            }
        },
        g = function(e) {
            var f = function(a, b) {
                for (var c = new Array(a.length), d = a.length / b, e = function(d, e) {
                    var f = a.slice(e * b, (e + 1) * b);
                    c.splice.apply(c, [d * b, b].concat(f))
                },
                f = [0, 4, 2, 1], g = [8, 8, 4, 2], h = 0, i = 0; 4 > i; i++) for (var j = f[i]; d > j; j += g[i]) e(j, h),
                h++;
                return c
            };
            e.leftPos = a.readUnsigned(),
            e.topPos = a.readUnsigned(),
            e.width = a.readUnsigned(),
            e.height = a.readUnsigned();
            var g = Ed.byteToBitArr(a.readByte());
            e.lctFlag = g.shift(),
            e.interlaced = g.shift(),
            e.sorted = g.shift(),
            e.reserved = g.splice(0, 2),
            e.lctSize = Ed.bitsToNum(g.splice(0, 3)),
            e.lctFlag && (e.lct = c(1 << e.lctSize + 1)),
            e.lzwMinCodeSize = a.readByte();
            var h = d();
            e.pixels = Ed.lzwDecode(e.lzwMinCodeSize, h),
            e.interlaced && (e.pixels = f(e.pixels, e.width)),
            b.img && b.img(e)
        },
        h = function() {
            var c = {};
            switch (c.sentinel = a.readByte(), String.fromCharCode(c.sentinel)) {
            case "!":
                c.type = "ext",
                f(c);
                break;
            case ",":
                c.type = "img",
                g(c);
                break;
            case ";":
                c.type = "eof",
                b.eof && b.eof(c);
                break;
            default:
                throw new Error("Unknown block: 0x" + c.sentinel.toString(16))
            }
            "eof" !== c.type && setTimeout(h, 0)
        },
        i = function() {
            e(),
            setTimeout(h, 0)
        };
        i()
    },
    Id = function(a, b, c) {
        var d = Ob.createElement("canvas");
        return Jd(d, b.width, b.height),
        d.getContext("2d").clearRect(0, 0, b.width, b.height),
        d.getContext("2d").putImageData(a[c].data, 0, 0),
        d
    },
    Jd = function(a, b, c) {
        a.width = b,
        a.height = c,
        a.style.width = b + "px",
        a.style.height = c + "px"
    };
    Ib.Data = function(a) {
        if (Ib.Data.superClass.constructor.apply(this, arguments), this._childList = new nd, this._childMap = {},
        this._clientMap = {},
        a === b || null === a) this._id = Jb.id();
        else if ("string" == typeof a || "number" == typeof a || "boolean" == typeof a) this._id = a;
        else {
            for (var c in a) if ("clients" === c) for (var d in a.clients) this._clientMap[d] = a.clients[d];
            else if ("styles" === c) for (var e in a.styles) this._styleMap[e] = a.styles[e];
            else null != a[c] && ("id" === c ? this._id = a[c] : this[Jb.setter(c)](a[c]));
            null == this._id && (this._id = Jb.id())
        }
    },
    Jb.ext("twaver.Data", Ib.PropertyChangeDispatcher, {
        IData: !0,
        IClient: !0,
        __client: 1,
        __new: 1,
        _parent: null,
        __accessor: ["name", "name2", "icon", "toolTip"],
        _icon: Dd.ICON_DATA,
        getId: function() {
            return this._id
        },
        getChildren: function() {
            return this._childList
        },
        getChildrenSize: function() {
            return this._childList.size()
        },
        toChildren: function(a, b) {
            return this._childList.toList(a, b)
        },
        addChild: function(a, c) {
            return c === b && (c = this._childList.size()),
            a && a !== this ? this._childMap[a.getId()] ? !1 : this.isDescendantOf(a) ? !1 : (a.getParent() && a.getParent().removeChild(a), (0 > c || c > this._childList.size()) && (c = this._childList.size()), this._childList.add(a, c), this._childMap[a._id] = a, a.setParent(this), this.firePropertyChange("children", null, a), this.onChildAdded(a, c), !0) : !1
        },
        onChildAdded: function(a, b) {},
        removeChild: function(a) {
            if (!a) return ! 1;
            if (!this._childMap[a._id]) return ! 1;
            var b = this._childList.remove(a);
            return delete this._childMap[a._id],
            this.firePropertyChange("children", a, null),
            a.setParent(null),
            this.onChildRemoved(a, b),
            !0
        },
        onChildRemoved: function(a, b) {},
        getChildAt: function(a) {
            return this._childList.get(a)
        },
        clearChildren: function() {
            if (0 === this._childList.size()) return ! 1;
            for (var a = this._childList.toArray(), b = a.length, c = 0; b > c; c++) this.removeChild(a[c]);
            return this.onChildrenCleared(a),
            !0
        },
        onChildrenCleared: function(a) {},
        getParent: function() {
            return this._parent
        },
        setParent: function(a) {
            if (! (this._isUpdatingParent || this._parent === a || this === a || a && a.isDescendantOf(this))) {
                var b = this._parent;
                this._parent = a,
                this._isUpdatingParent = !0,
                b && b.removeChild(this),
                a && a.addChild(this),
                delete this._isUpdatingParent,
                this.firePropertyChange("parent", b, a),
                this.onParentChanged(b, a)
            }
        },
        onParentChanged: function(a, b) {},
        hasChildren: function() {
            return this._childList.size() > 0
        },
        isRelatedTo: function(a) {
            return a ? this.isDescendantOf(a) || a.isDescendantOf(this) : !1
        },
        isParentOf: function(a) {
            return a ? null != this._childMap[a._id] : !1
        },
        isDescendantOf: function(a) {
            if (!a) return ! 1;
            if (!a.hasChildren()) return ! 1;
            for (var b = this._parent; b;) {
                if (a === b) return ! 0;
                b = b.getParent()
            }
            return ! 1
        },
        toString: function() {
            return this.getName() ? this.getName() : this._id
        }
    }),
    Ib.Alarm = function(a, b, c, d, e) {
        Ib.Alarm.superClass.constructor.call(this, a),
        this._elementId = b,
        this._alarmSeverity = c,
        this._acked = d || !1,
        this._cleared = e || !1
    },
    Jb.ext("twaver.Alarm", Ib.Data, {
        IAlarm: !0,
        getElementId: function() {
            return this._elementId
        },
        __accessor: ["acked", "cleared", "alarmSeverity"]
    }),
    Ib.Layer = function(a) {
        Ib.Layer.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Layer", Ib.Data, {
        ILayer: !0,
        __accessor: ["visible", "movable", "editable", "rotatable"],
        _visible: !0,
        _movable: !0,
        _editable: !0,
        _rotatable: !0,
        _name: "Default"
    }),
    Ib.Element = function(a) {
        this._styleMap = this._styleMap || {},
        this._alarmState = new Ib.AlarmState(this),
        Ib.Element.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Element", Ib.Data, {
        IElement: !0,
        IStyle: !0,
        __accessor: ["layerId"],
        __bool: ["visible", "movable"],
        __style: 1,
        _layerId: Dd.LAYER_DEFAULT_ID,
        _visible: !0,
        _movable: !0,
        getAlarmState: function() {
            return this._alarmState
        },
        isAdjustedToBottom: function() {
            return ! 1
        },
        getElementUIClass: function() {
            return null
        },
        getCanvasUIClass: function() {
            return null
        },
        getVectorUIClass: function() {
            return null
        },
        s: function(a, c) {
            return c === b ? this.getStyle(a) : (this.setStyle(a, c), this)
        }
    }),
    Ib.Dummy = function(a) {
        Ib.Dummy.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Dummy", Ib.Element, {
        IDummy: !0
    });
    var Kd = function(a) {
        this._location = {
            x: 0,
            y: 0
        },
        Kd.superClass.constructor.call(this, a)
    };
    Ib.Node = Kd,
    Kd.IS_INTERESTED_NODE_PROPERTY = {
        location: 1,
        width: 1,
        height: 1,
        expanded: 1
    },
    Jb.ext("twaver.Node", Ib.Element, {
        _icon: Dd.ICON_NODE,
        _image: Dd.IMAGE_NODE,
        _angle: 0,
        getLoopedLinks: function() {
            return this._loopedLinks
        },
        getLinks: function() {
            return this._links
        },
        getAgentLinks: function() {
            return this._agentLinks
        },
        getFollowers: function() {
            return this._followers
        },
        _addFollower: function(a) {
            this._followers || (this._followers = new nd),
            this._followers.add(a)
        },
        _removeFollower: function(a) {
            this._followers.remove(a),
            this._followers.isEmpty() && delete this._followers
        },
        getFromLinks: function() {
            return this._fromLinks
        },
        getToLinks: function() {
            return this._toLinks
        },
        _addFromLink: function(a) {
            this._links || (this._links = new nd(!1)),
            this._fromLinks || (this._fromLinks = new nd(!1)),
            this._links.add(a),
            this._toLinks && this._toLinks.contains(a) && (this._loopedLinks || (this._loopedLinks = new nd(!1)), this._loopedLinks.add(a)),
            this._fromLinks.add(a)
        },
        _addToLink: function(a) {
            this._links || (this._links = new nd(!1)),
            this._toLinks || (this._toLinks = new nd(!1)),
            this._links.add(a),
            this._fromLinks && this._fromLinks.contains(a) && (this._loopedLinks || (this._loopedLinks = new nd(!1)), this._loopedLinks.add(a)),
            this._toLinks.add(a)
        },
        _removeFromLink: function(a) {
            this._links && this._links.remove(a),
            this._fromLinks && this._fromLinks.remove(a),
            this._loopedLinks && this._loopedLinks.remove(a)
        },
        _removeToLink: function(a) {
            this._links && this._links.remove(a),
            this._toLinks && this._toLinks.remove(a),
            this._loopedLinks && this._loopedLinks.remove(a)
        },
        hasAgentLinks: function() {
            return null != this._agentLinks && !this._agentLinks.isEmpty()
        },
        getFromAgentLinks: function() {
            return this._fromAgentLinks
        },
        getToAgentLinks: function() {
            return this._toAgentLinks
        },
        _addFromAgentLink: function(a) {
            this._fromAgentLinks || (this._fromAgentLinks = new nd(!1)),
            this._agentLinks || (this._agentLinks = new nd(!1)),
            this._fromAgentLinks.add(a),
            this._agentLinks.add(a)
        },
        _addToAgentLink: function(a) {
            this._toAgentLinks || (this._toAgentLinks = new nd(!1)),
            this._agentLinks || (this._agentLinks = new nd(!1)),
            this._toAgentLinks.add(a),
            this._agentLinks.add(a)
        },
        _removeFromAgentLink: function(a) {
            this._fromAgentLinks && this._fromAgentLinks.remove(a),
            this._agentLinks && this._agentLinks.remove(a)
        },
        _removeToAgentLink: function(a) {
            this._toAgentLinks && this._toAgentLinks.remove(a),
            this._agentLinks && this._agentLinks.remove(a)
        },
        getImage: function() {
            return this._image
        },
        setImage: function(a) {
            var b = this._image,
            c = this.getWidth(),
            d = this.getHeight();
            this._image = a,
            this.firePropertyChange("image", b, a),
            this.firePropertyChange("width", c, this.getWidth()),
            this.firePropertyChange("height", d, this.getHeight())
        },
        getX: function() {
            return this._location.x
        },
        getY: function() {
            return this._location.y
        },
        setX: function(a) {
            this.setLocation(a, this._location.y)
        },
        setY: function(a) {
            this.setLocation(this._location.x, a)
        },
        getLocation: function() {
            return this._location
        },
        setLocation: function(a, b) {
            var c;
            if (c = 2 === arguments.length ? {
                x: arguments[0],
                y: arguments[1]
            }: arguments[0], Jb.num(c.x) && Jb.num(c.y) && (c.x !== this._location.x || c.y !== this._location.y)) {
                var d = this._location;
                this._location = c,
                this.firePropertyChange("location", d, c)
            }
        },
        getCenterLocation: function() {
            return Dd.CENTER_LOCATION ? this._location: {
                x: this.getX() + this.getWidth() / 2,
                y: this.getY() + this.getHeight() / 2
            }
        },
        setCenterLocation: function(a, b) {
            var c;
            c = 2 === arguments.length ? {
                x: arguments[0],
                y: arguments[1]
            }: Jb.clone(arguments[0]),
            Jb.num(c.x) && Jb.num(c.y) && (Dd.CENTER_LOCATION || (c.x -= this.getWidth() / 2, c.y -= this.getHeight() / 2), this.setLocation(c))
        },
        translate: function(a, b) {
            this.setLocation(this.getX() + a, this.getY() + b)
        },
        getWidth: function() {
            if (Jb.num(this._width) && this._width >= 0) return this._width;
            if ("object" != typeof this._image) {
                var a = Jb.getImageAsset(this._image);
                if (a) {
                    var b = a.getWidth();
                    return Jb.num(b) && b >= 0 ? b: (a = a._image, Yc(this, a, a, "w"))
                }
            } else if (this._image) return this._image.w;
            return Dd.NODE_WIDTH
        },
        setWidth: function(a) {
            var b = this._width;
            this._width = a,
            this.firePropertyChange("width", b, a)
        },
        getHeight: function() {
            if (Jb.num(this._height) && this._height >= 0) return this._height;
            if ("object" != typeof this._image) {
                var a = Jb.getImageAsset(this._image);
                if (a) {
                    var b = a.getHeight();
                    return Jb.num(b) && b >= 0 ? b: (a = a._image, Yc(this, a, a, "h"))
                }
            } else if (this._image) return this._image.h;
            return Dd.NODE_HEIGHT
        },
        setHeight: function(a) {
            var b = this._height;
            this._height = a,
            this.firePropertyChange("height", b, a)
        },
        setSize: function() {
            2 === arguments.length ? (this.setWidth(arguments[0]), this.setHeight(arguments[1])) : (this.setWidth(arguments[0].width), this.setHeight(arguments[0].height))
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            }
        },
        getRect: function() {
            var a = this.getOriginalRect();
            if (0 === this._angle) return a;
            for (var b = Tb.createMatrix(this._angle * Math.PI / 180, a.x + a.width / 2, a.y + a.height / 2), c = [{
                x: a.x,
                y: a.y
            },
            {
                x: a.x + a.width,
                y: a.y
            },
            {
                x: a.x + a.width,
                y: a.y + a.height
            },
            {
                x: a.x,
                y: a.y + a.height
            }], d = 0, e = c.length; e > d; d++) c[d] = b.transform(c[d]);
            var f = Tb.getRect(c);
            return f
        },
        getOriginalRect: function() {
            var a = this,
            b = a.getWidth(),
            c = a.getHeight();
            return Dd.CENTER_LOCATION ? {
                x: a._location.x - b / 2,
                y: a._location.y - c / 2,
                width: b,
                height: c
            }: {
                x: a.getX(),
                y: a.getY(),
                width: b,
                height: c
            }
        },
        getAngle: function() {
            return this._angle
        },
        setAngle: function(a) {
            var b = this._angle;
            this._angle = a % 360,
            this.firePropertyChange("angle", b, this._angle)
        },
        onParentChanged: function(a, b) {
            Kd.superClass.onParentChanged.call(this, a, b),
            this._checkLinkAgent()
        },
        _checkLinkAgent: function() {
            if (Ib._isInitializing) {
                if (this._links) for (var a = this._links.size(), b = 0; a > b; b++) this._links.get(b)._checkAgentNode()
            } else Ib.ElementBox.prototype.startBatch(function() {
                if (this._links) for (var a = this._links.size(), b = 0; a > b; b++) this._links.get(b)._checkAgentNode()
            },
            this)
        },
        onPropertyChanged: function(a) {
            if (Kd.superClass.onPropertyChanged.call(this, a), this._followers) for (var b = this._followers.size(), c = 0; b > c; c++) this._followers.get(c).handleHostPropertyChange(a);
            this.getParent() instanceof Md && Kd.IS_INTERESTED_NODE_PROPERTY[a.property] && this.getParent().updateLocationFromChildren()
        },
        getElementUIClass: function() {
            return Ib.network.NodeUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.NodeUI
        },
        getVectorUIClass: function() {
            return Ib.vector.NodeUI
        }
    });
    var Ld = function(a) {
        Ld.superClass.constructor.call(this, a)
    };
    Ib.HTMLNode = Ld,
    Jb.ext("twaver.HTMLNode", Ib.Node, {
        getElementUIClass: function() {
            return Ib.network.HTMLNodeUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.HTMLNodeUI
        },
        getVectorUIClass: function() {
            return Ib.vector.HTMLNodeUI
        }
    }),
    Ib.Link = function(a, b, c) {
        Ib.Link.superClass.constructor.call(this, a instanceof Kd ? null: a),
        a instanceof Kd && (c = b, b = a),
        b && this.setFromNode(b),
        c && this.setToNode(c)
    },
    Ib.Link.IS_INTERESTED_BUNDLE_STYLE = {
        "link.bundle.enable": 1,
        "link.bundle.id": 1,
        "link.bundle.independent": 1
    },
    Jb.ext("twaver.Link", Ib.Element, {
        _fromNode: null,
        _toNode: null,
        _fromAgent: null,
        _toAgent: null,
        _icon: Dd.ICON_LINK,
        getFromNode: function() {
            return this._fromNode
        },
        getToNode: function() {
            return this._toNode
        },
        getFromAgent: function() {
            return this._fromAgent
        },
        getToAgent: function() {
            return this._toAgent
        },
        setFromNode: function(a) {
            if (this._fromNode !== a) {
                var b = this._fromNode;
                this._fromNode = a,
                b && b._removeFromLink(this),
                this._fromNode && this._fromNode._addFromLink(this),
                this._checkAgentNode(),
                this.firePropertyChange("fromNode", b, a)
            }
        },
        setToNode: function(a) {
            if (this._toNode !== a) {
                var b = this._toNode;
                this._toNode = a,
                b && b._removeToLink(this),
                this._toNode && this._toNode._addToLink(this),
                this._checkAgentNode(),
                this.firePropertyChange("toNode", b, a)
            }
        },
        isLooped: function() {
            return this._fromNode === this._toNode && null != this._fromNode && null != this._toNode
        },
        _checkAgentNode: function() {
            Ib._isInitializing ? Ib._links[this._id] || (Ib._links[this._id] = this) : this._checkAgentNodeImpl()
        },
        _checkAgentNodeImpl: function() {
            var a, b, c = vc.figureFromAgent(this),
            d = this;
            this._fromAgent != c && (a = this._fromAgent, this._fromAgent && this._fromAgent._removeFromAgentLink(this), this._fromAgent = c, this._fromAgent && this._fromAgent._addFromAgentLink(this), this.firePropertyChange("fromAgent", a, this._fromAgent), Ib._isInitializing ? (a && this._toAgent && (b = a._id + ":" + this._toAgent._id, Ib._bundleLinks[b] || (Ib._bundleLinks[b] = [a, this._toAgent])), this._fromAgent && this._toAgent && (b = this._fromAgent._id + ":" + this._toAgent._id, Ib._bundleLinks[b] || (Ib._bundleLinks[b] = [this._fromAgent, this._toAgent]))) : (vc.resetBundleLinks(a, d._toAgent), vc.resetBundleLinks(d._fromAgent, d._toAgent)));
            var e = vc.figureToAgent(this);
            this._toAgent != e && (a = this._toAgent, this._toAgent && this._toAgent._removeToAgentLink(this), this._toAgent = e, this._toAgent && this._toAgent._addToAgentLink(this), this.firePropertyChange("toAgent", a, this._toAgent), Ib._isInitializing ? (a && this._fromAgent && (b = a._id + ":" + this._fromAgent._id, Ib._bundleLinks[b] || (Ib._bundleLinks[b] = [a, this._fromAgent])), this._toAgent && this._fromAgent && (b = this._toAgent._id + ":" + this._fromAgent._id, Ib._bundleLinks[b] || (Ib._bundleLinks[b] = [this._toAgent, this._fromAgent]))) : (vc.resetBundleLinks(a, d._fromAgent), vc.resetBundleLinks(d._toAgent, d._fromAgent)))
        },
        _setBundleLinks: function(a) {
            this._bundleLinks = a,
            this.firePropertyChange("bundleLinks", !0, !1)
        },
        getBundleLinks: function() {
            return this._bundleLinks
        },
        getBundleCount: function() {
            return this._bundleLinks ? this._bundleLinks.getLinks().size() : 1
        },
        getBundleIndex: function() {
            return this._bundleLinks ? this._bundleLinks.getLinks().indexOf(this) : 0
        },
        reverseBundleExpanded: function() {
            if (this._bundleLinks && this._bundleLinks.getLinks().size() > 0) {
                var a, b, c = this._bundleLinks.getLinks(),
                d = !this.getStyle("link.bundle.expanded");
                for (a = 0; a < c.size(); a++) b = c.get(a),
                b.setStyle("link.bundle.expanded", d);
                var e = this._bundleLinks.getSiblings();
                for (a = 0; a < e.size(); a++) {
                    var f = e.get(a);
                    if (f != this._bundleLinks) {
                        c = f.getLinks();
                        for (var g = 0; g < c.size(); g++) b = c.get(g),
                        b.firePropertyChange("bundleLinks", null, f)
                    }
                }
                return ! 0
            }
            return ! 1
        },
        isBundleAgent: function() {
            return null != this._bundleLinks && this._bundleLinks.getLinks().size() > 1 && this === this._bundleLinks.getLinks().get(0) && !this.getStyle("link.bundle.expanded")
        },
        onStyleChanged: function(a, b, c) {
            Ib.Link.superClass.onStyleChanged.call(this, a, b, c),
            Ib.Link.IS_INTERESTED_BUNDLE_STYLE[a] && vc.resetBundleLinks(this._toAgent, this._fromAgent)
        },
        getElementUIClass: function() {
            return Ib.network.LinkUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.LinkUI
        },
        getVectorUIClass: function() {
            return Ib.vector.LinkUI
        },
        isAdjustedToBottom: function() {
            return Dd.IS_LINK_ADJUSTED_TO_BOTTOM
        }
    }),
    Ib.HTMLLink = function(a, b, c) {
        Ib.HTMLLink.superClass.constructor.call(this, a, b, c)
    },
    Ib.Util.ext("twaver.HTMLLink", Ib.Link, {
        getElementUIClass: function() {
            return Ib.network.HTMLLinkUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.HTMLLinkUI
        },
        getVectorUIClass: function() {
            return Ib.vector.HTMLLinkUI
        }
    }),
    Ib.Follower = function(a) {
        this._isUpdatingFollower = !1,
        this._isUpdatingLocation = !1,
        Ib.Follower.superClass.constructor.call(this, a)
    },
    Ib.Follower.IS_INTERESTED_HOST_GRID_PROPERTY = {
        location: 1,
        width: 1,
        height: 1,
        "S:grid.row.count": 1,
        "S:grid.column.count": 1,
        "S:grid.row.percents": 1,
        "S:grid.column.percents": 1,
        "S:grid.border": 1,
        "S:grid.border.left": 1,
        "S:grid.border.right": 1,
        "S:grid.border.top": 1,
        "S:grid.border.bottom": 1,
        "S:grid.padding": 1,
        "S:grid.padding.left": 1,
        "S:grid.padding.right": 1,
        "S:grid.padding.top": 1,
        "S:grid.padding.bottom": 1
    },
    Ib.Follower.IS_INTERESTED_FOLLOWER_STYLE = {
        "follower.row.index": 1,
        "follower.column.index": 1,
        "follower.row.span": 1,
        "follower.column.span": 1,
        "follower.padding": 1,
        "follower.padding.left": 1,
        "follower.padding.right": 1,
        "follower.padding.top": 1,
        "follower.padding.bottom": 1
    },
    Jb.ext("twaver.Follower", Kd, {
        _host: null,
        getHost: function() {
            return this._host
        },
        setHost: function(a) {
            if (this !== a && this._host !== a) {
                var b = this._host;
                b && b._removeFollower(this),
                this._host = a,
                this._host && this._host._addFollower(this),
                this.firePropertyChange("host", b, a),
                this.onHostChanged(b, a)
            }
        },
        onStyleChanged: function(a, b, c) {
            Ib.Follower.superClass.onStyleChanged.call(this, a, b, c),
            Ib.Follower.IS_INTERESTED_FOLLOWER_STYLE[a] && this.updateFollower(null)
        },
        setLocation: function() {
            this._isUpdatingLocation || (this._isUpdatingLocation = !0, Ib.Follower.superClass.setLocation.apply(this, arguments), this._isUpdatingLocation = !1)
        },
        onHostChanged: function(a, b) {
            this.updateFollower(null)
        },
        handleHostPropertyChange: function(a) {
            this.updateFollower(a)
        },
        updateFollower: function(a) {
            this._isUpdatingFollower || Jb.isDeserializing || (this._isUpdatingFollower = !0, this.updateFollowerImpl(a), this._isUpdatingFollower = !1)
        },
        updateFollowerImpl: function(a) {
            var b = this.getHost();
            if (b instanceof Ib.Grid) {
                if (!a || Ib.Follower.IS_INTERESTED_HOST_GRID_PROPERTY[a.property]) {
                    var c = this.getStyle("follower.row.index"),
                    d = this.getStyle("follower.column.index"),
                    e = b.getCellRect(c, d);
                    if (!e) return;
                    var f = this.getStyle("follower.row.span"),
                    g = this.getStyle("follower.column.span");
                    if (1 != f || 1 != g) {
                        var h = b.getCellRect(c + f - 1, d + g - 1);
                        h && (e = Tb.unionRect(e, h))
                    }
                    if (Tb.addPadding(e, this, "follower.padding"), this.getStyle("follower.fill.cell")) this.setLocation(e.x, e.y),
                    this.setWidth(e.width),
                    this.setHeight(e.height);
                    else {
                        var i = this.getStyle("follower.cell.position");
                        e = Vb.get(i, e, this.getRect()),
                        this.setLocation(e.x, e.y)
                    }
                }
            } else if (null != a && "location" === a.property) {
                var j = a.oldValue,
                k = a.newValue,
                l = this.getLocation();
                this.setLocation(l.x + (k.x - j.x), l.y + (k.y - j.y))
            }
        },
        isHostOn: function(a) {
            if (!a) return ! 1;
            for (var b = {},
            c = this._host; c && c != this && !b[c.getId()];) {
                if (c === a) return ! 0;
                b[c.getId()] = c,
                c = c instanceof Ib.Follower ? c.getHost() : null
            }
            return ! 1
        },
        isLoopedHostOn: function(a) {
            return this.isHostOn(a) && a.isHostOn(this)
        }
    });
    var Md = function(a) {
        this._isUpdatingLocationFromChildren = !1,
        this._isAdjusting = !1,
        this._expanded = !1,
        Md.superClass.constructor.call(this, a)
    };
    Ib.Group = Md,
    Jb.ext("twaver.Group", Ib.Follower, {
        _image: Dd.IMAGE_GROUP,
        _icon: Dd.ICON_GROUP,
        isAdjustedToBottom: function() {
            return this.isExpanded() && vc.hasAgentLinks(this)
        },
        onChildAdded: function(a, b) {
            Md.superClass.onChildAdded.apply(this, arguments),
            this.updateLocationFromChildren()
        },
        onChildRemoved: function(a, b) {
            Md.superClass.onChildRemoved.apply(this, arguments),
            this.updateLocationFromChildren()
        },
        updateLocationFromChildren: function() {
            if (!this._isAdjusting && !Jb.isDeserializing) {
                for (var a, b, c = 0,
                d = this.getChildrenSize(); d > c; c++) b = this.getChildAt(c),
                b instanceof Kd && (a = Tb.unionRect(a, this.getChildRect(b)));
                a && (this._isUpdatingLocationFromChildren = !0, this.setLocation(a.x + a.width / 2 - this.getWidth() / 2, a.y + a.height / 2 - this.getHeight() / 2), this._isUpdatingLocationFromChildren = !1)
            }
        },
        getChildRect: function(a) {
            var b;
            return a instanceof Kd && (a instanceof Md ? (a.isExpanded() && a.getChildren().forEach(function(c) {
                b = Tb.unionRect(b, a.getChildRect(c))
            }), b || (b = a.getRect())) : b = a.getRect()),
            b
        },
        setLocation: function() {
            if (!this._isAdjusting) {
                var a;
                if (a = 2 === arguments.length ? {
                    x: arguments[0],
                    y: arguments[1]
                }: arguments[0], !Jb.isDeserializing && !this._isUpdatingLocationFromChildren) {
                    this._isAdjusting = !0;
                    var b = a.x - this.getX(),
                    c = a.y - this.getY();
                    vc.moveElements(this.getChildren(), b, c),
                    this._isAdjusting = !1
                }
                Md.superClass.setLocation.call(this, a)
            }
        },
        reverseExpanded: function() {
            this.setExpanded(!this.isExpanded())
        },
        isExpanded: function() {
            return this._expanded
        },
        setExpanded: function(a) {
            if (this._expanded !== a) {
                var b = this._expanded;
                this._expanded = a,
                this.firePropertyChange("expanded", b, this._expanded),
                this._checkLinkAgent()
            }
        },
        _checkLinkAgent: function() {
            Md.superClass._checkLinkAgent.call(this);
            for (var a = this.getChildrenSize(), b = 0; a > b; b++) {
                var c = this.getChildAt(b);
                c instanceof Kd && c._checkLinkAgent()
            }
        },
        getElementUIClass: function() {
            return Ib.network.GroupUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.GroupUI
        },
        getVectorUIClass: function() {
            return Ib.vector.GroupUI
        }
    }),
    Ib.SubNetwork = function(a) {
        Ib.SubNetwork.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.SubNetwork", Ib.Follower, {
        ISubNetwork: !0,
        _image: Dd.IMAGE_SUBNETWORK,
        _icon: Dd.ICON_SUBNETWORK,
        _checkLinkAgent: function() {
            Ib.SubNetwork.superClass._checkLinkAgent.call(this);
            for (var a = this.getChildrenSize(), b = 0; a > b; b++) {
                var c = this.getChildAt(b);
                c instanceof Kd && c._checkLinkAgent()
            }
        }
    }),
    Ib.Grid = function(a) {
        Ib.Grid.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Grid", Ib.Follower, {
        _icon: Dd.ICON_GRID,
        _image: null,
        getCellObject: function(a, b) {
            1 === arguments.length && (b = a.y, a = a.x);
            for (var c = this.getStyle("grid.row.count"), d = this.getStyle("grid.column.count"), e = 0; c > e; e++) for (var f = 0; d > f; f++) {
                var g = this.getCellRect(e, f);
                if (Tb.containsPoint(g, a, b)) return {
                    rowIndex: e,
                    columnIndex: f,
                    rect: g
                }
            }
            return null
        },
        getCellRect: function(a, b) {
            var c = this.getStyle("grid.row.count"),
            d = this.getStyle("grid.column.count");
            if (0 >= c || 0 >= d) return null;
            if (0 > a || a >= c) return null;
            if (0 > b || b >= d) return null;
            var e = this.getRect();
            Tb.addPadding(e, this, "grid.border");
            var f = 0,
            g = this.getStyle("grid.row.percents"),
            h = this.getStyle("grid.column.percents");
            if (g && g.length === c) {
                var i = 0;
                for (f = 0; a > f; f++) i += e.height * g[f];
                e.y += i,
                e.height = e.height * g[a]
            } else e.height = e.height / c,
            e.y += e.height * a;
            if (h && h.length === d) {
                var j = 0;
                for (f = 0; b > f; f++) j += e.width * h[f];
                e.x += j,
                e.width = e.width * h[b]
            } else e.width = e.width / d,
            e.x += e.width * b;
            return Tb.addPadding(e, this, "grid.padding"),
            e
        },
        getElementUIClass: function() {
            return Ib.network.GridUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.GridUI
        },
        getVectorUIClass: function() {
            return Ib.vector.GridUI
        }
    }),
    Ib.ShapeNode = function(a) {
        this._isUpdatingShapeNode = !1,
        this._points = new nd,
        Ib.ShapeNode.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.ShapeNode", Ib.Follower, {
        _icon: Dd.ICON_SHAPENODE,
        __accessor: ["segments"],
        getElementUIClass: function() {
            return Ib.network.ShapeNodeUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.ShapeNodeUI
        },
        getVectorUIClass: function() {
            return Ib.vector.ShapeNodeUI
        },
        getPoints: function() {
            return this._points
        },
        setPoints: function(a) {
            a || (a = new nd);
            var b = new nd(this._points);
            this._points = a,
            this.firePointsChange(b, this._points)
        },
        getSegments: function() {
            return this._segments
        },
        setSegments: function(a) {
            a || (a = new nd);
            var b = new nd(this._segments);
            this._segments = a,
            this._reCalculateLineLength(),
            this.firePropertyChange("segments", b, this._segments)
        },
        addPoint: function(a, b) {
            var c = new nd(this._points);
            this._points.add(a, b),
            this.firePointsChange(c, this._points)
        },
        setPoint: function(a, b) {
            var c = new nd(this._points);
            this._points.set(a, b),
            this.firePointsChange(c, this._points)
        },
        removePoint: function(a) {
            var b = new nd(this._points);
            this._points.remove(a),
            this.firePointsChange(b, this._points)
        },
        removeAt: function(a) {
            var b = new nd(this._points);
            this._points.removeAt(a),
            this.firePointsChange(b, this._points)
        },
        setWidth: function(a) {
            if (1 > a && (a = 1), !this._isUpdatingShapeNode && !Jb.isDeserializing) {
                this._isUpdatingShapeNode = !0;
                for (var b = new nd(this._points), c = 0; c < this._points.size(); c++) {
                    var d = this._points.get(c);
                    d.x = (d.x - this.getX()) * a / this.getWidth() + this.getX()
                }
                this.firePointsChange(b, this._points),
                this._isUpdatingShapeNode = !1
            }
            Ib.ShapeNode.superClass.setWidth.apply(this, arguments)
        },
        setHeight: function(a) {
            if (1 > a && (a = 1), !this._isUpdatingShapeNode && !Jb.isDeserializing) {
                this._isUpdatingShapeNode = !0;
                for (var b = new nd(this._points), c = 0; c < this._points.size(); c++) {
                    var d = this._points.get(c);
                    d.y = (d.y - this.getY()) * a / this.getHeight() + this.getY()
                }
                this.firePointsChange(b, this._points),
                this._isUpdatingShapeNode = !1
            }
            Ib.ShapeNode.superClass.setHeight.apply(this, arguments)
        },
        setLocation: function() {
            if (!this._isUpdatingShapeNode && !Jb.isDeserializing) {
                var a;
                if (a = 2 === arguments.length ? {
                    x: arguments[0],
                    y: arguments[1]
                }: arguments[0], !Jb.num(a.x) || !Jb.num(a.y)) return;
                var b = a.x - this.getX(),
                c = a.y - this.getY();
                if (0 === b && 0 === c) return;
                this._isUpdatingShapeNode = !0;
                for (var d = new nd(this._points), e = 0; e < this._points.size(); e++) {
                    var f = this._points.get(e);
                    f.x += b,
                    f.y += c
                }
                this.firePointsChange(d, this._points),
                this._isUpdatingShapeNode = !1
            }
            Ib.ShapeNode.superClass.setLocation.apply(this, arguments)
        },
        firePointsChange: function(a, b) {
            if (!this._isUpdatingShapeNode && !Jb.isDeserializing) {
                var c = Tb.getRect(b);
                c ? (this._isUpdatingShapeNode = !0, Dd.CENTER_LOCATION ? this.setLocation(c.x + c.width / 2, c.y + c.height / 2) : this.setLocation(c.x, c.y), this.setWidth(c.width), this.setHeight(c.height), this._isUpdatingShapeNode = !1) : (this._isUpdatingShapeNode = !0, this.setWidth(0), this.setHeight(0), this._isUpdatingShapeNode = !1)
            }
            this._reCalculateLineLength(),
            this.firePropertyChange("points", a, b)
        },
        _reCalculateLineLength: function() {
            this._lineLength = null != this._points && this._points.size() > 0 ? Tb.calculateLineLength(this._points, this._segments) : 0
        },
        getLineLength: function() {
            return this._lineLength
        }
    }),
    Ib.Bus = function(a) {
        this._styleMap = {},
        this._styleMap["vector.fill"] = !1,
        this._styleMap["shapenode.closed"] = !1,
        Ib.Bus.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Bus", Ib.ShapeNode, {
        _icon: Dd.ICON_BUS,
        firePointsChange: function() {
            var a = this._points.size();
            if (!Jb.isDeserializing && a >= 2) for (var b = this._points.get(0), c = 1; a > c; c++) {
                var d = this._points.get(c);
                Math.abs(d.x - b.x) > Math.abs(d.y - b.y) ? d.y = b.y: d.x = b.x,
                b = d
            }
            Ib.Bus.superClass.firePointsChange.apply(this, arguments)
        }
    }),
    Ib.ShapeLink = function(a, b, c) {
        this._points = new nd,
        this._styleMap = {},
        this._styleMap["link.bundle.enable"] = !1,
        Ib.ShapeLink.superClass.constructor.call(this, a, b, c)
    },
    Jb.ext("twaver.ShapeLink", Ib.Link, {
        _icon: Dd.ICON_SHAPELINK,
        getElementUIClass: function() {
            return Ib.network.ShapeLinkUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.ShapeLinkUI
        },
        getVectorUIClass: function() {
            return Ib.vector.ShapeLinkUI
        },
        getPoints: function() {
            return this._points
        },
        setPoints: function(a) {
            a || (a = new nd);
            var b = new nd(this._points);
            this._points = a,
            this.firePointsChange(b, this._points)
        },
        addPoint: function(a, b) {
            var c = new nd(this._points);
            this._points.add(a, b),
            this.firePointsChange(c, this._points)
        },
        setPoint: function(a, b) {
            var c = new nd(this._points);
            this._points.set(a, b),
            this.firePointsChange(c, this._points)
        },
        removePoint: function(a) {
            var b = new nd(this._points);
            this._points.remove(a),
            this.firePointsChange(b, this._points)
        },
        removeAt: function(a) {
            var b = new nd(this._points);
            this._points.removeAt(a),
            this.firePointsChange(b, this._points)
        },
        firePointsChange: function(a, b) {
            this.firePropertyChange("points", a, b)
        }
    }),
    Ib.ShapeSubNetwork = function(a) {
        Ib.ShapeSubNetwork.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.ShapeSubNetwork", Ib.ShapeNode, {
        ISubNetwork: !0,
        _icon: Dd.ICON_SHAPESUBNETWORK,
        _checkLinkAgent: function() {
            Ib.ShapeSubNetwork.superClass._checkLinkAgent.call(this);
            for (var a = this.getChildrenSize(), b = 0; a > b; b++) {
                var c = this.getChildAt(b);
                c instanceof Kd && c._checkLinkAgent()
            }
        }
    }),
    Ib.LinkSubNetwork = function() {
        Ib.LinkSubNetwork.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.LinkSubNetwork", Ib.Link, {
        ISubNetwork: !0,
        _icon: Dd.ICON_LINKSUBNETWORK
    }),
    Ib.ShapeLinkSubNetwork = function() {
        Ib.ShapeLinkSubNetwork.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.ShapeLinkSubNetwork", Ib.ShapeLink, {
        ISubNetwork: !0,
        _icon: Dd.ICON_LINKSUBNETWORK
    }),
    Ib.RotatableNode = function(a) {
        Ib.RotatableNode.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.RotatableNode", Ib.Follower, {
        getWidth: function() {
            return 0 == this._angle ? this._getOrignalWidth() : this._getRotateRect().width
        },
        setWidth: function(a) {},
        getHeight: function() {
            return 0 == this._angle ? this._getOrignalHeight() : this._getRotateRect().height
        },
        setHeight: function(a) {},
        getElementUIClass: function() {
            return Ib.network.RotatableNodeUI
        },
        getCanvasUIClass: function() {
            return Ib.canvas.RotatableNodeUI
        },
        getVectorUIClass: function() {
            return Ib.vector.RotatableNodeUI
        },
        _getRotateRect: function() {
            for (var a = this._getOrignalWidth(), b = this._getOrignalHeight(), c = Tb.createMatrix(this._angle * Math.PI / 180, a / 2, b / 2), d = [{
                x: 0,
                y: 0
            },
            {
                x: a,
                y: 0
            },
            {
                x: a,
                y: b
            },
            {
                x: 0,
                y: b
            }], e = 0, f = d.length; f > e; e++) d[e] = c.transform(d[e]);
            return Tb.getRect(d)
        },
        _getOrignalWidth: function() {
            return Ib.RotatableNode.superClass.getWidth.call(this)
        },
        _getOrignalHeight: function() {
            return Ib.RotatableNode.superClass.getHeight.call(this)
        }
    }),
    Ib.controls.ControlBase = function() {
        Ib.controls.ControlBase.superClass.constructor.apply(this, arguments),
        this._pools = new nd
    },
    Jb.ext("twaver.controls.ControlBase", Ib.PropertyChangeDispatcher, {
        _autoAdjustBounds: !1,
        addPool: function(a) {
            this._pools.contains(a) || this._pools.add(a)
        },
        removePool: function(a) {
            this._pools.remove(a)
        },
        adjustBounds: function(a) {
            var b = this._view.style;
            b.position = "absolute",
            b.left = a.x + "px",
            b.top = a.y + "px",
            b.width = a.width + "px",
            b.height = a.height + "px",
            this._autoAdjustBounds === !0 && (b.left = "0px", b.top = "0px", b.right = "0px", b.bottom = "0px"),
            this.invalidate && this.invalidate()
        },
        setAutoAdjustBounds: function(b) {
            b === !0 ? Wb.addEventListener("resize", "_handleResize", a, this) : Wb.removeEventListener("resize", a, this),
            this._autoAdjustBounds = b
        },
        isAutoAdjustBounds: function() {
            return this._autoAdjustBounds
        },
        _handleResize: function(a) {
            this.adjustBounds({
                x: 0,
                y: 0,
                width: Ob.documentElement.clientWidth,
                height: Ob.documentElement.clientHeight
            })
        },
        getView: function() {
            return this._view
        },
        invalidate: function(a) {
            this._invalidate || (this._invalidate = !0, Jb.callLater(this.validate, this, null, a))
        },
        validate: function() {
            this._invalidate && (this._invalidate = !1, 0 === this._view.offsetWidth && 0 === this._view.offsetHeight && null !== this._reinvalidateCount ? (this._reinvalidateCount === b && (this._reinvalidateCount = 100), this._reinvalidateCount > 0 ? this._reinvalidateCount--:this._reinvalidateCount = null, this.invalidate()) : this.validateImpl())
        },
        validateImpl: function() {}
    }),
    Ib.controls.ViewBase = function() {
        Ib.controls.ViewBase.superClass.constructor.apply(this, arguments),
        this._interactionDispatcher = new Ib.EventDispatcher,
        this._viewDispatcher = new Ib.EventDispatcher
    },
    Jb.ext("twaver.controls.ViewBase", Ib.controls.ControlBase, {
        __bool: ["focusOnClick"],
        _focusOnClick: Dd.FOCUS_ON_CLICK,
        getSelectionModel: function() {
            return this._selectionModel ? this._selectionModel: this._box.getSelectionModel()
        },
        isShareSelectionModel: function() {
            return null == this._selectionModel
        },
        setShareSelectionModel: function(a) {
            var b = null == this._selectionModel;
            b !== a && (a ? (this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this), this._selectionModel.removeSelectionChangeListener(this.handleSelectionChange, this), this._selectionModel.dispose(), this._selectionModel = null) : (this._box.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this), this._selectionModel = new Ib.SelectionModel(this._box), this._selectionModel.addSelectionChangeListener(this.handleSelectionChange, this)), this.onShareSelectionModelChanged(), this.firePropertyChange("shareSelectionModel", b, a))
        },
        removeSelection: function() {
            if (0 === this.getSelectionModel().size()) return null;
            var a = this.getSelectionModel().toSelection();
            return this._box._undoManager._enabled && this._box._undoManager.startBatch(),
            a.forEach(function(a) {
                this._box.remove(a)
            },
            this),
            this._box._undoManager._enabled && this._box._undoManager.endBatch(),
            a
        },
        selectAll: function() {
            var a = new nd;
            return this._box.forEach(function(b) {
                this.isVisible(b) && a.add(b)
            },
            this),
            this.getSelectionModel().setSelection(a),
            a
        },
        isSelected: function(a) {
            return this.getSelectionModel().contains(a)
        },
        isSelectable: function(a) {
            return this.getSelectionModel().isSelectable(a)
        },
        getLabel: function(a) {
            return a.getName()
        },
        getToolTip: function(a) {
            return a.getToolTip()
        },
        getIcon: function(a) {
            return a.getIcon()
        },
        getSelectColor: function(a) {
            return Dd.SELECT_COLOR
        },
        addViewListener: function(a, b, c) {
            this._viewDispatcher.add(a, b, c)
        },
        removeViewListener: function(a, b) {
            this._viewDispatcher.remove(a, b)
        },
        fireViewEvent: function(a) {
            this._viewDispatcher.fire(a)
        },
        addInteractionListener: function(a, b, c) {
            this._interactionDispatcher.add(a, b, c)
        },
        removeInteractionListener: function(a, b) {
            this._interactionDispatcher.remove(a, b)
        },
        fireInteractionEvent: function(a) {
            this._interactionDispatcher.fire(a)
        },
        invalidate: function(a) {
            this._invalidate || (this._invalidate = !0, this.fireViewEvent({
                kind: "invalidate"
            }), Jb.callLater(this.validate, this, null, a))
        },
        validate: function() {
            this._invalidate && (this._invalidate = !1, Mb || 0 !== this._view.offsetWidth || 0 !== this._view.offsetHeight || null === this._reinvalidateCount ? (this._isValidating = !0, this.fireViewEvent({
                kind: "validateStart"
            }), this.validateImpl(), this.fireViewEvent({
                kind: "validateEnd"
            }), delete this._isValidating) : (this._reinvalidateCount === b && (this._reinvalidateCount = 100), this._reinvalidateCount > 0 ? this._reinvalidateCount--:this._reinvalidateCount = null, this.invalidate()))
        }
    }),
    Ib.controls.View = function() {
        Ib.controls.View.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.controls.View", Ib.controls.ViewBase, {
        _zoom: 1,
        _maxZoom: Dd.ZOOM_MAX,
        _minZoom: Dd.ZOOM_MIN,
        getRootDiv: function() {
            return this._rootDiv
        },
        isValidEvent: function(a) {
            return Wb.isValidEvent(this._view, a)
        },
        getAlarmFillColor: function(a) {
            if (a.IElement) {
                var b = a.getAlarmState().getHighestNewAlarmSeverity();
                if (b) return b.color
            }
            return null
        },
        getInnerColor: function(a) {
            if (a.IElement) {
                var b = a.getAlarmState().getHighestNativeAlarmSeverity();
                return b ? b.color: a.getStyle("inner.color")
            }
            return null
        },
        getOuterColor: function(a) {
            if (a.IElement) {
                var b = a.getAlarmState().getPropagateSeverity();
                return b ? b.color: a.getStyle("outer.color")
            }
            return null
        },
        zoomOverview: function(a) {
            var b = Math.min(this._view.clientWidth / this._viewRect.width, this._view.clientHeight / this._viewRect.height);
            this.setZoom(b, a)
        },
        getLogicalPoint: function(a) {
            return Wb.getLogicalPoint(this._view, a, this.getZoom(), this._rootDiv)
        },
        centerByLogicalPoint: function(a, b, c) {
            c && Ib.animate.AnimateManager.endAnimate();
            var d = this._view.scrollWidth - this._view.clientWidth,
            e = this._view.scrollHeight - this._view.clientHeight,
            f = (a - this._view.clientWidth / this._zoom / 2) * this._zoom,
            g = (b - this._view.clientHeight / this._zoom / 2) * this._zoom;
            0 > f && (f = 0),
            0 > g && (g = 0),
            f > d && (f = d),
            g > e && (g = e),
            c ? Ib.animate.AnimateManager.start(new Ib.animate.AnimateScrollPosition(this._view, f, g)) : (this._view.scrollLeft = f, this._view.scrollTop = g)
        },
        panByOffset: function(a, b) {
            a *= this.getZoom(),
            b *= this.getZoom();
            var c = this._view.scrollLeft + a,
            d = this._view.scrollTop + b,
            e = this._view.scrollWidth - this._view.clientWidth,
            f = this._view.scrollHeight - this._view.clientHeight;
            0 > c && (c = 0),
            c > e && (c = e),
            0 > d && (d = 0),
            d > f && (d = f);
            var g = {
                x: (c - this._view.scrollLeft) / this.getZoom(),
                y: (d - this._view.scrollTop) / this.getZoom()
            };
            return this._view.scrollLeft = c,
            this._view.scrollTop = d,
            g
        },
        getMaxZoom: function() {
            return this._maxZoom
        },
        setMaxZoom: function(a) {
            if (! (0 > a)) {
                var b = this._maxZoom;
                this._maxZoom = a,
                this.firePropertyChange("maxZoom", b, a),
                this.getZoom() > a && this.setZoom(a)
            }
        },
        getMinZoom: function() {
            return this._minZoom
        },
        setMinZoom: function(a) {
            if (! (0 > a)) {
                var b = this._minZoom;
                this._minZoom = a,
                this.firePropertyChange("minZoom", b, a),
                this.getZoom() < a && this.setZoom(a, !1)
            }
        },
        getZoom: function() {
            return this._zoom
        },
        onZoomChanged: function(a, b) {},
        zoomIn: function(a) {
            this.setZoom(this._zoom * Dd.ZOOM_INCREMENT, a)
        },
        zoomOut: function(a) {
            this.setZoom(this._zoom / Dd.ZOOM_INCREMENT, a)
        },
        zoomReset: function(a) {
            this.setZoom(1, a)
        },
        checkZoom: function(a) {
            return a < this._minZoom && (a = this._minZoom),
            a > this._maxZoom && (a = this._maxZoom),
            a
        },
        setZoom: function(a, b) {
            if (Jb.num(a) && !(0 >= a) && (a = this.checkZoom(a), a !== this._zoom)) if (null == b && (b = Dd.ZOOM_ANIMATE), b) Ib.animate.AnimateManager.start(new Ib.animate.AnimateZoom(this, a));
            else {
                var c = (this._view.scrollLeft + this._view.clientWidth / 2) / this._zoom,
                d = (this._view.scrollTop + this._view.clientHeight / 2) / this._zoom,
                e = this._zoom;
                this._zoom = a,
                Wb.setZoom(this._rootDiv, a),
                this.firePropertyChange("zoom", e, a),
                this.onZoomChanged(e, a),
                this.centerByLogicalPoint(c, d, !1)
            }
        },
        setTouchZoom: function(a) {
            this.setZoom(a, !1)
        }
    }),
    function() {
        var a = function(a, b, c, d) {
            var e = new Pb;
            e.src = d,
            Ib.Util.registerImage(a, e, b, c)
        };
        a("subnetwork_image", 64, 46, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAuCAYAAACYlx/0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAB1JJREFUeNrkWmtQk1cafr4vUQhEiNeBpkWwXitCqK1WaiU4tCMjlmCnrU4rmE4v2v1Rmf7q7M6is/uj7e4OurMz7fSyiXXVddsasBa0xQawoqiFFPBWJATkVpQSLPdLTt/zkTCgSHVNuISXeZLvnC8JeZ7zvu8578kBRs/UhB0EE6GZwIaBmbCToIEXWSjBcAfCI4GLoZ3QzIX+0RwgpYnUsPT0dGY2m5nDwYagqKiYGQwGlpiYeKsQJvoc1UQjriKYCYwjJiaG5eScYN09fXeF8qsVLDk5hbneT2gWJkpYyARBJQpCMYFNV6nYRx9/wtq7uv8vnD57jkVGRjL+WYRmgsYDg+U+U0ydoiJvNpPjagICA2E6moVlERH39Zkt9hboEuJxobSUN+2iKMR2dPdYxkSAQD+FhoJSxxiLAY9LNsgtBeS6+qYFBuC/piNYGr7MLV/yZksLXkx6FpfKynjTRiJEtbR32EdFgNmB01REeAdjSHFm9N8146Ev8fgTq9zqqr/evImN8XGoq6nhzd1Nv7amelwA9awZOsrQBjizsHLaNCxf8YSEhUseue0L/nT5IgICArAp5RWP5Jeis2fwxpbN0jX3gtobv1g8IkCYOkjFiDiNvI63gx5QQ7/tD1i9Ng5KZcCYJtl3095BdqaJf3NjVX2j3u0CLA4LUTkcDjNzxvfLr24jbIdDmpLH3q7X1yMlKb5/xpGJSTwxOm9ZLldW2+9LgIhF8/vJ05zr76/EO399H0siHh1vawykvf0mSi1Fw9220/1cQRDyCBklV67a7kmA5eFLTNzt/ZVK/Ond3VCHPjwu1xqWwlM4lvnFQLvKehVtra23kyMRKFfsOVdyMfd3BYheHrmV3J4nPPz57/9CcEgoxqsRMdBADbRFQaQ+4HJZCWqrrDhtzkG1zTr49UZC6qnzxfZhBVj75EqVo89RybN9/MZNWLvhuYldg5AaDTVVOPnNURTmmwfCQxTF2O8KCi23CbBO+xQVLSxt+szZSP3LP9DrcHhFGSrQX431CrI/34+6a1VOcUR9tjnfOESAxHVxvD5XPbtZjwWRj8HbzNHTjexDeylELM41hBhlyvpGagibdBv40tYUOGMmknf8ET19ffBGk4si8r76H0rPF0rhIJPJww4czrDLfXx9+bqeprsodHR1w1utF31YGZeAlqYbaGyo4yvbdIJe2KZPLuZbUNoNz2O6ei683dqbfsbxz/e5QiFMrlD4SSs+1aw5cHhJ8hvJlLOCMG/hYtRfq+YZ8C25r59CujHVz9+rQ8Bl3TTIcxeHo7npOp8BtHI/Ig7XBhzDpDDV7GA4eWvkhn37pc650esmRQg4Yx8u3nJrZaV00dbZjclkLt5yV0e1tRwPjtPix6PrA14+0rO2zlaBkHkLJgXpcloROqtAO/eAPC5AydkCPBkXPykE4FydlivnNTOpkVZCNXZXZwf8/JXevRBqa8UZ83EqoQU+8+2V0UODzxS5TibKgnx8fLAoQiOVk96KzH2foOJCKWSiYOvpc2yXkuAUuXwP3TaczMrA07oXoPBSL+Be/n1WJqbK5TT6LLWzpxcyaXXU22tRKnx1zNEbdL2uBo89tVZyEW9CXVUFDO/vAnHkW+pGe1vHe0O2xIJUARpBFHlhhKSt27AmYaPXjHz+14dhMnzY32Ast765JdZ1T+a6aO3sapih9K+Sy2S68pIizJwTBHXo/Akd7/XVVhz453sozMmmmBe5Jxhrm5qTht0Uddl8dbCB3ruVX6+O1yFhy2sTbsQvnj+D77MzYb1UMtDHHCz1al3D7mE3RW+1R8JC0klBfpwFwSFhWP/yqwijCmpckCsqRENVJYLnhsGXCprO9jbUU7ujvRUN1ZVEumzI6xljRsKuS7ZrtuH3De9gkQvn6URBHPhdMJQEWPVMAhZHrRgz8vYbjfgg7W2J9EhGGd5GDxlEfM+P5VbbyBunI9jjSxepyBO4N2wd3B+6aCkio7USRss6O9rw2d92oqF/IG1E7lZiedTH9/1zz124ctc/mt7V+YBoTXgoifAWQUcIdfVvSNmOiFVrRkWAr/Z+iJLTeZIjUNkedaq41OaOz73nEyKxK5drnGJIXrF+y+tYtnK1B0e+HSe+3I/SMyelNidvLvxhbE6IDLb4mGiDS4SlK1YjVrcZvgo/t5JvrK3GsYOfSs/95Jn+WH6B0Z3/477OCCU+rd1JIqTx68AZs6DVbcKCcI0bRr0DRfnfouD4kYH8RyMfeyQnz+JuD7vvQ1LPr39GSyIYXLlhzgMP4dE1cZIQ9+oRLb/cQNm5Avxw8gS6yPWd01gukdd/kfWtzRMh5pZTYi/p1vPZYoczNwwcapxPIoQ8vFASZY76IRJEMeR9P9fWSESvVfyE8rJiNNbVDJ6/eabf9R/TUSM8aG49Jqd/IUkliiIXImXwbHEvRqQtNOJ7/n3osEeJe0SAwbY9ebOGxOBnjGKcYtxJEAsnTfiRkPHBZwdtGEX7TYABAPgBTYK366ChAAAAAElFTkSuQmCC"),
        a("bus_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAINJREFUeNqkU0EOgCAMo2Y/1P8Y/6NvnBADwTnGzHYiGetKW8DMKVJLChbVAwCNCrrzp5/Zg/4MaH0JMBOEh08o6OtxtgvXvkFuV/vFBeGEm0WZo8GgF+QlIkI2OrZq5WLAFjuy4DvVWXHl2VodyElMjkxAJNFm4EjmFGAqLKLf+RZgAKkFNRwzv7gHAAAAAElFTkSuQmCC"),
        a("data_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNqkU8ENwjAM9KEwWwaAKVA3iMQDtRtUTAEDdLZWMkkhIUljU4n7RInP9p3dgoiYBAzDgHAyfykA1rtzbr2bmpDDk5uBvu+ROO98pvs4FqRL10nCogokBS3UBaXCZg9JQ7JQY5qmZoK1trCQCuQJnoS9CsQZHKsNcOyWvS1ehdGqz8xyZ0BXEHG+PTdvj+uJkFsASsusdN5sQSKHGWgWfDxY1GcQfEIYIn4p+HuN+SqXRtL8+ZAOinwm5V+P8ZcAAwC0T1T5kpEqewAAAABJRU5ErkJggg=="),
        a("databox_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwMjI+N/BiIBUD0jMp8FpDm4cQ2DvYEiw8EL9/FqBqkBqUc3BGT7/0kbz/6HsXHhS/eewtWBXA7CYAMOX75PlCEgA9ANYYQaADbJVleRAShJ0Csw7+T5G2MaQCpgQReAuQAWqPhokAuYGCgEowZQwwBQuiYn/mGAEZaeYTkSlA6IBeCUCDMA2RBSsjZAgAEAOyp6/CYHWkwAAAAASUVORK5CYII="),
        a("grid_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQsACIhgZGUl2BtDljCguAHkFhIMb1xBkU9ULjCATQV4A2UAsWFsfAvcCzEn/YQBoEEE2VD1Y76gXhpcXyM0LjJRmZ4AAAwCoyOJjz29PsAAAAABJRU5ErkJggg=="),
        a("group_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAOFJREFUeNqUUwsOwjAILa67i2fwEMbEnUej55mJO4Rn8DBtglAh6YfOSdJkBfregwEgottiHiAlQuZjh68TQRJzI5L07nSbC//zOrUAmkxAJXBP2VgxRjpDK818z06gZIwrfSACF0iVVZrLiab7ownOl7PTV0QESsRgWqoHt80oD0fpy/BVhuZfsOpkC8LYxAkBw4YedOdDhuRny1UyZEPE334NvbZ6kBYeJGFPKFgp4HsUAqtI9u1AYipJgfQ+GjtQlPvPMkGlBHrLdFjeBeHruE+hYAxSo6C3jb4zyh8BBgBVL19PZ27iaAAAAABJRU5ErkJggg=="),
        a("group_image", 32, 29, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAYAAADLnm6HAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABHNJREFUeNqsV1ts21QY/uy4zc1ZnZY2bdbSLMlKxUWkaBJMgJY9gARIax/2NokVofLARWjiBYRY2QMdCGlI440H1ok3btsQ0wAxNdvKpnYdyyYK7UZHVK1L2rRZLo3j2InDOaZD60psp+WXrDjO93/nO7/PfwkDAwu0Nh8jH30wZwc6/f43X9jVJ5gBn/zueJozgaNkUXLtMwLyLt4XDG4Vtj+/B8lMQRf7QLsb079PCpzJnaVnEsmIEeiZgD/Mu5yYT4uYiWd1sW1NTlCsWQGmzC00gOd5lFQVkqLoYiuViobVBNzf3BRaCfUaUyuV2AomXI1sNrmkRUeUZBRlBXJJRVFRdQUoZVXDclvbvUeImn6j3VmAqpjg5ra0xcL2nDwdwW1JQeP2HJLLki7frVQOo+OXwNnttv5fp65vKPSvvLhHmBgf77fV10XqWBaLZPGEgYC0KIFiOYfdBoY8OH72D8QS6ZoX3x1+CFarFZSnxS1gk9OBeUJ+00BAimAolnM6nQDDEDVAHVOpWQBD/Ow2GyhPoyDHWKjYkr+GVrv+GWBmE6BYIsChRYCz0Kt2AWR92GxWUJ7TFy7GWltb9l368ZteM77lcukE53A4tC91VAC7jggwVIANd3h+OHM+Qlj2ktvQv9U0EIAkSZibm7vbNUpcIxxPQsfQV2BhwDHrE2C320F5qPnaPCMkdVel9EdDQ8iLeex/5+27H4dYljnGnRo5B1EUMT1fwI2lUs0CHs9JOD9xGeNjY9i7u9dXkKTovZgvv/j8H+y2njX+3FxiHmKhgHiGhCir1CwgKxawsLgEynP06xO0aO2sxV+rhAopm9migrRUuwCJVDMS8nXXEE2ALMtIF2UskVJaqxWIgIqqrl8ATUGFkNDaLKu174RGjzYWykO9A17P+6pa2WEqhVnmDOfmnUgmk+gN2vBsZ33NAng1DxspIpTH1+H1Pdrz2OCHn34GpaQfFYe1Dm+9+nKY62jzpIcG3xU20gukXAZtzU0Rkoo+mo6/TMZxI6E/Dzz9sFdLXc7jad6pSIW+jQho2OSKjl2djOyiAwmdB8jrLMj6Ka3emQd+Gh2jeUvTp7/aTGBgwyv+cJNm5HLx2plQSmX9AkYuiuXqOUuorKoj1RZ/7fU34PcHMLj/PSwv5/4LMsgy7EtKuTz887kLyMoq7CERi/miroD5TB4Xr/wGrsPT8omqqlV3PjAwgIYGAd9/+xVmrledG46QjhiZjs0iSYtSehk3M6KugAUigGK5rqA/rAc89MEBOJy81qq7u4LVJyYL27eYSkV50hkXxCLmDCKQIhiK5do3e3VL59TUNdrZ0N3dddTgLMQ89zX5XKQtP+m14kGB1QVv4VVMrIwCRn9M6PkAGctN1fjnwk9ddjc2hcxgb6eWov/rWE7tVGS0ZyWjfEYRoxlkVoBAIhE2gYst5vKDpVJ51QR96PBhxONxfHzw4Oo+wFl2mBFAJ1W6+IgR0OGwD2/zda4Z32/99ScpTiU80fPIvT/1/y3AAMOmtJl1Hv9IAAAAAElFTkSuQmCC"),
        a("link_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHVJREFUeNqkkwEOgCAIRaEr6nlqdR49I4XTzcqUn39jE5xP1C+LCPkjCl0Kq2NC5fYgRXlMSCw0K6Xozhqaol3ckj+QVwGFNIsI5HPCCunSLZDhGUcQ0033IOb3riE1CLJty/bTVubUBqDyc+Pm01oY8NQpwAAbUwhLBQIWcAAAAABJRU5ErkJggg=="),
        a("linksubnetwork_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAU5JREFUeNqUUi1Tw0AQ3cukEY0AwdlDM8XRD41ARAAi/RHoCmQ7/QNofkTQFQh8W9kOOtgiQIBImTnuXbs3udAvduZms5t9b/fdrUiHGW2z0cOdLsdJ71GU46yfUrgL/PWx8HLxsUTOI3EE98mp9ZdXie0K8HgydYXtVtN6znHsTQAwdy2DOcY/TMFytkqogqskLIf6qQhYL7q/PI8cOIoiiuO69bvIRf3o5M/YANVqIZ03GjSbz2m5/KGiKDxgp90irbUINzEz2BSQEMKSwJiEwfgONmlFR4AAhg2yV0talWNfAbfJN4s7KHcCCcBPgy7WhobdM7q9uXbd3TPyhvEOwL4/30kpRVJKwrYySZ7nWABlzpsthM49R5lzYUhAruERr/P7CdZNPJJVakUiuOgAw9jSXOyUX8f4ZkCHGzQvAGIw4v9M4E0CMEh/BRgAwM37IYxGnbkAAAAASUVORK5CYII="),
        a("node_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGBJREFUeNpiZGBg+M9AJvj//z8jC5RBsmZGRkYwzQITCGlaS7TmNXXBcDYTA4Vg1IDBYAAjJB2Rl5DgKRGWqshyATm2o3uBgcwMBbacBZdmZJfh8CJIASMLodxGCAAEGACTAB0gDBYjygAAAABJRU5ErkJggg=="),
        a("node_image", 30, 32, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAgCAYAAAAFQMh/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAO0SURBVHjavJZJaF1lGIaffzzn3pvbxAyYJulgNKJIF7WkuhEHFCy40LpRBLdFcFi4ciOCC9dmU910WbduBEEoRhFEarJw2UaLJXFImya5ubln+AcX5+YG3ZjCaT44cDb/+5zv/Ybzi7npo7Mhhi+886c5hFBaLUshX9dKq8tW2bPjExOHweXW+vpZ7/1lrZWanz52jK+//f5QwC8+8xSrN2/Oa2OM10pJgKwoWd/cRQpRKyzEyMRIk9QatFIYY7xOEou1BoD1zS6ff/kTqbW1grtZyVsvz3N8cgRrDUli0dZabB+kpGSkYdHWUGfOSkT6prLH04m1GFOBBaAkKBkQsU5wACpBYyyJtfSt1hVYVGDZf68rpNjXs1b3rU72rZaAlhFJRMj6wJUm+1bv1diYqrmEFCgJQtaf8Z6gMaaqcbPRpJGmgxprCYhYK1iL/YwbaUqz0UTneUFeusG8uRARNYPLEAn95spLR54X6K+uLDI1NQ3A7e0ey3+UtBJDnfO004vc6WRMjg3zzeIPrK2toje3O6StLWII7GYFt7qOPNS7uTo9x25WEENgY2uLze0Oem9xhOBwwZM5j3WyVnDmPC54QnAoWWlrgBgj3nuc9+yWHq3rBe+Wlbb3nhjjPhiowM7TdQ7t6rW66xzOVeBBpw/AzlM4z3bpkTVnvF1W2t79B1xZXVI4x3bpUfcE7PC+/LfVUgic80giY6lhJDG1gmUESawY/QWhG0aLxBh2dnoMqcBrpyawNWdcuMCQCuzs9EiMoWG00GPDR2QrMVxdWqIsch5L1cCOukJowerKn/x9M6GVGMaGj0hx+uEHrypjzzwwN0cI4Z7et6SU/HbtGr4sftbNVvN9a5NP1m78elpK6a0x9wRalCUhBNUeai0Xhf5ASykXh4fbbxo9+nin2y2v3/i9B3jq29YRUA+dPN5ot1qmdOXS7dvldfHIiRky5wBJt9djfePONHA/4Or6KwJ/TYzet9pqNIBAqjVianSEtY1NgCeBd4FTQBuoq+AS6AC/AAvAj1OjIzAzPoqS8pyAFQHx/x4gzs7OxosXP4ufLizEkydORA5wrv+sKCnPzYyPooFHh5vppQiTB/n8PMt47523Of/qebIsY7fT4eOPPiRJkoMcnxVwCXhOH2kPXWi3WpMH7s48J5Ql1tpq3p3j6Pj44MJ4gJgUUlwQzz5xpgMMHbhFYyRNU55+/gWC93x35Qp5niHu7q60I9545aUeoO5qPkJAqupICOFuoQD+nwEAIKWd899qAZAAAAAASUVORK5CYII="),
        a("shapelink_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIJJREFUeNqkUwsOgCAIxeYN5Ty1Og+ekUarzRwQ5tsYDpTPExIzgwY86uWgtSTwIAF6KTvxg/sMliwwCy27mEVr2Xu7+TjaWm4JqxvKpW/iWowQprX2i8RXhS0xXv+WL0xiKIAVxKssa/0hEMuPiB4epNFxnh7lZG1jdCPdABGcAgwAc06H0rgwLSIAAAAASUVORK5CYII="),
        a("shapenode_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAI9JREFUeNq0UtsNgDAILI0jdZN2Ho3O027SnRA+MNb0QTWS8EPuLncAIKL5UvY5CEdC7h7pjrEtEABgqwucRCBFk7aAfo9uZJtwmXhQCLDyLJlrkSxaMuGgu8QZ8hVhYD8LVgZx9fMO1H9QKXbm+EJvBYwsuSYyFaEmUvyBUkQWCYUDfg5NV8/49xW6dQowAIJydCoPajIHAAAAAElFTkSuQmCC"),
        a("shapesubnetwork_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAATBJREFUeNpiDG5cw4ALbO/L+I/M9yyawYjMX1MXzMCCT/PXD69RxLgFREFiKIbADSjzlAfTjq6eYFtBmk+dPgNXaGZqAqZhYjA+igtAmmG2ImuG8UFyIFfAvIPTC+ia0Q2BeYehLpiRCeZfkO37d2/HqRmX4Yxc/CJwZ9+6fYeBEPjw4QOYNjczZfj//z8j3AuMjIjAvXnrNoomdTVVFDkonxEjEIEmgg1C1oAuhw5YQKEZGhHzH9kVbcuPoiiqirSGy5UUF8FtBwFwIK5esYQRaIMfyE/Y/A0yEGbopk2b/FACEeQ0mO1Ati+UvQndFciuAVkG5W5GMQDqV1+QAci2oxuAFC5+4MCBGQIzAEKBBbFimBxILc7MhOQiPzTxTcixwYhsOxLwRWJvxicHEGAAkPKxzyGuYWgAAAAASUVORK5CYII="),
        a("subnetwork_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAOJJREFUeNqkUjsOwjAMzavSBQYY4FDM7SGYOUARHICZQ5SBiUPBAAMLIJk8aFASkoDgSVFlu/68Z6NatCqF3Woqrj2ZreHabVMpnUs+H/eerz8c0+cV0amuTK6XG69bDEWsa5hM0KafU/DZeJRCmBwWsXRUUwEU0Y5tRFLfgHRMARYDeoPRSyy383Zee0nsgO5rcROBzo19FUlOoYG0Bp/0IAW7y4LHQT5GB/UL4F6ie3mX0yFLoTQUTByQxE8lQ51wMRHx1Chd4FtkReQUj3VFktj97ZSDNYkK9h6L/03hLsAAjRx4oMVjqkMAAAAASUVORK5CYII="),
        a = function(a, b, c, d) {
            Ib.Util.registerImage(a, d, b, c)
        },
        a("expand_icon", 16, 18, "data:image/gif;base64,R0lGODlhEAASAIcAADFKY0L/QpSlvZylvZytxqW11qm92r3GxrnK5MbGxsbW69jh8efv9+vz/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAEALAAAAAAQABIAAAhfAAMIHEiwoMGDCBMqXMjQ4AICEAcMECDgwEECDjJmbMAAwEWNDjgi8GgQ40YGCwyQLDjAAYCXL1UeFBAS5QIFBVYSFMBxwU0EOWcyUIDAQIGjOgcegMnUYsOnUKMiDAgAOw=="),
        a("collapse_icon", 16, 18, "data:image/gif;base64,R0lGODlhEAASAIcAADFKY0L/QpSlvZylvZytxqW11qm92r3GxrXI48bGxsbS59Te8efv9+vz/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAEALAAAAAAQABIAAAhhAAMIHEiwoMGDCBMqXMjQ4AICEAcMECDgwEECDjJmbMAAwEWNADgq8GgQY0YADBYYIFlwgAMAMGGuPCjAAUcACxQUYElQAMcFABQg2EmTgVADBZLyHHggplOLDaNKnYowIAA7"),
        a("close_icon", 11, 11, "data:image/gif;base64,R0lGODlhCwALAIcAAHd3d319fUD/QIODg4iIiI6Ojq6urri4uNnZ2eHh4eTk5Ofn5/Dw8PT09Pj4+Pn5+fz8/P39/f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAIALAAAAAALAAsAAAhdAAUIOECw4AGBAyUoXCjh4AEJDBA4mIiAQcMDERAUKOBgI4IIBCE0IECSZAMIBB8wYDCg5coHBBkkCECTZgIGMQ0AAKBgpwGcBxgsMLCgKFGcA1cqXXlQoMGCAgMCADs="),
        a("sort_desc", 9, 5, "data:image/gif;base64,R0lGODlhCQAFAJECAImJiezs7P///wAAACH5BAEAAAIALAAAAAAJAAUAAAIMDI4QYrnC0INxUnYLADs="),
        a("sort_asc", 9, 5, "data:image/gif;base64,R0lGODlhCQAFAJECAImJiezs7P///wAAACH5BAEAAAIALAAAAAAJAAUAAAIMlAWnwIrcDJwi2HsLADs="),
        a("submenu_enable_icon", 8, 8, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAA7SURBVHjafI9BDgAgDMKqH3c/ryd1iTqOpARARQUYJG0/AWboB2yoAgTG8jtvtXvMSUdVEdXIeN2cAwDPLmAjfDYS7AAAAABJRU5ErkJggg=="),
        a("submenu_disable_icon", 8, 8, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABKSURBVHjafM9BDoAgDETRD1cTz0W9luDZxhUBCjpJkzZ9m0ESkrhLzW0fJ9JjpT4Zl+juBXmwoB0ACH/gOtNhX2B6AjDUtF3NdwAU6zx4LEQe5AAAAABJRU5ErkJggg=="),
        a("checkbox_selected_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAflJREFUeNqkk09oE1EQxn+7btyIYBRCbayFtlhEtLeAin+KouDNo548eJHCQkFQC1K0Bw8VqT1EVIqo0IMUvejNg6AIIglSsdSCiA0WolaIOWi3+2fGw242CRFBHPjg8d7MfPO+mTEcxzkNDAF5/s1KwE0cxylWKhX1fV89r44gget6bVhd9bRcLqvjOEULyGezWTwvAMAwjIRCRAnD8I/0nZ05gLwZOTYeVBXQOIGgqgk+flrk3MUxVBWRyMeMw5oCG2eREFVBVZibf8+x4ydZLH9GVRISq5W5uXwhDKPSvnz9xolTZ/A29GNZFiJ1kjhBnVFVEw0a7MrQ8HlqbMZwXeYXlpL7ti/Usbz8Hd8PEBGmHzxk9kMVfI+BrWt4PHM/0abtC67r8vTZC4qlWY4c2s/Azh2MTxQwpIPduzZx99Z1bNtu1yBiFp6/fMXr4ht+/NzI+MQNBg/sxdccPbmAqcI1UqkUEresTQMR5ejhQbb19XJ25BJzC8Lbd3dIp22mCtPY9tokuDmB2VyBqtDb082VyxdYv26JXysrTF4dY0uuI3lvoKWCaOoMA1SF7q4u7t2eZObREw7u25MMTbPF8VGCqHNRB4IgQFXY3t/H6MhwLFirGYZBfeItoFSr1fKZTAbVaPbT6fRf19A0TarVKkDJ+N91/j0A8Y5o3Yt7KRAAAAAASUVORK5CYII="),
        a("checkbox_unselected_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiUlEQVR42qXM3QYFIRiF4d3dJpIhI5FKJCOSSHe7f9gn4ztZo3Wwzt6HvTbHfhdCeD8Nvw27Ad57OI4xUsA5BwMpJQpYa2Eg50wBYwwMlFIocJ4nDFzXRQGtNQzUWilwHAcMtNYooJSCgd47BaSUMDDGoIAQAgbmnBTgnMPAWosCcP3fDdjZNvABvRhVEQglsV8AAAAASUVORK5CYII="),
        a("radiobutton_selected_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAXFJREFUeNrUUz9rwkAUv0syBVxMm01L2lIdilOg4BcQ7eKcIV/AqZAxo1/B2a/QoSSTH6AQCoFMJUSig5C0EiPEv8G+Z604eJNTHxz37vf73Y977+7obrcjlwRHLoyLDYTThWmav6AgKDA9wrg6UF8wvO12O8RFt9s9bwACwvP8U6lUajWbzbYsy/eIR1Hk27b9GgSBlef5O7OEzWZzC5ufNU17gc01gEQcmCOGHGqYJaxWq1qj0WhzHFfwfZ84jrPHVVUliqIUkPM87wOg4KzBcrm8liTpbr1ek8FgQNI03eOz2Yzouk6QQw3zBFmWUewDxnQ6JUmSHHsDRz9qmD0A8ns8HgcortfrRxxzxJBDDfMEi8XC7ff7b4Zh3FSr1UKlUtnjlFI0mCOHGqZBHMd+GIbWZDIROp1OCxqH74HA9Q17vZ7luq4liqJ/uoee/oVyufxX/wPctwqpfKAieB9OsVj8xMVoNDpv8D8/048AAwDskrF8QGeJUgAAAABJRU5ErkJggg=="),
        a("radiobutton_unselected_icon", 16, 16, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAATVJREFUeNrUU71qhEAQ9q8S0mhip3C5kCpcFcgjiJfmal/BKr2lr2DtK1wR9BkCaYRUQTzUQtDE5sB/MTOJAQs3jVUGhp2Z75vPnV2XHseRWmMMtdJWC3DzxDTNnyLHbWC5A7+coA/wt77vT5hYlrUsAASKZdkHWZb3mqYdJEm6wXqWZYHneccwDN1hGF6II3Rddw3Nj7quP0HzDko8OsZYQww5RIGmaXaqqh4YhrnA3cwda4ghh3gGdV1fiaK4bdt28cAQQw5RoCxLGr/2lyGHOAKAn0mShDAnteSIIYcoUFWV7zjOM5DPuJPfxik+I4Yc4gh5ngdRFLlpmnKGYew3YFiH6zvZtu36vu/yPB/Me+j5W1AU5XstiuIW7vseQmmCMvg/XgVBeMckjuNlgf/5mL4EGAAhHbltcqEYDQAAAABJRU5ErkJggg==")
    } (),
    Rb.__tree = function(a, b) {
        a._rootVisible = !0,
        a._initTree = function(a) {
            this._rootData = null,
            this._expandMap = {},
            this._levelMap = {}
        },
        a.validateModel = function() {
            this._rowDatas.clear(),
            this._levelMap = {},
            this._dataRowMap = {},
            this._currentLevel = 0,
            this._rootData ? this._rootVisible ? this.isVisible(this._rootData) && this._buildData(this._rootData) : this._buildChildren(this._rootData) : this._buildChildren(),
            delete this._currentLevel
        },
        a._buildData = function(a) {
            this._dataRowMap[a.getId()] = this._rowDatas.size(),
            this._rowDatas.add(a),
            this._levelMap[a.getId()] = this._currentLevel,
            this.isExpanded(a) && (this._currentLevel++, this._buildChildren(a), this._currentLevel--)
        },
        a._buildChildren = function(a) {
            var b = a ? a.getChildren() : this._box.getRoots(),
            c = this.getCurrentSortFunction();
            c && this.isChildrenSortable(a) ? b.toList(this.isVisible, this).sort(c).forEach(function(a) {
                this._buildData(a)
            },
            this) : b.forEach(function(a) {
                this.isVisible(a) && this._buildData(a)
            },
            this)
        },
        a.getLevel = function(a) {
            return this._levelMap[a.getId()]
        },
        a.getToggleImage = function(a) {
            return a.getChildrenSize() > 0 ? this.isExpanded(a) ? this._expandIcon: this._collapseIcon: null
        },
        a.isCheckable = function(a) {
            return this.isCheckMode()
        },
        a.isCheckMode = function() {
            return 1 === Rb.__tree._checkMap[this._checkMode]
        },
        a.isChildrenSortable = function(a) {
            return ! 0
        },
        a.handleDataBoxChange = function(a) {
            "remove" === a.kind ? delete this._expandMap[a.data.getId()] : "clear" === a.kind && (this._expandMap = {}),
            this.invalidateModel()
        },
        a.isExpanded = function(a) {
            return 1 === this._expandMap[a.getId()]
        },
        a.expand = function(a) {
            if (!this.isExpanded(a)) {
                for (var b = a.getParent(); null != b && b !== this._rootData;) this._expandMap[b.getId()] = 1,
                b = b.getParent();
                this._expandMap[a.getId()] = 1,
                this.invalidateModel()
            }
        },
        a.collapse = function(a) {
            this.isExpanded(a) && (delete this._expandMap[a.getId()], this.invalidateModel())
        },
        a.expandAll = function() {
            this._box.forEach(function(a) {
                this._expandMap[a.getId()] = 1
            },
            this),
            this.invalidateModel()
        },
        a.collapseAll = function() {
            this._expandMap = {},
            this.invalidateModel()
        },
        a._handleClick = function(a) {
            if (this.isFocusOnClick() && Ib.Util.setFocus(this._view), !this._isValidating) {
                var b;
                if (a.target._expandData) b = a.target._expandData,
                this.isExpanded(b) ? (this.collapse(b), this.fireInteractionEvent({
                    kind: "collapse",
                    data: b
                })) : (this.expand(b), this.fireInteractionEvent({
                    kind: "expand",
                    data: b
                }));
                else if (a.target._selectData || a.target.parentNode._selectData) {
                    if (this._handlePressSelection(a.target._selectData || a.target.parentNode._selectData, a), this.isCheckMode()) {
                        var c = this.getRowIndexAt(a);
                        c >= 0 && this.__handleClick(a)
                    }
                } else this._treeColumn ? (b = this.getDataAt(a), b && (this.isCheckMode() ? a.target._checkData || this.__handleClick(a) : this._handlePressSelection(b, a))) : this.isCheckMode() && !a.target._checkData && this.__handleClick(a);
                if (this._currentEditor && !this._isCommitting && (this._isCommitting = !0, this.commitEditValue(this._currentEditor._editInfo, this._currentEditor)), this.updateCurrentEditor) {
                    var d = this;
                    setTimeout(function() {
                        d.updateCurrentEditor(a)
                    },
                    0)
                }
            }
        },
        a.__handleClick = function(a) {
            var b = this.getDataAt(a),
            c = this.getRowIndexByData(b);
            if (this._focusedRow !== c) {
                var d = this._rowDatas.get(this._focusedRow);
                this._focusedRow = c,
                d && this.invalidateData(d),
                this.invalidateData(b)
            }
        },
        a.handleChange = function(a) {
            if (! (this._isCommitting || this._isCanceling || this._isValidating)) {
                var b = a.target._checkData;
                if (b) {
                    var c, d = this.isSelected(b),
                    e = this.getSelectionModel();
                    if ("default" === this._checkMode) d ? e.removeSelection(b) : e.appendSelection(b);
                    else if ("children" === this._checkMode) c = new nd(b),
                    c.addAll(b.getChildren());
                    else if ("descendant" === this._checkMode) c = new nd,
                    Jb.fillDescendant(b, c);
                    else if ("descendantAncestor" === this._checkMode && (c = new nd, Jb.fillDescendant(b, c), !d)) for (var f = b.getParent(); f;) c.add(f),
                    f = f.getParent();
                    d ? e.removeSelection(c) : e.appendSelection(c)
                }
                a.target._editInfo && this.commitEditValue && (this._isCommitting = !0, this.commitEditValue(a.target._editInfo, a.target))
            }
        },
        a.onLabelRendered = function(a, b, c, d, e, f) {},
        a.onToggleImageRendered = function(a) {},
        a._renderTree = function(a, b, c, d) {
            var e = this._levelMap[b.getId()],
            f = this.getToggleImage(b),
            g = this.getLineType(),
            h = this._indent,
            i = this.__spanPool.get();
            i.style.width = f ? this._indent * e + "px": this._indent * (e + 1) + "px",
            i.style.display = "inline-block",
            i.style.position = "relative",
            i.style.verticalAlign = "top",
            i.style.margin = "0px 1px 0px 1px",
            i.style.width = (e + 1) * h + "px",
            a.appendChild(i);
            var j = b,
            k = j.getParent(),
            l = 0;
            if ("dotted" === g || "solid" === g) {
                if (null == k) {
                    var m = this.getIcon(b);
                    this._addLine(i, b, m, !0)
                }
                for (; null !== k;) {
                    var n = k.getChildren(),
                    o = j === n.get(n.size() - 1),
                    m = this.getIcon(j);
                    j.setClient("isLast", o),
                    0 == l && this._addLine(i, b, m, o),
                    l++,
                    j = k,
                    k = k.getParent()
                }
            }
            if (f) {
                var p = this.__imagePool.get();
                p.setAttribute("src", Jb.getImageSrc(f)),
                p.style.verticalAlign = "middle",
                p._expandData = b,
                p.style.position = "absolute",
                p.style.right = "0px",
                p.style.top = this.getRowHeight() / 2 - p.height / 2 + "px",
                i.appendChild(p),
                this.onToggleImageRendered(p)
            }
            var q = this.isCheckable(b),
            r = "disabled" === this.getUncheckableStyle();
            if (q || r) {
                var s = this._addCheckBox(a, b, d);
                s.disabled = !q
            }
            var m = this.getIcon(b);
            if (m) {
                var t = this.isCheckMode() || this._treeColumn ? null: b;
                this._addIcon(a, b, m, t)
            }
            var u = this.getLabel(b);
            u && (i = this.__textPool.get(), i.style.whiteSpace = "nowrap", i.style.verticalAlign = "middle", i.style.padding = "1px 2px 1px 2px", Jb.setText(i, u, this._treeColumn ? this._treeColumn.isInnerText() : this._innerText), this.isCheckMode() || this._treeColumn ? this._focusedRow === c && (i.style.backgroundColor = this.getSelectColor(b)) : (i._selectData = b, i.style.backgroundColor = d ? this.getSelectColor(b) : ""), this.onLabelRendered(i, b, u, c, e, d), a.appendChild(i))
        }
    },
    Rb.__tree._checkMap = {
        "default": 1,
        children: 1,
        descendant: 1,
        descendantAncestor: 1
    },
    Ib.Column = function(a) {
        Ib.Column.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Column", Ib.Data, {
        IColumn: !0,
        __property: 1,
        __accessor: ["width", "horizontalAlign", "valueType", "propertyType", "propertyName", "editable", "visible", "sortable", "resizable", "movable", "sortDirection", "sortFunction", "enumInfo"],
        __bool: ["innerText"],
        _innerText: Dd.COLUMN_INNER_TEXT,
        _width: Dd.COLUMN_WIDTH,
        _horizontalAlign: Dd.COLUMN_HORIZONTAL_ALIGN,
        _propertyName: null,
        _propertyType: Dd.COLUMN_PROPERTY_TYPE,
        _valueType: Dd.COLUMN_VALUE_TYPE,
        _editable: Dd.COLUMN_EDITABLE,
        _sortable: Dd.COLUMN_SORTABLE,
        _visible: Dd.COLUMN_VISIBLE,
        _resizable: Dd.COLUMN_RESIZABLE,
        _movable: Dd.COLUMN_MOVABLE,
        _sortDirection: "asc",
        _sortFunction: Dd.SORT_FUNCTION,
        _enumInfo: null,
        renderCell: Dd.COLUMN_RENDER_CELL,
        renderHeader: Dd.COLUMN_RENDER_HEADER,
        setParent: function(a) {
            throw "parent not supported"
        },
        getEnumInfo: function() {
            return "object" == typeof this._enumInfo ? this._enumInfo: "function" == typeof this._enumInfo ? 1 === arguments.length ? this._enumInfo(arguments[0]) : this._enumInfo() : void 0
        }
    }),
    Ib.ColumnBox = function(a) {
        Ib.ColumnBox.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.ColumnBox", Ib.DataBox, {
        _name: "ColumnBox",
        add: function(a, b) {
            if (!a.IColumn) throw "Only IColumn can be added into ColumnBox";
            Ib.ColumnBox.superClass.add.apply(this, arguments)
        }
    }),
    Ib.Property = function(a) {
        Ib.Property.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Property", Ib.Data, {
        IProperty: !0,
        __property: 1,
        __accessor: ["horizontalAlign", "valueType", "editable", "propertyType", "propertyName", "categoryName", "enumInfo"],
        __bool: ["innerText"],
        _innerText: Dd.PROPERTY_INNER_TEXT,
        _horizontalAlign: Dd.PROPERTY_HORIZONTAL_ALIGN,
        _propertyName: null,
        _propertyType: Dd.PROPERTY_PROPERTY_TYPE,
        _valueType: Dd.PROPERTY_VALUE_TYPE,
        _editable: Dd.PROPERTY_EDITABLE,
        _categoryName: Dd.PROPERTY_CATEGORY_NAME,
        _enumInfo: null,
        renderName: Dd.PROPERTY_RENDER_NAME,
        renderValue: Dd.PROPERTY_RENDER_VALUE,
        isVisible: null,
        renderEditor: Dd.PROPERTY_RENDER_EDITOR,
        setParent: function(a) {
            throw "parent not supported"
        },
        setPropertyName: function(a) {
            var b = this._propertyName;
            this._propertyName = a,
            this.firePropertyChange("propertyName", b, a)
        },
        setPropertyType: function(a) {
            var b = this._propertyType;
            this._propertyType = a,
            this.firePropertyChange("propertyType", b, a)
        },
        getEnumInfo: function() {
            return "object" == typeof this._enumInfo ? this._enumInfo: "function" == typeof this._enumInfo ? 1 === arguments.length ? this._enumInfo(arguments[0]) : this._enumInfo() : void 0
        }
    }),
    Ib.PropertyBox = function(a) {
        Ib.PropertyBox.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.PropertyBox", Ib.DataBox, {
        _name: "PropertyBox",
        add: function(a, b) {
            if (!a.IProperty) throw "Only IProperty can be added into PropertyBox";
            Ib.PropertyBox.superClass.add.apply(this, arguments)
        }
    }),
    Ib.Tab = function(a) {
        Ib.Tab.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.Tab", Ib.Data, {
        ITab: !0,
        __accessor: ["view", "width", "closable", "resizable", "movable", "disabled", "visible"],
        _icon: null,
        _width: Dd.TAB_WIDTH,
        _closable: Dd.TAB_CLOSABLE,
        _resizable: Dd.TAB_RESIZABLE,
        _movable: Dd.TAB_MOVABLE,
        _disabled: Dd.TAB_DISABLED,
        _visible: Dd.TAB_VISIBLE,
        setParent: function(a) {
            throw "parent not supported"
        }
    }),
    Ib.TabBox = function(a) {
        Ib.TabBox.superClass.constructor.apply(this, arguments),
        this.getSelectionModel().setSelectionMode("singleSelection")
    },
    Jb.ext("twaver.TabBox", Ib.DataBox, {
        _name: "TabBox",
        add: function(a, b) {
            if (!a.ITab) throw "Only ITab can be added into TabBox";
            Ib.TabBox.superClass.add.apply(this, arguments)
        }
    }),
    Ib.controls.ListBase = function(a) {
        Ib.controls.ListBase.superClass.constructor.apply(this, arguments),
        this._invalidate = !1,
        this._invalidateModel = !1,
        this._invalidateDisplay = !1,
        this._invalidateDatas = null,
        this._rowDatas = new nd,
        this._startRowIndex = 0,
        this._endRowIndex = 0,
        this._renderMap = {},
        this._dataRowMap = {},
        this.__divPool = new Ib.Pool("div", 20),
        this.__imagePool = new Ib.Pool("img", 20),
        this.__canvasPool = new Ib.Pool("canvas", 20),
        this.__spanPool = new Ib.Pool("span", 20),
        this.__textPool = new Ib.Pool("span", 20),
        this.__checkBoxPool = new Ib.Pool("input", 20),
        this.__linePool = new Ib.Pool("canvas", 20),
        this._pools.add(this.__divPool),
        this._pools.add(this.__linePool),
        this._pools.add(this.__imagePool),
        this._pools.add(this.__canvasPool),
        this._pools.add(this.__spanPool),
        this._pools.add(this.__textPool),
        this._pools.add(this.__checkBoxPool),
        this._view = Wb.createView("auto", !0),
        this._rootDiv = Wb.createDiv(),
        this._dataDiv = Wb.createDiv(),
        this._dataDiv.style.width = "1px",
        this._view.appendChild(this._rootDiv),
        this._rootDiv.appendChild(this._dataDiv),
        this.setDataBox(a ? a: new Ib.DataBox);
        var b = this;
        b.handleChange && b._view.addEventListener("change",
        function(a) {
            b.handleChange(a)
        },
        !1),
        Qb.isMSToucheable ? new Ib.controls.ListBaseMSTouchInteraction(this) : (new Ib.controls.ListBaseTouchInteraction(this), new Ib.controls.ListBaseInteraction(this))
    },
    Jb.ext("twaver.controls.ListBase", Ib.controls.View, {
        __bool: ["innerText"],
        _innerText: Dd.LISTBASE_INNER_TEXT,
        getDataDiv: function() {
            return this._dataDiv
        },
        getStartRowIndex: function() {
            return this._startRowIndex
        },
        getEndRowIndex: function() {
            return this._endRowIndex
        },
        getRowDatas: function() {
            return this._rowDatas
        },
        getRowIndexByData: function(a) {
            return this._dataRowMap[a.getId()]
        },
        getRowIndexById: function(a) {
            return this._dataRowMap[a]
        },
        getRowSize: function() {
            return this._rowDatas.size()
        },
        getDataBox: function() {
            return this._box
        },
        setDataBox: function(a) {
            if (!a) throw "DataBox can not be null";
            if (this._box !== a) {
                var b = this._box;
                b && (b.removeDataBoxChangeListener(this.handleDataBoxChange, this), b.removeDataPropertyChangeListener(this.handlePropertyChange, this), b.removeHierarchyChangeListener(this.handleHierarchyChange, this), this._selectionModel || b.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this)),
                this._box = a,
                this._box.addDataBoxChangeListener(this.handleDataBoxChange, this),
                this._box.addDataPropertyChangeListener(this.handlePropertyChange, this),
                this._box.addHierarchyChangeListener(this.handleHierarchyChange, this),
                this._selectionModel ? this._selectionModel._setDataBox(a) : this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
                this.invalidateModel(),
                this.firePropertyChange("dataBox", b, this._box)
            }
        },
        onPropertyChanged: function(a) {
            "zoom" === a.property ? this.invalidate() : this.invalidateModel()
        },
        invalidateModel: function() {
            this._invalidateModel || (this._invalidateModel = !0, this._invalidateDisplay = !0, this._invalidateDatas = null, this.invalidate())
        },
        invalidateDisplay: function() {
            this._invalidateDisplay || (this._invalidateDisplay = !0, this._invalidateDatas = null, this.invalidate())
        },
        invalidateData: function(a) {
            this._invalidateDisplay || (this._invalidateDatas || (this._invalidateDatas = {}), this._invalidateDatas[a.getId()] = a, this.invalidate())
        },
        validateImpl: function() {
            var a = this._view.scrollLeft,
            b = this._view.scrollTop;
            this._invalidateModel && (this._invalidateModel = !1, this.validateModel()),
            this._invalidateDisplay && (this._invalidateDisplay = !1, this._renderMap = {},
            Wb.release(this._dataDiv), this._dataDiv.style.height = this.getRowSize() * this._rowHeight + "px");
            var c;
            if (this._invalidateDatas) {
                for (c in this._invalidateDatas) {
                    var d = this._renderMap[c];
                    d && (Wb.release(d), this._dataDiv.removeChild(d), delete this._renderMap[c])
                }
                this._invalidateDatas = null
            }
            var e = this._view.scrollTop / this._zoom,
            f = this._view.clientHeight / this._zoom;
            this._startRowIndex = Math.floor(e / this._rowHeight) - 2,
            this._endRowIndex = Math.ceil((e + f) / this._rowHeight) + 2,
            this._startRowIndex < 0 && (this._startRowIndex = 0),
            this._endRowIndex > this._rowDatas.size() && (this._endRowIndex = this._rowDatas.size());
            for (var g = this._rowHeight - this._rowLineWidth - 2 + "px",
            h = this._rowLineWidth + "px",
            i = this._startRowIndex; i < this._endRowIndex; i++) {
                var j = this._rowDatas.get(i);
                c = j.getId();
                var k = this._renderMap[c];
                if (!k) {
                    k = this.__divPool.get();
                    var l = k.style;
                    l.position = "absolute",
                    l.whiteSpace = "nowrap",
                    l.lineHeight = g,
                    l.top = i * this._rowHeight + "px",
                    l.borderStyle = "solid",
                    l.borderWidth = "0px",
                    l.borderBottomWidth = h,
                    l.borderBottomColor = this._rowLineColor,
                    l.opacity = j.getStyle ? j.getStyle("whole.alpha") : 1,
                    this._dataDiv.appendChild(k),
                    this._renderMap[c] = k;
                    var m = this.isSelected(j);
                    this.renderData(k, j, i, m),
                    this.onDataRendered(k, j, i, m)
                }
            }
            Jb.keys(this._renderMap).forEach(function(a) {
                var b = this.getRowIndexById(a);
                if (b < this._startRowIndex || b >= this._endRowIndex) {
                    var c = this._renderMap[a];
                    Wb.release(c),
                    this._dataDiv.removeChild(c),
                    delete this._renderMap[a]
                }
            },
            this),
            this._pools.forEach(function(a) {
                a.clear()
            }),
            this._view.scrollLeft !== a && (this._view.scrollLeft = a),
            this._view.scrollTop !== b && (this._view.scrollTop = b),
            this.adjustRowSize(),
            this.onValidated()
        },
        adjustRowSize: function() {
            var a, b, c = this._rowHeight - this._rowLineWidth + "px",
            d = Math.floor((this._view.scrollLeft + this._view.clientWidth) / this._zoom) + "px";
            for (a in this._renderMap) b = this._renderMap[a],
            b.style.height = c,
            b.style.width = d
        },
        onValidated: function() {},
        onDataRendered: function(a, b, c, d) {},
        _addCheckBox: function(a, b, c) {
            var d = this.__checkBoxPool.get();
            return d.keepDefault = !0,
            d.type = "checkbox",
            d.style.margin = "0px 2px",
            d.style.verticalAlign = "middle",
            d._checkData = b,
            d.checked = c,
            d.disabled = !1,
            a.appendChild(d),
            d
        },
        _addIcon: function(a, b, c, d) {
            var e, f = Jb.getImageAsset(c),
            g = this.getInnerColor(b),
            h = this.getOuterColor(b),
            i = this.getAlarmFillColor(b);
            if (f && f.getImage()) {
                var j = f.getWidth(),
                k = f.getHeight();
                e = this.__canvasPool.get(),
                e.style.verticalAlign = "middle",
                e.setAttribute("width", j),
                e.setAttribute("height", k);
                var l = e.getContext("2d");
                l.clearRect(0, 0, j, k);
                var m = {
                    x: 0,
                    y: 0,
                    width: j,
                    height: k
                };
                Nc(l, c, g, m, b, this),
                h && (l.lineWidth = 2, l.strokeStyle = h, l.beginPath(), l.rect(0, 0, j, k), l.closePath(), l.stroke()),
                i && (l.fillStyle = Xb.createRadialGradient(l, i, "white", 1, k - 9, 8, 8, .75, .25), l.beginPath(), l.arc(5, k - 5, 4, 0, 2 * Math.PI, !0), l.closePath(), l.fill())
            } else e = this.__imagePool.get(),
            e.style.verticalAlign = "middle",
            e.setAttribute("src", Jb.getImageSrc(c));
            e.style.margin = "0px 1px 0px 1px",
            e._selectData = d,
            a.appendChild(e)
        },
        _addLine: function(a, b, c, d) {
            var e, f, g = this.__linePool.get(),
            h = Jb.getImageAsset(c),
            i = this.getToggleImage(b),
            j = this._levelMap[b.getId()],
            k = this._indent,
            l = k,
            m = k,
            n = 0;
            this.isCheckable(b),
            "disabled" === this.getUncheckableStyle(),
            n = 2,
            h && (l = h.getWidth(), m = h.getHeight()),
            d ? (e = (j + n - 1) * k + l, f = this.getRowHeight()) : (e = (j + n - 1) * k + l, f = this.getRowHeight()),
            a.style.width = (j + n - 1) * k + "px",
            a.style.height = f + "px";
            var o = this.getLineType(),
            p = this.getLineColor(),
            q = this.getLineAlpha(),
            r = this.getLineThickness(),
            s = this.getLineDash();
            Jb.getImageSrc(i),
            g.style.verticalAlign = "top",
            g.style.margin = "0px 0px 0px 0px",
            g.style.zIndex = -1,
            g.setAttribute("width", e),
            g.setAttribute("height", f);
            var t = g.getContext("2d");
            t.lineWidth = r,
            t.strokeStyle = p,
            t.globalAlpha = q,
            "dotted" === o && t.setLineDash(s);
            var u = 2 * (j + n);
            if (d) {
                var v = b,
                w = v.getParent();
                t.clearRect(0, 0, e, f),
                null === w && 0 !== b.getChildrenSize() && this.isExpanded(b) && (t.moveTo((j + n + 1) * e / u, f / 2 + m / 2), t.lineTo((j + n + 1) * e / u, f), t.stroke());
                for (var x = 2 * j - 1; x >= 1; x -= 2) {
                    if (v.getClient("isLast")) {
                        if (v = w, w = v.getParent(), (x + 1) / 2 != j) continue
                    } else v = w,
                    w = v.getParent();
                    x == 2 * j - 1 ? (t.moveTo((x + n) * e / u, 0), t.lineTo((x + n) * e / u, f / 2), t.stroke(), t.moveTo((x + n) * e / u, f / 2), t.lineTo((x + n + 1) * e / u, f / 2), t.stroke(), 0 !== b.getChildrenSize() && this.isExpanded(b) && (t.moveTo((x + n + 2) * e / u, f / 2 + m / 2), t.lineTo((x + n + 2) * e / u, f), t.stroke())) : (t.moveTo((x + n) * e / u, 0), t.lineTo((x + n) * e / u, f), t.stroke())
                }
            } else {
                var v = b,
                w = v.getParent();
                t.clearRect(0, 0, e, f);
                for (var x = 2 * j - 1; x >= 1; x -= 2) {
                    if (v.getClient("isLast")) {
                        if (v = w, w = v.getParent(), (x + 1) / 2 != j) continue
                    } else v = w,
                    w = v.getParent();
                    t.moveTo((x + n) * e / u, 0),
                    t.lineTo((x + n) * e / u, f),
                    t.stroke(),
                    x == 2 * j - 1 && (t.moveTo((x + n) * e / u, f / 2), t.lineTo((x + n + 1) * e / u, f / 2), t.stroke(), 0 !== b.getChildrenSize() && this.isExpanded(b) && (t.moveTo((x + n + 2) * e / u, f / 2 + m / 2), t.lineTo((x + n + 2) * e / u, f), t.stroke()))
                }
            }
            return a.appendChild(g),
            g
        },
        isVisible: function(a) {
            return this._box.contains(a) ? this._visibleFunction ? this._visibleFunction(a) : !0 : !1
        },
        handleDataBoxChange: function(a) {
            this.invalidateModel()
        },
        handlePropertyChange: function(a) {
            "parent" === a.property ? this.invalidateModel() : this.invalidateData(a.source)
        },
        handleHierarchyChange: function(a) {
            this.invalidateModel()
        },
        handleSelectionChange: function(a) {
            a.datas.forEach(function(a) {
                this.invalidateData(a)
            },
            this),
            this.onSelectionChanged(a)
        },
        getRowIndexAt: function(a) {
            var b = this.getLogicalPoint(a);
            if (!b) return - 1;
            var c = parseInt(b.y / this._rowHeight);
            return c >= 0 && c < this._rowDatas.size() ? c: -1
        },
        getDataAt: function(a) {
            var b = this.getRowIndexAt(a);
            return b >= 0 ? this._rowDatas.get(b) : null
        },
        getCurrentSortFunction: function() {
            return this._sortFunction
        },
        validateModel: function() {
            this._rowDatas.clear(),
            this._dataRowMap = {},
            this._buildChildren(this._box.getRoots()),
            this._rowDatas = this._rowDatas.toList(this.isVisible, this);
            var a = this.getCurrentSortFunction();
            a && this._rowDatas.sort(a);
            for (var b = this._rowDatas.size(), c = 0; b > c; c++) this._dataRowMap[this._rowDatas.get(c).getId()] = c
        },
        _buildChildren: function(a) {
            a.forEach(function(a) {
                this._rowDatas.add(a),
                this._buildChildren(a.getChildren())
            },
            this)
        },
        _handlePressSelection: function(a, b) {
            var c = this.getSelectionModel();
            if (Jb.isCtrlDown(b)) c.contains(a) ? c.removeSelection(a) : c.appendSelection(a);
            else if (b.shiftKey && c.getLastData()) {
                var d = c.getLastData(),
                e = this.getRowIndexByData(d),
                f = this.getRowIndexByData(a),
                g = new nd;
                for (g.add(this.getRowDatas().get(e)); e !== f;) e += f > e ? 1 : -1,
                g.add(this.getRowDatas().get(e));
                c.setSelection(g)
            } else 1 === c.size() && c.contains(a) || c.setSelection(a);
            this.fireInteractionEvent({
                kind: 2 === b.detail ? "doubleClick": "click",
                data: a
            })
        },
        _handleClick: function(a) {
            this.isFocusOnClick() && Ib.Util.setFocus(this._view);
            var b = this.getDataAt(a);
            if (b) {
                if (this.isCheckMode() && !a.target._checkData) {
                    var c = this.getRowIndexByData(b);
                    if (this._focusedRow !== c) {
                        var d = this._rowDatas.get(this._focusedRow);
                        this._focusedRow = c,
                        d && this.invalidateData(d),
                        this.invalidateData(b)
                    }
                }
                this.isCheckMode() || this._handlePressSelection(b, a)
            }
            if (this._currentEditor && this.commitEditValue(this._currentEditor._editInfo, this._currentEditor), this.updateCurrentEditor) {
                var e = this;
                setTimeout(function() {
                    e.updateCurrentEditor(a)
                },
                0)
            }
        },
        handleChange: function(a) {
            if (!this._isCanceling && !this._isValidating) {
                var b = a.target._checkData;
                if (b) {
                    var c = this.isSelected(b),
                    d = this.getSelectionModel();
                    c ? d.removeSelection(b) : d.appendSelection(b)
                }
                a.target._editInfo && this.commitEditValue && this.commitEditValue(a.target._editInfo, a.target)
            }
        },
        scrollToData: function(a) {
            if (a) {
                var b = this.getRowIndexById(a.getId());
                if (! (0 > b)) {
                    var c = b * this._rowHeight * this._zoom,
                    d = c + this._rowHeight * this._zoom,
                    e = this._view.scrollTop;
                    this._view.scrollTop > c && (e = c),
                    this._view.scrollTop + this._view.clientHeight < d && (e = d - this._view.clientHeight),
                    this._view.scrollTop != e && (this._view.scrollTop = e, this.invalidate())
                }
            }
        },
        makeVisible: function(a) {
            this.isVisible(a) && (this.expand && this.expand(a), Jb.callLater(this.scrollToData, this, [a], 2 * Dd.CALL_LATER_DELAY))
        },
        onSelectionChanged: function(a) {
            this._makeVisibleOnSelected && ("append" === a.kind || "set" === a.kind || "all" === a.kind) && (this.expand && this.getSelectionModel().getSelection().forEach(function(a) {
                a.getParent() && this.expand(a.getParent())
            },
            this), Jb.callLater(this.scrollToData, this, [this.getSelectionModel().getLastData()], 2 * Dd.CALL_LATER_DELAY))
        },
        onShareSelectionModelChanged: function() {
            this.invalidateModel()
        }
    }),
    Ib.controls.TableBase = function(a) {
        this._columnBox = new Ib.ColumnBox,
        this._columnBox.addDataBoxChangeListener(this.handleColumnBoxChange, this),
        this._columnBox.addDataPropertyChangeListener(this.handleColumnPropertyChange, this),
        this._columnBox.addHierarchyChangeListener(this.handleColumnHierarchyChange, this),
        Ib.controls.TableBase.superClass.constructor.apply(this, arguments),
        this._cellPool = new Ib.Pool("div", 20),
        this._stringPool = new Ib.Pool("span", 20),
        this._booleanPool = new Ib.Pool("input", 20),
        this._colorPool = new Ib.Pool("div", 20),
        this._pools.add(this._cellPool),
        this._pools.add(this._stringPool),
        this._pools.add(this._booleanPool),
        this._pools.add(this._colorPool)
    },
    Jb.ext("twaver.controls.TableBase", Ib.controls.ListBase, {
        getColumnBox: function() {
            return this._columnBox
        },
        handleColumnBoxChange: function(a) {
            this.invalidateDisplay()
        },
        handleColumnPropertyChange: function(a) {
            a.source !== this._sortColumn || "sortDirection" !== a.property && "sortFunction" !== a.property && "sortable" !== a.property ? this.invalidateDisplay() : this.invalidateModel()
        },
        handleColumnHierarchyChange: function(a) {
            this.invalidateDisplay()
        },
        renderData: function(a, b, c, d) {
            for (var e, f = this._columnBox.getRoots(), g = f.size(), h = 0, i = this._rowHeight - this._rowLineWidth + "px", j = 0; g > j; j++) {
                var k = f.get(j),
                l = k.getWidth();
                0 > l && (l = 0);
                var m = Math.min(this._columnLineWidth, l);
                if (k.isVisible()) {
                    var n = this._cellPool.get();
                    e = n.style,
                    e.position = "absolute",
                    e.whiteSpace = "nowrap",
                    e.verticalAlign = "middle",
                    e.textAlign = k.getHorizontalAlign(),
                    e.overflow = "hidden",
                    e.textOverflow = "ellipsis",
                    e.left = h + "px",
                    e.width = l - m + "px",
                    e.height = i,
                    e.borderStyle = "solid",
                    e.borderWidth = "0px",
                    e.borderRightWidth = m + "px",
                    e.borderRightColor = this._columnLineColor,
                    0 === j ? (e.borderLeftWidth = m + "px", e.borderLeftColor = this._columnLineColor) : e.borderLeftWidth = "0px",
                    a.appendChild(n);
                    var o = {
                        data: b,
                        value: this.getValue(b, k),
                        div: n,
                        view: this,
                        column: k,
                        rowIndex: c,
                        selected: d
                    };
                    this.renderCell(o),
                    this.onCellRendered(o),
                    h += l
                }
            }
            e = a.style,
            e.width = h + "px",
            e.height = i,
            e.backgroundColor = this.isCheckMode() && this._focusedRow === c || !this.isCheckMode() && d ? this.getSelectColor(b) : ""
        },
        adjustRowSize: function() {},
        onCellRendered: function(a) {},
        getCurrentSortFunction: function() {
            var a = this._sortColumn;
            if (a) {
                var b = a.getSortFunction();
                if (b) {
                    var c = this,
                    d = "asc" === a.getSortDirection() ? 1 : -1;
                    return function(e, f) {
                        var g = c.getValue(e, a),
                        h = c.getValue(f, a);
                        return b.call(c, g, h, e, f) * d
                    }
                }
            }
            return this._sortFunction
        },
        renderCell: function(a) {
            var b = a.column;
            if (b.renderCell) return void b.renderCell(a);
            var c = a.value,
            d = b.getEnumInfo(a.rowIndex);
            d && !Array.isArray(d) && (c = d.map[c]),
            a.view.isCellEditable(a.data, b) && (a.enumInfo = d, a.div._editInfo = a),
            Ac.render(b.getValueType(), c, a.div, a.view, b.isInnerText())
        },
        getValue: function(a, b) {
            return b.getValue(a, this)
        },
        setValue: function(a, b, c) {
            b.setValue(a, c, this)
        },
        getColumnAt: function(a) {
            var b = this.getLogicalPoint(a);
            if (!b) return null;
            for (var c = this._columnBox.getRoots(), d = 0, e = c.size(), f = 0; e > d; d++) {
                var g = c.get(d),
                h = g.getWidth();
                if (0 > h && (h = 0), b.x > f && b.x < f + h) return g;
                f += h
            }
            return null
        },
        isCellEditable: function(a, b) {
            return this.isEditable() && b.isEditable()
        },
        commitEditValue: function(a, b) {
            if (!this._isCanceling) {
                var c;
                c = "checkbox" === b.type ? b.checked: b.value;
                var d = a.column,
                e = d.getValueType();
                if ("int" === e && "string" == typeof c ? c = parseInt(c) : "number" === e && "string" == typeof c && (c = parseFloat(c)), this.setValue(a.data, d, c), this._currentEditor) {
                    var f = this._currentEditor.parentNode,
                    g = this._currentEditor;
                    delete this._currentEditor,
                    f && f.removeChild(g),
                    Ib.Util.setFocus(this._view)
                }
                delete this._isCommitting
            }
        },
        cancelEditing: function() {
            if (this._currentEditor) {
                this._isCanceling = !0;
                var a = this._currentEditor.parentNode,
                b = this._currentEditor;
                delete this._currentEditor,
                a && a.removeChild(b),
                Ib.Util.setFocus(this._view),
                delete this._isCanceling
            }
        },
        renderEditor: function(a) {},
        onEditorRendered: function(a) {},
        updateCurrentEditor: function(a) {
            var b = a.target;
            if (b !== this._currentEditor && b.parentNode !== this._currentEditor) {
                for (var c; b && b !== this._view && !(c = b._editInfo);) b = b.parentNode;
                if (c && b === c.div) {
                    var d = this.renderEditor && this.renderEditor(c);
                    d ? (this._currentEditor = d.view, null != c.value && (this._currentEditor.value = c.value)) : c.enumInfo ? this._currentEditor = Wb.createSelect(c.enumInfo, c.value) : (this._currentEditor = Ob.createElement("input"), null != c.value && (this._currentEditor.value = c.value));
                    var e = this;
                    if (this._currentEditor) {
                        if (d && d.onKeyDown) {
                            var f = d.onKeyDown;
                            f && Array.isArray(f) && e._currentEditor.addEventListener("keydown",
                            function(a) {
                                for (var b = 0; b < f.length; b++) if (f[b].combKey) {
                                    var c = null;
                                    switch (f[b].combKey) {
                                    case "ctrlKey":
                                        c = a.ctrlKey;
                                        break;
                                    case "shiftKey":
                                        c = a.shiftKey;
                                        break;
                                    case "altKey":
                                        c = a.altKey
                                    }
                                    a.keyCode === f[b].keyCode && c && f[b].handlerEvent && f[b].handlerEvent(a)
                                } else a.keyCode === f[b].keyCode && f[b].handlerEvent && f[b].handlerEvent(a)
                            })
                        } else this._currentEditor.addEventListener("keydown",
                        function(a) {
                            var b = a.target._editInfo.view;
                            13 === a.keyCode && a.shiftKey || (13 === a.keyCode ? b.commitEditValue(a.target._editInfo, a.target) : 27 === a.keyCode && b.cancelEditing())
                        },
                        !1);
                        if (this._currentEditor.addEventListener("blur",
                        function(a) {
                            var b = a.target._editInfo.view;
                            b._isCanceling || b.commitEditValue(a.target._editInfo, a.target)
                        },
                        !1), this._currentEditor.keepDefault = !0, this._currentEditor._editInfo = c, !this._currentEditor.parentNode) {
                            var g = this._currentEditor.style;
                            g.position = "absolute",
                            g.margin = "0px",
                            g.border = "0px",
                            g.padding = "0px",
                            g.left = c.div.style.left,
                            g.top = c.div.parentNode.style.top,
                            g.width = c.div.style.width,
                            g.height = c.div.style.height,
                            this._rootDiv.appendChild(this._currentEditor)
                        }
                        Ib.Util.setFocus(this._currentEditor)
                    }
                }
            }
        },
        onColumnSorted: function(a) {},
        getCurrentEditor: function() {
            return this._currentEditor
        }
    }),
    Ib.controls.List = function(a) {
        Ib.controls.List.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.controls.List", Ib.controls.ListBase, {
        __accessor: ["rowHeight", "indent", "rowLineWidth", "rowLineColor", "sortFunction", "visibleFunction"],
        __bool: ["makeVisibleOnSelected", "keyboardRemoveEnabled", "keyboardSelectEnabled"],
        _checkMode: !1,
        _rowHeight: Dd.LIST_ROW_HEIGHT,
        _indent: Dd.LIST_INDENT,
        _rowLineWidth: Dd.LIST_ROW_LINE_WIDTH,
        _rowLineColor: Dd.LIST_ROW_LINE_COLOR,
        _makeVisibleOnSelected: Dd.LIST_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Dd.LIST_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Dd.LIST_KEYBOARD_SELECT_ENABLED,
        isCheckMode: function() {
            return this._checkMode
        },
        setCheckMode: function(a) {
            delete this._focusedRow;
            var b = this._checkMode;
            this._checkMode = a,
            this.firePropertyChange("checkMode", b, a)
        },
        isCheckable: function(a) {
            return this._checkMode === !0
        },
        renderData: function(a, b, c, d) {
            var e;
            this._indent > 0 && (e = this.__spanPool.get(), e.style.width = this._indent + "px", e.style.display = "inline-block", a.appendChild(e));
            var f = this.isCheckable(b);
            f && this._addCheckBox(a, b, d);
            var g = this.getIcon(b);
            g && this._addIcon(a, b, g);
            var h = this.getLabel(b);
            if (h) {
                e = this.__textPool.get();
                var i = e.style;
                i.whiteSpace = "nowrap",
                i.verticalAlign = "middle",
                i.padding = "1px 2px 1px 2px",
                i.display = "inline-block",
                Jb.setText(e, h, this._innerText),
                this.onLabelRendered(e, b, h, c, d),
                a.appendChild(e)
            }
            a.style.backgroundColor = this.isCheckMode() ? this._focusedRow === c ? this.getSelectColor(b) : "": d ? this.getSelectColor(b) : ""
        },
        onLabelRendered: function(a, b, c, d, e) {}
    }),
    Ib.controls.ListBaseInteraction = function(a) {
        this.listBase = a,
        this.view = a._view;
        var b = this;
        this.view.addEventListener("scroll",
        function(a) {
            b.handleScroll(a)
        },
        !1),
        this.view.addEventListener("mousedown",
        function(a) {
            b.handleMouseDown(a)
        },
        !1),
        this.view.addEventListener("keydown",
        function(a) {
            b.handleKeyDown(a)
        },
        !1)
    },
    Jb.ext("twaver.controls.ListBaseInteraction", Object, {
        handleMouseDown: function(a) {
            var b = this.listBase;
            a.target !== b._currentEditor && a.target.parentNode !== b._currentEditor && b._handleClick(a)
        },
        handleKeyDown: function(a) {
            var b = this.listBase;
            if (!b._currentEditor) if (Jb.isCtrlDown(a) && 65 == a.keyCode) b.isKeyboardSelectEnabled() && b.selectAll().size() > 0 && b.fireInteractionEvent({
                kind: "selectAll"
            }),
            Wb.preventDefault(a);
            else if (46 == a.keyCode) b.isKeyboardRemoveEnabled() && b.removeSelection() && b.fireInteractionEvent({
                kind: "removeElement"
            }),
            Wb.preventDefault(a);
            else if (b.isCheckMode() || 38 !== a.keyCode && 40 !== a.keyCode && 37 !== a.keyCode && 39 !== a.keyCode) Jb.showVersion(a);
            else {
                var c = b.getSelectionModel().getLastData();
                if (c) if (38 === a.keyCode || 40 === a.keyCode) {
                    var d = b.getRowDatas(),
                    e = b.getRowIndexByData(c);
                    e >= 0 && (38 === a.keyCode ? 0 !== e && (c = d.get(e - 1), b.getSelectionModel().setSelection(c)) : e !== d.size() - 1 && (c = d.get(e + 1), b.getSelectionModel().setSelection(c)))
                } else ! b.expand || 37 !== a.keyCode && 39 !== a.keyCode || c.hasChildren() && (37 === a.keyCode ? b.collapse(c) : b.expand(c));
                else b.getRowDatas().size() > 0 && (c = b.getRowDatas().get(0), b.getSelectionModel().setSelection(c))
            }
        },
        handleScroll: function(a) {
            this.listBase.invalidate()
        }
    }),
    Ib.controls.ListBaseTouchInteraction = function(a) {
        this.listBase = a,
        this.view = a._view,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.controls.ListBaseTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            this.startPoint = this.lastPoint = this.listBase.getLogicalPoint(a),
            Wb.addEventListener("touchmove", "handleTouchmove", this.view, this),
            Wb.addEventListener("touchend", "handleTouchend", this.view, this),
            zc.isMultiTouch(a) && (this.distance = zc.getDistance(a), this.zoom = this.listBase._zoom)
        },
        handleTouchmove: function(a) {
            Wb.preventDefault(a);
            var b = this.listBase.getLogicalPoint(a);
            if (! (Tb.getDistance(this.startPoint, b) < 20)) if (this.moved || (this.moved = !0), zc.isSingleTouch(a)) {
                if (this.lastPoint) {
                    var c = this.lastPoint.x - b.x,
                    d = this.lastPoint.y - b.y,
                    e = this.listBase.panByOffset(c, d);
                    this.listBase.invalidate(),
                    this.lastPoint.x -= c - e.x,
                    this.lastPoint.y -= d - e.y
                }
            } else if (this.distance) {
                var f = zc.getDistance(a) / this.distance;
                this.listBase.setZoom(this.zoom * f, !1)
            }
        },
        handleTouchend: function(a) {
            Wb.preventDefault(a),
            this.moved || a.target === this.listBase._currentEditor || a.target.parentNode === this.listBase._currentEditor || this.listBase._handleClick(a),
            delete this.startPoint,
            delete this.lastPoint,
            delete this.moved,
            delete this.distance,
            delete this.zoom,
            Wb.removeEventListener("touchmove", this.view, this),
            Wb.removeEventListener("touchend", this.view, this)
        }
    }),
    Ib.controls.ListBaseMSTouchInteraction = function(a) {
        Ib.controls.ListBaseMSTouchInteraction.superClass.constructor.apply(this, arguments),
        this._pointerMap = {},
        this._pointerIdArray = [];
        var b = this;
        this.view.addEventListener("MSPointerDown",
        function(a) {
            b.handleTouchstart(a)
        },
        !1),
        this.view.addEventListener("MSPointerMove",
        function(a) {
            b.handleTouchmove(a)
        },
        !1),
        this.view.addEventListener("MSPointerUp",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.view.addEventListener("MSPointerCancel",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.superHandleMouseDown = Ib.controls.ListBaseMSTouchInteraction.superClass.handleMouseDown
    },
    Jb.ext("twaver.controls.ListBaseMSTouchInteraction", Ib.controls.ListBaseInteraction, {
        handleMouseDown: function(a) {},
        handleTouchstart: function(a) {
            a.isPrimary && this._pointerIdArray.length > 0 && (this._pointerMap = {},
            this._pointerIdArray = []),
            this._pointerMap[a.pointerId] || null == this.listBase.getLogicalPoint(a) || (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a),
            1 == this._pointerIdArray.length && a.pointerType == a.MSPOINTER_TYPE_MOUSE && this.superHandleMouseDown(a),
            1 == this._pointerIdArray.length ? (this._startTouchPoint = this.listBase.getLogicalPoint(a), this._startTouchTime = new Date) : 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.listBase.getZoom())
        },
        handleTouchmove: function(a) {
            if (null != this._startTouchPoint && 0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10)) if (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length) {
                var b = this._getDistance() / this._distance;
                this.listBase.setZoom(this._zoom * b, !1)
            } else if (1 == this._pointerIdArray.length && a.pointerType != a.MSPOINTER_TYPE_MOUSE && this._startTouchPoint) {
                var c = this.listBase.getLogicalPoint(a);
                if (null == c) return;
                var d = this._startTouchPoint.x - c.x,
                e = this._startTouchPoint.y - c.y,
                f = this.listBase.panByOffset(d, e);
                this.listBase.invalidate(),
                this._startTouchPoint.x -= d - f.x,
                this._startTouchPoint.y -= e - f.y
            }
        },
        handleTouchend: function(a) {
            if (this._startTouchPoint && 1 == this._pointerIdArray.length && a.pointerType != a.MSPOINTER_TYPE_MOUSE) {
                var b = this.listBase.getLogicalPoint(a);
                if (b) {
                    var c = new Date;
                    c.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 20 && this.superHandleMouseDown(a)
                }
            }
            this._pointerMap = {},
            this._pointerIdArray = []
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        }
    }),
    Ib.controls.Tree = function(a) {
        this._interactionDispatcher = new Ib.EventDispatcher,
        this._initTree(a),
        Ib.controls.Tree.superClass.constructor.apply(this, arguments),
        this.setToolTipEnabled(Dd.TREE_TOOLTIP_ENABLED)
    },
    Jb.ext("twaver.controls.Tree", Ib.controls.ListBase, {
        __tree: 1,
        __accessor: ["rootData", "sortFunction", "visibleFunction", "indent", "rowHeight", "rowLineWidth", "rowLineColor", "expandIcon", "collapseIcon", "uncheckableStyle", "lineType", "lineColor", "lineThickness", "lineAlpha", "lineDash"],
        __bool: ["rootVisible", "makeVisibleOnSelected", "keyboardRemoveEnabled", "keyboardSelectEnabled"],
        _checkMode: !1,
        _indent: Dd.TREE_INDENT,
        _rowHeight: Dd.TREE_ROW_HEIGHT,
        _rowLineWidth: Dd.TREE_ROW_LINE_WIDTH,
        _rowLineColor: Dd.TREE_ROW_LINE_COLOR,
        _makeVisibleOnSelected: Dd.TREE_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Dd.TREE_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Dd.TREE_KEYBOARD_SELECT_ENABLED,
        _expandIcon: Dd.TREE_EXPAND_ICON,
        _collapseIcon: Dd.TREE_COLLAPSE_ICON,
        _uncheckableStyle: "none",
        _lineType: Dd.TREE_LINE_TYPE,
        _lineColor: Dd.TREE_LINE_COLOR,
        _lineThickness: Dd.TREE_LINE_THICKNESS,
        _lineAlpha: Dd.TREE_LINE_ALPHA,
        _lineDash: Dd.TREE_LINE_DASH,
        getCheckMode: function() {
            return this._checkMode
        },
        setCheckMode: function(a) {
            delete this._focusedRow;
            var b = this._checkMode;
            this._checkMode = a,
            this.firePropertyChange("checkMode", b, a)
        },
        renderData: function(a, b, c, d) {
            this._renderTree(a, b, c, d)
        },
        isToolTipEnabled: function() {
            return this._toolTipEnabled ? !0 : !1
        },
        setToolTipEnabled: function(a) {
            if (this._toolTipEnabled = a, a) {
                if (!this._toolTipListener) {
                    var b = this;
                    this._toolTipListener = function(a) {
                        var c = b.getDataAt(a);
                        if (!c) return void Bc.hideToolTip();
                        if (b._preElement !== c) {
                            if (b._preElement = c, c) {
                                var d = b.getToolTip(c);
                                return void Bc.showToolTip(a, d)
                            }
                            Bc.hideToolTip()
                        }
                    },
                    this._view.addEventListener("mousemove", this._toolTipListener, !1),
                    this.firePropertyChange("toolTipEnabled", !1, !0)
                }
            } else this._toolTipListener && (Bc.hideToolTip(), this._view.removeEventListener("mousemove", this._toolTipListener, !1), delete this._toolTipListener, this.firePropertyChange("toolTipEnabled", !0, !1))
        },
        getToolTip: function(a) {
            return a.getToolTip()
        }
    }),
    Ib.controls.Table = function(a) {
        this._checkColumn = new Ib.Column,
        this._checkColumn.setName("check"),
        this._checkColumn.setEditable(!0),
        this._checkColumn.setWidth(40),
        this._checkColumn.setHorizontalAlign("center"),
        this._checkColumn.renderCell = this.renderCheckCell;
        var b = this;
        this._checkColumn.getValue = function(a, c) {
            return b.isSelected(a)
        },
        Ib.controls.Table.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.controls.Table", Ib.controls.TableBase, {
        __accessor: ["rowHeight", "rowLineWidth", "rowLineColor", "columnLineWidth", "columnLineColor", "sortFunction", "visibleFunction", "sortColumn"],
        __bool: ["editable", "makeVisibleOnSelected", "keyboardRemoveEnabled", "keyboardSelectEnabled"],
        _editable: Dd.TABLE_EDITABLE,
        _rowHeight: Dd.TABLE_ROW_HEIGHT,
        _rowLineWidth: Dd.TABLE_ROW_LINE_WIDTH,
        _rowLineColor: Dd.TABLE_ROW_LINE_COLOR,
        _columnLineWidth: Dd.TABLE_COLUMN_LINE_WIDTH,
        _columnLineColor: Dd.TABLE_COLUMN_LINE_COLOR,
        _makeVisibleOnSelected: Dd.TABLE_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Dd.TABLE_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Dd.TABLE_KEYBOARD_SELECT_ENABLED,
        getCheckColumn: function() {
            return this._checkColumn
        },
        isCheckMode: function() {
            return this._columnBox.contains(this._checkColumn)
        },
        setCheckMode: function(a) {
            a !== this.isCheckMode() && (delete this._focusedRow, a ? this._columnBox.add(this._checkColumn, 0) : this._columnBox.remove(this._checkColumn), this.firePropertyChange("checkMode", !a, a))
        },
        renderCheckCell: function(a) {
            var b = a.view._booleanPool.get();
            b.disabled = !1,
            b.type = "checkbox",
            b.style.margin = "0px 2px",
            b.style.verticalAlign = "middle",
            b.checked = a.selected;
            var c = a.div;
            c.appendChild(b),
            "" === c.style.textAlign && (c.style.textAlign = "center"),
            b._checkData = a.data
        }
    }),
    Ib.controls.TableHeader = function(a) {
        Ib.controls.TableHeader.superClass.constructor.apply(this, arguments),
        this._invalidateScroll = !1,
        this._invalidateDisplay = !1,
        this._divPool = new Ib.Pool("div"),
        this._imagePool = new Ib.Pool("img"),
        this._textPool = new Ib.Pool("span"),
        this._resizePool = new Ib.Pool("div"),
        this._pools.add(this._divPool),
        this._pools.add(this._imagePool),
        this._pools.add(this._textPool),
        this._pools.add(this._resizePool),
        this._table = a,
        this._tableView = a.getView(),
        this._columnBox = a.getColumnBox(),
        this._columnBox.addDataBoxChangeListener(this.handleColumnBoxChange, this),
        this._columnBox.addDataPropertyChangeListener(this.handleColumnPropertyChange, this),
        this._columnBox.addHierarchyChangeListener(this.handleColumnHierarchyChange, this);
        var b = this;
        a.getView().addEventListener("scroll",
        function(a) {
            b.invalidateScroll()
        },
        !1),
        a.addPropertyChangeListener(function(a) {
            b.invalidateDisplay()
        },
        this),
        this._view = Wb.createView("hidden"),
        this._view.tabIndex = -1,
        this._view.style.background = Dd.TABLEHEADER_BACKGROUND,
        this._rootDiv = Wb.createDiv(),
        this._view.appendChild(this._rootDiv),
        this.invalidateDisplay(),
        Qb.isTouchable && !Qb.isMSToucheable && new Ib.controls.TableHeaderTouchInteraction(this),
        new Ib.controls.TableHeaderInteraction(this)
    },
    Jb.ext("twaver.controls.TableHeader", Ib.controls.ControlBase, {
        __accessor: ["height", "moveBackground", "insertBackground", "columnLineColor", "resizeTolerance", "sortDescIcon", "sortAscIcon", "sortIconPosition"],
        _height: Dd.TABLEHEADER_HEIGHT,
        _moveBackground: Dd.TABLEHEADER_MOVE_BACKGROUND,
        _insertBackground: Dd.TABLEHEADER_INSERT_BACKGROUND,
        _columnLineColor: Dd.TABLEHEADER_COLUMN_LINE_COLOR,
        _resizeTolerance: Dd.TABLEHEADER_RESIZE_TOLERANCE,
        _sortDescIcon: Dd.TABLEHEADER_SORT_DESC_ICON,
        _sortAscIcon: Dd.TABLEHEADER_SORT_ASC_ICON,
        _sortIconPosition: Dd.TABLEHEADER_SORT_ICON_POSITION,
        getRootDiv: function() {
            return this._rootDiv
        },
        handleColumnBoxChange: function(a) {
            this.invalidateDisplay()
        },
        handleColumnPropertyChange: function(a) {
            this.invalidateDisplay()
        },
        handleColumnHierarchyChange: function(a) {
            this.invalidateDisplay()
        },
        onPropertyChanged: function(a) {
            this.invalidateDisplay()
        },
        invalidateScroll: function() {
            this._invalidateScroll || (this._invalidateScroll = !0, this.invalidate())
        },
        invalidateDisplay: function() {
            this._invalidateDisplay || (this._invalidateDisplay = !0, this._invalidateScroll = !0, this.invalidate())
        },
        validate: function() {
            this._invalidate && (this._invalidate = !1, this._invalidateDisplay && (this._invalidateDisplay = !1, this.validateDisplay()), this._invalidateScroll && (this._invalidateScroll = !1, this._rootDiv.style.left = -this._tableView.scrollLeft + "px"))
        },
        validateDisplay: function() {
            Wb.release(this._rootDiv);
            for (var a = this._table.getZoom(), b = this.getHeight() + "px", c = this.getHeight() - 2 + "px", d = this._table.getColumnBox().getRoots(), e = d.size(), f = 0, g = this._table._columnLineWidth * a, h = 0; e > h; h++) {
                var i = d.get(h);
                if (i.isVisible()) {
                    var j = i.getWidth() * a;
                    0 > j && (j = 0);
                    var k = Math.min(g, j),
                    l = this._divPool.get();
                    l._column = i;
                    var m = l.style;
                    m.position = "absolute",
                    m.whiteSpace = "nowrap",
                    m.lineHeight = c,
                    m.overflow = "hidden",
                    m.textOverflow = "ellipsis",
                    m.backgroundPosition = this._sortIconPosition ? this._sortIconPosition: "",
                    m.backgroundRepeat = "no-repeat",
                    m.backgroundImage = "",
                    m.textAlign = i.getHorizontalAlign(),
                    m.borderStyle = "solid",
                    m.borderWidth = "0px",
                    m.borderRightWidth = k + "px",
                    m.borderRightColor = this._columnLineColor,
                    0 === h ? (m.borderLeftWidth = k + "px", m.borderLeftColor = this._columnLineColor) : m.borderLeftWidth = "0px",
                    m.left = f + "px",
                    m.width = j - k + "px",
                    m.height = b,
                    l._x = f,
                    l._width = j - k,
                    this._rootDiv.insertBefore(l, this._rootDiv.firstChild),
                    this.renderColumn(l, i),
                    this.onColumnRendered(l, i),
                    f += j,
                    i.isResizable() && (l = this._resizePool.get(), l._resizeColumn = i, m = l.style, m.position = "absolute", m.backgroundColor = "white", m.opacity = 0, m.left = f - k - this._resizeTolerance + "px", m.width = k + 2 * this._resizeTolerance + "px", m.height = b, this._rootDiv.appendChild(l))
                }
            }
            this._pools.forEach(function(a) {
                a.clear()
            }),
            this._rootDiv.style.width = f + "px",
            this._rootDiv.style.height = b
        },
        renderColumn: function(a, b) {
            if (b.renderHeader) b.renderHeader(a);
            else {
                var c = this._textPool.get();
                if (c.style.whiteSpace = "nowrap", c.style.verticalAlign = "middle", c.style.padding = "1px 2px 1px 2px", c.innerHTML = b.getName() ? b.getName() : b.getPropertyName(), c.setAttribute("title", c.innerHTML), a.appendChild(c), Qb.isOpera) {
                    var d = a.cloneNode(!1);
                    d.style.left = "0px",
                    d.style.top = "0px",
                    d.style.opacity = 0,
                    a.appendChild(d)
                }
            }
            if (this._table.getSortColumn() === b && b.isSortable()) {
                var e = "asc" === b.getSortDirection() ? this._sortAscIcon: this._sortDescIcon,
                f = Jb.getImageSrc(e);
                if (this._sortIconPosition && "" !== this._sortIconPosition) a.style.backgroundImage = "url(" + f + ")";
                else {
                    var g = this._imagePool.get();
                    g.setAttribute("src", f),
                    g.style.verticalAlign = "middle",
                    a.appendChild(g)
                }
            }
        },
        onColumnRendered: function(a, b) {}
    }),
    Ib.controls.TableHeaderInteraction = function(a) {
        this.header = a,
        this.table = a._table,
        this.view = a._view;
        var b = this;
        this.view.addEventListener("mousedown",
        function(a) {
            b.handleMouseDown(a)
        },
        !1),
        this.view.addEventListener("mousemove",
        function(a) {
            b.handleMouseMove(a)
        },
        !1)
    },
    Jb.ext("twaver.controls.TableHeaderInteraction", Object, {
        handleMouseDown: function(a) {
            if (0 === a.button) {
                if (this.movableDiv) return void this.handleMouseUp(a);
                this.resizeColumn = a.target._resizeColumn,
                this.resizeColumn || (this.movableDiv = this.getMovableDivAt(a)),
                this.changeCursor(a),
                this._startClient = Wb.getClientPoint(a),
                this.lastX = this.getX(a),
                this._startLogicalX = this.lastX,
                Wb.handle_mousedown(this, a)
            }
        },
        changeCursor: function(a) {
            var b = "";
            if (a.target._resizeColumn) b = "ew-resize";
            else {
                var c = this.getColumnAt(a);
                c && (c.isMovable() || c.isSortable()) && (b = "pointer")
            }
            this.view.style.cursor = b
        },
        handleMouseMove: function(a) {
            if (null == this.lastX) return void this.changeCursor(a);
            if (Wb.target === this) {
                var b = this._startLogicalX + a.clientX - this._startClient.x;
                if (this.resizeColumn) {
                    if (null != this.stopX) {
                        if (b < this.stopX) return;
                        delete this.stopX
                    }
                    var c = this.resizeColumn.getWidth() + (b - this.lastX) / this.table.getZoom();
                    10 > c && (c = 10, this.stopX = b),
                    this.resizeColumn.setWidth(c),
                    this.lastX = b
                } else if (this.movableDiv) {
                    var d = b - this.lastX;
                    if (!this.cloneDiv) {
                        if (Math.abs(d) < 3) return;
                        this.cloneDiv = this.movableDiv.cloneNode(!0),
                        this.cloneDiv._x = this.movableDiv._x,
                        this.cloneDiv.style.background = this.header.getMoveBackground(),
                        this.insertDiv = Wb.createDiv(),
                        this.insertDiv.style.width = "1px",
                        this.insertDiv.style.height = this.cloneDiv.style.height,
                        this.insertDiv.style.background = this.header.getInsertBackground(),
                        this.movableDiv.parentNode.appendChild(this.cloneDiv),
                        this.movableDiv.parentNode.appendChild(this.insertDiv)
                    }
                    var e = this.cloneDiv._x + d;
                    this.cloneDiv.style.left = e + "px",
                    this.cloneDiv._x = e,
                    this.lastX = b,
                    this.columnInfo = this.getColumnInfoAt(a),
                    this.columnInfo && (this.insertDiv.style.left = this.columnInfo.position)
                }
            }
        },
        handleMouseUp: function(a) {
            if (0 === a.button) {
                var b;
                if (this.resizeColumn);
                else if (this.movableDiv && this.columnInfo) {
                    b = this.movableDiv._column;
                    var c = this.columnInfo.index;
                    this.table.getColumnBox().moveTo(b, c)
                } else if (b = this.getColumnAt(a), b && b.isSortable()) {
                    var d = b.getSortDirection();
                    this.table.getSortColumn() === b ? ("desc" === d && this.table.setSortColumn(null), b.setSortDirection("asc" === d ? "desc": "asc")) : this.table.setSortColumn(b),
                    this.table.onColumnSorted(this.table.getSortColumn())
                }
                this.clear()
            }
        },
        clear: function() {
            this.view.style.cursor = "",
            this.cloneDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.cloneDiv),
            this.insertDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.insertDiv),
            delete this.movableDiv,
            delete this.columnInfo,
            delete this.insertDiv,
            delete this.cloneDiv,
            delete this.resizeColumn,
            delete this.stopX,
            delete this.lastX,
            delete this._startClient,
            delete this._startLogicalX
        },
        getColumnAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._column);) a = a.parentNode;
            return b
        },
        getMovableDivAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._column);) a = a.parentNode;
            return b && b.isMovable() ? a: null
        },
        getX: function(a) {
            var b = Wb.getLogicalPoint(this.view, a);
            return b ? b.x: null
        },
        getColumnInfoAt: function(a) {
            for (var b = this._startLogicalX + a.clientX - this._startClient.x + this.table.getView().scrollLeft, c = this.table.getColumnBox().getRoots(), d = c.size(), e = this.table.getZoom(), f = 0, g = !1, h = 0; d > h; h++) {
                var i = c.get(h);
                if (i === this.movableDiv._column && (g = !0), i.isVisible()) {
                    var j = i.getWidth() * e;
                    if (0 >= j) continue;
                    if (b >= f && f + j >= b) {
                        var k = f + j / 2 > b; ! g || i === this.movableDiv._column && k || h--;
                        var l = k ? Math.max(0, h) : Math.min(h + 1, d),
                        m = k ? f: f + j;
                        return m = Math.max(0, m - 1),
                        {
                            index: l,
                            column: i,
                            position: m + "px"
                        }
                    }
                    f += j
                }
            }
            return this.columnInfo
        }
    }),
    Ib.controls.TableHeaderTouchInteraction = function(a) {
        this.header = a,
        this.table = a._table,
        this.view = a._view,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.controls.TableHeaderTouchInteraction", Object, {
        handleTouchstart: function(a) {
            return Wb.preventDefault(a),
            this.movableDiv ? void this.handleTouchend(a) : (this.resizeColumn = a.target._resizeColumn, this.resizeColumn || (this.movableDiv = this.getMovableDivAt(a)), this.lastX = this.getX(a), Wb.addEventListener("touchmove", "handleTouchmove", this.view, this), void Wb.addEventListener("touchend", "handleTouchend", this.view, this))
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), null != this.lastX) {
                var b;
                if (this.resizeColumn) {
                    if (b = this.getX(a), null != this.stopX) {
                        if (b < this.stopX) return;
                        delete this.stopX
                    }
                    var c = this.resizeColumn.getWidth() + (b - this.lastX) / this.table.getZoom();
                    0 > c && (c = 0, this.stopX = b),
                    this.resizeColumn.setWidth(c),
                    this.lastX = b
                } else if (this.movableDiv) {
                    b = this.getX(a);
                    var d = b - this.lastX;
                    if (!this.cloneDiv) {
                        if (Math.abs(d) < 3) return;
                        this.cloneDiv = this.movableDiv.cloneNode(!0),
                        this.cloneDiv._x = this.movableDiv._x,
                        this.cloneDiv.style.background = this.header.getMoveBackground(),
                        this.insertDiv = Wb.createDiv(),
                        this.insertDiv.style.width = "1px",
                        this.insertDiv.style.height = this.cloneDiv.style.height,
                        this.insertDiv.style.background = this.header.getInsertBackground(),
                        this.movableDiv.parentNode.appendChild(this.cloneDiv),
                        this.movableDiv.parentNode.appendChild(this.insertDiv)
                    }
                    var e = this.cloneDiv._x + d;
                    this.cloneDiv.style.left = e + "px",
                    this.cloneDiv._x = e,
                    this.lastX = b,
                    this.columnInfo = this.getColumnInfoAt(a),
                    this.columnInfo && (this.insertDiv.style.left = this.columnInfo.position)
                }
            }
        },
        handleTouchend: function(a) {
            Wb.preventDefault(a);
            var b;
            if (this.resizeColumn);
            else if (this.movableDiv && this.columnInfo) {
                b = this.movableDiv._column;
                var c = this.columnInfo.index;
                this.table.getColumnBox().moveTo(b, c)
            } else if (b = this.getColumnAt(a), b && b.isSortable()) {
                var d = b.getSortDirection();
                this.table.getSortColumn() === b ? ("desc" === d && this.table.setSortColumn(null), b.setSortDirection("asc" === d ? "desc": "asc")) : this.table.setSortColumn(b)
            }
            this.clear(),
            Wb.removeEventListener("touchmove", this.view, this),
            Wb.removeEventListener("touchend", this.view, this)
        },
        clear: function() {
            this.cloneDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.cloneDiv),
            this.insertDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.insertDiv),
            delete this.movableDiv,
            delete this.columnInfo,
            delete this.insertDiv,
            delete this.cloneDiv,
            delete this.resizeColumn,
            delete this.stopX,
            delete this.lastX
        },
        getColumnAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._column);) a = a.parentNode;
            return b
        },
        getMovableDivAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._column);) a = a.parentNode;
            return b && b.isMovable() ? a: null
        },
        getX: function(a) {
            var b = Wb.getLogicalPoint(this.view, a);
            return b ? b.x: null
        },
        getColumnInfoAt: function(a) {
            for (var b = this.getX(a) + this.table.getView().scrollLeft, c = this.table.getColumnBox().getRoots(), d = c.size(), e = this.table.getZoom(), f = 0, g = !1, h = 0; d > h; h++) {
                var i = c.get(h);
                if (i === this.movableDiv._column && (g = !0), i.isVisible()) {
                    var j = i.getWidth() * e;
                    if (0 >= j) continue;
                    if (b >= f && f + j >= b) {
                        var k = f + j / 2 > b; ! g || i === this.movableDiv._column && k || h--;
                        var l = k ? Math.max(0, h) : Math.min(h + 1, d),
                        m = k ? f: f + j;
                        return m = Math.max(0, m - 1),
                        {
                            index: l,
                            column: i,
                            position: m + "px"
                        }
                    }
                    f += j
                }
            }
            return this.columnInfo
        }
    }),
    Ib.controls.TablePane = function(a, b) {
        Ib.controls.TablePane.superClass.constructor.apply(this, arguments),
        this.invalidate(),
        this._table = a,
        this._tableHeader = b ? b: new Ib.controls.TableHeader(a),
        this._view = Wb.createView("hidden", !0),
        this._view.tabIndex = -1,
        this._view.appendChild(this._tableHeader.getView()),
        this._view.appendChild(this._table.getView());
        var c = this;
        this._tableHeader.addPropertyChangeListener(function(a) {
            "height" === a.property && c.invalidate()
        })
    },
    Jb.ext("twaver.controls.TablePane", Ib.controls.ControlBase, {
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        getTable: function() {
            return this._table
        },
        getTableHeader: function() {
            return this._tableHeader
        },
        validateImpl: function() {
            var a = this._view.offsetWidth,
            b = this._view.offsetHeight,
            c = this._tableHeader.getHeight();
            this._tableHeader.adjustBounds({
                x: 0,
                y: 0,
                width: a,
                height: c
            }),
            this._table.adjustBounds({
                x: 0,
                y: c,
                width: a,
                height: Math.max(0, b - c)
            })
        }
    }),
    Ib.controls.TreeTable = function(a) {
        this._treeColumn = new Ib.Column,
        this._treeColumn.setName("tree"),
        this._treeColumn.setWidth(120),
        this._treeColumn.renderCell = this.renderTreeCell,
        this._treeColumn.getValue = this.getTreeValue,
        this._treeColumn.setValue = this.setTreeValue,
        this._initTree(a),
        Ib.controls.TreeTable.superClass.constructor.apply(this, arguments),
        this._columnBox.add(this._treeColumn)
    },
    Jb.ext("twaver.controls.TreeTable", Ib.controls.TableBase, {
        __tree: 1,
        __accessor: ["sortFunction", "visibleFunction", "checkMode", "rootData", "sortColumn", "indent", "rowHeight", "rowLineWidth", "rowLineColor", "columnLineWidth", "columnLineColor", "expandIcon", "collapseIcon", "uncheckableStyle", "lineType", "lineColor", "lineThickness", "lineAlpha", "lineDash"],
        __bool: ["editable", "rootVisible", "makeVisibleOnSelected", "keyboardRemoveEnabled", "keyboardSelectEnabled"],
        _editable: Dd.TREETABLE_EDITABLE,
        _indent: Dd.TREETABLE_INDENT,
        _rowHeight: Dd.TREETABLE_ROW_HEIGHT,
        _rowLineWidth: Dd.TREETABLE_ROW_LINE_WIDTH,
        _rowLineColor: Dd.TREETABLE_ROW_LINE_COLOR,
        _columnLineWidth: Dd.TREETABLE_COLUMN_LINE_WIDTH,
        _columnLineColor: Dd.TREETABLE_COLUMN_LINE_COLOR,
        _makeVisibleOnSelected: Dd.TREETABLE_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Dd.TREETABLE_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Dd.TREETABLE_KEYBOARD_SELECT_ENABLED,
        _expandIcon: Dd.TREETABLE_EXPAND_ICON,
        _collapseIcon: Dd.TREETABLE_COLLAPSE_ICON,
        _lineType: Dd.TREE_LINE_TYPE,
        _lineColor: Dd.TREE_LINE_COLOR,
        _lineThickness: Dd.TREE_LINE_THICKNESS,
        _lineAlpha: Dd.TREE_LINE_ALPHA,
        _lineDash: Dd.TREE_LINE_DASH,
        getTreeColumn: function() {
            return this._treeColumn
        },
        renderTreeCell: function(a) {
            a.view._renderTree(a.div, a.data, a.rowIndex, a.selected)
        },
        getTreeValue: function(a, b) {
            return b.getLabel(a)
        },
        setTreeValue: function(a, b, c) {
            a.setName(b)
        }
    }),
    Ib.controls.PropertySheet = function(a) {
        Ib.controls.PropertySheet.superClass.constructor.apply(this, arguments),
        this._currentRowIndex = -1,
        this._currentEditor = null,
        this._currentData = null,
        this._invalidate = !1,
        this._resizeDiv = Wb.createDiv(),
        this._resizeDiv.style.backgroundColor = "white",
        this._resizeDiv.style.opacity = 0,
        this._resizeDiv.style.top = "0px",
        this._categoryList = new nd,
        this._categoryMap = {},
        this._rowList = new nd,
        this._propertyBox = new Ib.PropertyBox,
        this._propertyBox.addDataBoxChangeListener(this.invalidatePropertyBox, this),
        this._propertyBox.addDataPropertyChangeListener(this.invalidatePropertyBox, this),
        this._propertyBox.addHierarchyChangeListener(this.invalidatePropertyBox, this),
        this.__divPool = new Ib.Pool("div", 2),
        this.__cellPool = new Ib.Pool("div", 2),
        this.__imagePool = new Ib.Pool("img", 2),
        this.__textPool = new Ib.Pool("span", 2),
        this._stringPool = new Ib.Pool("span", 2),
        this._booleanPool = new Ib.Pool("input", 2),
        this._colorPool = new Ib.Pool("div", 2),
        this._pools.add(this.__divPool),
        this._pools.add(this.__cellPool),
        this._pools.add(this.__imagePool),
        this._pools.add(this.__textPool),
        this._pools.add(this._stringPool),
        this._pools.add(this._booleanPool),
        this._pools.add(this._colorPool),
        this._view = Wb.createView("auto"),
        this._rootDiv = Wb.createDiv(),
        this._dataDiv = Wb.createDiv(),
        this._view.appendChild(this._rootDiv),
        this._rootDiv.appendChild(this._dataDiv),
        this.setDataBox(a ? a: new Ib.DataBox);
        var b = this;
        this._view.addEventListener("change",
        function(a) {
            b.handleChange(a)
        },
        !1),
        Qb.isMSToucheable ? new Ib.controls.PropertySheetMSTouchInteraction(this) : (new Ib.controls.PropertySheetTouchInteraction(this), new Ib.controls.PropertySheetInteraction(this))
    },
    Jb.ext("twaver.controls.PropertySheet", Ib.controls.View, {
        __accessor: ["indent", "rowHeight", "sumWidth", "propertyNameWidth", "propertyNameHorizontalAlign", "autoAdjustable", "rowLineWidth", "columnLineWidth", "borderColor", "categorizable", "resizeTolerance", "editable", "selectColor", "expandIcon", "collapseIcon", "sortFunction", "visibleFunction"],
        _autoAdjustable: Dd.PROPERTYSHEET_AUTO_ADJUSTABLE,
        _selectColor: Dd.SELECT_COLOR,
        _categorizable: Dd.PROPERTYSHEET_CATEGORIZABLE,
        _editable: Dd.PROPERTYSHEET_EDITABLE,
        _propertyNameWidth: Dd.PROPERTYSHEET_PROPERTY_NAME_WIDTH,
        _propertyNameHorizontalAlign: Dd.PROPERTYSHEET_PROPERTY_NAME_HORIZONTAL_ALIGN,
        _sumWidth: Dd.PROPERTYSHEET_SUM_WIDTH,
        _indent: Dd.PROPERTYSHEET_INDENT,
        _rowHeight: Dd.PROPERTYSHEET_ROW_HEIGHT,
        _rowLineWidth: Dd.PROPERTYSHEET_ROW_LINE_WIDTH,
        _columnLineWidth: Dd.PROPERTYSHEET_COLUMN_LINE_WIDTH,
        _borderColor: Dd.PROPERTYSHEET_BORDER_COLOR,
        _expandIcon: Dd.PROPERTYSHEET_EXPAND_ICON,
        _collapseIcon: Dd.PROPERTYSHEET_COLLAPSE_ICON,
        _resizeTolerance: Dd.PROPERTYSHEET_RESIZE_TOLERANCE,
        getPropertyBox: function() {
            return this._propertyBox
        },
        getCurrentData: function() {
            return this._currentData
        },
        getDataDiv: function() {
            return this._dataDiv
        },
        getDataBox: function() {
            return this._box
        },
        setDataBox: function(a) {
            if (!a) throw "DataBox can not be null";
            if (this._box !== a) {
                var b = this._box;
                b && (b.removeDataPropertyChangeListener(this.handlePropertyChange, this), this._selectionModel || b.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this)),
                this._box = a,
                this._box.addDataPropertyChangeListener(this.handlePropertyChange, this),
                this._selectionModel ? this._selectionModel._setDataBox(a) : this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
                this.invalidate(),
                this.firePropertyChange("dataBox", b, this._box)
            }
        },
        invalidatePropertyBox: function() {
            this._isValidating || this.invalidate()
        },
        onPropertyChanged: function(a) {
            "zoom" !== a.property && this.invalidate()
        },
        isVisible: function(a) {
            return a.isVisible && !a.isVisible(this._currentData, this) ? !1 : this._visibleFunction ? this._visibleFunction(a) : !0
        },
        handlePropertyChange: function(a) {
            this._currentData === a.source && this.invalidate()
        },
        handleSelectionChange: function(a) {
            this._currentData !== this.getSelectionModel().getLastData() && (this._currentRowIndex = -1, this.invalidate())
        },
        isExpanded: function(a) {
            if (!a) return ! 0;
            var b = this._categoryMap[a];
            return b ? b.isExpanded: Dd.PROPERTYSHEET_EXPAND_CATEGORY
        },
        expand: function(a) {
            if (a) {
                var b = this._categoryMap[a];
                b && !b.isExpanded && (b.isExpanded = !0, this.invalidate())
            }
        },
        expandAll: function() {
            for (var a in this._categoryMap) {
                var b = this._categoryMap[a];
                b && (b.isExpanded = !0)
            }
            this.invalidate()
        },
        collapse: function(a) {
            if (a) {
                var b = this._categoryMap[a];
                b && b.isExpanded && (b.isExpanded = !1, this.invalidate())
            }
        },
        collapseAll: function() {
            for (var a in this._categoryMap) {
                var b = this._categoryMap[a];
                b && (b.isExpanded = !1)
            }
            this.invalidate()
        },
        getCategoryName: function(a) {
            if (!this.isCategorizable()) return "null";
            var b = a.getCategoryName();
            return b ? b: "null"
        },
        validateModel: function() {
            this._rowList.clear(),
            this._categoryList.clear();
            var a, b, c, d, e, f = {},
            g = new nd,
            h = this._currentData ? this._propertyBox.getRoots() : new nd;
            for (d = h.size(), a = 0; d > a; a++) e = h.get(a),
            this.isVisible(e) && (g.add(e), c = this.getCategoryName(e), f[c] || (this._categoryList.add(c), f[c] = {
                isExpanded: this.isExpanded(c),
                properties: new nd
            }));
            for (this._sortFunction && g.sort(this._sortFunction), this._categoryMap = f, d = g.size(), a = 0; a < this._categoryList.size(); a++) {
                c = this._categoryList.get(a),
                "null" !== c && this._rowList.add(c);
                var i = f[c];
                if (i.isExpanded) for (b = 0; d > b; b++) e = g.get(b),
                this.getCategoryName(e) === c && (i.properties.add(e), this._rowList.add({
                    view: this,
                    data: this._currentData,
                    property: e,
                    value: this._currentData ? this.getValue(this._currentData, e) : null
                }))
            }
        },
        adjustWidth: function() {
            var a = this._view.offsetWidth,
            b = this._view.offsetHeight;
            a <= this._indent || 0 >= b || (a -= this._indent, this._rowList.size() * this._rowHeight > b && (a -= Dd.SCROLL_BAR_WIDTH, 0 >= a) || (this._propertyNameWidth = 0 === this._sumWidth || this._propertyNameWidth > this._sumWidth ? a / 2 : a * (this._propertyNameWidth / this._sumWidth), this._sumWidth = a, this._view.style.overflowX = "hidden", this._view.style.overflowY = "auto"))
        },
        validateDisplay: function() {
            var a = this._rowList.size(),
            b = this._borderColor,
            c = this._indent,
            d = this._rowHeight,
            e = this._propertyNameWidth,
            f = Math.max(0, this._sumWidth - e),
            g = this._rowLineWidth,
            h = this._columnLineWidth,
            i = d - g + "px",
            j = d - g - 2 + "px",
            k = c + "px",
            l = e - h + "px",
            m = f - h + "px",
            n = e + f + "px",
            o = g + "px",
            p = h + "px",
            q = e + "px",
            r = this._dataDiv,
            s = r.style;
            s.height = a * d + "px",
            s.width = c + e + f + "px";
            var t = this.__divPool.get();
            s = t.style,
            s.position = "absolute",
            s.left = "0px",
            s.top = "0px",
            s.width = k,
            s.height = r.style.height,
            s.borderWidth = "0px",
            s.backgroundColor = b,
            r.appendChild(t);
            for (var u = 0; a > u; u++) {
                var v = this._rowList.get(u),
                w = u * d + "px",
                x = this.__divPool.get();
                if (v.rowDiv = x, s = x.style, s.position = "absolute", s.whiteSpace = "nowrap", s.overflow = "hidden", s.textOverflow = "ellipsis", s.left = k, s.top = w, s.width = n, s.height = i, s.lineHeight = j, s.borderStyle = "solid", s.borderWidth = "0px", s.borderBottomWidth = o, s.borderBottomColor = b, r.appendChild(x), "string" == typeof v) {
                    s.backgroundColor = b,
                    t = this.__divPool.get(),
                    s = t.style,
                    s.position = "absolute",
                    s.left = "0px",
                    s.top = w,
                    s.width = k,
                    s.height = i,
                    s.lineHeight = j,
                    s.borderWidth = "0px",
                    r.appendChild(t);
                    var y = this.__imagePool.get(),
                    z = this.isExpanded(v) ? this._expandIcon: this._collapseIcon;
                    y.setAttribute("src", Jb.getImageSrc(z)),
                    s = y.style,
                    s.verticalAlign = "middle",
                    y._expandData = v,
                    t.appendChild(y),
                    this.renderCategory(x, v),
                    this.onCategoryRendered(x, v)
                } else {
                    var A = v.property,
                    B = this.__cellPool.get();
                    v.nameRender = B,
                    s = B.style,
                    this._currentRowIndex === u && (s.backgroundColor = this.getSelectColor()),
                    s.position = "absolute",
                    s.verticalAlign = "middle",
                    s.textAlign = this._propertyNameHorizontalAlign,
                    s.overflow = "hidden",
                    s.textOverflow = "ellipsis",
                    s.whiteSpace = "nowrap",
                    s.left = "0px",
                    s.top = "0px",
                    s.width = l,
                    s.height = i,
                    s.borderStyle = "solid",
                    s.borderWidth = "0px",
                    s.borderRightWidth = p,
                    s.borderRightColor = b,
                    x.appendChild(B),
                    this.renderName(v),
                    this.onNameRendered(v),
                    B = this.__cellPool.get(),
                    v.valueRender = B,
                    s = B.style,
                    s.position = "absolute",
                    s.verticalAlign = "middle",
                    s.textAlign = A.getHorizontalAlign(),
                    s.whiteSpace = "nowrap",
                    s.overflow = "hidden",
                    s.textOverflow = "ellipsis",
                    s.left = q,
                    s.top = "0px",
                    s.width = m,
                    s.height = i,
                    s.borderStyle = "solid",
                    s.borderWidth = "0px",
                    s.borderRightWidth = p,
                    s.borderRightColor = b,
                    x.appendChild(B),
                    this.renderValue(v),
                    this.onValueRendered(v)
                }
            }
            s = this._resizeDiv.style,
            s.left = c + e - h - this._resizeTolerance + "px",
            s.width = h + 2 * this._resizeTolerance + "px",
            s.height = r.style.height,
            r.appendChild(this._resizeDiv)
        },
        renderCategory: function(a, b) {
            var c = this.__textPool.get(),
            d = c.style;
            d.fontWeight = "bold",
            d.whiteSpace = "nowrap",
            d.overflow = "hidden",
            d.textOverflow = "ellipsis",
            d.verticalAlign = "middle",
            d.padding = "1px 2px 1px 2px",
            c.innerHTML = b,
            c.setAttribute("title", b),
            a.appendChild(c)
        },
        onCategoryRendered: function(a, b) {},
        renderName: function(a) {
            if (a.property.renderName) return void a.property.renderName(a);
            var b = this.__textPool.get(),
            c = b.style;
            c.fontWeight = "",
            c.whiteSpace = "nowrap",
            c.verticalAlign = "middle",
            c.padding = "1px 2px 1px 2px";
            var d = a.property.getName();
            d || (d = a.property.getPropertyName()),
            b.innerHTML = d,
            b.setAttribute("title", d),
            a.nameRender.appendChild(b)
        },
        onNameRendered: function(a) {},
        renderValue: function(a) {
            var b = a.property;
            if (b.renderValue) return void b.renderValue(a);
            var c = a.value,
            d = b.getEnumInfo(this._currentData);
            d && !Array.isArray(d) && (c = d.map[c]),
            a.view.isCellEditable(a.data, b) && (a.enumInfo = d, a.valueRender._editInfo = a),
            a.valueRender.innerHTML = "",
            Ac.render(b.getValueType(), c, a.valueRender, a.view, b.isInnerText())
        },
        onValueRendered: function(a) {},
        renderEditor: function(a) {},
        onEditorRendered: function(a) {},
        updateCurrentData: function() {
            this._currentData = this.getSelectionModel().getLastData()
        },
        validateImpl: function() {
            var a = this._view.scrollLeft,
            b = this._view.scrollTop;
            Wb.release(this._dataDiv),
            this.updateCurrentData(),
            this.validateModel(),
            this.isAutoAdjustable() && this.adjustWidth(),
            this.validateDisplay(),
            this._pools.forEach(function(a) {
                a.clear()
            }),
            this._view.scrollLeft !== a && (this._view.scrollLeft = a),
            this._view.scrollTop !== b && (this._view.scrollTop = b)
        },
        getValue: function(a, b) {
            return a ? b.getValue(a, this) : null
        },
        setValue: function(a, b, c) {
            a && b.setValue(a, c, this)
        },
        isCellEditable: function(a, b) {
            return a ? this.isEditable() && b.isEditable() : !1
        },
        getRowIndexAt: function(a) {
            var b = this.getLogicalPoint(a);
            if (!b) return - 1;
            var c = parseInt(b.y / this._rowHeight);
            return c >= 0 && c < this._rowList.size() ? c: -1
        },
        handleChange: function(a) {
            this._isCommitting || this._isCanceling || this._isValidating || a.target._editInfo && this.commitEditValue && this.commitEditValue(a.target._editInfo, a.target)
        },
        commitEditValue: function(a, b) {
            var c;
            c = "checkbox" === b.type ? b.checked: b.value;
            var d = a.property,
            e = d.getValueType();
            if ("int" === e && "string" == typeof c) c = parseInt(c);
            else if ("number" === e && "string" == typeof c) c = parseFloat(c);
            else if ("array.string" === e) c = c.split(",");
            else if ("array.number" === e) {
                c = c.split(",");
                for (var f = 0,
                g = c.length; g > f; f++) c[f] = parseFloat(c[f])
            }
            if (b._rowInfo && (b._rowInfo.value = c, this.renderValue(b._rowInfo)), this.setValue(a.data, d, c), Ib.Util.setFocus(this._view), this._currentEditor) {
                var h = this._currentEditor.parentNode;
                h && h.removeChild(this._currentEditor),
                delete this._currentEditor
            }
            delete this._isCommitting
        },
        cancelEditing: function() {
            if (this._currentEditor) {
                var a = this._currentEditor.parentNode;
                a && a.removeChild(this._currentEditor),
                delete this._currentEditor,
                delete this._isCanceling
            }
        },
        updateCurrentRowIndex: function(a) {
            var b = this._rowList.size(); (0 > a || a >= b) && (a = -1);
            var c, d = this._currentRowIndex;
            if (a !== d && (d >= 0 && b > d && (c = this._rowList.get(d), c.nameRender && (c.nameRender.style.backgroundColor = "")), this._currentRowIndex = a), a >= 0 && (c = this._rowList.get(a), c.nameRender && (c.nameRender.style.backgroundColor = this.getSelectColor(), !this._currentEditor && c.valueRender && c.valueRender._editInfo))) {
                var e = c.valueRender._editInfo,
                f = this.renderEditor && this.renderEditor(c);
                f ? (this._currentEditor = f.view, null != e.value && (this._currentEditor.value = e.value)) : e.enumInfo ? this._currentEditor = Wb.createSelect(e.enumInfo, e.value) : (this._currentEditor = Ob.createElement("input"), null != e.value && (this._currentEditor.value = e.value));
                var g = this;
                if (this._currentEditor) {
                    if (f && f.onKeyDown) {
                        var h = f.onKeyDown;
                        h && Array.isArray(h) && g._currentEditor.addEventListener("keydown",
                        function(a) {
                            for (var b = 0; b < h.length; b++) if (h[b].combKey) {
                                var c = null;
                                switch (h[b].combKey) {
                                case "ctrlKey":
                                    c = a.ctrlKey;
                                    break;
                                case "shiftKey":
                                    c = a.shiftKey;
                                    break;
                                case "altKey":
                                    c = a.altKey
                                }
                                a.keyCode === h[b].keyCode && c && h[b].handlerEvent && h[b].handlerEvent(a)
                            } else a.keyCode === h[b].keyCode && h[b].handlerEvent && h[b].handlerEvent(a)
                        })
                    } else this._currentEditor.addEventListener("keydown",
                    function(a) {
                        var b = a.target._editInfo.view;
                        if (13 !== a.keyCode || !a.shiftKey) if (13 === a.keyCode) {
                            if (b._isCommitting) return;
                            b._isCommitting = !0,
                            b.commitEditValue(a.target._editInfo, a.target)
                        } else 27 === a.keyCode && (b._isCanceling = !0, b.cancelEditing())
                    },
                    !1);
                    if (this._currentEditor.addEventListener("blur",
                    function(a) {
                        var b = a.target._editInfo.view;
                        b._isCommitting || b._isCanceling || (b._isCommitting = !0, b.commitEditValue(a.target._editInfo, a.target))
                    },
                    !1), this._currentEditor.keepDefault = !0, this._currentEditor._rowInfo = c, this._currentEditor._editInfo = e, !this._currentEditor.parentNode) {
                        var i = this._currentEditor.style;
                        i.position = "absolute",
                        i.margin = "0px",
                        i.border = "0px",
                        i.padding = "0px",
                        i.left = this._indent + this._propertyNameWidth + "px",
                        i.top = c.rowDiv.style.top,
                        i.width = c.valueRender.style.width,
                        i.height = c.valueRender.style.height,
                        this._rootDiv.appendChild(this._currentEditor)
                    }
                    Ib.Util.setFocus(this._currentEditor)
                }
            }
        }
    }),
    Ib.controls.PropertySheetInteraction = function(a) {
        this.sheet = a,
        this.view = a._view,
        this.resizeDiv = a._resizeDiv;
        var b = this;
        this.view.addEventListener("mousedown",
        function(a) {
            0 === a.button && b.handleMouseDown(a)
        },
        !1),
        this.view.addEventListener("mousemove",
        function(a) {
            b.handleMouseMove(a)
        },
        !1)
    },
    Jb.ext("twaver.controls.PropertySheetInteraction", Object, {
        minGap: 10,
        handleMouseDown: function(a) {
            if (a.target !== this.sheet._currentEditor && a.target.parentNode !== this.sheet._currentEditor && (this.sheet.isFocusOnClick() && Ib.Util.setFocus(this.view), !this.sheet._isValidating)) if (a.target._expandData) {
                var b = a.target._expandData;
                this.sheet.isExpanded(b) ? this.sheet.collapse(b) : this.sheet.expand(b)
            } else if (a.target === this.resizeDiv) this.lastX = this.getX(a),
            Wb.handle_mousedown(this, a);
            else {
                this.sheet._currentEditor && !this.sheet._isCommitting && (this.sheet._isCommitting = !0, this.sheet.commitEditValue(this.sheet._currentEditor._editInfo, this.sheet._currentEditor));
                var c = this.sheet.getRowIndexAt(a);
                this.sheet.updateCurrentRowIndex(c)
            }
        },
        handleMouseMove: function(a) {
            if (null == this.lastX && !Wb.target) return void this.changeCursor(a);
            if (Wb.target === this && null != this.lastX) {
                var b = this.getX(a);
                if (null != this.stopLeft) {
                    if (b < this.stopLeft) return;
                    delete this.stopLeft
                }
                if (null != this.stopRight) {
                    if (b > this.stopRight) return;
                    delete this.stopRight
                }
                var c = this.sheet.getPropertyNameWidth() + (b - this.lastX);
                c < this.minGap ? (c = this.minGap, this.stopLeft = b) : c > this.sheet.getSumWidth() - this.minGap && (c = this.sheet.getSumWidth() - this.minGap, this.stopRight = b),
                this.sheet.setPropertyNameWidth(c),
                this.lastX = b
            }
        },
        handleMouseUp: function(a) {
            0 === a.button && (this.view.style.cursor = "default", delete this.stopLeft, delete this.stopRight, delete this.lastX)
        },
        changeCursor: function(a) {
            this.view.style.cursor = a.target === this.resizeDiv ? "ew-resize": "default"
        },
        getX: function(a) {
            return a.clientX / this.sheet.getZoom()
        }
    }),
    Ib.controls.PropertySheetTouchInteraction = function(a) {
        this.sheet = a,
        this.view = a._view,
        this.resizeDiv = a._resizeDiv,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.controls.PropertySheetTouchInteraction", Object, {
        minGap: 10,
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            a.target !== this.sheet._currentEditor && a.target.parentNode !== this.sheet._currentEditor && (this.sheet.isFocusOnClick() && Ib.Util.setFocus(this.view), this.sheet._isValidating || (a.target === this.resizeDiv && (this.lastX = this.getX(a)), this.lastPoint = this.sheet.getLogicalPoint(a), zc.isMultiTouch(a) && (this.distance = zc.getDistance(a), this.zoom = this.sheet.getZoom()), Wb.addEventListener("touchmove", "handleTouchmove", this.view, this), Wb.addEventListener("touchend", "handleTouchend", this.view, this)))
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), this.moved || (this.moved = !0), null != this.lastX) {
                var b = this.getX(a);
                if (null != this.stopLeft) {
                    if (b < this.stopLeft) return;
                    delete this.stopLeft
                }
                if (null != this.stopRight) {
                    if (b > this.stopRight) return;
                    delete this.stopRight
                }
                var c = this.sheet.getPropertyNameWidth() + (b - this.lastX);
                c < this.minGap ? (c = this.minGap, this.stopLeft = b) : c > this.sheet.getSumWidth() - this.minGap && (c = this.sheet.getSumWidth() - this.minGap, this.stopRight = b),
                this.sheet.setPropertyNameWidth(c),
                this.lastX = b
            } else if (zc.isSingleTouch(a)) {
                if (this.lastPoint) {
                    var d = this.sheet.getLogicalPoint(a),
                    e = this.lastPoint.x - d.x,
                    f = this.lastPoint.y - d.y,
                    g = this.sheet.panByOffset(e, f);
                    this.lastPoint.x -= e - g.x,
                    this.lastPoint.y -= f - g.y
                }
            } else if (this.distance) {
                var h = zc.getDistance(a) / this.distance;
                this.sheet.setZoom(this.zoom * h, !1)
            }
        },
        handleTouchend: function(a) {
            if (Wb.preventDefault(a), !this.moved) if (a.target._expandData) {
                var b = a.target._expandData;
                this.sheet.isExpanded(b) ? this.sheet.collapse(b) : this.sheet.expand(b)
            } else if (a.target === this.resizeDiv);
            else {
                var c = this.sheet.getRowIndexAt(a);
                this.sheet.updateCurrentRowIndex(c)
            }
            delete this.stopLeft,
            delete this.stopRight,
            delete this.lastX,
            delete this.lastPoint,
            delete this.distance,
            delete this.zoom,
            delete this.moved,
            Wb.removeEventListener("touchmove", this.view, this),
            Wb.removeEventListener("touchend", this.view, this)
        },
        getX: function(a) {
            var b = a.changedTouches[0];
            return b.clientX
        }
    }),
    Ib.controls.PropertySheetMSTouchInteraction = function(a) {
        this.sheet = a,
        this.view = a._view,
        this.resizeDiv = a._resizeDiv,
        this._pointerMap = {},
        this._pointerIdArray = [];
        var b = this;
        this.view.addEventListener("MSPointerDown",
        function(a) {
            b.handleTouchstart(a)
        },
        !1),
        this.view.addEventListener("MSPointerMove",
        function(a) {
            b.handleTouchmove(a)
        },
        !1),
        this.view.addEventListener("MSPointerUp",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.view.addEventListener("MSPointerCancel",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.superHandleMouseDown = Ib.controls.PropertySheetMSTouchInteraction.superClass.handleMouseDown
    },
    Jb.ext("twaver.controls.PropertySheetMSTouchInteraction", Ib.controls.PropertySheetInteraction, {
        handleMouseDown: function(a) {},
        handleTouchstart: function(a) {
            a.isPrimary && this._pointerIdArray.length > 0 && (this._pointerMap = {},
            this._pointerIdArray = []),
            this._pointerMap[a.pointerId] || null == this.sheet.getLogicalPoint(a) || (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a),
            1 == this._pointerIdArray.length && a.pointerType == a.MSPOINTER_TYPE_MOUSE && this.superHandleMouseDown(a),
            1 == this._pointerIdArray.length ? (this._startTouchPoint = this.sheet.getLogicalPoint(a), this._startTouchTime = new Date) : 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.sheet.getZoom())
        },
        handleTouchmove: function(a) {
            if (0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10)) if (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length) {
                var b = this._getDistance() / this._distance;
                this.sheet.setZoom(this._zoom * b, !1)
            } else if (1 == this._pointerIdArray.length && a.pointerType != a.MSPOINTER_TYPE_MOUSE && this._startTouchPoint) {
                var c = this.sheet.getLogicalPoint(a);
                if (null == c) return;
                var d = this._startTouchPoint.x - c.x,
                e = this._startTouchPoint.y - c.y,
                f = this.sheet.panByOffset(d, e);
                this._startTouchPoint.x -= d - f.x,
                this._startTouchPoint.y -= e - f.y
            }
        },
        handleTouchend: function(a) {
            if (1 == this._pointerIdArray.length && a.pointerType != a.MSPOINTER_TYPE_MOUSE) {
                var b = this.sheet.getLogicalPoint(a),
                c = new Date;
                c.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 20 && this.superHandleMouseDown(a)
            }
            this._pointerMap = {},
            this._pointerIdArray = []
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        }
    }),
    Ib.controls.SplitPane = function(a, b, c, d) {
        Ib.controls.SplitPane.superClass.constructor.apply(this, arguments),
        this._view = Wb.createView("hidden", !0),
        this._view.tabIndex = -1,
        this._dividerDiv = Wb.createDiv(),
        this._dividerDiv.tabIndex = -1,
        this._view.appendChild(this._dividerDiv),
        a && this.setFirstView(a),
        b && this.setNextView(b),
        c && this.setOrientation(c),
        null != d && this.setPosition(d),
        this.setDividerDraggable(!0),
        this.invalidate(),
        Qb.isTouchable && !Qb.isMSToucheable && new Ib.controls.SplitPaneTouchInteraction(this),
        new Ib.controls.SplitPaneInteraction(this)
    },
    Jb.ext("twaver.controls.SplitPane", Ib.controls.ControlBase, {
        __accessor: ["orientation", "dividerWidth", "dividerBackground", "dividerOpacity", "maskBackground"],
        __bool: ["dividerDraggable"],
        _position: Dd.SPLITPANE_POSITION,
        _orientation: Dd.SPLITPANE_ORIENTATION,
        _dividerWidth: Dd.SPLITPANE_DIVIDER_WIDTH,
        _dividerBackground: Dd.SPLITPANE_DIVIDER_BACKGROUND,
        _dividerOpacity: Dd.SPLITPANE_DIVIDER_OPACITY,
        _maskBackground: Dd.SPLITPANE_MASK_BACKGROUND,
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        getDividerDiv: function() {
            return this._dividerDiv
        },
        getPosition: function() {
            return this._position
        },
        setPosition: function(a) {
            if (0 > a && (a = 0), a > 1 && (a = 1), a !== this._position) {
                var b = this._position;
                this._position = a,
                this.firePropertyChange("position", b, a)
            }
        },
        setFirstView: function(a) {
            if (this._firstView !== a) {
                var b = this._firstView;
                b && this._view.removeChild(b.getView ? b.getView() : b),
                this._firstView = a,
                a && (a.getView ? this._view.insertBefore(a.getView(), this._dividerDiv) : this._view.insertBefore(a, this._dividerDiv)),
                this.firePropertyChange("firstView", b, a)
            }
        },
        getFirstView: function() {
            return this._firstView
        },
        setNextView: function(a) {
            if (this._nextView !== a) {
                var b = this._nextView;
                b && this._view.removeChild(b.getView ? b.getView() : b),
                this._nextView = a,
                a && (a.getView ? this._view.insertBefore(a.getView(), this._dividerDiv) : this._view.insertBefore(a, this._dividerDiv)),
                this.firePropertyChange("nextView", b, a)
            }
        },
        getNextView: function() {
            return this._nextView
        },
        validateImpl: function() {
            var a = this._position,
            b = this._view.offsetWidth,
            c = this._view.offsetHeight,
            d = this._dividerWidth;
            if (d >= 8 || 0 === d ? this._coverDiv && (this._dividerDiv.removeChild(this._coverDiv), delete this._coverDiv) : this._coverDiv || (this._coverDiv = Wb.createDiv(), this._coverDiv.tabIndex = -1, this._dividerDiv.appendChild(this._coverDiv)), "horizontal" === this._orientation) {
                d > b && (d = b);
                var e = (b - d) * a,
                f = b - d - e + 1;
                Jb.setViewBounds(this._firstView, {
                    x: 0,
                    y: 0,
                    width: e,
                    height: c
                }),
                Jb.setViewBounds(this._nextView, {
                    x: e + d,
                    y: 0,
                    width: f,
                    height: c
                }),
                Jb.setViewBounds(this._dividerDiv, {
                    x: e,
                    y: 0,
                    width: d,
                    height: c
                }),
                this._dividerDiv.position = e,
                this._coverDiv && Jb.setViewBounds(this._coverDiv, {
                    x: d / 2 - 4,
                    y: 0,
                    width: 8,
                    height: c
                })
            } else {
                d > c && (d = c);
                var g = (c - d) * a,
                h = c - d - g;
                Jb.setViewBounds(this._firstView, {
                    x: 0,
                    y: 0,
                    width: b,
                    height: g
                }),
                Jb.setViewBounds(this._nextView, {
                    x: 0,
                    y: g + d,
                    width: b,
                    height: h
                }),
                Jb.setViewBounds(this._dividerDiv, {
                    x: 0,
                    y: g,
                    width: b,
                    height: d
                }),
                this._dividerDiv.position = g,
                this._coverDiv && Jb.setViewBounds(this._coverDiv, {
                    x: 0,
                    y: d / 2 - 4,
                    width: b,
                    height: 8
                })
            }
            var i = this._dividerDiv.style;
            i.background = this._dividerBackground
        }
    }),
    Ib.controls.SplitPaneInteraction = function(a) {
        this.splitPane = a,
        this.view = a._view,
        this.dividerDiv = a._dividerDiv;
        var b = this;
        this.view.addEventListener("mousedown",
        function(a) {
            0 === a.button && b.handleMouseDown(a)
        },
        !1),
        this.view.addEventListener("mousemove",
        function(a) {
            b.handleMouseMove(a)
        },
        !1)
    },
    Jb.ext("twaver.controls.SplitPaneInteraction", Object, {
        handleMouseDown: function(a) {
            if (this.splitPane.isDividerDraggable()) if (this.resizeDiv) this.clear(a);
            else if (a.target === this.dividerDiv || a.target === this.splitPane._coverDiv) {
                this.resizeDiv = Wb.createDiv();
                var b = this.resizeDiv.style;
                b.left = this.dividerDiv.style.left,
                b.top = this.dividerDiv.style.top,
                b.width = this.dividerDiv.style.width,
                b.height = this.dividerDiv.style.height,
                b.opacity = this.splitPane.getDividerOpacity(),
                b.background = this.splitPane.getDividerBackground(),
                this.resizeDiv.lastPosition = "horizontal" === this.splitPane._orientation ? a.clientX: a.clientY,
                this.resizeDiv.maskDiv = Wb.createDiv(),
                b = this.resizeDiv.maskDiv.style,
                b.left = "0px",
                b.top = "0px",
                b.width = this.view.clientWidth + "px",
                b.height = this.view.clientHeight + "px",
                b.background = this.splitPane.getMaskBackground(),
                this.view.appendChild(this.resizeDiv.maskDiv),
                this.view.appendChild(this.resizeDiv),
                Wb.handle_mousedown(this, a),
                a.preventDefault()
            }
        },
        handleMouseMove: function(a) {
            if (this.splitPane.isDividerDraggable()) if (this.resizeDiv || Wb.target) this.resizeDiv && Wb.target === this && ("horizontal" === this.splitPane._orientation ? this.resizeDiv.style.left = this.dividerDiv.position + a.clientX - this.resizeDiv.lastPosition + "px": this.resizeDiv.style.top = this.dividerDiv.position + a.clientY - this.resizeDiv.lastPosition + "px");
            else {
                var b = "horizontal" === this.splitPane._orientation ? "ew-resize": "ns-resize";
                this.view.style.cursor = a.target === this.dividerDiv || a.target === this.splitPane._coverDiv ? b: "default"
            }
        },
        handleMouseUp: function(a) {
            this.splitPane.isDividerDraggable() && 0 === a.button && this.clear(a)
        },
        clear: function(a) {
            if (this.resizeDiv) {
                var b, c = this.splitPane._dividerWidth;
                if ("horizontal" === this.splitPane._orientation) {
                    var d = this.view.clientWidth;
                    c > d && (c = d),
                    b = this.dividerDiv.position + a.clientX - this.resizeDiv.lastPosition,
                    this.splitPane.setPosition(b / (d - c))
                } else {
                    var e = this.view.clientHeight;
                    c > e && (c = e),
                    b = this.dividerDiv.position + a.clientY - this.resizeDiv.lastPosition,
                    this.splitPane.setPosition(b / (e - c))
                }
                this.view.removeChild(this.resizeDiv.maskDiv),
                this.view.removeChild(this.resizeDiv),
                delete this.resizeDiv
            }
        }
    }),
    Ib.controls.SplitPaneTouchInteraction = function(a) {
        this.splitPane = a,
        this.view = a._view,
        this.dividerDiv = a._dividerDiv,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.controls.SplitPaneTouchInteraction", Object, {
        handleTouchstart: function(a) {
            if (Wb.preventDefault(a), this.resizeDiv) this.clear(a);
            else if (a.target === this.dividerDiv || a.target === this.splitPane._coverDiv) {
                this.resizeDiv = Wb.createDiv();
                var b = this.resizeDiv.style;
                b.left = this.dividerDiv.style.left,
                b.top = this.dividerDiv.style.top,
                b.width = this.dividerDiv.style.width,
                b.height = this.dividerDiv.style.height,
                b.opacity = this.splitPane.getDividerOpacity(),
                b.background = this.splitPane.getDividerBackground();
                var c = a.changedTouches[0];
                this.resizeDiv.lastPosition = "horizontal" === this.splitPane._orientation ? c.clientX: c.clientY,
                this.resizeDiv.maskDiv = Wb.createDiv();
                var b = this.resizeDiv.maskDiv.style;
                b.left = "0px",
                b.top = "0px",
                b.width = this.view.clientWidth + "px",
                b.height = this.view.clientHeight + "px",
                b.background = this.splitPane.getMaskBackground(),
                this.view.appendChild(this.resizeDiv.maskDiv),
                this.view.appendChild(this.resizeDiv)
            }
            Wb.addEventListener("touchmove", "handleTouchmove", this.view, this),
            Wb.addEventListener("touchend", "handleTouchend", this.view, this)
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), this.resizeDiv) {
                var b = a.changedTouches[0];
                "horizontal" === this.splitPane._orientation ? this.resizeDiv.style.left = this.dividerDiv.position + b.clientX - this.resizeDiv.lastPosition + "px": this.resizeDiv.style.top = this.dividerDiv.position + b.clientY - this.resizeDiv.lastPosition + "px"
            }
        },
        handleTouchend: function(a) {
            Wb.removeEventListener("touchmove", this.view, this),
            Wb.removeEventListener("touchend", this.view, this),
            this.clear(a)
        },
        clear: function(a) {
            var b = a.changedTouches[0];
            if (this.resizeDiv) {
                var c = this.splitPane._dividerWidth;
                if ("horizontal" === this.splitPane._orientation) {
                    var d = this.view.clientWidth;
                    c > d && (c = d);
                    var e = this.dividerDiv.position + b.clientX - this.resizeDiv.lastPosition;
                    this.splitPane.setPosition(e / (d - c))
                } else {
                    var f = this.view.clientHeight;
                    c > f && (c = f);
                    var e = this.dividerDiv.position + b.clientY - this.resizeDiv.lastPosition;
                    this.splitPane.setPosition(e / (f - c))
                }
                this.view.removeChild(this.resizeDiv.maskDiv),
                this.view.removeChild(this.resizeDiv),
                delete this.resizeDiv
            }
        }
    }),
    Ib.controls.TabPane = function() {
        Ib.controls.TabPane.superClass.constructor.apply(this, arguments),
        this._tabBox = new Ib.TabBox,
        this._tabBox.addDataBoxChangeListener(this.handleTabChange, this),
        this._tabBox.addDataPropertyChangeListener(this.handleTabChange, this),
        this._tabBox.addHierarchyChangeListener(this.handleTabChange, this),
        this._tabBox.getSelectionModel().addSelectionChangeListener(this.handleTabChange, this),
        this._view = Wb.createView("hidden", !0),
        this._tabDiv = Wb.createDiv(),
        this._tabDiv.onmousedown = Wb.preventDefault,
        this._tabDiv.onkeydown = Wb.preventDefault,
        this._contentDiv = Wb.createDiv(),
        this._view.appendChild(this._tabDiv),
        this._view.appendChild(this._contentDiv),
        this._divPool = new Ib.Pool("div"),
        this._iconPool = new Ib.Pool("img"),
        this._closePool = new Ib.Pool("img"),
        this._textPool = new Ib.Pool("span"),
        this._resizePool = new Ib.Pool("div"),
        this._pools.add(this._divPool),
        this._pools.add(this._iconPool),
        this._pools.add(this._closePool),
        this._pools.add(this._textPool),
        this._pools.add(this._resizePool),
        this.invalidateTab(),
        Qb.isTouchable && !Qb.isMSToucheable && new Ib.controls.TabPaneTouchInteraction(this),
        new Ib.controls.TabPaneInteraction(this)
    },
    Jb.ext("twaver.controls.TabPane", Ib.controls.ControlBase, {
        __accessor: ["tabGap", "tabRadius", "tabHeight", "horizontalAlign", "tabOrientation", "resizeTolerance", "tabBackground", "selectBackground", "moveBackground", "insertBackground", "closeIcon", "disabledColor"],
        __bool: ["selectNextOnClose", "selectNextOnInVisible"],
        _tabGap: Dd.TABPANE_TAB_GAP,
        _tabRadius: Dd.TABPANE_TAB_RADIUS,
        _tabHeight: Dd.TABPANE_TAB_HEIGHT,
        _resizeTolerance: Dd.TABPANE_RESIZE_TOLERANCE,
        _tabOrientation: Dd.TABPANE_TAB_ORIENTATION,
        _tabBackground: Dd.TABPANE_TAB_BACKGROUND,
        _disabledColor: Dd.TABPANE_DISABLED_COLOR,
        _selectBackground: Dd.TABPANE_SELECT_BACKGROUND,
        _moveBackground: Dd.TABPANE_MOVE_BACKGROUND,
        _insertBackground: Dd.TABPANE_INSERT_BACKGROUND,
        _horizontalAlign: Dd.TABPANE_HORIZONTAL_ALIGN,
        _closeIcon: Dd.TABPANE_CLOSE_ICON,
        _selectNextOnClose: Dd.TABPANE_SELECT_NEXT_ON_CLOSE,
        _selectNextOnInVisible: Dd.TABPANE_SELECT_NEXT_ON_INVISIBLE,
        onPropertyChanged: function(a) {
            this.invalidateTab()
        },
        getTabBox: function() {
            return this._tabBox
        },
        getTabDiv: function() {
            return this._tabDiv
        },
        getContentDiv: function() {
            return this._contentDiv
        },
        handleTabChange: function(a) {
            if (this._selectNextOnInVisible && "visible" === a.property && !a.newValue && this._tabBox.getSelectionModel().contains(a.source)) {
                for (var b, c, d = a.source,
                e = this._tabBox.getRoots().indexOf(d), f = this._tabBox.getRoots(), g = f.size(), h = e; g - 1 > h;) if (b = f.get(++h), b.isVisible() && !b.isDisabled()) {
                    c = b;
                    break
                }
                if (!c) for (h = e; h > 0;) if (b = f.get(--h), b.isVisible() && !b.isDisabled()) {
                    c = b;
                    break
                }
                this._tabBox.getSelectionModel().setSelection(c)
            }
            this.invalidateTab()
        },
        invalidateTab: function(a) {
            this._invalidateTab || (this._invalidateTab = !0, this.invalidate(a))
        },
        validateImpl: function() {
            this._invalidateTab && (this._invalidateTab = !1, this.validateTab());
            var a, b = this._view.offsetWidth,
            c = this._view.offsetHeight;
            "top" === this._tabOrientation ? (this._tabDiv.style.top = "0px", a = {
                x: 0,
                y: this._tabHeight,
                width: b,
                height: Math.max(0, c - this._tabHeight)
            }) : (this._tabDiv.style.top = c - this._tabHeight + "px", a = {
                x: 0,
                y: 0,
                width: b,
                height: Math.max(0, c - this._tabHeight)
            }),
            this._currentView && Jb.setViewBounds(this._currentView, a)
        },
        getCurrentTab: function() {
            return this._currentTab
        },
        getCurrentView: function() {
            return this._currentView
        },
        onViewRemoved: function(a) {},
        onViewAdded: function(a) {},
        validateTab: function() {
            this._currentTab = this._tabBox.getSelectionModel().getLastData();
            var a = this._currentTab ? this._currentTab.getView() : null;
            if (a !== this._currentView) {
                var b, c;
                this._currentView && (b = this._currentView.getView ? this._currentView.getView() : this._currentView, b.style.visibility = "hidden", this.onViewRemoved(this._currentView)),
                a && (c = a.getView ? a.getView() : a, c.style.visibility = "inherit", c.parentNode || this._contentDiv.appendChild(c), this.onViewAdded(a)),
                this._currentView = a
            }
            Wb.release(this._tabDiv);
            for (var d = this._tabBox.getRoots(), e = this._tabHeight + "px", f = this._tabHeight - 2 + "px", g = this._tabRadius + "px", h = d.size(), i = 0, j = 0; h > j; j++) {
                var k = d.get(j);
                if (k.isVisible()) {
                    var l = this._currentTab === k,
                    m = k.getWidth();
                    0 > m && (m = 0);
                    var n = Math.min(this._tabGap, m),
                    o = this._divPool.get();
                    o._tab = k;
                    var p = o.style;
                    p.position = "absolute",
                    p.whiteSpace = "nowrap",
                    p.lineHeight = f,
                    p.overflow = "hidden",
                    p.textOverflow = "ellipsis",
                    p.background = l ? this._selectBackground: this._tabBackground,
                    p.textAlign = this._horizontalAlign,
                    "top" === this._tabOrientation ? (p.borderTopLeftRadius = g, p.borderTopRightRadius = g, p.borderBottomLeftRadius = "0px", p.borderBottomRightRadius = "0px") : (p.borderTopLeftRadius = "0px", p.borderTopRightRadius = "0px", p.borderBottomLeftRadius = g, p.borderBottomRightRadius = g),
                    p.left = i + "px",
                    p.width = m - n + "px",
                    p.height = e,
                    o._x = i,
                    o._width = m - n,
                    this.renderTab(o, k),
                    this.onTabRendered(o, k),
                    this._tabDiv.insertBefore(o, this._tabDiv.firstChild),
                    i += m,
                    k.isResizable() && (o = this._resizePool.get(), o._resizeTab = k, p = o.style, p.position = "absolute", p.backgroundColor = "white", p.opacity = 0, p.left = i - n - this._resizeTolerance + "px", p.width = n + 2 * this._resizeTolerance + "px", p.height = e, this._tabDiv.appendChild(o))
                }
            }
            this._tabDiv.style.left = "0px",
            this._tabDiv.style.width = i + "px",
            this._tabDiv.style.height = this._tabHeight + "px",
            this._pools.forEach(function(a) {
                a.clear()
            })
        },
        renderTab: function(a, b) {
            if (b.renderTab) b.renderTab(a);
            else {
                var c = b.getIcon();
                if (c) {
                    var d = this._iconPool.get();
                    d.setAttribute("src", Jb.getImageSrc(c)),
                    d.style.paddingLeft = "4px",
                    d.style.verticalAlign = "middle",
                    a.appendChild(d)
                }
                var e = b.getName();
                if (e) {
                    var f = this._textPool.get();
                    f.style.whiteSpace = "nowrap",
                    f.style.verticalAlign = "middle",
                    f.style.padding = "2px 4px",
                    f.innerHTML = e,
                    a.appendChild(f)
                }
                if (Qb.isOpera) {
                    var g = a.cloneNode(!1);
                    g.style.left = "0px",
                    g.style.top = "0px",
                    g.style.opacity = 0,
                    a.appendChild(g)
                }
            }
            if (b.isClosable()) {
                var h = this._tabRadius / 4 + 2,
                d = this._closePool.get();
                d._closeTab = b,
                d.setAttribute("src", Jb.getImageSrc(this._closeIcon)),
                d.style.position = "absolute",
                d.style.top = h + "px",
                d.style.right = h + "px",
                a.appendChild(d)
            }
            a.style.color = b.isDisabled() ? this.getDisabledColor() : ""
        },
        onTabRendered: function(a, b) {}
    }),
    Ib.controls.TabPaneInteraction = function(a) {
        this.tabPane = a,
        this.view = a.getTabDiv();
        var b = this;
        this.view.addEventListener("mousedown",
        function(a) {
            b.handleMouseDown(a)
        },
        !1),
        this.view.addEventListener("mousemove",
        function(a) {
            b.handleMouseMove(a)
        },
        !1)
    },
    Jb.ext("twaver.controls.TabPaneInteraction", Object, {
        handleMouseDown: function(a) {
            if (0 === a.button) {
                if (this.movableDiv) return void this.handleMouseUp(a);
                this.resizeTab = a.target._resizeTab,
                this.resizeTab || (this.movableDiv = this.getMovableDivAt(a)),
                this.changeCursor(a),
                this.lastX = this.getX(a),
                this._startClient = Wb.getClientPoint(a),
                this._startLogicalX = this.lastX,
                Wb.handle_mousedown(this, a)
            }
        },
        changeCursor: function(a) {
            var b = "";
            if (a.target._resizeTab) b = "ew-resize";
            else {
                var c = this.getTabAt(a); ! c || c.isDisabled() && !c.isMovable() || (b = "pointer")
            }
            this.view.style.cursor = b
        },
        handleMouseMove: function(a) {
            if (null == this.lastX) return void this.changeCursor(a);
            if (Wb.target === this) {
                var b = this._startLogicalX + a.clientX - this._startClient.x;
                if (this.resizeTab) {
                    if (null != this.stopX) {
                        if (b < this.stopX) return;
                        delete this.stopX
                    }
                    var c = this.resizeTab.getWidth() + (b - this.lastX);
                    10 > c && (c = 10, this.stopX = b),
                    this.resizeTab.setWidth(c),
                    this.lastX = b
                } else if (this.movableDiv) {
                    var d = b - this.lastX;
                    if (!this.cloneDiv) {
                        if (Math.abs(d) < 3) return;
                        this.cloneDiv = this.movableDiv.cloneNode(!0),
                        this.cloneDiv._x = this.movableDiv._x,
                        this.cloneDiv.style.background = this.tabPane.getMoveBackground(),
                        this.insertDiv = Wb.createDiv(),
                        this.insertDiv.style.width = "1px",
                        this.insertDiv.style.height = this.cloneDiv.style.height,
                        this.insertDiv.style.background = this.tabPane.getInsertBackground(),
                        this.movableDiv.parentNode.appendChild(this.cloneDiv),
                        this.movableDiv.parentNode.appendChild(this.insertDiv)
                    }
                    var e = this.cloneDiv._x + d;
                    this.cloneDiv.style.left = e + "px",
                    this.cloneDiv._x = e,
                    this.lastX = b,
                    this.tabInfo = this.getTabInfoAt(a),
                    this.tabInfo && (this.insertDiv.style.left = this.tabInfo.position)
                }
            }
        },
        handleMouseUp: function(a) {
            if (0 === a.button) {
                if (this.resizeTab);
                else if (this.movableDiv && this.tabInfo) {
                    var b = this.movableDiv._tab,
                    c = this.tabInfo.index;
                    this.tabPane.getTabBox().moveTo(b, c)
                } else {
                    var d = this.tabPane.getTabBox(),
                    b = a.target._closeTab;
                    if (b) if (this.tabPane.isSelectNextOnClose() && this.tabPane.getCurrentTab() === b) {
                        var e = d.getRoots(),
                        c = e.indexOf(b);
                        d.remove(b),
                        e.size() > 0 && (c >= e.size() && (c = e.size() - 1), d.getSelectionModel().setSelection(e.get(c)))
                    } else d.remove(b);
                    else {
                        var b = this.getTabAt(a);
                        b && !b.isDisabled() && d.getSelectionModel().setSelection(b)
                    }
                }
                this.clear()
            }
        },
        clear: function() {
            this.view.style.cursor = "",
            this.cloneDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.cloneDiv),
            this.insertDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.insertDiv),
            delete this.movableDiv,
            delete this.tabInfo,
            delete this.insertDiv,
            delete this.cloneDiv,
            delete this.resizeTab,
            delete this.stopX,
            delete this.lastX,
            delete this._startLogicalX,
            delete this._startClient
        },
        getTabAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._tab);) a = a.parentNode;
            return b
        },
        getMovableDivAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._tab);) a = a.parentNode;
            return b && b.isMovable() ? a: null
        },
        getX: function(a) {
            var b = Wb.getLogicalPoint(this.view, a);
            return b ? b.x: null
        },
        getTabInfoAt: function(a) {
            for (var b = this._startLogicalX + a.clientX - this._startClient.x,
            c = this.tabPane.getTabBox().getRoots(), d = c.size(), e = 0, f = !1, g = 0; d > g; g++) {
                var h = c.get(g);
                if (h === this.movableDiv._tab && (f = !0), h.isVisible()) {
                    var i = h.getWidth();
                    if (0 >= i) continue;
                    if (b >= e && e + i >= b) {
                        var j = e + i / 2 > b; ! f || h === this.movableDiv._tab && j || g--;
                        var k = j ? Math.max(0, g) : Math.min(g + 1, d),
                        l = j ? e: e + i;
                        return l = Math.max(0, l - 1),
                        {
                            index: k,
                            tab: h,
                            position: l + "px"
                        }
                    }
                    e += i
                }
            }
            return this.tabInfo
        }
    }),
    Ib.controls.TabPaneTouchInteraction = function(a) {
        this.tabPane = a,
        this.view = a.getTabDiv(),
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.controls.TabPaneTouchInteraction", Object, {
        handleTouchstart: function(a) {
            return Wb.preventDefault(a),
            this.movableDiv ? void this.handleTouchend(a) : (this.resizeTab = a.target._resizeTab, this.resizeTab || (this.movableDiv = this.getMovableDivAt(a)), this.lastX = this.getX(a), Wb.addEventListener("touchmove", "handleTouchmove", this.view, this), void Wb.addEventListener("touchend", "handleTouchend", this.view, this))
        },
        handleTouchmove: function(a) {
            if (null != this.lastX) if (this.resizeTab) {
                var b = this.getX(a);
                if (null != this.stopX) {
                    if (b < this.stopX) return;
                    delete this.stopX
                }
                var c = this.resizeTab.getWidth() + (b - this.lastX);
                0 > c && (c = 0, this.stopX = b),
                this.resizeTab.setWidth(c),
                this.lastX = b
            } else if (this.movableDiv) {
                var b = this.getX(a),
                d = b - this.lastX;
                if (!this.cloneDiv) {
                    if (Math.abs(d) < 3) return;
                    this.cloneDiv = this.movableDiv.cloneNode(!0),
                    this.cloneDiv._x = this.movableDiv._x,
                    this.cloneDiv.style.background = this.tabPane.getMoveBackground(),
                    this.insertDiv = Wb.createDiv(),
                    this.insertDiv.style.width = "1px",
                    this.insertDiv.style.height = this.cloneDiv.style.height,
                    this.insertDiv.style.background = this.tabPane.getInsertBackground(),
                    this.movableDiv.parentNode.appendChild(this.cloneDiv),
                    this.movableDiv.parentNode.appendChild(this.insertDiv)
                }
                var e = this.cloneDiv._x + d;
                this.cloneDiv.style.left = e + "px",
                this.cloneDiv._x = e,
                this.lastX = b,
                this.tabInfo = this.getTabInfoAt(a),
                this.tabInfo && (this.insertDiv.style.left = this.tabInfo.position)
            }
        },
        handleTouchend: function(a) {
            if (this.resizeTab);
            else if (this.movableDiv && this.tabInfo) {
                var b = this.movableDiv._tab,
                c = this.tabInfo.index;
                this.tabPane.getTabBox().moveTo(b, c)
            } else {
                var d = this.tabPane.getTabBox(),
                b = a.target._closeTab;
                if (b) if (this.tabPane.isSelectNextOnClose() && this.tabPane.getCurrentTab() === b) {
                    var e = d.getRoots(),
                    c = e.indexOf(b);
                    d.remove(b),
                    e.size() > 0 && (c >= e.size() && (c = e.size() - 1), d.getSelectionModel().setSelection(e.get(c)))
                } else d.remove(b);
                else {
                    var b = this.getTabAt(a);
                    b && !b.isDisabled() && d.getSelectionModel().setSelection(b)
                }
            }
            this.clear(),
            Wb.removeEventListener("touchmove", this.view, this),
            Wb.removeEventListener("touchend", this.view, this)
        },
        clear: function() {
            this.cloneDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.cloneDiv),
            this.insertDiv && this.movableDiv && this.movableDiv.parentNode.removeChild(this.insertDiv),
            delete this.movableDiv,
            delete this.tabInfo,
            delete this.insertDiv,
            delete this.cloneDiv,
            delete this.resizeTab,
            delete this.stopX,
            delete this.lastX
        },
        getTabAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._tab);) a = a.parentNode;
            return b
        },
        getMovableDivAt: function(a) {
            a = a.target;
            for (var b; a && a !== this.view && !(b = a._tab);) a = a.parentNode;
            return b && b.isMovable() ? a: null
        },
        getX: function(a) {
            var b = Wb.getLogicalPoint(this.view, a);
            return b ? b.x: null
        },
        getTabInfoAt: function(a) {
            for (var b = this.getX(a), c = this.tabPane.getTabBox().getRoots(), d = c.size(), e = 0, f = !1, g = 0; d > g; g++) {
                var h = c.get(g);
                if (h === this.movableDiv._tab && (f = !0), h.isVisible()) {
                    var i = h.getWidth();
                    if (0 >= i) continue;
                    if (b >= e && e + i >= b) {
                        var j = e + i / 2 > b; ! f || h === this.movableDiv._tab && j || g--;
                        var k = j ? Math.max(0, g) : Math.min(g + 1, d),
                        l = j ? e: e + i;
                        return l = Math.max(0, l - 1),
                        {
                            index: k,
                            tab: h,
                            position: l + "px"
                        }
                    }
                    e += i
                }
            }
            return this.tabInfo
        }
    }),
    Ib.controls.TitlePane = function(a, b, c) {
        Ib.controls.TitlePane.superClass.constructor.apply(this, arguments),
        this.invalidate(),
        this._titleDiv = Wb.createDiv(),
        this._titleDiv.tabIndex = -1,
        this._titleDiv.style.verticalAlign = "middle",
        this._titleDiv.style.fontWeight = "bold",
        this._titleDiv.style.textOverflow = "ellipsis",
        this._titleDiv.style.overflow = "hidden",
        this._titleDiv.style.whiteSpace = "nowrap",
        this._titleDiv.onmousedown = Wb.preventDefault,
        this._span = Ob.createElement("span"),
        this._span.style.verticalAlign = "middle",
        this._span.style.paddingLeft = "4px",
        this._span.style.paddingRight = "4px",
        this._img = Ob.createElement("img"),
        this._img.style.verticalAlign = "middle",
        this._img.style.paddingLeft = "4px",
        this._view = Wb.createView("hidden", !0),
        this._view.tabIndex = -1,
        this._view.appendChild(this._titleDiv),
        b && this.setTitle(b),
        a && this.setContent(a),
        c && this.setIcon(c)
    },
    Jb.ext("twaver.controls.TitlePane", Ib.controls.ControlBase, {
        __accessor: ["icon", "title", "titleHeight", "titleHorizontalAlign", "titleBackground"],
        _titleHeight: Dd.TITLEPANE_TITLE_HEIGHT,
        _titleBackground: Dd.TITLEPANE_TITLE_BACKGROUND,
        _titleHorizontalAlign: Dd.TITLEPANE_TITLE_HORIZONTAL_ALIGN,
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        getTitleDiv: function() {
            return this._titleDiv
        },
        getContent: function() {
            return this._content
        },
        setContent: function(a) {
            if (this._content !== a) {
                var b = this._content;
                b && this._view.removeChild(b.getView ? b.getView() : b),
                this._content = a,
                a && this._view.appendChild(a.getView ? a.getView() : a),
                this.firePropertyChange("content", b, a)
            }
        },
        validateImpl: function() {
            var a = this._view.offsetWidth,
            b = this._view.offsetHeight,
            c = this._titleDiv.style;
            c.textAlign = this._titleHorizontalAlign,
            c.lineHeight = this._titleHeight - 2 + "px",
            c.background = this._titleBackground,
            Wb.clear(this._titleDiv),
            this._icon && (this._img.setAttribute("src", Jb.getImageSrc(this._icon)), this._titleDiv.appendChild(this._img)),
            this._title && (this._span.innerHTML = this._title, this._span.setAttribute("title", this._title), this._titleDiv.appendChild(this._span));
            var c = this._titleDiv.style;
            c.left = "0px",
            c.top = "0px",
            c.width = a + "px",
            c.height = this._titleHeight + "px",
            Jb.setViewBounds(this._content, {
                x: 0,
                y: this._titleHeight,
                width: a,
                height: Math.max(b - this._titleHeight, 0)
            })
        }
    }),
    Ib.controls.Accordion = function() {
        Ib.controls.Accordion.superClass.constructor.apply(this, arguments),
        this._titleMap = {},
        this._titleList = new nd,
        this._currentTitle = null,
        this._currentView = null,
        this._view = Wb.createView("hidden", !0),
        this.invalidate();
        var a = this;
        this._view.addEventListener("mousedown",
        function(b) {
            a.handleMouseDown(b)
        },
        !1)
    },
    Jb.ext("twaver.controls.Accordion", Ib.controls.ControlBase, {
        __accessor: ["expandIcon", "collapseIcon", "titleHeight", "titleBackground", "borderBottomColor", "iconPosition"],
        _expandIcon: Dd.ACCORDION_EXPAND_ICON,
        _collapseIcon: Dd.ACCORDION_COLLAPSE_ICON,
        _titleHeight: Dd.ACCORDION_TITLE_HEIGHT,
        _titleBackground: Dd.ACCORDION_TITLE_BACKGROUND,
        _borderBottomColor: Dd.ACCORDION_BORDER_BOTTOM_COLOR,
        _iconPosition: Dd.ACCORDION_ICON_POSITION,
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        handleMouseDown: function(a) {
            if (0 === a.button) {
                var b = a.target._title;
                b || (b = a.target.parentNode._title),
                b && (this._currentTitle === b ? this.collapse() : this.expand(b))
            }
        },
        getTitles: function() {
            return this._titleList
        },
        getCurrentTitle: function() {
            return this._currentTitle
        },
        add: function(a, b) {
            if (this._titleMap[a]) throw "Title ' + title + ' already exists";
            var c = Wb.createDiv();
            c._title = a,
            c.onmousedown = Wb.preventDefault,
            c.style.cursor = "pointer",
            c.style.textAlign = "left",
            c.style.textOverflow = "ellipsis",
            c.style.whiteSpace = "nowrap",
            c.style.overflow = "hidden",
            c.style.borderBottomWidth = "1px",
            c.style.borderBottomStyle = "solid";
            var d = Ob.createElement("img");
            d.style.verticalAlign = "middle",
            d.style.paddingLeft = "4px";
            var e = Ob.createElement("span");
            if (e.style.verticalAlign = "middle", e.style.paddingLeft = "4px", e.innerHTML = a, e.setAttribute("title", a), this._view.appendChild(c), c.appendChild(d), c.appendChild(e), "right" == this._iconPosition) {
                var f = d.style,
                g = (this._titleHeight - 8) / 2;
                f.marginTop = g + "px",
                f.right = "15px",
                f.position = "absolute"
            }
            this._titleMap[a] = {
                content: b,
                titleDiv: c,
                span: e,
                img: d
            },
            this._titleList.add(a),
            this.invalidate()
        },
        remove: function(a) {
            var b = this._titleMap[a];
            b && this._view.removeChild(b.titleDiv),
            delete this._titleMap[a],
            this._titleList.remove(a),
            this.invalidate()
        },
        clear: function() {
            var a = this;
            Object.keys(a._titleMap).forEach(function(b) {
                a._view.removeChild(a._titleMap[b].titleDiv)
            }),
            a._titleMap = {},
            a._titleList.clear(),
            a.invalidate()
        },
        expand: function(a) {
            this._titleMap[a] && this._currentTitle !== a && (this._currentTitle = a, this.onExpanded(a), this.invalidate())
        },
        onExpanded: function(a) {},
        collapse: function() {
            this._currentTitle && (this.onCollapsed(this._currentTitle), this._currentTitle = null, this.invalidate())
        },
        onCollapsed: function(a) {},
        validateImpl: function() {
            var a = this._currentView;
            this._currentView = null;
            for (var b = this._view.offsetWidth,
            c = this._view.offsetHeight,
            d = this._titleList.size(), e = 0, f = 0; d > f; f++) {
                var g = this._titleList.get(f),
                h = this._titleMap[g],
                i = h.titleDiv.style;
                i.lineHeight = this._titleHeight - 3 + "px",
                i.background = this._titleBackground,
                i.borderBottomColor = this._borderBottomColor,
                i.left = "0px",
                i.top = e + "px",
                i.width = b + "px",
                i.height = this._titleHeight - 1 + "px";
                var j = this._currentTitle === g,
                k = j ? this._expandIcon: this._collapseIcon;
                if (h.img.setAttribute("src", Jb.getImageSrc(k)), j) {
                    var l = Math.max(0, c - d * this._titleHeight);
                    h.content && (this._currentView = h.content.getView ? h.content.getView() : h.content, Jb.setViewBounds(h.content, {
                        x: 0,
                        y: e + this._titleHeight,
                        width: b,
                        height: l
                    })),
                    e += this._titleHeight + l
                } else e += this._titleHeight
            }
            this._currentView && this._currentView !== a && this._view.appendChild(this._currentView),
            a && a !== this._currentView && this._view.removeChild(a)
        }
    }),
    Ib.controls.BorderPane = function(a, b, c, d, e) {
        Ib.controls.BorderPane.superClass.constructor.apply(this, arguments),
        this.invalidate(),
        this._view = Wb.createView("hidden", !0),
        this._view.tabIndex = -1,
        a && this.setCenter(a),
        b && this.setTop(b),
        c && this.setRight(c),
        d && this.setBottom(d),
        e && this.setLeft(e)
    },
    Jb.ext("twaver.controls.BorderPane", Ib.controls.ControlBase, {
        __accessor: ["hGap", "vGap", "topHeight", "bottomHeight", "leftWidth", "rightWidth"],
        _hGap: Dd.BORDERPANE_HGAP,
        _vGap: Dd.BORDERPANE_VGAP,
        _topHeight: 0,
        _bottomHeight: 0,
        _leftWidth: 0,
        _rightWidth: 0,
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        getCenter: function() {
            return this._center
        },
        setCenter: function(a) {
            this._setContent("center", a)
        },
        getTop: function() {
            return this._top
        },
        setTop: function(a) {
            this._setContent("top", a)
        },
        getRight: function() {
            return this._right
        },
        setRight: function(a) {
            this._setContent("right", a)
        },
        getBottom: function() {
            return this._bottom
        },
        setBottom: function(a) {
            this._setContent("bottom", a)
        },
        getLeft: function() {
            return this._left
        },
        setLeft: function(a) {
            this._setContent("left", a)
        },
        _setContent: function(a, b) {
            var c = this["_" + a];
            if (c !== b) {
                if (c) {
                    var d = c.getView ? c.getView() : c;
                    this._view.contains(d) && this._view.removeChild(d)
                }
                this["_" + a] = b,
                b && this._view.appendChild(b.getView ? b.getView() : b),
                this.firePropertyChange(a, c, b)
            }
        },
        validateImpl: function() {
            var a = this._view.offsetWidth,
            b = this._view.offsetHeight,
            c = 0,
            d = 0,
            e = a,
            f = b,
            g = 0,
            h = 0,
            i = 0,
            j = 0;
            this._top && (g = this._topHeight || (this._top.getView ? this._top.getView().offsetHeight: this._top.offsetHeight), d = g + this._vGap),
            this._bottom && (h = this._bottomHeight || (this._bottom.getView ? this._bottom.getView().offsetHeight: this._bottom.offsetHeight), f = b - h - this._vGap),
            this._left && (i = this._leftWidth || (this._left.getView ? this._left.getView().offsetWidth: this._left.offsetWidth), c = i + this._hGap),
            this._right && (j = this._rightWidth || (this._right.getView ? this._right.getView().offsetWidth: this._right.offsetWidth), e = a - j - this._hGap);
            var k = Math.max(0, e - c),
            l = Math.max(0, f - d);
            this._top && Jb.setViewBounds(this._top, {
                x: 0,
                y: 0,
                width: a,
                height: g
            }),
            this._bottom && Jb.setViewBounds(this._bottom, {
                x: 0,
                y: f,
                width: a,
                height: h
            }),
            this._left && Jb.setViewBounds(this._left, {
                x: 0,
                y: d,
                width: i,
                height: l
            }),
            this._right && Jb.setViewBounds(this._right, {
                x: e,
                y: d,
                width: j,
                height: l
            }),
            this._center && Jb.setViewBounds(this._center, {
                x: c,
                y: d,
                width: k,
                height: l
            })
        }
    }),
    Ib.controls.PopupMenu = function(a) {
        this._view = Wb.createDiv(),
        this._view.style.zIndex = 100001,
        this._items = [],
        this._itemsMap = {},
        this.setContextView(a);
        var b = this._view,
        c = this;
        b.addEventListener("mouseover",
        function(a) {
            c._mouseOver = !0
        },
        !1),
        b.addEventListener("mouseout",
        function(a) {
            c._mouseOver = !1
        },
        !1),
        b.oncontextmenu = function(a) {
            a.preventDefault()
        },
        Wb.addEventListener("mousedown", "_handleClick", b, this)
    },
    Jb.ext("twaver.controls.PopupMenu", Object, {
        _width: 200,
        _menuItemHeight: 25,
        _background: "#F9F9F9",
        _border: "2px outset white",
        _disabledColor: "#BABBBC",
        _focusColor: "white",
        _focusBackground: "#C2CFF1",
        _color: "black",
        _subMenuEnableIcon: Dd.POPUPMENU_SUBNENU_ENABLE_ICON,
        _subMenuDisableIcon: Dd.POPUPMENU_SUBNENU_DISABLE_ICON,
        _checkboxSelectedIcon: Dd.POPUPMENU_CHECKBOX_SELECTED_ICON,
        _checkboxUnselectedIcon: Dd.POPUPMENU_CHECKBOX_UNSELECTED_ICON,
        _radiobuttonSelectedIcon: Dd.POPUPMENU_RADIOBUTTON_SELECTED_ICON,
        _radiobuttonUnselectedIcon: Dd.POPUPMENU_RADIOBUTTON_UNSELECTED_ICON,
        getView: function() {
            return this._view
        },
        getContextView: function() {
            return this._contextView
        },
        setContextView: function(a) {
            if (this._removeContextmenuListener(), this._contextView = a, a) {
                var b = a.getView ? a.getView() : a;
                Qb.isTouchable ? (b.addEventListener("touchstart", this._getTouchStartListener(), !1), b.addEventListener("touchmove", this._getTouchMoveListener(), !1), b.addEventListener("touchend", this._getTouchEndListener(), !1)) : Wb.addEventListener("contextmenu", "_handleContextmenu", b, this)
            }
        },
        getMenuItems: function() {
            return this._items
        },
        setMenuItems: function(a) {
            if (this._items = [], this._itemsMap = {},
            a) for (var b = 0,
            c = a.length; c > b; b++) this.addMenuItem(a[b])
        },
        addMenuItem: function(a) {
            a.separator !== !0 && (this._itemsMap[a.id || a.label] = a),
            this._items.push(a)
        },
        getMenuItem: function(a) {
            return this._itemsMap[a]
        },
        addSeparator: function() {
            this.addMenuItem({
                separator: !0
            })
        },
        getMenuItemById: function(a) {
            return this._itemsMap[a]
        },
        isVisible: function(a) {
            return a.visible !== !1
        },
        isEnabled: function(a) {
            return a.enabled !== !1
        },
        show: function(a) {
            this.hide();
            var b, c, d = this._view,
            e = this._view.style;
            if (Qb.isTouchable ? (b = a.changedTouches[0].clientX, c = a.changedTouches[0].clientY) : (b = a.clientX, c = a.clientY), Wb.clear(d), this.renderMenu(d, this._items), 0 !== this._height) {
                Wb.addEventListener(Qb.isTouchable ? "touchstart": "mousedown", "_handleBodyClicked", Ob.body, this);
                var f = Wb.windowWidth() - this._width - 10,
                g = Wb.windowHeight() - this._height - 10;
                b = b > f ? f: b,
                c = c > g ? g: c,
                b = 0 > b ? 0 : b,
                c = 0 > c ? 0 : c,
                e.left = b + zc.scrollLeft() + "px",
                e.top = c + zc.scrollTop() + "px",
                Ob.body.appendChild(d)
            }
        },
        _showMenuItem: function(a, b) {
            this._hideMenuItem(b);
            var c = Ob.createElement("div");
            b.menuItem.childrenDiv = c;
            var d = c.style;
            d.color = "#000000",
            d.position = "absolute";
            var e = this._width,
            f = b.offsetTop,
            g = b.menuItem.items;
            if (this._itemsShow = !0, b.appendChild(c), Wb.clear(c), this.renderMenu(c, g), 0 !== this._height) {
                var h = Wb.windowWidth() - this._width - 10,
                i = Wb.windowHeight() - 10,
                j = this._getPosition(this._view);
                e = j.left + this._width > h ? -this._width: e,
                f = j.top + f + g.length * this._menuItemHeight > i ? f - (g.length - 1) * this._menuItemHeight: f,
                d.left = e + "px",
                d.top = f + "px",
                b.appendChild(c)
            }
        },
        hide: function() {
            Ob.body.contains(this._view) && Ob.body.removeChild(this._view),
            delete this._mouseOver,
            delete this._itemsShow,
            Wb.removeEventListener(Qb.isTouchable ? "touchstart": "mousedown", Ob.body, this)
        },
        _hideMenuItem: function(a) {
            var b = a.menuItem.childrenDiv;
            b && a.contains(b) && a.removeChild(b),
            this._itemsShow = !1
        },
        dispose: function() {
            this._removeContextmenuListener(),
            this.hide()
        },
        onMenuShowing: function(a) {
            return ! 0
        },
        onAction: function(a) {},
        renderMenu: function(a, b) {
            var c = a.style;
            c.background = this._background,
            c.border = this._border,
            c.width = this._width + "px",
            this._height = 0,
            delete this._separator;
            for (var d, e = 0,
            f = b.length; f > e; e++) if (d = b[e], this.isVisible(d)) if (d.separator === !0) this._separator = !0;
            else {
                var g = Ob.createElement("div");
                this.isEnabled(d) && this._addMouseoverListener(g, d),
                g.menuItem = d,
                a.appendChild(g),
                this.renderMenuItem(g, d),
                this.onMenuItemRendered(g, d),
                this._separator = !1,
                this._height += this._menuItemHeight
            }
        },
        renderMenuItem: function(a, b) {
            var c = a.style;
            c.height = this._menuItemHeight + "px",
            this._separator && (c.borderTop = "1px solid gray"),
            this.isEnabled(b) || (c.color = this._disabledColor);
            var d = Ob.createElement("span");
            c = d.style,
            c.position = "absolute",
            c.width = "25px",
            c.height = this._menuItemHeight + "px",
            c.lineHeight = this._menuItemHeight + "px",
            c.textAlign = "center",
            a.appendChild(d);
            var e;
            if ("check" === b.type ? e = b.selected ? this._checkboxSelectedIcon: this._checkboxUnselectedIcon: "radio" === b.type ? e = b.selected ? this._radiobuttonSelectedIcon: this._radiobuttonUnselectedIcon: b.icon && (e = b.icon), e) {
                var f = new Pb;
                f.src = Jb.getImageSrc(e),
                f.style.verticalAlign = "middle",
                d.appendChild(f)
            }
            var g = Ob.createElement("label");
            if (Jb.setText(g, b.label, !0), c = g.style, c.position = "absolute", c.height = this._menuItemHeight + "px", c.lineHeight = this._menuItemHeight + "px", c.left = "25px", a.appendChild(g), b.items && a.parentNode === this._view) {
                var h = Ob.createElement("img");
                c = h.style,
                this.isEnabled(b) ? h.setAttribute("src", Jb.getImageSrc(this._subMenuEnableIcon)) : h.setAttribute("src", Jb.getImageSrc(this._subMenuDisableIcon));
                var i = (this._menuItemHeight - 8) / 2;
                c.marginTop = i + "px",
                c.right = "5px",
                c.position = "absolute",
                a.appendChild(h)
            }
        },
        onMenuItemRendered: function(a, b) {},
        _addMouseoverListener: function(a, b) {
            var c = this;
            a.addEventListener(Qb.isTouchable ? "touchstart": "mouseover",
            function(d) {
                a.style.background = c._focusBackground,
                a.style.color = c._focusColor,
                this === d.relatedTarget || this.contains(d.relatedTarget) || b.items && !c._itemsShow && a.parentNode == c._view && c._showMenuItem(d, a)
            },
            !1),
            a.addEventListener(Qb.isTouchable ? "touchend": "mouseout",
            function(d) {
                if (a.style.background = c._background, a.style.color = c._color, this !== d.relatedTarget && !this.contains(d.relatedTarget) && b.items && a.parentNode === c._view) {
                    var e = d.clientX,
                    f = d.clientY,
                    g = b.childrenDiv,
                    h = c._getPosition(g); (e < h.left + 2 || e > h.left + g.offsetWidth - 2 || f < h.top + 2 || f > h.top + g.offsetHeight - 2) && c._hideMenuItem(a)
                }
            },
            !1)
        },
        _getPosition: function(a) {
            for (var b = 0,
            c = 0; a;) c += a.offsetLeft,
            b += a.offsetTop,
            a = a.offsetParent;
            return {
                left: c,
                top: b
            }
        },
        _removeContextmenuListener: function() {
            var a = this._contextView;
            a && (a = a.getView ? a.getView() : a, Qb.isTouchable ? (a.removeEventListener("touchstart", this._getTouchStartListener(), !1), a.removeEventListener("touchmove", this._getTouchMoveListener(), !1), a.removeEventListener("touchend", this._getTouchEndListener(), !1)) : Wb.removeEventListener("contextmenu", a, this))
        },
        _handleContextmenu: function(a) {
            this.onMenuShowing(a) === !0 && this.show(a),
            a.preventDefault()
        },
        _handleBodyClicked: function(a) {
            if (Qb.isTouchable) {
                for (var b = a.target; b && b !== this._view;) b = b.parentElement;
                b !== this._view && this.hide()
            } else this._mouseOver || this.hide()
        },
        _handleClick: function(a) {
            if (0 === a.button) {
                for (var b = a.target; ! b.menuItem && b.parentElement;) b = b.parentElement;
                var c = b ? b.menuItem: null;
                c && this.isEnabled(c) && ("check" === c.type && (c.selected = !c.selected), "radio" === c.type && (c.groupName ? (c.selected = !0, this._items.forEach(function(a) {
                    c !== a && a.groupName === c.groupName && (a.selected = !1),
                    a.items && a.items.forEach(function(a) {
                        c !== a && a.groupName === c.groupName && (a.selected = !1)
                    })
                })) : c.selected = !c.selected), c.action && c.action(c), this.onAction(c), c.items && c.items.length > 0 || this.hide())
            }
        },
        _getTouchStartListener: function() {
            if (!this._touchStartListener) {
                var a = this;
                this._touchStartListener = function(b) {
                    a._touchMoved = !1,
                    a._lastTouch = new Date
                }
            }
            return this._touchStartListener
        },
        _getTouchMoveListener: function() {
            if (!this._touchMoveListener) {
                var a = this;
                this._touchMoveListener = function(b) {
                    a._touchMoved = !0
                }
            }
            return this._touchMoveListener
        },
        _getTouchEndListener: function() {
            if (!this._touchEndListener) {
                var a = this;
                this._touchEndListener = function(b) { ! a._touchMoved && (new Date).getTime() - a._lastTouch.getTime() > 1e3 && a._handleContextmenu(b)
                }
            }
            return this._touchEndListener
        },
        getWidth: function() {
            return this._width
        },
        setWidth: function(a) {
            this._width = a
        },
        getMenuItemHeight: function() {
            return this._menuItemHeight
        },
        setMenuItemHeight: function(a) {
            this._menuItemHeight = a
        },
        getBackground: function() {
            return this._background
        },
        setBackground: function(a) {
            this._background = a
        },
        getBorder: function() {
            return this._border
        },
        setBorder: function(a) {
            this._border = a
        },
        getDisabledColor: function() {
            return this._disabledColor
        },
        setDisabledColor: function(a) {
            this._disabledColor = a
        },
        getFocusColor: function() {
            return this._focusColor
        },
        setFocusColor: function(a) {
            this._focusColor = a
        },
        getFocusBackground: function() {
            return this._focusBackground
        },
        setFocusBackground: function(a) {
            this._focusBackground = a
        },
        getColor: function() {
            return this._color
        },
        setColor: function(a) {
            this._color = a
        },
        getSubMenuEnableIcon: function() {
            return this._subMenuEnableIcon
        },
        setSubMenuEnableIcon: function(a) {
            this._subMenuEnableIcon = a
        },
        getSubMenuDisableIcon: function() {
            return this._subMenuDisableIcon
        },
        setSubMenuDisableIcon: function(a) {
            this._subMenuDisableIcon = a
        },
        getCheckboxSelectedIcon: function() {
            return this._checkboxSelectedIcon
        },
        setCheckboxSelectedIcon: function(a) {
            this._checkboxSelectedIcon = a
        },
        getCheckboxUnselectedIcon: function() {
            return this._checkboxUnselectedIcon
        },
        setCheckboxUnselectedIcon: function(a) {
            this._checkboxUnselectedIcon = a
        },
        getRadiobuttonSelectedIcon: function() {
            return this._radiobuttonSelectedIcon
        },
        setRadiobuttonSelectedIcon: function(a) {
            this._radiobuttonSelectedIcon = a
        },
        getRadiobuttonUnselectedIcon: function() {
            return this._radiobuttonUnselectedIcon
        },
        setRadiobuttonUnselectedIcon: function(a) {
            this._radiobuttonUnselectedIcon = a
        }
    }),
    Ib.charts.IS_INVALIDATE_PROPERTY = {
        xZoom: 1,
        xTranslate: 1,
        yZoom: 1,
        yTranslate: 1
    },
    Ib.charts.ChartBase = function(a) {
        Ib.charts.ChartBase.superClass.constructor.apply(this, arguments),
        this._uniqueColors = {},
        this._nonDataColors = {},
        this._publishedDatas = new nd,
        this._view = Wb.createView("hidden"),
        this._canvas = Wb.createCanvas(),
        this._view.appendChild(this._canvas),
        this.setDataBox(a ? a: new Ib.ElementBox),
        this.invalidate();
        var b;
        b = Qb.isMSToucheable ? Ib.charts.ChartMSTouchInteraction: Qb.isTouchable ? Ib.charts.ChartTouchInteraction: Ib.charts.ChartInteraction,
        b && new b(this),
        this.setToolTipEnabled(Dd.CHART_TOOLTIP_ENABLED)
    },
    Jb.ext("twaver.charts.ChartBase", Ib.controls.ViewBase, {
        __accessor: ["xGap", "yGap", "xTranslate", "yTranslate", "valueVisible", "sortFunction", "visibleFunction", "xTranslateEnabled", "yTranslateEnabled", "xZoomEnabled", "yZoomEnabled", "selectTolerance", "backgroundVisible", "backgroundFill", "backgroundFillColor", "backgroundOutlineWidth", "backgroundOutlineColor", "backgroundGradient", "backgroundGradientColor", "outerZoom"],
        __bool: ["doubleClickToReset", "focusOnClick"],
        _backgroundVisible: Dd.CHART_BACKGROUND_VISIBLE,
        _backgroundFill: Dd.CHART_BACKGROUND_FILL,
        _backgroundFillColor: Dd.CHART_BACKGROUND_FILL_COLOR,
        _backgroundOutlineWidth: Dd.CHART_BACKGROUND_OUTLINE_WIDTH,
        _backgroundOutlineColor: Dd.CHART_BACKGROUND_OUTLINE_COLOR,
        _backgroundGradient: Dd.CHART_BACKGROUND_GRADIENT,
        _backgroundGradientColor: Dd.CHART_BACKGROUND_GRADIENT_COLOR,
        _selectTolerance: Dd.CHART_SELECT_TOLERANCE,
        _doubleClickToReset: Dd.CHART_DOUBLE_CLICK_TO_RESET,
        _focusOnClick: Dd.FOCUS_ON_CLICK,
        _sortFunction: null,
        _visibleFunction: null,
        _canvasWidth: 0,
        _canvasHeight: 0,
        _outerZoomL: 1,
        _xGap: Dd.CHART_XGAP,
        _yGap: Dd.CHART_YGAP,
        _xTranslate: 0,
        _yTranslate: 0,
        _xTranslateEnabled: Dd.CHART_XTRANSLATE_ENABLED,
        _yTranslateEnabled: Dd.CHART_YTRANSLATE_ENABLED,
        _xZoom: 1,
        _yZoom: 1,
        _maxZoom: Dd.ZOOM_MAX,
        _minZoom: Dd.ZOOM_MIN,
        _xZoomEnabled: Dd.CHART_XZOOM_ENABLED,
        _yZoomEnabled: Dd.CHART_YZOOM_ENABLED,
        _valueVisible: Dd.CHART_VALUE_VISIBLE,
        _valueFont: Dd.CHART_VALUE_FONT,
        isToolTipEnabled: function() {
            return this._toolTipListener ? !0 : !1
        },
        setToolTipEnabled: function(a) {
            if (a) {
                if (!this._toolTipListener) {
                    var b = this;
                    this._toolTipListener = function(a) {
                        Bc.showToolTip(a, b.getToolTip(a))
                    },
                    this._canvas.addEventListener("mousemove", this._toolTipListener, !0),
                    this.firePropertyChange("toolTipEnabled", !1, !0)
                }
            } else this._toolTipListener && (Bc.hideToolTip(), this._canvas.removeEventListener("mousemove", this._toolTipListener, !0), delete this._toolTipListener, this.firePropertyChange("toolTipEnabled", !0, !1))
        },
        getToolTip: function(a) {
            if (this._toolTipInfos) {
                var b = this.getLogicalPoint(a);
                b.x -= this._xTranslate,
                b.y -= this._yTranslate;
                for (var c = this._toolTipInfos.size(), d = c - 1; d >= 0; d--) {
                    var e = this._toolTipInfos.get(d);
                    if (e.rect && Tb.containsPoint(e.rect, b)) return this.getToolTipByData(e.data, e)
                }
            } else {
                var f = this.tryGetDataAt(a);
                if (f) return this.getToolTipByData(f, {
                    value: this.getValue(f)
                })
            }
            return null
        },
        getToolTipByData: function(a, c) {
            return c.value !== b ? this.formatValueText(c.value, a) : null
        },
        addToolTipInfo: function(a, b, c, d, e, f, g) {
            this._toolTipInfos && this._toolTipInfos.add({
                data: f,
                rect: {
                    x: a,
                    y: b,
                    width: c,
                    height: d
                },
                value: e,
                index: g
            })
        },
        getLogicalPoint: function(a) {
            return Wb.getLogicalPoint(this._canvas, a, this._outerZoom)
        },
        getTextSize: function(a, b) {
            var c = Xb.getTextSize(a, b);
            return c.width && (c.width += 4),
            c
        },
        getUniqueColor: function(a, c) {
            if (null == a) return null;
            var d;
            if (!c && (d = this._nonDataColors[a])) return d;
            var e = Xb.getColorArray(a);
            if (!c) return d = 255 != e[3] ? a: "rgba(" + e[0] + "," + e[1] + "," + e[2] + ",0.99)",
            this._nonDataColors[a] = d,
            d;
            var f = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")";
            if (this._uniqueColors[f] === b || this._uniqueColors[f] === c);
            else {
                var g = 1,
                h = -1,
                i = 1;
                for (Qb.isOpera && (e = [e[0], e[1], e[2]]); e[0] += g, e[0] >= 255 ? (e[0] = 255, g = -1) : e[0] <= 0 && (e[0] = 0, g = 1), f = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", this._uniqueColors[f] !== b && this._uniqueColors[f] !== c && (e[1] += h, e[1] >= 255 ? (e[1] = 255, h = -1) : e[1] <= 0 && (e[1] = 0, h = 1), f = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", this._uniqueColors[f] !== b && this._uniqueColors[f] !== c) && (e[2] += i, e[2] >= 255 ? (e[2] = 255, i = -1) : e[2] <= 0 && (e[2] = 0, i = 1), f = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", this._uniqueColors[f] !== b && this._uniqueColors[f] !== c););
            }
            return this._uniqueColors[f] = c,
            f
        },
        tryGetDataAt: function(a, b) {
            if ((null == b || 0 > b) && (b = this._selectTolerance), a.target && (a = Wb.getLogicalPoint(this._canvas, arguments[0], this._outerZoom)), !a) return null;
            var c = a.x - b,
            d = a.y - b,
            e = 2 * b + 1,
            f = 2 * b + 1;
            try {
                for (var g = this._canvas.getContext("2d").getImageData(c, d, e, f).data, h = 0, i = g.length; i > h; h += 4) if (255 === g[h + 3]) {
                    var j = "rgb(" + g[h] + "," + g[h + 1] + "," + g[h + 2] + ")",
                    k = this._uniqueColors[j];
                    if (k) return k
                }
            } catch(l) {}
            return null
        },
        _getPoint: function() {
            var a, b;
            if (2 === arguments.length) a = arguments[0],
            b = arguments[1];
            else if (arguments[0].target) {
                var c = Wb.getLogicalPoint(this._canvas, arguments[0], this._outerZoom);
                if (!c) return null;
                a = c.x,
                b = c.y
            } else a = arguments[0].x,
            b = arguments[0].y;
            return {
                x: a,
                y: b
            }
        },
        getDataAt: function() {
            var a = this._getPoint.apply(this, arguments),
            b = a.x,
            c = a.y;
            if (0 > b || 0 > c || b > this._canvasWidth || c > this._canvasHeight) return null;
            try {
                var d = this._canvas.getContext("2d").getImageData(b, c, 1, 1).data;
                if (255 === d[3]) {
                    var e = "rgb(" + d[0] + "," + d[1] + "," + d[2] + ")",
                    f = this._uniqueColors[e];
                    if (f) return f
                }
            } catch(g) {}
            return null
        },
        getBackgroundRect: function() {
            return this._backgroundRect
        },
        drawBackground: function(a, b) {
            this._backgroundRect = Jb.clone(b),
            null != b && b.width > 0 && b.height > 0 && this._backgroundVisible && (this._backgroundFill && Xb.fill(a, this.getUniqueColor(this._backgroundFillColor), this._backgroundGradient, this.getUniqueColor(this._backgroundGradientColor), b), this._backgroundOutlineWidth > 0 && (a.lineWidth = this._backgroundOutlineWidth, a.strokeStyle = this._backgroundOutlineColor), a.beginPath(), a.rect(b.x, b.y, b.width, b.height), a.closePath(), this._backgroundFill && a.fill(), this._backgroundOutlineWidth > 0 && a.stroke())
        },
        getName: function(a) {
            return a.getName()
        },
        getColor: function(a) {
            return a.getStyle ? a.getStyle("chart.color") : a.getClient("chart.color")
        },
        getValue: function(a) {
            return a.getStyle ? a.getStyle("chart.value") : 0
        },
        getValueColor: function(a) {
            return a.getStyle ? a.getStyle("chart.value.color") : Ib.Styles.getStyle("chart.value.color")
        },
        setValueFont: function(a) {
            if (a !== this._valueFont) {
                var b = a;
                this._valueFont = a,
                this.firePropertyChange("valueFont", b, a)
            }
        },
        getValueFont: function(a) {
            if (a) {
                var b = a.getStyle ? a.getStyle("chart.value.font") : Ib.Styles.getStyle("chart.value.font");
                if (b) return b
            }
            return this._valueFont
        },
        formatValueText: function(a, b) {
            return a
        },
        getCanvasWidth: function() {
            return this._canvasWidth
        },
        getCanvasHeight: function() {
            return this.canvasHeight
        },
        getCanvas: function() {
            return this._canvas
        },
        isVisible: function(a) {
            return this._internalVisibleFunction && !this._internalVisibleFunction(a) ? !1 : this._visibleFunction ? this._visibleFunction(a) : !0
        },
        onPropertyChanged: function(a) {
            Ib.charts.IS_INVALIDATE_PROPERTY[a.property] ? this.invalidate() : this.invalidateModel()
        },
        getDataBox: function() {
            return this._box
        },
        setDataBox: function(a) {
            if (!a) throw "DataBox can not be null";
            if (this._box !== a) {
                var b = this._box;
                b && (b.removeDataBoxChangeListener(this.handleDataBoxChange, this), b.removeDataPropertyChangeListener(this.handlePropertyChange, this), b.removeHierarchyChangeListener(this.handleHierarchyChange, this), this._selectionModel || b.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this)),
                this._box = a,
                this._box.addDataBoxChangeListener(this.handleDataBoxChange, this),
                this._box.addDataPropertyChangeListener(this.handlePropertyChange, this),
                this._box.addHierarchyChangeListener(this.handleHierarchyChange, this),
                this._selectionModel ? this._selectionModel._setDataBox(a) : this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
                this.invalidateModel(),
                this.firePropertyChange("dataBox", b, this._box)
            }
        },
        handleDataBoxChange: function(a) {
            this.invalidateModel()
        },
        handlePropertyChange: function(a) {
            this.invalidateModel()
        },
        handleHierarchyChange: function(a) {
            this.invalidateModel()
        },
        handleSelectionChange: function(a) {
            this.invalidateModel()
        },
        getUnfilteredDatas: function() {
            return this._unfilteredDatas ? this._unfilteredDatas: this._publishedDatas
        },
        getPublishedDatas: function() {
            return this._publishedDatas
        },
        createPublishedDatas: function() {
            return this._unfilteredDatas = new nd,
            this._buildChildren(this._box.getRoots(), this._unfilteredDatas),
            this._sortFunction && this._unfilteredDatas.sort(this._sortFunction),
            this._unfilteredDatas.toList(this.isVisible, this)
        },
        _buildChildren: function(a, b) {
            a.forEach(function(a) {
                b.add(a),
                this._buildChildren(a.getChildren(), b)
            },
            this)
        },
        invalidateModel: function() {
            this._invalidateModel || (this._invalidateModel = !0, this.invalidate())
        },
        validateImpl: function() {
            this._invalidateModel && (this._invalidateModel = !1, this._uniqueColors = {},
            this._nonDataColors = {},
            this._publishedDatas = this.createPublishedDatas(), this._publishedDatas.forEach(function(a) {
                a.IStyle ? a.getStyle("chart.color") || a.setStyle("chart.color", Jb.nextColor()) : a.getClient("chart.color") || a.setClient("chart.color", Jb.nextColor())
            }), this.validateModel());
            var a = this._canvas.getContext("2d");
            this._canvasWidth = this._view.clientWidth,
            this._canvasHeight = this._view.clientHeight,
            this._canvas.setAttribute("width", this._canvasWidth),
            this._canvas.setAttribute("height", this._canvasHeight),
            a.clearRect(0, 0, this._canvasWidth, this._canvasHeight),
            this._canvasWidth > 0 && this._canvasHeight > 0 && (a.translate(this._xTranslate, this._yTranslate), this._valueTexts = this._valueVisible ? new nd: null, this.validateDisplay(a, this._canvasWidth * this._xZoom, this._canvasHeight * this._yZoom), delete this._valueTexts, a.translate( - this._xTranslate, -this._yTranslate))
        },
        validateModel: function() {},
        validateDisplay: function(a, b, c) {},
        drawLine: function(a, b, c, d, e, f, g) {
            c > 0 && (a.lineWidth = c, a.strokeStyle = this.getUniqueColor(b), a.beginPath(), a.moveTo(d, e), a.lineTo(f, g), a.stroke())
        },
        drawValueTexts: function(a) {
            this._valueTexts && this._valueTexts.forEach(function(b) {
                Xb.drawText(a, b.text, b, b.font, b.color)
            })
        },
        drawVerticalText: function(a, b, c, d, e) {
            e = this.getUniqueColor(e),
            a.translate(c.x, c.y),
            a.rotate( - Math.PI / 2),
            Xb.drawText(a, b, null, d, e),
            a.rotate(Math.PI / 2),
            a.translate( - c.x, -c.y)
        },
        _getValueTextInfo: function(a, b) {
            if (this._valueTexts) {
                var c = this.formatValueText(b, a);
                if (c && "" !== c) {
                    var d = this.getValueColor(a),
                    e = {
                        text: c,
                        font: this.getValueFont(a),
                        color: this.getUniqueColor(d, a)
                    };
                    return this._valueTexts.add(e),
                    e
                }
            }
            return null
        },
        getMaxZoom: function() {
            return this._maxZoom
        },
        setMaxZoom: function(a) {
            if (! (0 > a)) {
                var b = this._maxZoom;
                this._maxZoom = a,
                this.firePropertyChange("maxZoom", b, a),
                this.getXZoom() > a && this.setXZoom(a, !1),
                this.getYZoom() > a && this.setYZoom(a, !1)
            }
        },
        getMinZoom: function() {
            return this._minZoom
        },
        setMinZoom: function(a) {
            if (! (0 > a)) {
                var b = this._minZoom;
                this._minZoom = a,
                this.firePropertyChange("minZoom", b, a),
                this.getXZoom() < a && this.setXZoom(a),
                this.getYZoom() < a && this.setYZoom(a)
            }
        },
        zoomIn: function(a) {
            null == a && (a = Dd.ZOOM_ANIMATE),
            a ? Ib.animate.AnimateManager.start(new Ib.animate.AnimateXYZoom(this, this._xZoom * Dd.ZOOM_INCREMENT, this._yZoom * Dd.ZOOM_INCREMENT)) : (this.xZoomIn(!1), this.yZoomIn(!1))
        },
        zoomOut: function(a) {
            null == a && (a = Dd.ZOOM_ANIMATE),
            a ? Ib.animate.AnimateManager.start(new Ib.animate.AnimateXYZoom(this, this._xZoom / Dd.ZOOM_INCREMENT, this._yZoom / Dd.ZOOM_INCREMENT)) : (this.xZoomOut(!1), this.yZoomOut(!1))
        },
        zoomReset: function(a) {
            null == a && (a = Dd.ZOOM_ANIMATE),
            a ? Ib.animate.AnimateManager.start(new Ib.animate.AnimateXYZoom(this, 1, 1)) : (this.xZoomReset(!1), this.yZoomReset(!1))
        },
        getXZoom: function() {
            return this._xZoom
        },
        onXZoomChanged: function(a, b) {},
        xZoomIn: function(a) {
            this.setXZoom(this._xZoom * Dd.ZOOM_INCREMENT, a)
        },
        xZoomOut: function(a) {
            this.setXZoom(this._xZoom / Dd.ZOOM_INCREMENT, a)
        },
        xZoomReset: function(a) {
            this.setXZoom(1, a)
        },
        setXZoom: function(a, b) {
            if (Jb.num(a) && !(0 >= a) && (a < this._minZoom && (a = this._minZoom), a > this._maxZoom && (a = this._maxZoom), a !== this.xZoom)) if (null == b && (b = Dd.ZOOM_ANIMATE), b) Ib.animate.AnimateManager.start(new Ib.animate.AnimateXZoom(this, a));
            else {
                var c = this._xZoom,
                d = this._xTranslate - (this._canvasWidth / 2 - this._xTranslate) / c * (a - c);
                this._xZoom = a,
                this.firePropertyChange("xZoom", c, a),
                this.onXZoomChanged(c, a),
                this.setXTranslate(d)
            }
        },
        getYZoom: function() {
            return this._yZoom
        },
        onYZoomChanged: function(a, b) {},
        yZoomIn: function(a) {
            this.setYZoom(this._yZoom * Dd.ZOOM_INCREMENT, a)
        },
        yZoomOut: function(a) {
            this.setYZoom(this._yZoom / Dd.ZOOM_INCREMENT, a)
        },
        yZoomReset: function(a) {
            this.setYZoom(1, a)
        },
        setYZoom: function(a, b) {
            if (Jb.num(a) && !(0 >= a) && (a < this._minZoom && (a = this._minZoom), a > this._maxZoom && (a = this._maxZoom), a !== this.YZoom)) if (null == b && (b = Dd.ZOOM_ANIMATE), b) Ib.animate.AnimateManager.start(new Ib.animate.AnimateYZoom(this, a));
            else {
                var c = this._yZoom,
                d = this._yTranslate - (this._canvasHeight / 2 - this._yTranslate) / c * (a - c);
                this._yZoom = a,
                this.firePropertyChange("yZoom", c, a),
                this.onYZoomChanged(c, a),
                this.setYTranslate(d)
            }
        }
    }),
    Ib.charts.ScaleChart = function(a) {
        Ib.charts.ScaleChart.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.charts.ScaleChart", Ib.charts.ChartBase, {
        __accessor: ["upperLimit", "lowerLimit", "xAxisText", "xAxisLineColor", "xAxisLineWidth", "xAxisTextColor", "xAxisTextFont", "yAxisText", "yAxisLineColor", "yAxisLineWidth", "yAxisTextColor", "yAxisTextFont", "xScaleTexts", "xScaleTextFont", "xScaleTextColor", "xScaleTextOrientation", "yScaleTextVisible", "yScaleTextColor", "yScaleTextFont", "yScaleLineColor", "yScaleLineWidth", "yScaleValueGap", "yScalePixelGap", "yScaleMinTextVisible", "valueSpanCount"],
        _reset: function() {
            this._map = {},
            this._max = 0,
            this._min = 0,
            this._columnCount = this._xScaleTexts ? this._xScaleTexts.size() : 0,
            null != this._upperLimit && (this._max = this._upperLimit),
            null != this._lowerLimit && (this._min = this._lowerLimit)
        },
        getMin: function() {
            return this._min
        },
        getMax: function() {
            return this._max
        },
        getRange: function() {
            return this._range
        },
        getColumnCount: function() {
            return this._columnCount
        },
        getColumnWidth: function() {
            return this._columnWidth
        },
        getValues: function(a) {
            return a.getStyle ? a.getStyle("chart.values") : null
        },
        formatYScaleText: function(a) {
            return a.toFixed(2)
        },
        _initRange: function() {
            null == this._lowerLimit && (this._min >= this._max && (this._min = this._max - .1 * Math.abs(this._max)), this._min = this._min - .1 * (this._max - this._min)),
            this._range = this._max - this._min
        },
        _initValuesProportion: function() {
            this._publishedDatas.forEach(function(a) {
                var b = this._map[a.getId()];
                b.values.forEach(function(a) {
                    b.proportions.add(null == a ? null: 0 == this._range ? 0 : a / this._range)
                },
                this)
            },
            this)
        },
        _commonValidateModel: function() {
            this._publishedDatas.forEach(function(a) {
                var b = new nd(this.getValues(a));
                b.size() > this._columnCount && (this._columnCount = b.size());
                var c = {
                    data: a,
                    values: b,
                    proportions: new nd,
                    color: this.getUniqueColor(this.getColor(a), a)
                };
                this._initInfo && this._initInfo(a, c),
                this._map[a.getId()] = c,
                (null == this._upperLimit || null == this._lowerLimit) && b.forEach(function(a) {
                    null != a && (null == this._upperLimit && a > this._max && (this._max = a), null == this._lowerLimit && a < this._min && (this._min = a))
                },
                this)
            },
            this),
            this._initRange(),
            this._initValuesProportion()
        },
        validateDisplay: function(a, b, c) {
            var d = 0;
            this._xAxisText && (d = this.getTextSize(this._xAxisTextFont, this._xAxisText).height);
            var e = 0;
            this._xScaleTexts && this._xScaleTexts.forEach(function(a) {
                var b = this.getTextSize(this._xScaleTextFont, a),
                c = "vertical" === this._xScaleTextOrientation ? b.width: b.height;
                c > e && (e = c)
            },
            this);
            var f = c - this._yGap - d - e,
            g = f - this._yGap,
            h = null == this._upperLimit ? .9 * g: g,
            i = 0;
            this._yAxisText && (i = this.getTextSize(this._yAxisTextFont, this._yAxisText).height);
            var j, k;
            this._yScaleValueGap > 0 ? (j = Math.max(this._yScaleValueGap / this._range * h, 1), k = this._yScaleValueGap) : (j = Math.max(this._yScalePixelGap, 1), k = this._range * (j / h));
            var l, m, n = 0,
            o = new nd;
            if (this._yScaleTextVisible) {
                l = this._yScaleMinTextVisible ? 0 : j;
                for (var p = this._min + (this._yScaleMinTextVisible ? 0 : k); g + 1 >= l;) {
                    if (m = this.formatYScaleText(p)) {
                        var q = this.getTextSize(this._yScaleTextFont, m);
                        q.width > n && (n = q.width),
                        o.add({
                            text: m,
                            size: q,
                            cursor: l
                        })
                    }
                    l += j,
                    p += k
                }
            }
            var r = {
                x: this._xGap + i + n,
                y: this._yGap,
                width: b - this._xGap - i - n - this._xGap,
                height: c - this._yGap - e - d - this._yGap
            };
            if (this.drawBackground(a, r), this._columnWidth = this._columnCount > 0 ? r.width / (3 * this._columnCount + 1) * 2 : r.width / 2, 0 === this._columnWidth && (this._columnWidth = 1), this._yScaleLineWidth > 0) for (l = 0; g + 1 >= l;) this.drawLine(a, this._yScaleLineColor, this._yScaleLineWidth, r.x, f - l, r.x + r.width, f - l),
            l += j;
            this._xAxisText && Xb.drawText(a, this._xAxisText, {
                x: r.x + r.width / 2,
                y: f + e + d / 2
            },
            this._xAxisTextFont, this.getUniqueColor(this._xAxisTextColor)),
            this._yAxisText && this.drawVerticalText(a, this._yAxisText, {
                x: this._xGap + i / 2,
                y: g / 2 + this._yGap
            },
            this._yAxisTextFont, this.getUniqueColor(this._yAxisTextColor)),
            this.drawLine(a, this._yAxisLineColor, this._yAxisLineWidth, r.x, r.y + r.height, r.x, r.y);
            var s = this.getUniqueColor(this._yScaleTextColor);
            o.forEach(function(b) {
                var c = {
                    x: this._xGap + i + n - b.size.width / 2,
                    y: f - b.cursor
                };
                Xb.drawText(a, b.text, c, this._yScaleTextFont, s)
            },
            this);
            var t = r.y + r.height + e / 2;
            s = this.getUniqueColor(this._xScaleTextColor);
            for (var u = this._xScaleLineWidth > 0 ? this.getUniqueColor(this._xScaleLineColor) : null, v = 0; v < this._columnCount; v++) {
                var w = r.x + this._columnWidth * (1 + 1.5 * v);
                if (this._xScaleTexts && v < this._xScaleTexts.size() && (m = this._xScaleTexts.get(v))) {
                    var x = {
                        x: w,
                        y: t
                    };
                    "vertical" === this._xScaleTextOrientation ? this.drawVerticalText(a, m, x, this._yScaleTextFont, s) : this._valueSpanCount ? v % this._valueSpanCount == 0 && Xb.drawText(a, m, x, this._xScaleTextFont, s) : Xb.drawText(a, m, x, this._xScaleTextFont, s)
                }
                "default" !== this._type && u && (this._valueSpanCount ? v % this._valueSpanCount == 0 && this.drawLine(a, u, this._xScaleLineWidth, w, r.y + r.height, w, r.y) : this.drawLine(a, u, this._xScaleLineWidth, w, r.y + r.height, w, r.y))
            }
            var y = f + this._min / k * j;
            this._publishedDatas.size() > 0 && this._columnCount > 0 && this.drawContent(a, r, h, y),
            this.drawLine(a, this._xAxisLineColor, this._xAxisLineWidth, r.x, r.y + r.height, r.x + r.width, r.y + r.height)
        }
    }),
    Ib.charts.PieChart = function(a) {
        this._sum = 0,
        this._map = {},
        Ib.charts.PieChart.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.charts.PieChart", Ib.charts.ChartBase, {
        __accessor: ["type", "selectOffset", "startAngle", "shadowColor", "shadowOffset", "lineRate", "donutRate", "valuePosition"],
        _type: Dd.PIECHART_TYPE,
        _lineRate: Dd.PIECHART_LINE_RATE,
        _donutRate: Dd.PIECHART_DONUT_RATE,
        _startAngle: Dd.PIECHART_START_ANGLE,
        _shadowColor: Dd.PIECHART_SHADOW_COLOR,
        _shadowOffset: Dd.PIECHART_SHADOW_OFFSET,
        _selectOffset: Dd.PIECHART_SELECT_OFFSET,
        _valuePosition: Dd.PIECHART_VALUE_POSITION,
        getSum: function() {
            return this._sum
        },
        validateModel: function() {
            this._sum = 0,
            this._map = {},
            this._publishedDatas.forEach(function(a) {
                var b = this.getValue(a);
                this._map[a.getId()] = {
                    data: a,
                    value: b,
                    color: this.getUniqueColor(this.getColor(a), a)
                },
                this._sum += b
            },
            this);
            var a = this._startAngle;
            this._publishedDatas.forEach(function(b) {
                var c = this._map[b.getId()];
                c.proportion = 0 === this._sum ? 0 : c.value / this._sum,
                "line" !== this._type && (c.startAngle = a, c.arc = c.proportion * Math.PI * 2, a += c.arc)
            },
            this)
        },
        validateDisplay: function(a, b, c) {
            var d = {
                x: this._xGap,
                y: this._yGap,
                width: b - 2 * this._xGap,
                height: c - 2 * this._yGap
            };
            if (this.drawBackground(a, d), Tb.grow(d, -4, -4), !(d.width <= 0 || d.height <= 0)) {
                var e = this._shadowOffset;
                if (e > 0 && (a.shadowOffsetX = e, a.shadowOffsetY = e, a.shadowBlur = 1.5 * e, a.shadowColor = this._shadowColor), "oval" === this._type || "circle" === this._type) {
                    var f = d.x + d.width / 2,
                    g = d.y + d.height / 2,
                    h = d.width / 2,
                    i = d.height / 2;
                    "circle" === this._type && (h = i = Math.min(h, i)),
                    this._publishedDatas.forEach(function(b) {
                        var c = this._map[b.getId()];
                        if (0 !== c.arc) {
                            var d = 0,
                            e = 0;
                            if (this.isSelected(b)) {
                                var j = c.startAngle + c.arc / 2;
                                d = Math.cos(j) * this._selectOffset,
                                e = Math.sin(j) * this._selectOffset * i / h
                            }
                            a.fillStyle = c.color,
                            a.beginPath(),
                            a.moveTo(f + d, g - e),
                            Xb.drawArc(a, f + d, g - e, c.startAngle, c.arc, h, i, !0),
                            a.closePath(),
                            a.fill();
                            var k = this._getValueTextInfo(b, c.value);
                            if (k) {
                                var j = c.startAngle + c.arc / 2;
                                k.x = f + d + Math.cos(j) * h * this._valuePosition,
                                k.y = g - e - Math.sin(j) * i * this._valuePosition
                            }
                        }
                    },
                    this)
                } else if ("donut" === this._type || "ovalDonut" === this._type) {
                    var f = d.x + d.width / 2,
                    g = d.y + d.height / 2,
                    h = d.width / 2,
                    i = d.height / 2;
                    "donut" === this._type && (h = i = Math.min(h, i)),
                    this._publishedDatas.forEach(function(b) {
                        var c = this._map[b.getId()];
                        if (0 !== c.arc) {
                            var d = 0,
                            e = 0;
                            if (this.isSelected(b)) {
                                var j = c.startAngle + c.arc / 2;
                                d = Math.cos(j) * this._selectOffset,
                                e = Math.sin(j) * this._selectOffset * i / h
                            }
                            var k = f + Math.cos(c.startAngle) * h * this._donutRate,
                            l = g - Math.sin(c.startAngle) * i * this._donutRate,
                            m = f + Math.cos(c.startAngle + c.arc) * h * this._donutRate,
                            n = g - Math.sin(c.startAngle + c.arc) * i * this._donutRate;
                            a.fillStyle = c.color,
                            a.beginPath(),
                            a.moveTo(k + d, l - e),
                            Xb.drawArc(a, f + d, g - e, c.startAngle, c.arc, h, i, !0),
                            a.lineTo(m + d, n - e),
                            Xb.drawArc(a, f + d, g - e, c.startAngle + c.arc, -c.arc, h * this._donutRate, i * this._donutRate, !0),
                            a.closePath(),
                            a.fill();
                            var o = this._getValueTextInfo(b, c.value);
                            if (o) {
                                var j = c.startAngle + c.arc / 2,
                                p = this._donutRate + (1 - this._donutRate) * this._valuePosition;
                                o.x = f + d + Math.cos(j) * h * p,
                                o.y = g - e - Math.sin(j) * i * p
                            }
                        }
                    },
                    this)
                } else if ("line" === this._type) {
                    var j = d.height * this._lineRate;
                    d.y = d.y + d.height / 2 - j / 2,
                    d.height = j;
                    var k = d.x;
                    this._publishedDatas.forEach(function(b) {
                        var c = this._map[b.getId()],
                        e = d.width * c.proportion;
                        if (0 !== e) {
                            a.beginPath(),
                            a.fillStyle = c.color;
                            var f = this.isSelected(b) ? -this._selectOffset: 0;
                            a.rect(k, d.y + f, e, d.height),
                            a.closePath(),
                            a.fill();
                            var g = this._getValueTextInfo(b, c.value);
                            g && (g.x = k + e / 2, g.y = d.y + d.height + f - d.height * this._valuePosition),
                            k += e
                        }
                    },
                    this)
                }
                this._shadowOffset > 0 && (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0),
                this.drawValueTexts(a)
            }
        }
    }),
    Ib.charts.BarChart = function(a) {
        Ib.charts.BarChart.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.charts.BarChart", Ib.charts.ScaleChart, {
        __accessor: ["type"],
        _upperLimit: Dd.BARCHART_UPPER_LIMIT,
        _lowerLimit: Dd.BARCHART_LOWER_LIMIT,
        _type: Dd.BARCHART_TYPE,
        _xAxisText: null,
        _xAxisTextColor: Dd.BARCHART_XAXIS_TEXT_COLOR,
        _xAxisTextFont: Dd.BARCHART_XAXIS_TEXT_FONT,
        _xAxisLineColor: Dd.BARCHART_XAXIS_LINE_COLOR,
        _xAxisLineWidth: Dd.BARCHART_XAXIS_LINE_WIDTH,
        _yAxisText: null,
        _yAxisTextColor: Dd.BARCHART_YAXIS_TEXT_COLOR,
        _yAxisTextFont: Dd.BARCHART_YAXIS_TEXT_FONT,
        _yAxisLineColor: Dd.BARCHART_YAXIS_LINE_COLOR,
        _yAxisLineWidth: Dd.BARCHART_YAXIS_LINE_WIDTH,
        _xScaleTexts: null,
        _xScaleTextFont: Dd.BARCHART_XSCALE_TEXT_FONT,
        _xScaleTextColor: Dd.BARCHART_XSCALE_TEXT_COLOR,
        _xScaleTextOrientation: Dd.BARCHART_XSCALE_TEXT_ORIENTATION,
        _yScaleTextVisible: Dd.BARCHART_YSCALE_TEXT_VISIBLE,
        _yScaleTextColor: Dd.BARCHART_YSCALE_TEXT_COLOR,
        _yScaleTextFont: Dd.BARCHART_YSCALE_TEXT_FONT,
        _yScaleLineColor: Dd.BARCHART_YSCALE_LINE_COLOR,
        _yScaleLineWidth: Dd.BARCHART_YSCALE_LINE_WIDTH,
        _yScaleValueGap: Dd.BARCHART_YSCALE_VALUE_GAP,
        _yScalePixelGap: Dd.BARCHART_YSCALE_PIXEL_GAP,
        _yScaleMinTextVisible: Dd.BARCHART_YSCALE_MIN_TEXT_VISIBLE,
        validateModel: function() {
            var a = this._type + "ValidateModel";
            this[a] && (this._reset(), this[a]())
        },
        defaultValidateModel: function() {
            this._columnCount = this._publishedDatas.size(),
            this._publishedDatas.forEach(function(a) {
                var b = this.getValue(a);
                null == this._upperLimit && b > this._max && (this._max = b),
                null == this._lowerLimit && b < this._min && (this._min = b),
                this._map[a.getId()] = {
                    data: a,
                    value: b,
                    color: this.getUniqueColor(this.getColor(a), a)
                }
            },
            this),
            this._initRange(),
            this._publishedDatas.forEach(function(a) {
                var b = this._map[a.getId()];
                b.proportion = 0 == this._range ? 0 : b.value / this._range
            },
            this)
        },
        layerValidateModel: function() {
            this._commonValidateModel()
        },
        groupValidateModel: function() {
            this._commonValidateModel()
        },
        stackValidateModel: function() {
            if (this._publishedDatas.forEach(function(a) {
                var b = new nd(this.getValues(a));
                b.size() > this._columnCount && (this._columnCount = b.size());
                var c = {
                    data: a,
                    values: b,
                    proportions: new nd,
                    color: this.getUniqueColor(this.getColor(a), a)
                };
                this._map[a.getId()] = c
            },
            this), null == this._upperLimit || null == this._lowerLimit) for (var a = 0; a < this._columnCount; a++) {
                var b = 0,
                c = 0;
                this._publishedDatas.forEach(function(d) {
                    var e = this._map[d.getId()];
                    if (e.values.size() > a) {
                        var f = e.values.get(a);
                        null != f && (f >= 0 ? b += f: c += f)
                    }
                },
                this),
                null == this._upperLimit && b > this._max && (this._max = b),
                null == this._lowerLimit && c < this._min && (this._min = c)
            }
            this._initRange(),
            this._initValuesProportion()
        },
        percentValidateModel: function() {
            this._publishedDatas.forEach(function(a) {
                var b = new nd(this.getValues(a));
                b.size() > this._columnCount && (this._columnCount = b.size());
                var c = {
                    data: a,
                    values: b,
                    proportions: new nd,
                    color: this.getUniqueColor(this.getColor(a), a)
                };
                this._map[a.getId()] = c
            },
            this);
            for (var a = new nd,
            b = 0; b < this._columnCount; b++) {
                var c = 0;
                this._publishedDatas.forEach(function(a) {
                    var d = this._map[a.getId()];
                    if (d.values.size() > b) {
                        var e = d.values.get(b);
                        null != e && (c += e)
                    }
                },
                this),
                a.add(c)
            }
            for (var b = 0; b < this._columnCount; b++) this._publishedDatas.forEach(function(c) {
                var d = this._map[c.getId()],
                e = a.get(b);
                if (0 !== e && d.values.size() > b) {
                    var f = d.values.get(b);
                    if (null != f) return void d.proportions.add(f / e)
                }
                d.proportions.add(null)
            },
            this);
            this._min = 0,
            this._max = 1,
            this._range = 1
        },
        drawRect: function(a, b, c, d, e, f, g) {
            a.fillStyle = b,
            c && this._selectInfos.add({
                x: d,
                y: e,
                w: f,
                h: g,
                color: this.getUniqueColor(Xb.darker(b))
            }),
            a.beginPath(),
            a.rect(d, e, f, g),
            a.closePath(),
            a.fill()
        },
        drawContent: function(a, b, c, d) {
            this._selectInfos = new nd,
            this._toolTipInfos = this.isToolTipEnabled() ? new nd: null,
            "default" === this._type ? this.drawDefaultContent(a, b, c, d) : "group" === this._type ? this.drawGroupContent(a, b, c, d) : "percent" === this._type ? this.drawPercentContent(a, b, c, d) : "stack" === this._type ? this.drawStackContent(a, b, c, d) : "layer" === this._type && this.drawLayerContent(a, b, c, d),
            this.drawValueTexts(a),
            this._selectInfos.forEach(function(b) {
                a.lineWidth = 2,
                a.strokeStyle = b.color,
                a.beginPath(),
                a.rect(b.x, b.y, b.w, b.h),
                a.closePath(),
                a.stroke()
            },
            this),
            delete this._selectInfos
        },
        drawDefaultContent: function(a, b, c, d) {
            for (var e = this._publishedDatas.size(), f = this._columnWidth, g = 0; e > g; g++) {
                var h = this._publishedDatas.get(g),
                i = this._map[h.getId()],
                j = b.x + f * (.5 + 1.5 * g),
                k = Math.abs(c * i.proportion),
                l = i.proportion > 0 ? d - k: d;
                this.drawRect(a, i.color, this.isSelected(h), j, l, f, k),
                this.addToolTipInfo(j, l, f, k, i.value, h);
                var m = this._getValueTextInfo(h, i.value);
                if (m) {
                    var n = this.getTextSize(m.font, m.text);
                    m.x = j + f / 2,
                    m.y = l - n.height / 2 + 1
                }
            }
        },
        drawPercentContent: function(a, b, c, d) {
            this.drawStackContent(a, b, c, d)
        },
        drawStackContent: function(a, b, c, d) {
            for (var e = this._columnCount,
            f = this._columnWidth,
            g = 0; e > g; g++) {
                var h = d,
                i = b.x + f * (.5 + 1.5 * g);
                this._publishedDatas.forEach(function(b) {
                    var d = this._map[b.getId()];
                    if (g < d.proportions.size()) {
                        var e = d.proportions.get(g);
                        if (null != e) {
                            var j = c * e;
                            h -= j,
                            this.drawRect(a, d.color, this.isSelected(b), i, h, f, j),
                            this.addToolTipInfo(i, h, f, j, d.values.get(g), b);
                            var k = this._getValueTextInfo(b, d.values.get(g));
                            k && (k.x = i + f / 2, k.y = h + j / 2)
                        }
                    }
                },
                this)
            }
        },
        drawLayerContent: function(a, b, c, d) {
            for (var e = this._publishedDatas.size(), f = this._columnCount, g = this._columnWidth, h = 3 * g / 8 / e, i = 0; f > i; i++) {
                var j = b.x + g * (.5 + 1.5 * i),
                k = 0;
                this._publishedDatas.forEach(function(b) {
                    var f = this._map[b.getId()];
                    if (i < f.proportions.size()) {
                        var l = f.proportions.get(i);
                        if (null != l) {
                            var m = c * l,
                            n = d - m,
                            o = j + g / 2 - g / 8 - h * (e - k),
                            p = 2 * (g / 8 + h * (e - k));
                            this.drawRect(a, f.color, this.isSelected(b), o, n, p, m),
                            this.addToolTipInfo(o, n, p, m, f.values.get(i), b);
                            var q = this._getValueTextInfo(b, f.values.get(i));
                            if (q) {
                                var r = this.getTextSize(q.font, q.text);
                                q.x = o + p / 2,
                                q.y = n - r.height / 2 + 1
                            }
                        }
                    }
                    k++
                },
                this)
            }
        },
        drawGroupContent: function(a, b, c, d) {
            for (var e = this._publishedDatas.size(), f = this._columnCount, g = this._columnWidth, h = g / e, i = 0; f > i; i++) {
                var j = b.x + g * (.5 + 1.5 * i),
                k = 0;
                this._publishedDatas.forEach(function(b) {
                    var e = this._map[b.getId()];
                    if (i < e.proportions.size()) {
                        var f = e.proportions.get(i);
                        if (null != f) {
                            var g = c * f,
                            l = d - g;
                            this.drawRect(a, e.color, this.isSelected(b), j + h * k, l, h, g),
                            this.addToolTipInfo(j + h * k, l, h, g, e.values.get(i), b);
                            var m = this._getValueTextInfo(b, e.values.get(i));
                            if (m) {
                                var n = this.getTextSize(m.font, m.text);
                                m.x = j + h * k + h / 2,
                                m.y = l - n.height / 2 + 1
                            }
                        }
                    }
                    k++
                },
                this)
            }
        }
    }),
    Ib.charts.LineChart = function(a) {
        Ib.charts.LineChart.superClass.constructor.apply(this, arguments),
        this._selectTolerance = 2
    },
    Jb.ext("twaver.charts.LineChart", Ib.charts.ScaleChart, {
        __accessor: ["xScaleLineColor", "xScaleLineWidth", "interruptable"],
        _interruptable: Dd.LINECHART_INTERRUPTABLE,
        _upperLimit: Dd.LINECHART_UPPER_LIMIT,
        _lowerLimit: Dd.LINECHART_LOWER_LIMIT,
        _xAxisText: null,
        _xAxisTextColor: Dd.LINECHART_XAXIS_TEXT_COLOR,
        _xAxisTextFont: Dd.LINECHART_XAXIS_TEXT_FONT,
        _xAxisLineColor: Dd.LINECHART_XAXIS_LINE_COLOR,
        _xAxisLineWidth: Dd.LINECHART_XAXIS_LINE_WIDTH,
        _yAxisText: null,
        _yAxisTextColor: Dd.LINECHART_YAXIS_TEXT_COLOR,
        _yAxisTextFont: Dd.LINECHART_YAXIS_TEXT_FONT,
        _yAxisLineColor: Dd.LINECHART_YAXIS_LINE_COLOR,
        _yAxisLineWidth: Dd.LINECHART_YAXIS_LINE_WIDTH,
        _xScaleTexts: null,
        _xScaleTextFont: Dd.LINECHART_XSCALE_TEXT_FONT,
        _xScaleTextColor: Dd.LINECHART_XSCALE_TEXT_COLOR,
        _xScaleTextOrientation: Dd.LINECHART_XSCALE_TEXT_ORIENTATION,
        _xScaleLineColor: Dd.LINECHART_XSCALE_LINE_COLOR,
        _xScaleLineWidth: Dd.LINECHART_XSCALE_LINE_WIDTH,
        _valueSpanCount: Dd.LINECHART_VALUESPANCOUNT,
        _yScaleTextVisible: Dd.LINECHART_YSCALE_TEXT_VISIBLE,
        _yScaleTextColor: Dd.LINECHART_YSCALE_TEXT_COLOR,
        _yScaleTextFont: Dd.LINECHART_YSCALE_TEXT_FONT,
        _yScaleLineColor: Dd.LINECHART_YSCALE_LINE_COLOR,
        _yScaleLineWidth: Dd.LINECHART_YSCALE_LINE_WIDTH,
        _yScaleValueGap: Dd.LINECHART_YSCALE_VALUE_GAP,
        _yScalePixelGap: Dd.LINECHART_YSCALE_PIXEL_GAP,
        _yScaleMinTextVisible: Dd.LINECHART_YSCALE_MIN_TEXT_VISIBLE,
        getLineWidth: function(a) {
            return a.getStyle ? a.getStyle("chart.line.width") : Ib.Styles.getStyle("chart.line.width")
        },
        getMarkerShape: function(a) {
            return a.getStyle ? a.getStyle("chart.marker.shape") : Ib.Styles.getStyle("chart.marker.shape")
        },
        getMarkerSize: function(a) {
            return a.getStyle ? a.getStyle("chart.marker.size") : Ib.Styles.getStyle("chart.marker.size")
        },
        _initInfo: function(a, b) {
            b.markerShape = this.getMarkerShape(a),
            b.markerSize = this.getMarkerSize(a),
            b.lineWidth = this.getLineWidth(a),
            this.isSelected(a) && (b.lineWidth += 2)
        },
        validateModel: function() {
            this._reset(),
            this._commonValidateModel()
        },
        getPointIndexAt: function() {
            var a = this._getPoint.apply(this, arguments),
            b = this.tryGetDataAt(a);
            if (!b) return - 1;
            for (var c, d = this._map[b.getId()], e = d.points, f = d.markerSize, g = 0, h = e.size(); h > g; g++) if (c = e.get(g), c && Tb.getDistance(a, c) <= f) return g;
            return - 1
        },
        drawContent: function(a, b, c, d) {
            this._toolTipInfos = this.isToolTipEnabled() ? new nd: null,
            this._publishedDatas.forEach(function(e) {
                var f = this._map[e.getId()],
                g = f.markerSize > 0 ? new nd: null;
                a.strokeStyle = f.color,
                a.lineWidth = f.lineWidth,
                a.beginPath();
                var h = f.proportions,
                i = null,
                j = h.size(),
                k = new nd;
                f.points = k;
                for (var l = 0; j > l; l++) {
                    var m = h.get(l);
                    if (null != m) {
                        var n = {
                            x: b.x + this._columnWidth * (1 + 1.5 * l),
                            y: d - c * m
                        };
                        k.add(n),
                        null == i ? a.moveTo(n.x, n.y) : a.lineTo(n.x, n.y);
                        var o = f.values.get(l),
                        p = this._getValueTextInfo(e, o);
                        if (p) {
                            var q = this.getTextSize(p.font, p.text);
                            p.x = n.x,
                            p.y = n.y - q.height / 2 + 2
                        }
                        g && g.add({
                            point: n,
                            value: o,
                            data: e,
                            index: l
                        }),
                        i = n
                    } else this._interruptable && (i = null, k.add(null))
                }
                if (a.stroke(), g) {
                    var r = f.markerSize / 2;
                    g.forEach(function(b) {
                        a.fillStyle = f.color;
                        var c = b.point.x - r,
                        d = b.point.y - r,
                        e = f.markerSize,
                        g = f.markerSize;
                        Xb.drawVector(a, f.markerShape, null, c, d, e, g),
                        a.fill(),
                        this.addToolTipInfo(c, d, e, g, b.value, b.data, b.index)
                    },
                    this)
                }
            },
            this),
            this.drawValueTexts(a)
        }
    }),
    Ib.charts.BubbleChart = function(a) {
        Ib.charts.BubbleChart.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.charts.BubbleChart", Ib.charts.ScaleChart, {
        __accessor: ["xAxisUpperLimit", "xAxisLowerLimit", "xScaleLineColor", "xScaleLineWidth", "selectShadowColor", "selectShadowOffset"],
        _upperLimit: Dd.BUBBLECHART_UPPER_LIMIT,
        _lowerLimit: Dd.BUBBLECHART_LOWER_LIMIT,
        _xAxisUpperLimit: Dd.BUBBLECHART_XAXIS_UPPER_LIMIT,
        _xAxisLowerLimit: Dd.BUBBLECHART_XAXIS_LOWER_LIMIT,
        _xAxisText: null,
        _xAxisTextColor: Dd.BUBBLECHART_XAXIS_TEXT_COLOR,
        _xAxisTextFont: Dd.BUBBLECHART_XAXIS_TEXT_FONT,
        _xAxisLineColor: Dd.BUBBLECHART_XAXIS_LINE_COLOR,
        _xAxisLineWidth: Dd.BUBBLECHART_XAXIS_LINE_WIDTH,
        _yAxisText: null,
        _yAxisTextColor: Dd.BUBBLECHART_YAXIS_TEXT_COLOR,
        _yAxisTextFont: Dd.BUBBLECHART_YAXIS_TEXT_FONT,
        _yAxisLineColor: Dd.BUBBLECHART_YAXIS_LINE_COLOR,
        _yAxisLineWidth: Dd.BUBBLECHART_YAXIS_LINE_WIDTH,
        _xScaleTexts: null,
        _xScaleTextFont: Dd.BUBBLECHART_XSCALE_TEXT_FONT,
        _xScaleTextColor: Dd.BUBBLECHART_XSCALE_TEXT_COLOR,
        _xScaleTextOrientation: Dd.BUBBLECHART_XSCALE_TEXT_ORIENTATION,
        _xScaleLineColor: Dd.BUBBLECHART_XSCALE_LINE_COLOR,
        _xScaleLineWidth: Dd.BUBBLECHART_XSCALE_LINE_WIDTH,
        _yScaleTextVisible: Dd.BUBBLECHART_YSCALE_TEXT_VISIBLE,
        _yScaleTextColor: Dd.BUBBLECHART_YSCALE_TEXT_COLOR,
        _yScaleTextFont: Dd.BUBBLECHART_YSCALE_TEXT_FONT,
        _yScaleLineColor: Dd.BUBBLECHART_YSCALE_LINE_COLOR,
        _yScaleLineWidth: Dd.BUBBLECHART_YSCALE_LINE_WIDTH,
        _yScaleValueGap: Dd.BUBBLECHART_YSCALE_VALUE_GAP,
        _yScalePixelGap: Dd.BUBBLECHART_YSCALE_PIXEL_GAP,
        _yScaleMinTextVisible: Dd.BUBBLECHART_YSCALE_MIN_TEXT_VISIBLE,
        _selectShadowColor: Dd.BUBBLECHART_SELECT_SHADOW_COLOR,
        _selectShadowOffset: Dd.BUBBLECHART_SELECT_SHADOW_OFFSET,
        _resetX: function() {
            this._xMax = 0,
            this._xMin = 0,
            null != this._xAxisUpperLimit && (this._xMax = this._xAxisUpperLimit),
            null != this._xAxisLowerLimit && (this._xMin = this._xAxisLowerLimit)
        },
        getXMin: function() {
            return this._xMin
        },
        getXMax: function() {
            return this._xMax
        },
        getXRange: function() {
            return this._xRange
        },
        getShape: function(a) {
            return a.getStyle ? a.getStyle("chart.bubble.shape") : Ib.Styles.getStyle("chart.bubble.shape")
        },
        getSize: function(a, b) {
            return b
        },
        getNames: function(a) {
            return a.getStyle ? a.getStyle("chart.names") : Ib.Styles.getStyle("chart.names")
        },
        getXAxisValues: function(a) {
            return a.getStyle ? a.getStyle("chart.xaxis.values") : Ib.Styles.getStyle("chart.xaxis.values")
        },
        getYAxisValues: function(a) {
            return a.getStyle ? a.getStyle("chart.yaxis.values") : Ib.Styles.getStyle("chart.yaxis.values")
        },
        _initXRange: function() {
            null == this._xAxisLowerLimit && (this._xMin >= this._xMax && (this._xMin = this._xMax - .1 * Math.abs(this._xMax)), this._xMin = this._xMin - .1 * (this._xMax - this._xMin)),
            this._xRange = this._xMax - this._xMin
        },
        _initXYValuesProportion: function() {
            this._publishedDatas.forEach(function(a) {
                var b = this._map[a.getId()];
                b.xAxisValues.forEach(function(a) {
                    b.xAxisProportions.add(null == a ? null: 0 == this._xRange ? 0 : a / this._xRange)
                },
                this),
                b.yAxisValues.forEach(function(a) {
                    b.yAxisProportions.add(null == a ? null: 0 == this._range ? 0 : a / this._range)
                },
                this)
            },
            this)
        },
        validateModel: function() {
            this._reset(),
            this._resetX(),
            this._columnCount = null == this._xScaleTexts ? 0 : this._xScaleTexts.size(),
            this._publishedDatas.forEach(function(a) {
                var b = new nd(this.getYAxisValues(a)),
                c = new nd(this.getXAxisValues(a)),
                d = new nd(this.getValues(a));
                d.size() > this._columnCount && (this._columnCount = d.size());
                var e = {
                    data: a,
                    values: d,
                    yAxisValues: b,
                    xAxisValues: c,
                    yAxisProportions: new nd,
                    xAxisProportions: new nd,
                    color: this.getUniqueColor(this.getColor(a), a),
                    anchorShape: this.getShape(a)
                };
                this._map[a.getId()] = e,
                (null == this._upperLimit || null == this._lowerLimit) && b.forEach(function(a) {
                    null != a && (null == this._upperLimit && a > this._max && (this._max = a), null == this._lowerLimit && a < this._min && (this._min = a))
                },
                this),
                (null == this._upperLimit || null == this._lowerLimit) && c.forEach(function(a) {
                    null != a && (null == this._xAxisUpperLimit && a > this._xMax && (this._xMax = a), null == this._xAxisLowerLimit && a < this._xMin && (this._xMin = a))
                },
                this)
            },
            this),
            this._initRange(),
            this._initXRange(),
            this._initXYValuesProportion()
        },
        drawContent: function(a, b, c, d) {
            this._toolTipInfos = this.isToolTipEnabled() ? new nd: null,
            this._publishedDatas.forEach(function(e) {
                var f = this._map[e.getId()],
                g = f.yAxisProportions,
                h = f.xAxisProportions,
                i = f.values,
                j = f.yAxisProportions.size(),
                k = this._selectShadowOffset;
                this.isSelected(e) && k > 0 ? (a.shadowOffsetX = k, a.shadowOffsetY = k, a.shadowBlur = 2 * k, a.shadowColor = this._selectShadowColor) : (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0, a.shadowColor = f.color),
                a.fillStyle = f.color;
                for (var l = 0; j > l; l++) {
                    var m = g.get(l),
                    n = h.get(l);
                    if (null != m) {
                        var o = {
                            x: b.x + b.width * n,
                            y: d - c * m
                        },
                        p = i.get(l),
                        q = this.getSize(e, p),
                        k = q / 2,
                        r = o.x - k,
                        s = o.y - k,
                        t = q,
                        u = q;
                        Xb.drawVector(a, f.anchorShape, null, r, s, t, u),
                        a.fill(),
                        this.addToolTipInfo(r, s, t, u, p, e, l);
                        var v = this._getValueTextInfo(e, p);
                        if (v) {
                            var q = this.getTextSize(v.font, v.text);
                            v.x = o.x,
                            v.y = o.y
                        }
                    }
                }
            },
            this),
            this.drawValueTexts(a)
        }
    }),
    Ib.charts.DialChart = function(a) {
        Ib.charts.DialChart.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.charts.DialChart", Ib.charts.ChartBase, {
        __accessor: ["upperLimit", "lowerLimit", "startAngle", "endAngle", "innerRadius", "colorRangeFillColor", "outlineWidth", "outlineColor", "majorScaleCount", "majorScaleLineWidth", "majorScaleLineLength", "majorScaleLineColor", "minorScaleCount", "minorScaleLineWidth", "minorScaleLineLength", "minorScaleLineColor", "scaleTextVisible", "scaleUpperLimitTextVisible", "scaleLowerLimitTextVisible", "scaleTextFont", "scaleTextColor", "pivotRadius", "pivotFillColor", "pivotOutlineWidth", "pivotOutlineColor", "pivotGradient", "pivotGradientColor", "valuePosition", "colorRangeList", "innerDarkerRadius", "outerBrighterRadius", "selectShadowColor", "selectShadowOffset"],
        __bool: ["scaleInside", "pivotFill"],
        _upperLimit: Dd.DIALCHART_UPPER_LIMIT,
        _lowerLimit: Dd.DIALCHART_LOWER_LIMIT,
        _startAngle: Dd.DIALCHART_START_ANGLE,
        _endAngle: Dd.DIALCHART_END_ANGLE,
        _innerRadius: Dd.DIALCHART_INNER_RADIUS,
        _colorRangeFillColor: Dd.DIALCHART_COLOR_RANGE_FILL_COLOR,
        _outlineWidth: Dd.DIALCHART_OUTLINE_WIDTH,
        _outlineColor: Dd.DIALCHART_OUTLINE_COLOR,
        _scaleInside: Dd.DIALCHART_SCALE_INSIDE,
        _majorScaleCount: Dd.DIALCHART_MAJOR_SCALE_COUNT,
        _majorScaleLineWidth: Dd.DIALCHART_MAJOR_SCALE_LINE_WIDTH,
        _majorScaleLineLength: Dd.DIALCHART_MAJOR_SCALE_LINE_LENGTH,
        _majorScaleLineColor: Dd.DIALCHART_MAJOR_SCALE_LINE_COLOR,
        _minorScaleCount: Dd.DIALCHART_MINOR_SCALE_COUNT,
        _minorScaleLineWidth: Dd.DIALCHART_MINOR_SCALE_LINE_WIDTH,
        _minorScaleLineLength: Dd.DIALCHART_MINOR_SCALE_LINE_LENGTH,
        _minorScaleLineColor: Dd.DIALCHART_MINOR_SCALE_LINE_COLOR,
        _scaleTextVisible: Dd.DIALCHART_SCALE_TEXT_VISIBLE,
        _scaleUpperLimitTextVisible: Dd.DIALCHART_SCALE_UPPER_LIMIT_TEXT_VISIBLE,
        _scaleLowerLimitTextVisible: Dd.DIALCHART_SCALE_LOWER_LIMIT_TEXT_VISIBLE,
        _scaleTextFont: Dd.DIALCHART_SCALE_TEXT_FONT,
        _scaleTextColor: Dd.DIALCHART_SCALE_TEXT_COLOR,
        _pivotRadius: Dd.DIALCHART_PIVOT_RADIUS,
        _pivotFill: Dd.DIALCHART_PIVOT_FILL,
        _pivotFillColor: Dd.DIALCHART_PIVOT_FILL_COLOR,
        _pivotOutlineWidth: Dd.DIALCHART_PIVOT_OUTLINE_WIDTH,
        _pivotOutlineColor: Dd.DIALCHART_PIVOT_OUTLINE_COLOR,
        _pivotGradient: Dd.DIALCHART_PIVOT_GRADIENT,
        _pivotGradientColor: Dd.DIALCHART_PIVOT_GRADIENT_COLOR,
        _valuePosition: Dd.DIALCHART_VALUE_POSITION,
        _innerDarkerRadius: Dd.DIALCHART_INNER_DARKER_RADIUS,
        _outerBrighterRadius: Dd.DIALCHART_OUTER_BRIGHTER_RADIUS,
        _selectShadowColor: Dd.DIALCHART_SELECT_SHADOW_COLOR,
        _selectShadowOffset: Dd.DIALCHART_SELECT_SHADOW_OFFSET,
        formatScaleText: function(a) {
            return a.toFixed(2)
        },
        validateModel: function() {
            this._map = {},
            this._valueRange = this._upperLimit - this._lowerLimit;
            var a = this._startAngle;
            0 != a && (a = (a % 360 + 360) % 360, 0 == a && (a = 360)),
            this._positiveStartAngle = a;
            var b = this._endAngle;
            0 != b && (b = (b % 360 + 360) % 360, 0 == b && (b = 360)),
            this._positiveEndAngle = b,
            this._whole = 360 == Math.abs(a - b),
            this._startAngleByRadian = a * Math.PI / 180,
            this._endAngleByRadian = b * Math.PI / 180,
            this._clockwise = this._startAngleByRadian > this._endAngleByRadian,
            this._angleRange = Math.abs(this._startAngleByRadian - this._endAngleByRadian),
            this._publishedDatas.forEach(function(a) {
                var b = this.getValue(a);
                this._map[a.getId()] = {
                    data: a,
                    value: b,
                    color: this.getUniqueColor(this.getColor(a), a),
                    angle: this._startAngleByRadian + (this._clockwise ? -1 : 1) * b / this._valueRange * this._angleRange
                }
            },
            this)
        },
        validateDisplay: function(a, b, c) {
            var d = {
                x: this._xGap,
                y: this._yGap,
                width: b - 2 * this._xGap,
                height: c - 2 * this._yGap
            };
            if (this.drawBackground(a, d), this._startAngleByRadian != this._endAngleByRadian) {
                var e, f, g = this._lowerLimit,
                h = this._majorScaleCount > 1 ? this._valueRange / (this._majorScaleCount - 1) : 0,
                i = 0,
                j = 0,
                k = null,
                l = null;
                if (this._scaleTextVisible) for (k = new nd, e = 0; e < this._majorScaleCount; e++) 0 == e && !this._scaleLowerLimitTextVisible || e == this._majorScaleCount - 1 && !this._scaleUpperLimitTextVisible ? (f = null, k.add({
                    text: "",
                    size: {
                        width: 0,
                        height: 0
                    }
                })) : (l = this.formatScaleText(g), f = this.getTextSize(this._scaleTextFont, l), k.add({
                    text: l,
                    size: f
                })),
                this._scaleInside || null == f || (f.width > i && (i = f.width), f.height > j && (j = f.height)),
                g += h;
                if (this._angleRange <= Math.PI && (i = Math.max(i, this._pivotRadius), j = Math.max(j, this._pivotRadius)), Tb.grow(d, -i, -j), this._calcluateCenterAndRadius(d), a.lineWidth = 0, null == this._colorRangeList || 0 == this._colorRangeList.size()) this._drawArcGroup(a, this._startAngleByRadian, this._endAngleByRadian, this.getUniqueColor(this._colorRangeFillColor)),
                this._drawArcOutLine(a, this._startAngleByRadian, this._endAngleByRadian, !0, !0);
                else {
                    var m = this._angleRange / this._colorRangeList.size(),
                    n = this._startAngleByRadian;
                    for (e = 0; e < this._colorRangeList.size(); e++) {
                        var o = this.getUniqueColor(this._colorRangeList.get(e)),
                        p = n + (this._clockwise ? -1 : 1) * m;
                        this._drawArcGroup(a, n, p, o),
                        this._drawArcOutLine(a, n, n + (this._clockwise ? -1 : 1) * m, 0 == e, e == this._colorRangeList.size() - 1),
                        n += (this._clockwise ? -1 : 1) * m
                    }
                }
                var q, r, s, t, u, v, w, x, y = this._startAngleByRadian,
                z = this._majorScaleCount > 1 ? this._angleRange / (this._majorScaleCount - 1) : 0;
                for (v = this._scaleInside ? this._innerRadiusByPixel: this._outerRadius, w = v + this._majorScaleLineLength * (this._scaleInside ? 1 : -1), x = v + this._minorScaleLineLength * (this._scaleInside ? 1 : -1), e = 0; e < this._majorScaleCount; e++) {
                    if (r = this._center.x + Math.cos(y) * v, s = this._center.y + Math.sin( - y) * v, t = this._center.x + Math.cos(y) * w, u = this._center.y + Math.sin( - y) * w, a.lineWidth = this._majorScaleLineWidth, a.strokeStyle = this.getUniqueColor(this._majorScaleLineColor), a.beginPath(), a.moveTo(r, s), a.lineTo(t, u), a.closePath(), a.stroke(), this._scaleTextVisible) if (0 == e && !this._scaleLowerLimitTextVisible || e == this._majorScaleCount - 1 && !this._scaleUpperLimitTextVisible);
                    else {
                        var A = k.get(e);
                        if (A) {
                            var B = this.getScaleTextPosition(y / Math.PI * 180, r, s, A.size.width, A.size.height);
                            A.x = B.x,
                            A.y = B.y
                        }
                    }
                    if (this._whole || !this._whole && e < this._majorScaleCount - 1) {
                        var C = y,
                        D = this._minorScaleCount > 0 ? z / (this._minorScaleCount + 1) : 0;
                        for (q = 0; q < this._minorScaleCount; q++) C += (this._clockwise ? -1 : 1) * D,
                        r = this._center.x + Math.cos(C) * v,
                        s = this._center.y + Math.sin( - C) * v,
                        t = this._center.x + Math.cos(C) * x,
                        u = this._center.y + Math.sin( - C) * x,
                        a.lineWidth = this._minorScaleLineWidth,
                        a.strokeStyle = this.getUniqueColor(this._minorScaleLineColor),
                        a.beginPath(),
                        a.moveTo(r, s),
                        a.lineTo(t, u),
                        a.closePath(),
                        a.stroke()
                    }
                    y += (this._clockwise ? -1 : 1) * z
                }
                this._pivotFill && Xb.fill(a, this.getUniqueColor(this._pivotFillColor), this._pivotGradient, this._pivotGradientColor, this._center.x - this._pivotRadius, this._center.y - this._pivotRadius, 2 * this._pivotRadius, 2 * this._pivotRadius),
                a.lineWidth = this._pivotOutlineWidth,
                a.strokeStyle = this.getUniqueColor(this._pivotOutlineColor),
                a.beginPath(),
                a.arc(this._center.x, this._center.y, this._pivotRadius, 0, 2 * Math.PI, !0),
                a.closePath(),
                this._pivotFill && a.fill(),
                k && k.forEach(function(b) {
                    b && Xb.drawText(a, b.text, b, this._scaleTextFont, this._scaleTextColor)
                },
                this),
                this._publishedDatas.forEach(function(b) {
                    var c = this._map[b.getId()],
                    d = this._getDataStyle("dialchart.rear.extension", b),
                    e = this._getDataStyle("dialchart.base.width", b),
                    f = this._getDataStyle("dialchart.top.width", b),
                    g = this._getDataStyle("dialchart.radius", b);
                    g >= -1 && 1 >= g && (g *= this._innerRadiusByPixel),
                    a.fillStyle = c.color,
                    a.lineWidth = 0;
                    var h = Tb.createMatrix( - c.angle, this._center.x, this._center.y),
                    i = h.transform(this._center.x + g, this._center.y + f / 2),
                    j = h.transform(this._center.x + g, this._center.y - f / 2),
                    k = h.transform(this._center.x - d, this._center.y - e / 2),
                    l = h.transform(this._center.x - d, this._center.y + e / 2),
                    m = this._selectShadowOffset;
                    this.isSelected(b) && m > 0 ? (a.shadowOffsetX = m, a.shadowOffsetY = m, a.shadowBlur = 2 * m, a.shadowColor = this._selectShadowColor) : (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0, a.shadowColor = c.color),
                    a.beginPath(),
                    a.moveTo(i.x, i.y),
                    a.lineTo(j.x, j.y),
                    a.lineTo(k.x, k.y),
                    a.lineTo(l.x, l.y),
                    a.lineTo(i.x, i.y),
                    a.closePath(),
                    a.fill();
                    var n = this._getValueTextInfo(b, c.value);
                    if (n) {
                        var o = h.transform(this._center.x + g * this._valuePosition, this._center.y);
                        n.x = o.x,
                        n.y = o.y
                    }
                },
                this),
                this.drawValueTexts(a)
            }
        },
        _getDataStyle: function(a, b) {
            return b.getStyle ? b.getStyle(a) : b.getClient(a)
        },
        _calcluateCenterAndRadius: function(a) {
            var b = this._clockwise ? this._positiveEndAngle: this._positiveStartAngle,
            c = this._clockwise ? this._positiveStartAngle: this._positiveEndAngle;
            Math.abs(this._positiveEndAngle - this._positiveStartAngle),
            b >= 0 && 90 > b ? c >= 0 && 90 >= c ? (this._outerRadius = Math.min(a.width, a.height), this._center = {
                x: a.x + (a.width - this._outerRadius) / 2,
                y: a.y + (a.height + this._outerRadius) / 2
            }) : c > 90 && 180 >= c ? (this._outerRadius = Math.min(a.width / 2, a.height), this._center = {
                x: a.x + a.width / 2,
                y: a.y + (a.height + this._outerRadius) / 2
            }) : (this._center = {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            },
            this._outerRadius = Math.min(a.width, a.height) / 2) : b >= 90 && 180 > b ? c >= 90 && 180 >= c ? (this._outerRadius = Math.min(a.width, a.height), this._center = {
                x: a.x + (a.width + this._outerRadius) / 2,
                y: a.y + (a.height + this._outerRadius) / 2
            }) : c > 180 && 270 >= c ? (this._outerRadius = Math.min(a.width, a.height / 2), this._center = {
                x: a.x + (a.width + this._outerRadius) / 2,
                y: a.y + a.height / 2
            }) : (this._center = {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            },
            this._outerRadius = Math.min(a.width, a.height) / 2) : b >= 180 && 270 > b ? c >= 180 && 270 >= c ? (this._outerRadius = Math.min(a.width, a.height), this._center = {
                x: a.x + (a.width + this._outerRadius) / 2,
                y: a.y + (a.height - this._outerRadius) / 2
            }) : (this._outerRadius = Math.min(a.width / 2, a.height), this._center = {
                x: a.x + a.width / 2,
                y: a.y + (a.height - this._outerRadius) / 2
            }) : (this._outerRadius = Math.min(a.width, a.height), this._center = {
                x: a.x + (a.width - this._outerRadius) / 2,
                y: a.y + (a.height - this._outerRadius) / 2
            }),
            this._innerRadiusByPixel = this._innerRadius > 1 ? this._innerRadius: this._outerRadius * this._innerRadius,
            this._innerDarkerRadiusByPixel = this._innerDarkerRadius > 1 ? this._innerDarkerRadius: this._outerRadius * this._innerDarkerRadius,
            this._outerBrighterRadiusByPixel = this._outerBrighterRadius > 1 ? this._outerBrighterRadius: this._outerRadius * this._outerBrighterRadius
        },
        _drawArcOutLine: function(a, b, c, d, e) {
            if (! (this._outlineWidth <= 0)) {
                var f = Math.abs(b - c),
                g = this._center.x + Math.cos(b) * this._innerRadiusByPixel,
                h = this._center.y + Math.sin( - b) * this._innerRadiusByPixel,
                i = this._center.x + Math.cos(b) * this._outerRadius,
                j = this._center.y + Math.sin( - b) * this._outerRadius,
                k = this._center.x + Math.cos(c) * this._innerRadiusByPixel,
                l = this._center.y + Math.sin( - c) * this._innerRadiusByPixel,
                m = this._center.x + Math.cos(c) * this._outerRadius,
                n = this._center.y + Math.sin( - c) * this._outerRadius;
                this._clockwise ? (a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor), a.beginPath(), a.moveTo(this._center.x, this._center.y), Xb.drawArc(a, this._center.x, this._center.y, c, f, this._outerRadius, this._outerRadius, !1), a.stroke(), !this._whole && d ? (a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor)) : a.lineWidth = 0, a.lineTo(g, h), a.stroke(), a.beginPath(), a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor), a.moveTo(this._center.x, this._center.y), Xb.drawArc(a, this._center.x, this._center.y, b, -f, this._innerRadiusByPixel, this._innerRadiusByPixel, !1), a.stroke(), !this._whole && e ? (a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor)) : a.lineWidth = 0, a.lineTo(m, n), a.stroke()) : (a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor), a.beginPath(), a.moveTo(this._center.x, this._center.y), Xb.drawArc(a, this._center.x, this._center.y, b, f, this._outerRadius, this._outerRadius, !1), a.stroke(), !this._whole && e ? (a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor)) : a.lineWidth = 0, a.lineTo(k, l), a.stroke(), a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor), a.beginPath(), a.moveTo(this._center.x, this._center.y), Xb.drawArc(a, this._center.x, this._center.y, c, -f, this._innerRadiusByPixel, this._innerRadiusByPixel, !1), a.stroke(), !this._whole && d ? (a.lineWidth = this._outlineWidth, a.strokeStyle = this.getUniqueColor(this._outlineColor)) : a.lineWidth = 0, a.lineTo(i, j), a.stroke())
            }
        },
        _drawArcGroup: function(a, b, c, d) {
            0 != this._outerBrighterRadiusByPixel && this._drawArc(a, b, c, this._outerRadius - this._outerBrighterRadiusByPixel, this._outerRadius, Xb.brighter(d)),
            this._drawArc(a, b, c, this._innerRadiusByPixel + this._innerDarkerRadiusByPixel, this._outerRadius - this._outerBrighterRadiusByPixel, d),
            0 != this._innerDarkerRadiusByPixel && this._drawArc(a, b, c, this._innerRadiusByPixel, this._innerRadiusByPixel + this._innerDarkerRadiusByPixel, Xb.darker(d, 20))
        },
        _drawArc: function(a, b, c, d, e, f) {
            var g = Math.abs(b - c);
            a.lineWidth = 0,
            a.fillStyle = f;
            var h = this._center.x + Math.cos(b) * d,
            i = this._center.y + Math.sin( - b) * d,
            j = (this._center.x + Math.cos(b) * e, this._center.y + Math.sin( - b) * e, this._center.x + Math.cos(c) * d),
            k = this._center.y + Math.sin( - c) * d;
            this._center.x + Math.cos(c) * e,
            this._center.y + Math.sin( - c) * e,
            a.beginPath(),
            this._clockwise ? (a.moveTo(j, k), Xb.drawArc(a, this._center.x, this._center.y, c, g, e, e, !0), a.lineTo(h, i), Xb.drawArc(a, this._center.x, this._center.y, b, -g, d, d, !0), a.closePath()) : (a.moveTo(h, i), Xb.drawArc(a, this._center.x, this._center.y, b, g, e, e, !0), a.lineTo(j, k), Xb.drawArc(a, this._center.x, this._center.y, c, -g, d, d, !0), a.closePath()),
            a.fill()
        },
        getScaleTextPosition: function(a, b, c, d, e) {
            a = (a % 360 + 360) % 360;
            var f = {
                x: b,
                y: c
            };
            return 0 == a && (f = this._scaleInside ? {
                x: b - d / 2,
                y: c
            }: {
                x: b + d / 2,
                y: c
            }),
            180 == a && (f = this._scaleInside ? {
                x: b + d / 2,
                y: c
            }: {
                x: b - d / 2,
                y: c
            }),
            90 == a && (f = this._scaleInside ? {
                x: b,
                y: c + e / 2
            }: {
                x: b,
                y: c - e / 2
            }),
            270 == a && (f = this._scaleInside ? {
                x: b,
                y: c - e / 2
            }: {
                x: b,
                y: c + e / 2
            }),
            a > 270 && 360 > a && (f = this._scaleInside ? {
                x: b - d / 2,
                y: c - e / 2
            }: {
                x: b + d / 2,
                y: c + e / 2
            }),
            a > 180 && 270 > a && (f = this._scaleInside ? {
                x: b + d / 2,
                y: c - e / 2
            }: {
                x: b - d / 2,
                y: c + e / 2
            }),
            a > 90 && 180 > a && (f = this._scaleInside ? {
                x: b + d / 2,
                y: c + e / 2
            }: {
                x: b - d / 2,
                y: c - e / 2
            }),
            a > 0 && 90 > a && (f = this._scaleInside ? {
                x: b - d / 2,
                y: c + e / 2
            }: {
                x: b + d / 2,
                y: c - e / 2
            }),
            f
        }
    }),
    Ib.charts.RadarChart = function(a) {
        Ib.charts.RadarChart.superClass.constructor.apply(this, arguments),
        this._selectTolerance = 2
    },
    Jb.ext("twaver.charts.RadarChart", Ib.charts.ChartBase, {
        __accessor: ["axisTextVisible", "axisTextFont", "axisTextColor", "scaleTextVisible", "scaleTextFont", "scaleTextColor", "axisVisible", "axisLineColor", "axisLineWidth", "axisStartAngle", "ringVisible", "ringType", "ringLineColor", "ringLineWidth", "scaleCount", "scaleMaxValue", "scaleMinValue", "anchorVisible", "areaFillAlpha", "areaSelectFillAlpha", "axisList"],
        __bool: ["areaFill"],
        _axisTextVisible: Dd.RADARCHART_AXIS_TEXT_VISIBLE,
        _axisTextFont: Dd.RADARCHART_AXIS_TEXT_FONT,
        _axisTextColor: Dd.RADARCHART_AXIS_TEXT_COLOR,
        _scaleTextVisible: Dd.RADARCHART_SCALE_TEXT_VISIBLE,
        _scaleTextFont: Dd.RADARCHART_SCALE_TEXT_FONT,
        _scaleTextColor: Dd.RADARCHART_SCALE_TEXT_COLOR,
        _axisVisible: Dd.RADARCHART_AXIS_VISIBLE,
        _axisLineColor: Dd.RADARCHART_AXIS_LINE_COLOR,
        _axisLineWidth: Dd.RADARCHART_AXIS_LINE_WIDTH,
        _axisStartAngle: Dd.RADARCHART_AXIS_START_ANGLE,
        _ringVisible: Dd.RADARCHART_RING_VISIBLE,
        _ringType: Dd.RADARCHART_RING_TYPE,
        _ringLineColor: Dd.RADARCHART_RING_LINE_COLOR,
        _ringLineWidth: Dd.RADARCHART_RING_LINE_WIDTH,
        _scaleCount: Dd.RADARCHART_SCALE_COUNT,
        _scaleMaxValue: Dd.RADARCHART_SCALE_MAXVALUE,
        _scaleMinValue: Dd.RADARCHART_SCALE_MINVALUE,
        _anchorVisible: Dd.RADARCHART_ANCHOR_VISIBLE,
        _areaFill: Dd.RADARCHART_AREA_FILL,
        _areaFillAlpha: Dd.RADARCHART_AREA_FILL_ALPHA,
        _areaSelectFillAlpha: Dd.RADARCHART_AREA_SELECT_FILL_ALPHA,
        getAxisCount: function() {
            return this._axisCount
        },
        formatScaleText: function(a, b) {
            return a.toFixed(2)
        },
        getAnchorSize: function(a) {
            return a.getStyle ? a.getStyle("chart.marker.size") : Ib.Styles.getStyle("chart.marker.size")
        },
        getAnchorShape: function(a) {
            return a.getStyle ? a.getStyle("chart.marker.shape") : Ib.Styles.getStyle("chart.marker.shape")
        },
        getLineWidth: function(a) {
            return a.getStyle ? a.getStyle("chart.line.width") : Ib.Styles.getStyle("chart.line.width")
        },
        getValues: function(a) {
            return a.getStyle ? a.getStyle("chart.values") : null
        },
        tryGetDataAt: function(a, b) {
            if ((null == b || 0 > b) && (b = this._selectTolerance), a.target && (a = Wb.getLogicalPoint(this._canvas, arguments[0], 1)), !a) return null;
            if (!this._areaFill) {
                var c = a.x - b,
                d = a.y - b,
                e = 2 * b + 1,
                f = 2 * b + 1;
                try {
                    for (var g = this._canvas.getContext("2d").getImageData(c, d, e, f).data, h = 0, i = g.length; i > h; h += 4) if (255 === g[h + 3]) {
                        var j = "rgb(" + g[h] + "," + g[h + 1] + "," + g[h + 2] + ")",
                        k = this._uniqueColors[j];
                        if (k) return k
                    }
                } catch(l) {}
                return null
            }
            if (!this._center) return null;
            a = {
                x: a.x - this._xTranslate,
                y: a.y - this._yTranslate
            };
            for (var h = this._publishedDatas.size() - 1; h >= 0; h--) {
                var k = this._publishedDatas.get(h),
                m = this._map[k.getId()],
                n = Tb.isPointInPolygon(m.points, a);
                if (n) return k
            }
            return null
        },
        getDataAt: function() {
            var a, b;
            if (2 === arguments.length) a = arguments[0],
            b = arguments[1];
            else if (arguments[0].target) {
                var c = Wb.getLogicalPoint(this._canvas, arguments[0], 1);
                if (!c) return;
                a = c.x,
                b = c.y
            } else a = arguments[0].x,
            b = arguments[0].y;
            if (0 > a || 0 > b || a > this._canvasWidth || b > this._canvasHeight) return null;
            if (!this._areaFill) {
                try {
                    var d = this._canvas.getContext("2d").getImageData(a, b, 1, 1).data;
                    if (255 === d[3]) {
                        var e = "rgb(" + d[0] + "," + d[1] + "," + d[2] + ")",
                        f = this._uniqueColors[e];
                        if (f) return f
                    }
                } catch(g) {}
                return null
            }
            for (var h = this._publishedDatas.size() - 1; h >= 0; h--) {
                var f = this._publishedDatas.get(h),
                i = this._map[f.getId()],
                j = Tb.isPointInPolygon(i.points, {
                    x: a - this._xTranslate,
                    y: b - this._yTranslate
                });
                if (j) return f
            }
            return null
        },
        validateModel: function() {
            if (this._map = {},
            this._axisTexts = new nd, this._axisMaxValues = new nd, this._axisMinValues = new nd, this._axisRangeValues = new nd, this._axisCount = null == this._axisList ? 0 : this._axisList.size(), 0 != this._axisCount) {
                this._averageAngleByRadian = 2 * Math.PI / this._axisCount,
                this._averageAngle = 360 / this._axisCount,
                this._axisList.forEach(function(a) {
                    if ("string" == typeof a) this._axisTexts.add(a),
                    this._axisMaxValues.add(this._scaleMaxValue),
                    this._axisMinValues.add(this._scaleMinValue),
                    this._axisRangeValues.add(this._scaleMaxValue - this._scaleMinValue);
                    else {
                        this._axisTexts.add(a.text);
                        var b = isNaN(a.max) ? this._scaleMaxValue: a.max,
                        c = isNaN(a.min) ? this._scaleMinValue: a.min;
                        this._axisMaxValues.add(b),
                        this._axisMinValues.add(c),
                        this._axisRangeValues.add(b - c)
                    }
                },
                this),
                this._publishedDatas.forEach(function(a) {
                    var b = new nd(this.getValues(a)),
                    c = {
                        data: a,
                        values: b,
                        proportions: new nd,
                        color: this.getUniqueColor(this.getColor(a), a),
                        anchorShape: this.getAnchorShape(a),
                        anchorSize: this.getAnchorSize(a),
                        lineWidth: this.getLineWidth(a),
                        points: new nd
                    };
                    this.isSelected(a) && (c.lineWidth += 2),
                    this._map[a.getId()] = c
                },
                this);
                for (var a = 0; a < this._axisCount; a++) this._publishedDatas.forEach(function(b) {
                    var c = this._map[b.getId()],
                    d = 0;
                    if (c.values.size() > a) {
                        var e = c.values.get(a),
                        f = this._axisMinValues.get(a),
                        g = this._axisRangeValues.get(a);
                        g > 0 && (d = (e - f) / g)
                    }
                    c.proportions.add(d)
                },
                this)
            }
        },
        validateDisplay: function(a, b, c) {
            var d = {
                x: this._xGap,
                y: this._yGap,
                width: b - 2 * this._xGap,
                height: c - 2 * this._yGap
            };
            if (this.drawBackground(a, d), !(d.width <= 0 || d.height <= 0 || this._axisCount < 3)) {
                var e = 0,
                f = 0,
                g = 0,
                h = null,
                i = null,
                j = null,
                k = null;
                if (this._axisTextVisible) for (k = new nd, g = 0; g < this._axisCount; g++) j = this._axisTexts.get(g),
                h = this.getTextSize(this._axisTextFont, j),
                k.add({
                    text: j,
                    size: h
                }),
                h.width > e && (e = h.width),
                h.height > f && (f = h.height);
                var l = d.width / 2 - e > d.height / 2 - f ? d.height / 2 - 2 * f: d.width / 2 - e,
                m = {
                    x: d.x + d.width / 2,
                    y: d.y + d.height / 2
                };
                this._center = {
                    x: m.x + this._xTranslate,
                    y: m.y + this._yTranslate
                };
                var n = null;
                this._scaleTextVisible && (n = new nd);
                var o = this._axisStartAngle / 180 * Math.PI;
                for (g = 0; g < this._axisCount; g++) {
                    var p = 180 * o / Math.PI,
                    q = m.x + Math.cos(o) * l,
                    r = m.y + Math.sin( - o) * l,
                    s = null;
                    n && (s = new nd, n.add(s)),
                    this._ringVisible && this._ringLineWidth > 0 && (a.lineWidth = this._ringLineWidth, a.strokeStyle = this._ringLineColor);
                    for (var t = 1; t <= this._scaleCount; t++) {
                        var u = t / this._scaleCount,
                        v = l * u,
                        w = m.x + Math.cos(o) * v,
                        x = m.y + Math.sin( - o) * v;
                        if (this._ringVisible && this._ringLineWidth > 0) {
                            var y = m.x + Math.cos(o + this._averageAngleByRadian) * v,
                            z = m.y + Math.sin( - o - this._averageAngleByRadian) * v;
                            "line" == this._ringType ? this.drawLine(a, this._ringLineColor, this._ringLineWidth, w, x, y, z) : "arc" == this._ringType && (a.beginPath(), a.moveTo(m.x, m.y), Xb.drawArc(a, m.x, m.y, o, this._averageAngleByRadian, v, v, !0), a.closePath(), a.stroke())
                        }
                        s && (j = this.formatScaleText(this._axisMinValues.get(g) + this._axisRangeValues.get(g) * u, g), h = this.getTextSize(this._scaleTextFont, j), i = this.getScaleTextPosition(p, w, x, h.width, h.height), s.add({
                            text: j,
                            x: i.x,
                            y: i.y
                        }))
                    }
                    if (this._axisVisible && this.drawLine(a, this._axisLineColor, this._axisLineWidth, m.x, m.y, q, r), k) {
                        var A = k.get(g);
                        i = this.getAxisTextPosition(p, q, r, A.size.width, A.size.height),
                        A.x = i.x,
                        A.y = i.y
                    }
                    o += this._averageAngleByRadian
                }
                this._publishedDatas.forEach(function(b) {
                    var c = this._map[b.getId()];
                    c.points.clear();
                    var d = c.anchorSize > 0 ? new nd: null,
                    e = c.proportions;
                    if (a.lineWidth = 0, a.globalAlpha = this.isSelected(b) ? this._areaSelectFillAlpha: this._areaFillAlpha, this._areaFill && (a.fillStyle = c.color), this._drawItem(a, e, m, l, d, c), this._areaFill && a.fill(), a.lineWidth = c.lineWidth, a.strokeStyle = c.color, a.globalAlpha = 1, this._drawItem(a, e, m, l), a.lineWidth = 0, null != d && d.size() > 0) {
                        var f = c.anchorSize / 2;
                        d.forEach(function(b) {
                            a.fillStyle = c.color,
                            Xb.drawVector(a, c.anchorShape, null, b.x - f, b.y - f, c.anchorSize, c.anchorSize),
                            a.fill()
                        })
                    }
                },
                this),
                n && n.forEach(function(b) {
                    b.forEach(function(b) {
                        Xb.drawText(a, b.text, b, this._scaleTextFont, this._scaleTextColor)
                    },
                    this)
                },
                this),
                k && k.forEach(function(b) {
                    Xb.drawText(a, b.text, b, this._axisTextFont, this._axisTextColor)
                },
                this)
            }
        },
        _drawItem: function(a, b, c, d, e, f) {
            var g = this._axisStartAngle / 180 * Math.PI,
            h = null;
            a.beginPath();
            for (var i = 0; i < this._axisCount; i++) {
                var j = b.get(i),
                k = {
                    x: c.x + Math.cos(g) * d * j,
                    y: c.y + Math.sin( - g) * d * j
                };
                null == h ? a.moveTo(k.x, k.y) : a.lineTo(k.x, k.y),
                null != e && this._anchorVisible && e.add(k),
                f && f.points.add(k),
                0 == i && (h = k),
                g += this._averageAngleByRadian
            }
            null != h && a.lineTo(h.x, h.y),
            a.closePath(),
            a.stroke()
        },
        getAxisTextPosition: function(a, b, c, d, e) {
            a = (a % 360 + 360) % 360;
            var f = {
                x: b,
                y: c
            };
            return 0 == a && (f = {
                x: b + d / 2,
                y: c
            }),
            180 == a && (f = {
                x: b - d / 2,
                y: c
            }),
            90 == a && (f = {
                x: b,
                y: c - e / 2
            }),
            270 == a && (f = {
                x: b,
                y: c + e / 2
            }),
            a > 270 && 360 > a && (f = {
                x: b + d / 2,
                y: c + e / 2
            }),
            a > 180 && 270 > a && (f = {
                x: b - d / 2,
                y: c + e / 2
            }),
            a > 90 && 180 > a && (f = {
                x: b - d / 2,
                y: c - e / 2
            }),
            a > 0 && 90 > a && (f = {
                x: b + d / 2,
                y: c - e / 2
            }),
            f
        },
        getScaleTextPosition: function(a, b, c, d, e) {
            a = (a % 360 + 360) % 360;
            var f = {
                x: b,
                y: c
            };
            return 0 == a && (f = {
                x: b,
                y: c + e / 2
            }),
            180 == a && (f = {
                x: b - d / 2,
                y: c + e / 2
            }),
            90 == a && (f = {
                x: b + d / 2,
                y: c
            }),
            270 == a && (f = {
                x: b + d / 2,
                y: c
            }),
            a > 270 && 360 > a && (f = {
                x: b + d / 2,
                y: c - e / 2
            }),
            a > 180 && 270 > a && (f = {
                x: b - d / 2,
                y: c - e / 2
            }),
            a > 90 && 180 > a && (f = {
                x: b - d / 2,
                y: c + e / 2
            }),
            a > 0 && 90 > a && (f = {
                x: b + d / 2,
                y: c + e / 2
            }),
            f
        }
    }),
    Ib.charts.LegendPane = function(a) {
        Ib.charts.LegendPane.superClass.constructor.apply(this, arguments),
        this._divPool = new Ib.Pool("div"),
        this._iconPool = new Ib.Pool("div"),
        this._textPool = new Ib.Pool("span"),
        this._pools.add(this._divPool),
        this._pools.add(this._iconPool),
        this._pools.add(this._textPool),
        this._chart = a,
        this._chart.addViewListener(this.handleViewChange, this),
        this._view = Wb.createView("hidden"),
        this._view.style.verticalAlign = "middle",
        this._legendDiv = Wb.createDiv(),
        this._legendDiv.style.whiteSpace = "nowrap",
        this._legendDiv.style.verticalAlign = "middle",
        this._legendDiv.style.position = "",
        this._view.appendChild(this._legendDiv),
        this._hiddenMap = {};
        var b = this;
        this._chart._internalVisibleFunction = function(a) {
            return ! b.isHidden(a)
        };
        var c;
        c = Qb.isTouchable && !Qb.isMSToucheable ? Ib.charts.LegendPaneTouchInteraction: Ib.charts.LegendPaneInteraction,
        c && new c(this)
    },
    Jb.ext("twaver.charts.LegendPane", Ib.controls.ControlBase, {
        __accessor: ["iconWidth", "iconHeight", "iconRadius", "rowHeight", "orientation", "hiddenColor", "selectBackgroundColor", "selectForegroundColor"],
        _iconWidth: Dd.LEGENDPANE_ICON_WIDTH,
        _iconHeight: Dd.LEGENDPANE_ICON_HEIGHT,
        _iconRadius: Dd.LEGENDPANE_ICON_RADIUS,
        _rowHeight: Dd.LEGENDPANE_ROW_HEIGHT,
        _orientation: Dd.LEGENDPANE_ORIENTATION,
        _hiddenColor: Dd.LEGENDPANE_HIDDEN_COLOR,
        _selectBackgroundColor: Dd.LEGENDPANE_SELECT_BACKGROUND_COLOR,
        _selectForegroundColor: Dd.LEGENDPANE_SELECT_FOREGROUND_COLOR,
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        getChart: function() {
            return this._chart
        },
        isHidden: function(a) {
            return null != this._hiddenMap[a.getId()]
        },
        handleViewChange: function(a) {
            "validateEnd" === a.kind && (this._invalidate = !0, this.validate())
        },
        validate: function() {
            if (this._invalidate) {
                this._invalidate = !1,
                Wb.release(this._legendDiv),
                Jb.keys(this._hiddenMap).forEach(function(a) {
                    this._chart.getDataBox().containsById(a) || delete this._hiddenMap[a]
                },
                this);
                for (var a = new nd(this._chart.getUnfilteredDatas()), b = 0; b < a.size(); b++) {
                    var c = a.get(b);
                    this._chart.isVisible(c) || this.isHidden(c) || (a.removeAt(b), b--)
                }
                var d = a.size(),
                e = this._view.style,
                f = "horizontal" === this._orientation;
                for (f ? (e.textAlign = "center", e.height = this._rowHeight + "px") : (e.textAlign = "", e.height = this._rowHeight * d + "px"), e.lineHeight = this._rowHeight - 2 + "px", b = 0; d > b; b++) {
                    var c = a.get(b),
                    g = this._divPool.get();
                    g._data = c,
                    g.style.cursor = "pointer",
                    g.style.height = this._rowHeight + "px",
                    g.style.display = f ? "inline-block": "block",
                    this._legendDiv.appendChild(g),
                    this.renderLegend(g, c),
                    this.onLegendRendered(g, c)
                }
                this._pools.forEach(function(a) {
                    a.clear()
                })
            }
        },
        renderLegend: function(a, b) {
            var c = !this.isHidden(b),
            d = this._chart.isSelected(b),
            e = this._iconPool.get(),
            f = e.style;
            f.display = "inline-block",
            f.verticalAlign = "middle",
            f.marginLeft = "4px",
            f.width = this.getIconWidth() + "px",
            f.height = this.getIconHeight() + "px",
            f.backgroundColor = c ? this._chart.getColor(b) : this.getHiddenColor(),
            a.appendChild(e);
            var g = this._textPool.get();
            f = g.style,
            f.paddingLeft = "2px",
            f.paddingRight = "4px",
            f.display = "inline-block",
            f.verticalAlign = "middle",
            f.color = c ? d ? this._selectForegroundColor: "": this.getHiddenColor(),
            g.innerHTML = this._chart.getName(b),
            a.appendChild(g),
            a.style.backgroundColor = c && d ? this._selectBackgroundColor: ""
        },
        onLegendRendered: function(a, b) {}
    }),
    Ib.charts.ChartPane = function(a, b, c, d) {
        Ib.charts.ChartPane.superClass.constructor.apply(this, arguments),
        this.invalidate(),
        this._chart = a,
        this._legendPane = new Ib.charts.LegendPane(a),
        this._titleDiv = Wb.createDiv(),
        this._titleDiv.style.verticalAlign = "middle",
        this._titleDiv.style.whiteSpace = "nowrap",
        this._view = Wb.createView("hidden"),
        this._view.appendChild(this._titleDiv),
        this._view.appendChild(this._legendPane.getView()),
        this._view.appendChild(this._chart.getView());
        var e = this;
        this._legendPane.addPropertyChangeListener(function(a) { ("rowHeight" === a.property || "orientation" === a.porperty) && e.invalidate()
        }),
        arguments.length > 1 && this.setTitle(b),
        arguments.length > 2 && this.setLegendOrientation(c),
        arguments.length > 3 && this.setLegendWidth(d)
    },
    Jb.ext("twaver.charts.ChartPane", Ib.controls.ControlBase, {
        __accessor: ["title", "titleHorizontalAlign", "titleHeight", "legendWidth"],
        _title: null,
        _titleHeight: Dd.CHARTPANE_TITLE_HEIGHT,
        _titleHorizontalAlign: Dd.CHARTPANE_TITLE_HORIZONTAL_ALIGN,
        _legendOrientation: Dd.CHARTPANE_LEGEND_ORIENTATION,
        _legendWidth: Dd.CHARTPANE_LEGEND_WIDTH,
        getLegendOrientation: function() {
            return this._legendOrientation
        },
        setLegendOrientation: function(a) {
            if (this._legendOrientation !== a) {
                var b = this._legendOrientation;
                this._legendOrientation = a,
                this.firePropertyChange("orientation", b, a),
                this._adjustLegendOrientation()
            }
        },
        _adjustLegendOrientation: function() {
            this._legendPane.setOrientation("left" === this._legendOrientation || "right" === this._legendOrientation ? "vertical": "horizontal")
        },
        onPropertyChanged: function(a) {
            this.invalidate()
        },
        getTitleDiv: function() {
            return this._titleDiv
        },
        getChart: function() {
            return this._chart
        },
        getLegendPane: function() {
            return this._legendPane
        },
        validateImpl: function() {
            this._adjustLegendOrientation();
            var a, b = this._view.offsetWidth,
            c = this._view.offsetHeight,
            d = this._legendPane.getRowHeight();
            this._title && "" !== this._title ? (a = this._titleHeight, this._titleDiv.innerHTML = this._title) : (a = 0, this._titleDiv.innerHTML = ""),
            this._titleDiv.innerHTML = this._title ? this._title: "",
            this._titleDiv.style.textAlign = this._titleHorizontalAlign,
            this._titleDiv.style.lineHeight = this._titleHeight - 2 + "px";
            var e = this._titleDiv.style;
            e.left = "0px",
            e.top = "0px",
            e.width = b + "px",
            e.height = a + "px";
            var f, g;
            "bottom" === this._legendOrientation ? (f = {
                x: 0,
                y: a,
                width: b,
                height: Math.max(c - a - d, 0)
            },
            g = {
                x: 0,
                y: Math.max(c - d, 0),
                width: b,
                height: d
            }) : "right" === this._legendOrientation ? (f = {
                x: 0,
                y: a,
                width: Math.max(b - this._legendWidth, 0),
                height: Math.max(c - a, 0)
            },
            g = {
                x: Math.max(b - this._legendWidth, 0),
                y: a,
                width: this._legendWidth,
                height: Math.max(c - a, 0)
            }) : "top" === this._legendOrientation ? (f = {
                x: 0,
                y: a + d,
                width: b,
                height: Math.max(c - a - d, 0)
            },
            g = {
                x: 0,
                y: a,
                width: b,
                height: d
            }) : "left" === this._legendOrientation && (f = {
                x: this._legendWidth,
                y: a,
                width: Math.max(b - this._legendWidth, 0),
                height: Math.max(c - a, 0)
            },
            g = {
                x: 0,
                y: a,
                width: this._legendWidth,
                height: Math.max(c - a, 0)
            }),
            f && this._chart.adjustBounds(f),
            g && this._legendPane.adjustBounds(g)
        }
    }),
    Ib.charts.ChartInteraction = function(a) {
        this.chart = a,
        this.canvas = a._canvas;
        var b = this;
        this.canvas.addEventListener("mousedown",
        function(a) {
            0 === a.button && b.handleMouseDown(a),
            a.preventDefault()
        },
        !1);
        var c = Qb.isFirefox ? "DOMMouseScroll": "mousewheel";
        this.canvas.addEventListener(c,
        function(a) {
            b.handleMouseWheel(a)
        },
        !1)
    },
    Jb.ext("twaver.charts.ChartInteraction", Object, {
        handleMouseDown: function(a) {
            this.chart.isFocusOnClick() && Ib.Util.setFocus(this.canvas),
            this.lastPoint = this.chart.getLogicalPoint(a);
            var b = this.chart.tryGetDataAt(a);
            2 === a.detail && null == b ? this.chart.isDoubleClickToReset() && (this.chart.zoomReset(!1), this.chart.setXTranslate(0), this.chart.setYTranslate(0)) : (this._startLogical = this.lastPoint, this._startClient = Wb.getClientPoint(a), Wb.handle_mousedown(this, a))
        },
        handleMouseMove: function(a) {
            if (this.lastPoint) {
                var b = {
                    x: this._startLogical.x + a.clientX - this._startClient.x,
                    y: this._startLogical.y + a.clientY - this._startClient.y
                }; ! this.startPan && Tb.getDistance(this.lastPoint, b) > 3 && (this.startPan = !0, this.lastPoint = b),
                this.startPan && (this.chart.isXTranslateEnabled() && this.chart.setXTranslate(this.chart.getXTranslate() + b.x - this.lastPoint.x), this.chart.isYTranslateEnabled() && this.chart.setYTranslate(this.chart.getYTranslate() + b.y - this.lastPoint.y), this.lastPoint = b)
            }
        },
        handleMouseUp: function(a) {
            if (!this.startPan && 1 === a.detail) {
                var b = this.chart.tryGetDataAt(a),
                c = this.chart.getSelectionModel();
                b ? Jb.isCtrlDown(a) ? c.contains(b) ? c.removeSelection(b) : c.appendSelection(b) : c.contains(b) || c.setSelection(b) : Jb.isCtrlDown(a) || c.clearSelection()
            }
            delete this.lastPoint,
            delete this.startPan,
            delete this._startClient,
            delete this._startLogical
        },
        handleMouseWheel: function(a) {
            Wb.preventDefault(a);
            var b = Qb.isFirefox ? -a.detail: a.wheelDelta;
            b > 0 ? (this.chart.isXZoomEnabled() && this.chart.setXZoom(1.1 * this.chart.getXZoom(), !1), this.chart.isYZoomEnabled() && this.chart.setYZoom(1.1 * this.chart.getYZoom(), !1)) : 0 > b && (this.chart.isXZoomEnabled() && this.chart.setXZoom(this.chart.getXZoom() / 1.1, !1), this.chart.isYZoomEnabled() && this.chart.setYZoom(this.chart.getYZoom() / 1.1, !1))
        }
    }),
    Ib.charts.ChartTouchInteraction = function(a) {
        this.chart = a,
        this.canvas = a._canvas,
        Wb.addEventListener("touchstart", "handleTouchstart", this.canvas, this)
    },
    Jb.ext("twaver.charts.ChartTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            this.chart.isFocusOnClick() && Ib.Util.setFocus(this.canvas),
            this.endPoint = this.chart.getLogicalPoint(a),
            zc.isMultiTouch(a) && (this.distance = zc.getDistance(a), this.xZoom = this.chart.getXZoom(), this.yZoom = this.chart.getYZoom()),
            Wb.addEventListener("touchmove", "handleTouchmove", this.canvas, this),
            Wb.addEventListener("touchend", "handleTouchend", this.canvas, this)
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), this.endPoint) {
                var b = this.chart.getLogicalPoint(a);
                if (!this.moved && Tb.getDistance(this.endPoint, b) > 10 && (this.moved = !0, this.lastPoint = b), this.moved) if (zc.isSingleTouch(a)) this.endPoint && (this.chart.isXTranslateEnabled() && this.chart.setXTranslate(this.chart.getXTranslate() + b.x - this.endPoint.x), this.chart.isYTranslateEnabled() && this.chart.setYTranslate(this.chart.getYTranslate() + b.y - this.endPoint.y), this.endPoint = b);
                else if (this.distance) {
                    var c = zc.getDistance(a) / this.distance,
                    d = this.xZoom * c,
                    e = this.yZoom * c;
                    this.chart.isXZoomEnabled() && this.chart.setXZoom(d, !1),
                    this.chart.isYZoomEnabled() && this.chart.setYZoom(e, !1)
                }
            }
        },
        handleTouchend: function(a) {
            if (Wb.preventDefault(a), !this.moved) {
                this.endPoint = this.chart.getLogicalPoint(a);
                var b = this.lastPoint && this.lastTouchStartTime && (new Date).getTime() - this.lastTouchStartTime.getTime() <= 300 && Math.abs(this.endPoint.x - this.lastPoint.x) <= 10 && Math.abs(this.endPoint.y - this.lastPoint.y) <= 10;
                b ? (this.lastPoint = null, this.lastTouchStartTime = null) : (this.lastPoint = this.endPoint, this.lastTouchStartTime = new Date);
                var c = this.chart.tryGetDataAt(a);
                if (b && null == c) this.chart.isDoubleClickToReset() && (this.chart.zoomReset(!1), this.chart.setXTranslate(0), this.chart.setYTranslate(0));
                else {
                    var d = this.chart.getSelectionModel();
                    c ? d.contains(c) || d.setSelection(c) : d.clearSelection()
                }
            }
            delete this.endPoint,
            delete this.distance,
            delete this.xZoom,
            delete this.yZoom,
            delete this.moved,
            Wb.removeEventListener("touchmove", this.canvas, this),
            Wb.removeEventListener("touchend", this.canvas, this)
        }
    }),
    Ib.charts.ChartMSTouchInteraction = function(a) {
        this.chart = a,
        this.canvas = a._canvas,
        this._pointerMap = {},
        this._pointerIdArray = [];
        var b = this;
        this.canvas.addEventListener("MSPointerDown",
        function(a) {
            b.handleTouchstart(a)
        },
        !1),
        this.canvas.addEventListener("MSPointerMove",
        function(a) {
            b.handleTouchmove(a)
        },
        !1),
        this.canvas.addEventListener("MSPointerUp",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.canvas.addEventListener("MSPointerCancel",
        function(a) {
            b.handleTouchend(a)
        },
        !1);
        var c = Qb.isFirefox ? "DOMMouseScroll": "mousewheel";
        this.canvas.addEventListener(c,
        function(a) {
            b.handleMouseWheel(a)
        },
        !1)
    },
    Jb.ext("twaver.charts.ChartMSTouchInteraction", Object, {
        handleTouchstart: function(a) {
            this.chart.isFocusOnClick() && Ib.Util.setFocus(this.canvas);
            var b = this.chart.getLogicalPoint(a);
            a.isPrimary && this._pointerIdArray.length > 0 && (this._pointerMap = {},
            this._pointerIdArray = []),
            !this._pointerMap[a.pointerId] && b && (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a);
            var c = this.chart.tryGetDataAt(a);
            if (1 == this._pointerIdArray.length && b) {
                var d = this._startTouchPoint && this._startTouchTime && (new Date).getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 10;
                d && null == c ? this.chart.isDoubleClickToReset() && (this.chart.zoomReset(!1), this.chart.setXTranslate(0), this.chart.setYTranslate(0), this._startTouchPoint = null, this._startTouchTime = null, this._startClientPoint = null) : (this._startTouchPoint = b, this._startTouchTime = new Date, this._startClientPoint = {
                    x: a.clientX,
                    y: a.clientY
                },
                Wb.handle_mousedown(this, a))
            } else 2 == this._pointerIdArray.length && (this.xZoom = this.chart.getXZoom(), this.yZoom = this.chart.getYZoom(), this._distance = this._getDistance())
        },
        handleTouchmove: function(a) {
            if (0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 3) && (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length)) {
                var b = this._getDistance() / this._distance,
                c = this.xZoom * b,
                d = this.yZoom * b;
                this.chart.isXZoomEnabled() && this.chart.setXZoom(c, !1),
                this.chart.isYZoomEnabled() && this.chart.setYZoom(d, !1)
            }
        },
        handleTouchend: function(a) {
            var b = this.chart.getLogicalPoint(a);
            if (1 == this._pointerIdArray.length && b && !this.moved) {
                var c = this.chart.tryGetDataAt(a),
                d = this._startTouchPoint && this._startTouchTime && (new Date).getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 10,
                e = this.chart.getSelectionModel();
                c && d ? Jb.isCtrlDown(a) ? e.contains(c) ? e.removeSelection(c) : e.appendSelection(c) : e.contains(c) || e.setSelection(c) : Jb.isCtrlDown(a) || e.clearSelection()
            }
            this.moved = !1,
            this._pointerMap = {},
            this._pointerIdArray = []
        },
        handleMouseWheel: function(a) {
            Wb.preventDefault(a);
            var b = Qb.isFirefox ? -a.detail: a.wheelDelta;
            b > 0 ? (this.chart.isXZoomEnabled() && this.chart.setXZoom(1.1 * this.chart.getXZoom(), !1), this.chart.isYZoomEnabled() && this.chart.setYZoom(1.1 * this.chart.getYZoom(), !1)) : 0 > b && (this.chart.isXZoomEnabled() && this.chart.setXZoom(this.chart.getXZoom() / 1.1, !1), this.chart.isYZoomEnabled() && this.chart.setYZoom(this.chart.getYZoom() / 1.1, !1))
        },
        handle_mousemove: function(a) {
            if (1 == this._pointerIdArray.length && this._startTouchPoint && this._startClientPoint) {
                var b = {
                    x: this._startTouchPoint.x + (a.clientX - this._startClientPoint.x) / this.chart.getXZoom(),
                    y: this._startTouchPoint.y + (a.clientY - this._startClientPoint.y) / this.chart.getYZoom()
                };
                Tb.getDistance(this._startTouchPoint, b) > 3 && (this.moved = !0, this.chart.isXTranslateEnabled() && this.chart.setXTranslate(this.chart.getXTranslate() + b.x - this._startTouchPoint.x), this.chart.isYTranslateEnabled() && this.chart.setYTranslate(this.chart.getYTranslate() + b.y - this._startTouchPoint.y), this._startClientPoint.x = a.clientX, this._startClientPoint.y = a.clientY)
            }
        },
        handle_mouseup: function(a) {
            this.handleTouchend(a)
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        }
    }),
    Ib.charts.LegendPaneInteraction = function(a) {
        this.legendPane = a;
        var b = this;
        this.legendPane._legendDiv.addEventListener("mousedown",
        function(a) {
            b.handleMouseDown(a)
        },
        !1)
    },
    Jb.ext("twaver.charts.LegendPaneInteraction", Object, {
        handleMouseDown: function(a) {
            if (0 === a.button) {
                var b = a.target._data;
                b || (b = a.target.parentNode._data),
                b && (this.legendPane._hiddenMap[b.getId()] ? delete this.legendPane._hiddenMap[b.getId()] : this.legendPane._hiddenMap[b.getId()] = b, this.legendPane._chart.invalidateModel())
            }
        }
    }),
    Ib.charts.LegendPaneTouchInteraction = function(a) {
        this.legendPane = a,
        Wb.addEventListener("touchstart", "handleTouchstart", this.legendPane._legendDiv, this)
    },
    Jb.ext("twaver.charts.LegendPaneTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a);
            var b = a.target._data;
            b || (b = a.target.parentNode._data),
            b && (this.legendPane._hiddenMap[b.getId()] ? delete this.legendPane._hiddenMap[b.getId()] : this.legendPane._hiddenMap[b.getId()] = b, this.legendPane._chart.invalidateModel())
        }
    }),
    Ib.network.Network = function(a) {
        Ib.network.Network.superClass.constructor.apply(this, arguments),
        this._elementUIMap = {},
        this._layerMap = {},
        this._layerList = new nd,
        this._view = Wb.createView("auto"),
        this._rootDiv = Wb.createDiv(),
        this._topDiv = Wb.createDiv(),
        this._attachmentDiv = Wb.createDiv(),
        this._layersDiv = Wb.createDiv(),
        this._bottomDiv = Wb.createDiv(),
        this._rootDiv.appendChild(this._bottomDiv),
        this._rootDiv.appendChild(this._layersDiv),
        this._rootDiv.appendChild(this._attachmentDiv),
        this._rootDiv.appendChild(this._topDiv),
        this._view.appendChild(this._rootDiv),
        this.setElementBox(a ? a: new Ib.ElementBox),
        Qb.isMSToucheable ? this.setMSTouchInteractions() : this.setDefaultInteractions(!1);
        var b = this;
        this._flowLink = function() {
            if (! (b.isMovingElement() || b.isSelectingElement() || b.isEditingElement() || b._box._layoutMovingElements)) {
                b._flowLinkQuickFinder || (b._flowLinkQuickFinder = new Ib.QuickFinder(b._box, "link.flow", "style"));
                var a = b._flowLinkQuickFinder.find(!0);
                a.forEach(function(a) {
                    a._styleMap["link.flow.offset"] = b.getLinkFlowOffset(a);
                    var c = b.getElementUI(a);
                    c.drawBody()
                })
            }
        },
        this.setToolTipEnabled(Dd.NETWORK_TOOLTIP_ENABLED),
        this._view.addEventListener("scroll",
        function(a) {
            oc.twm(b)
        }),
        this.addPropertyChangeListener(function(a) {
            "zoom" === a.property && oc.twm(b)
        })
    },
    Jb.ext("twaver.network.Network", Ib.controls.View, {
        __accessor: ["selectMode", "makeVisibleOnSelected", "movableFunction", "editPointSize", "editPointFillColor", "editPointOutlineWidth", "editPointOutlineColor", "editLineColor", "editLineWidth", "resizePointSize", "resizePointFillColor", "resizePointOutlineWidth", "resizePointOutlineColor", "resizeLineColor", "resizeLineWidth", "rotatePointSize", "rotatePointFillColor", "rotatePointOffset", "rotatePointOutlineWidth", "rotatePointOutlineColor", "rotateScaleFillColor", "rotateScaleFontColor", "rotateScaleWidth", "rotateScaleHeight", "selectOutlineColor", "selectOutlineWidth", "selectFillColor", "lazyMoveOutlineColor", "lazyMoveOutlineWidth", "lazyMoveFillColor", "rectSelectFilter", "selectionTolerance"],
        __bool: ["doubleClickToUpSubNetwork", "doubleClickToSubNetwork", "doubleClickToEmptySubNetwork", "doubleClickToLinkBundle", "doubleClickToGroupExpand", "subNetworkAnimate", "lazyMoveAnimate", "resizeAnimate", "noAgentLinkVisible", "keyboardRemoveEnabled", "keyboardSelectEnabled", "sendToTopOnSelected", "lazyMoveFill", "editingElement", "rotatingElement", "movingElement", "selectingElement", "rectSelectEnabled", "limitElementInPositiveLocation", "showRotateScale", "transparentSelectionEnable"],
        _viewRect: {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        _currentSubNetwork: null,
        _selectMode: Dd.NETWORK_SELECT_MODE,
        _noAgentLinkVisible: Dd.NETWORK_NO_AGENT_LINK_VISIBLE,
        _makeVisibleOnSelected: Dd.NETWORK_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Dd.NETWORK_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Dd.NETWORK_KEYBOARD_SELECT_ENABLED,
        _rectSelectEnabled: Dd.NETWORK_RECT_SELECT_ENABLED,
        _rectSelectFilter: null,
        _subNetworkAnimate: Dd.NETWORK_SUBNETWORK_ANIMATE,
        _transparentSelectable: Dd.NETWORK_TRANSPARENT_SELECTABLE,
        _removeElementUIOnInvisible: Dd.NETWORK_REMOVE_ELEMENTUI_ON_INVISIBLE,
        _elementUIFunction: Dd.ELEMENTUI_FUNCTION,
        _doubleClickToUpSubNetwork: Dd.NETWORK_DOUBLECLICK_TO_UPSUBNETWORK,
        _doubleClickToSubNetwork: Dd.NETWORK_DOUBLECLICK_TO_SUBNETWORK,
        _doubleClickToEmptySubNetwork: Dd.NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK,
        _doubleClickToLinkBundle: Dd.NETWORK_DOUBLECLICK_TO_LINKBUNDLE,
        _doubleClickToGroupExpand: Dd.NETWORK_DOUBLECLICK_TO_GROUPEXPAND,
        _sendToTopOnSelected: Dd.NETWORK_SENDTOTOP_ON_SELECTED,
        _selectOutlineColor: Dd.NETWORK_SELECT_OUTLINE_COLOR,
        _selectOutlineWidth: Dd.NETWORK_SELECT_OUTLINE_WIDTH,
        _selectFillColor: Dd.NETWORK_SELECT_FILL_COLOR,
        _lazyMoveOutlineColor: Dd.NETWORK_LAZYMOVE_OUTLINE_COLOR,
        _lazyMoveOutlineWidth: Dd.NETWORK_LAZYMOVE_OUTLINE_WIDTH,
        _lazyMoveFillColor: Dd.NETWORK_LAZYMOVE_FILL_COLOR,
        _lazyMoveFill: Dd.NETWORK_LAZYMOVE_FILL,
        _lazyMoveAnimate: Dd.NETWORK_LAZYMOVE_ANIMATE,
        _editPointSize: Dd.NETWORK_EDIT_POINT_SIZE,
        _editPointFillColor: Dd.NETWORK_EDIT_POINT_FILL_COLOR,
        _editPointOutlineColor: Dd.NETWORK_EDIT_POINT_OUTLINE_COLOR,
        _editPointOutlineWidth: Dd.NETWORK_EDIT_POINT_OUTLINE_WIDTH,
        _editLineColor: Dd.NETWORK_EDIT_LINE_COLOR,
        _editLineWidth: Dd.NETWORK_EDIT_LINE_WIDTH,
        _resizePointSize: Dd.NETWORK_RESIZE_POINT_SIZE,
        _resizePointFillColor: Dd.NETWORK_RESIZE_POINT_FILL_COLOR,
        _resizePointOutlineColor: Dd.NETWORK_RESIZE_POINT_OUTLINE_COLOR,
        _resizePointOutlineWidth: Dd.NETWORK_RESIZE_POINT_OUTLINE_WIDTH,
        _resizeLineColor: Dd.NETWORK_RESIZE_LINE_COLOR,
        _resizeLineWidth: Dd.NETWORK_RESIZE_LINE_WIDTH,
        _resizeAnimate: Dd.NETWORK_RESIZE_ANIMATE,
        _rotatePointSize: Dd.NETWORK_ROTATE_POINT_SIZE,
        _rotatePointFillColor: Dd.NETWORK_ROTATE_POINT_FILL_COLOR,
        _rotatePointOffset: Dd.NETWORK_ROTATE_POINT_OFFSET,
        _rotatePointOutlineWidth: Dd.NETWORK_ROTATE_POINT_OUTLINE_WIDTH,
        _rotatePointOutlineColor: Dd.NETWORK_ROTATE_POINT_OUTLINE_COLOR,
        _rotateScaleWidth: Dd.NETWORK_ROTATE_SCALE_WIDTH,
        _rotateScaleHeight: Dd.NETWORK_ROTATE_SCALE_HEIGHT,
        _rotateScaleFillColor: Dd.NETWORK_ROTATE_SCALE_FILL_COLOR,
        _rotateScaleFontColor: Dd.NETWORK_ROTATE_SCALE_FONT_COLOR,
        _limitElementInPositiveLocation: Dd.NETWORK_LIMIT_ELEMENT_INPOSITIVE_LOCATION,
        _linkFlowInterval: Dd.NETWORK_LINK_FLOW_INTERVAL,
        _selectionTolerance: Dd.NETWORK_SELECTION_TOLERANCE,
        _invalidate: !1,
        _invalidateElementVisibility: !1,
        _invalidateElementIndex: !1,
        _isEditingElement: !1,
        _isRotatingElement: !1,
        _isMovingElement: !1,
        _isSelectingElement: !1,
        _hasEditInteraction: !1,
        _showRotateScale: !0,
        _transparentSelectionEnable: Ib.Defaults.NETWORK_TRANSPARENT_SELECTION_ENABLE,
        getLabel: function(a) {
            return a.getStyle("network.label") || a.getName()
        },
        isToolTipEnabled: function() {
            return this._toolTipEnabled ? !0 : !1
        },
        setToolTipEnabled: function(a) {
            if (this._toolTipEnabled = a, a) {
                if (!this._toolTipListener) {
                    var b = this;
                    this._toolTipListener = function(a) {
                        var c = b.getElementAt(a);
                        if (b._preElement !== c) if (b._preElement = c, c) {
                            var d = b.getToolTip(c);
                            Bc.showToolTip({
                                x: a.pageX,
                                y: a.pageY
                            },
                            d);
                            var e = Bc.getToolTipDiv();
                            if (e.children.length > 0) {
                                var f = b._view.getBoundingClientRect(),
                                g = e.getBoundingClientRect();
                                g.width + g.left > f.width + f.left && (e.style.left = f.width + f.left - g.width + (Ob.documentElement.scrollLeft || Ob.body.scrollLeft) + "px"),
                                g.height + g.top > f.height + f.top && (e.style.top = f.height + f.top - g.height + (Ob.documentElement.scrollTop || Ob.body.scrollTop) + "px")
                            }
                        } else Bc.hideToolTip()
                    },
                    this._view.addEventListener("mousemove", this._toolTipListener, !0),
                    this.firePropertyChange("toolTipEnabled", !1, !0)
                }
            } else this._toolTipListener && (Bc.hideToolTip(), this._view.removeEventListener("mousemove", this._toolTipListener, !0), delete this._toolTipListener, this.firePropertyChange("toolTipEnabled", !0, !1))
        },
        isLinkFlowEnabled: function() {
            return this._linkFlowEnabled ? !0 : !1
        },
        setLinkFlowEnabled: function(a) {
            a ? (this._linkFlowEnabled || (this._linkFlowEnabled = !0, this.firePropertyChange("linkFlowEnabled", !1, !0)), clearInterval(this._linkFlowTimerId), this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval)) : (this._linkFlowEnabled && (this._linkFlowEnabled = !1, this.firePropertyChange("linkFlowEnabled", !0, !1)), clearInterval(this._linkFlowTimerId), delete this._linkFlowTimerId)
        },
        getLinkFlowInterval: function() {
            return this._linkFlowInterval
        },
        setLinkFlowInterval: function(a) {
            var b = this._linkFlowInterval;
            this._linkFlowInterval = a,
            this.firePropertyChange("linkFlowInterval", b, a),
            clearInterval(this._linkFlowTimerId),
            this.isLinkFlowEnabled() && (this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval))
        },
        getTopDiv: function() {
            return this._topDiv
        },
        getAttachmentDiv: function() {
            return this._attachmentDiv
        },
        getLayersDiv: function() {
            return this._layersDiv
        },
        getBottomDiv: function() {
            return this._bottomDiv
        },
        validateImpl: function() {
            if (oc.twm(this), this.__lics__) {
                var a = 0,
                b = null,
                c = null,
                d = null,
                e = this._invalidateElementVisibility;
                if (this._invalidateElementVisibility && (this._invalidateElementVisibility = !1, this._removeElementUIOnInvisible && (this._invalidateElementIndex = !0), this.forEachElementUI(function(e) {
                    e.validate();
                    var f = e.getElement();
                    if (e.setVisible(this.isVisible(f)), this._removeElementUIOnInvisible) {
                        if (b = this.getLayerDivByElement(f), e.isVisible()) {
                            if (e.getView().parentNode !== b) for (b.appendChild(e.getView()), c = e.getAttachments(), a = 0; a < c.size(); a++) d = c.get(a),
                            d.isShowInAttachmentDiv() && this._attachmentDiv.appendChild(d.getView())
                        } else if (e.getView().parentNode === b) for (b.removeChild(e.getView()), c = e.getAttachments(), a = 0; a < c.size(); a++) d = c.get(a),
                        d.isShowInAttachmentDiv() && this._attachmentDiv.removeChild(d.getView())
                    } else if (!e.getView().parentNode) for (b = this.getLayerDivByElement(f), b.appendChild(e.getView()), c = e.getAttachments(), a = 0; a < c.size(); a++) d = c.get(a),
                    d.isShowInAttachmentDiv() && this._attachmentDiv.appendChild(d.getView())
                },
                null, this)), this._invalidateElementIndex) {
                    this._invalidateElementIndex = !1;
                    var f, g = this;
                    this._box.getLayerBox().forEachByDepthFirst(function(a) {
                        var b, c = g._layerMap[a.getId()];
                        g._box.forEachByLayer(function(a) {
                            var d = g._elementUIMap[a.getId()];
                            if (d && d.getView().parentNode === c) {
                                b = Wb.insertAfter(d.getView(), b);
                                for (var e = d.getAttachments(), h = 0; h < e.size(); h++) {
                                    var i = e.get(h);
                                    i.getView().parentNode === g._attachmentDiv && (f = Wb.insertAfter(i.getView(), f))
                                }
                            }
                        },
                        a)
                    })
                }
                if (e && !this._invalidateElementVisibility) {
                    var h;
                    for (var i in this._elementUIMap) {
                        var j = this._elementUIMap[i];
                        j.isVisible() && (h = Tb.unionRect(h, j.getViewRect()))
                    }
                    if (h = h ? {
                        x: 0,
                        y: 0,
                        width: h.x + h.width,
                        height: h.y + h.height
                    }: {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    },
                    h.x !== this._viewRect.x || h.y !== this._viewRect.y || h.width !== this._viewRect.width || h.height !== this._viewRect.height) {
                        var k = this._viewRect;
                        this._viewRect = h,
                        this._rootDiv.style.left = "0px",
                        this._rootDiv.style.top = "0px",
                        this._rootDiv.style.width = h.width + "px",
                        this._rootDiv.style.height = h.height + "px",
                        this.firePropertyChange("viewRect", k, h)
                    }
                }
            }
        },
        setInteractions: function(a) {
            var b = this._interactions;
            b && b.forEach(function(a) {
                a.tearDown()
            }),
            this._interactions = a,
            a && a.forEach(function(a) {
                a.setUp()
            }),
            this.invalidateSelectedElementUIs(!0),
            this.firePropertyChange("interactions", b, a)
        },
        getInteractions: function() {
            return this._interactions
        },
        upSubNetwork: function(a, b) {
            this._currentSubNetwork && this.setCurrentSubNetwork(vc.getSubNetwork(this._currentSubNetwork), a, b)
        },
        sendToTop: function(a) {
            if (this.isVisible(a)) {
                for (var b = a; this.isVisible(b.getParent()) && (b = b.getParent()););
                b !== a && this._box.adjustElementIndex(b),
                this._box.adjustElementIndex(a)
            }
        },
        invalidateElementIndex: function() {
            this._invalidateElementIndex || (this._invalidateElementIndex = !0, this.invalidate())
        },
        invalidateElementVisibility: function() {
            this._invalidateElementVisibility || (this._invalidateElementVisibility = !0, this.invalidate())
        },
        updateLayers: function() {
            Wb.clear(this._layersDiv),
            Wb.clear(this._attachmentDiv),
            this._layerMap = {},
            this._layerList.clear();
            var a = this;
            this._box.getLayerBox().forEachByDepthFirst(function(b) {
                var c = Wb.createDiv();
                Wb.setVisible(c, b.isVisible()),
                a._layerMap[b.getId()] = c,
                a._layersDiv.appendChild(c),
                a._layerList.add(b)
            }),
            this._box.forEach(this.createElementUI, this)
        },
        getCurrentSubNetwork: function() {
            return this._currentSubNetwork
        },
        setCurrentSubNetwork: function(a, b, c) {
            var d = Ib.animate.AnimateManager;
            if (d.endAnimate(), b) {
                if (this._currentSubNetwork === a) return;
                if (a && !this._box.contains(a)) throw a + " is not contained in this network's elementBox";
                d.start(new Ib.animate.AnimateSubNetwork(this, a, c))
            } else this._setCurrentSubNetwork(a),
            c && c()
        },
        _setCurrentSubNetwork: function(a) {
            if (this._currentSubNetwork !== a) {
                if (a && !this._box.contains(a)) throw a + " is not contained in this network's elementBox";
                var b = this._currentSubNetwork;
                this._currentSubNetwork = a,
                this.firePropertyChange("currentSubNetwork", b, a),
                this.invalidateElementVisibility()
            }
        },
        isVisible: function(a) {
            if (!this._box.contains(a)) return ! 1;
            if (!a.isVisible()) return ! 1;
            if (this._visibleFunction && !this._visibleFunction(a)) return ! 1;
            if (!this._box.getLayerBox().getLayerByElement(a).isVisible()) return ! 1;
            if (vc.getSubNetwork(a) !== this._currentSubNetwork) return ! 1;
            if (a instanceof Ib.Link) {
                if (!this.isNoAgentLinkVisible()) {
                    if (!a.getFromAgent() || !a.getToAgent()) return ! 1;
                    if (!this.isVisible(a.getFromAgent()) || !this.isVisible(a.getToAgent())) return ! 1
                }
                if (a.getBundleIndex() > 0 && a.getBundleCount() > 1 && !a.getStyle("link.bundle.expanded")) return ! 1
            } else for (var b = a.getParent(); b && !b.ISubNetwork;) {
                if (b instanceof Md && (!b.isExpanded() || !this.isVisible(b))) return ! 1;
                b = b.getParent()
            }
            return a.IDummy ? !1 : !0
        },
        isMovable: function(a) {
            return this._box.contains(a) ? a instanceof Ib.Link ? !1 : this._movableFunction && !this._movableFunction(a) ? !1 : this._box.getLayerBox().getLayerByElement(a).isMovable() : !1
        },
        isEditable: function(a) {
            return this._box.contains(a) ? this._editableFunction && !this._editableFunction(a) ? !1 : this._box.getLayerBox().getLayerByElement(a).isEditable() : !1
        },
        isRotatable: function(a) {
            return this._rotatableFunction && !this._rotatableFunction(a) ? !1 : !0
        },
        getVisibleFunction: function() {
            return this._visibleFunction
        },
        setVisibleFunction: function(a) {
            var b = this._visibleFunction;
            this._visibleFunction = a,
            this.firePropertyChange("visibleFunction", b, a),
            this.invalidateElementVisibility()
        },
        getEditableFunction: function() {
            return this._editableFunction
        },
        setEditableFunction: function(a) {
            var b = this._editableFunction;
            this._editableFunction = a,
            this.firePropertyChange("editableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        getRotatableFunction: function() {
            return this._rotatableFunction
        },
        setRotatableFunction: function(a) {
            var b = this._rotatableFunction;
            this._rotatableFunction = a,
            this.firePropertyChange("rotatableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        isLinkable: function(a) {
            return null == this._linkableFunction || this._linkableFunction(a)
        },
        getLinkableFunction: function() {
            return this._linkableFunction
        },
        setLinkableFunction: function(a) {
            var b = this._linkableFunction;
            this._linkableFunction = a,
            this.firePropertyChange("linkableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        onShareSelectionModelChanged: function() {
            this.invalidateElementUIs()
        },
        getElementBox: function() {
            return this._box
        },
        setElementBox: function(a) {
            if (!a) throw "ElementBox can not be null";
            if (this._box !== a) {
                var b = this._box;
                b && (b.removeDataBoxChangeListener(this.handleElementBoxChange, this), b.removeDataPropertyChangeListener(this.handleElementPropertyChange, this), b.removePropertyChangeListener(this.handleElementBoxPropertyChange, this), b.removeIndexChangeListener(this.handleIndexChange, this), b.getLayerBox().removeDataBoxChangeListener(this.handleLayerBoxChange, this), b.getLayerBox().removeDataPropertyChangeListener(this.handleLayerPropertyChange, this), b.getLayerBox().removeHierarchyChangeListener(this.handleLayerHierarchyChange, this), this._selectionModel || b.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this)),
                this._box = a,
                this._box.addDataBoxChangeListener(this.handleElementBoxChange, this),
                this._box.addDataPropertyChangeListener(this.handleElementPropertyChange, this),
                this._box.addPropertyChangeListener(this.handleElementBoxPropertyChange, this),
                this._box.addIndexChangeListener(this.handleIndexChange, this),
                this._box.getLayerBox().addDataBoxChangeListener(this.handleLayerBoxChange, this),
                this._box.getLayerBox().addDataPropertyChangeListener(this.handleLayerPropertyChange, this),
                this._box.getLayerBox().addHierarchyChangeListener(this.handleLayerHierarchyChange, this),
                this._flowLinkQuickFinder && (this._flowLinkQuickFinder.dispose(), this._flowLinkQuickFinder = new Ib.QuickFinder(this._box, "link.flow", "style")),
                this._selectionModel ? this._selectionModel._setDataBox(a) : this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
                this._elementUIMap = {},
                this.updateLayers(),
                this.invalidateElementVisibility(),
                this.firePropertyChange("elementBox", b, this._box)
            }
        },
        invalidateElementUI: function(a, b) {
            var c = this.getElementUI(a);
            c && c.invalidate(b)
        },
        invalidateElementUIs: function(a) {
            for (var b in this._elementUIMap) {
                var c = this._elementUIMap[b];
                c.invalidate(a)
            }
        },
        invalidateSelectedElementUIs: function(a) {
            this.getSelectionModel().getSelection().forEach(function(b) {
                this.invalidateElementUI(b, a)
            },
            this)
        },
        getElementUI: function(a) {
            return a ? this._elementUIMap[a.getId()] : null
        },
        getLayerDivByElement: function(a) {
            var b = this._box.getLayerBox().getLayerByElement(a);
            return b ? this._layerMap[b.getId()] : null
        },
        createElementUI: function(a) {
            var b = this._elementUIMap[a.getId()];
            if (b || (b = this._elementUIFunction(this, a), b && (this._elementUIMap[a.getId()] = b)), b) {
                var c = this.getLayerDivByElement(a);
                b.getView().parentNode !== c && (c.appendChild(b.getView()), b.getAttachments().forEach(function(a) {
                    a.isShowInAttachmentDiv() && a.getView().parentNode !== this._attachmentDiv && this._attachmentDiv.appendChild(a.getView())
                },
                this)),
                this.invalidateElementIndex()
            }
        },
        invalidateBundleLink: function(a) {
            if (a instanceof Ib.Link && a._bundleLinks) {
                var b = this._elementUIMap;
                a._bundleLinks.forEachSiblingLink(function(c) {
                    if (c !== a) {
                        var d = b[c._id];
                        d && d.invalidate(!1)
                    }
                },
                this)
            }
        },
        handleLayerBoxChange: function(a) {
            this.updateLayers(),
            this.invalidateElementVisibility()
        },
        handleLayerPropertyChange: function(a) {
            var b = a.source;
            if ("visible" === a.property) {
                var c = this._layerMap[b.getId()];
                Wb.setVisible(c, b.isVisible())
            } else "editable" === a.property && this.invalidateSelectedElementUIs(!0);
            this.invalidateElementVisibility()
        },
        handleLayerHierarchyChange: function(a) {
            var b;
            this._layerList.clear(),
            this._box.getLayerBox().forEachByDepthFirst(function(a) {
                var c = this._layerMap[a.getId()];
                b = Wb.insertAfter(c, b),
                this._layerList.add(a)
            },
            null, this),
            this.invalidateElementVisibility()
        },
        handleSelectionChange: function(a) {
            a.datas.forEach(function(b) {
                var c = this.getElementUI(b);
                c && c.handleSelectionChange(a)
            },
            this),
            this.invalidateElementVisibility();
            var b = this.getSelectionModel().getLastData();
            b && ("append" === a.kind || "set" === a.kind) && (this.isMakeVisibleOnSelected() && this.makeVisible(b), this.isSendToTopOnSelected() && this.sendToTop(b))
        },
        makeVisible: function(a) {
            var b = this.getElementUI(a);
            if (b) {
                var c = vc.getSubNetwork(a);
                if (c !== this._currentSubNetwork) {
                    var d = this;
                    return void this.setCurrentSubNetwork(c, this.isSubNetworkAnimate(),
                    function() {
                        Jb.callLater(d.makeVisible, d, [a])
                    })
                }
                for (var e = a; (e = e.getParent()) && e !== c;) e instanceof Md && e.setExpanded(!0);
                var f = b.getUnionBodyBounds();
                if (f) {
                    var g = {
                        x: this._view.scrollLeft / this._zoom,
                        y: this._view.scrollTop / this._zoom,
                        width: this._view.clientWidth / this._zoom,
                        height: this._view.clientHeight / this._zoom
                    };
                    Tb.intersects(g, f) || this.isVisible(a) && Jb.callLater(this.centerByLogicalPoint, this, [f.x + f.width / 2, f.y + f.height / 2])
                }
            }
        },
        handleElementBoxChange: function(a) {
            var b = a.data;
            if ("add" === a.kind) this.createElementUI(b),
            this.invalidateBundleLink(b);
            else if ("remove" === a.kind) {
                var c = this.getElementUI(b);
                if (c) {
                    var d = this._box.getLayerBox().getLayerByElement(b),
                    e = this._layerMap[d.getId()];
                    c.getView().parentNode === e && e.removeChild(c.getView()),
                    c.dispose(),
                    delete this._elementUIMap[b.getId()]
                }
                b === this._currentSubNetwork && null != this._currentSubNetwork && this._setCurrentSubNetwork(null)
            } else "clear" === a.kind && (this.forEachElementUI(function(a) {
                a.dispose()
            }), this._elementUIMap = {},
            this.updateLayers(), null != this._currentSubNetwork && this._setCurrentSubNetwork(null));
            this.invalidateElementVisibility()
        },
        handleElementPropertyChange: function(a) {
            var b = a.source,
            c = this.getElementUI(b);
            if (c && (c.handlePropertyChange(a), "layerId" === a.property)) {
                var d = this._box.getLayerBox().getLayerByElement(b),
                e = this._layerMap[d.getId()];
                c.getView().parentNode !== e && (e.appendChild(c.getView()), this.invalidateElementIndex())
            }
            this.invalidateBundleLink(b),
            this.invalidateElementVisibility()
        },
        handleElementBoxPropertyChange: function(a) {
            this.invalidateElementVisibility()
        },
        handleIndexChange: function(a) {
            this.invalidateElementIndex()
        },
        getElementUIFunction: function() {
            return this._elementUIFunction
        },
        setElementUIFunction: function(a) {
            if (!a) throw "ElementUIFunction can not be null";
            if (this._elementUIFunction !== a) {
                var b = this._elementUIFunction;
                this._elementUIFunction = a,
                this.firePropertyChange("elementUIFunction", b, a),
                this._box.isEmpty() || this.updateLayers()
            }
        },
        getIconsNames: function(a) {
            return a.getStyle("icons.names")
        },
        getIconsColors: function(a) {
            return a.getStyle("icons.colors")
        },
        getLinkHandlerLabel: function(a) {
            return a.isBundleAgent() ? "+(" + a.getBundleCount() + ")": null
        },
        getSelectColor: function(a) {
            return a.getStyle("select.color")
        },
        getShadowColor: function(a) {
            var b = a.getStyle("shadow.color");
            return ! b && this.isSelected(a) && "shadow" === a.getStyle("select.style") ? a.getStyle("select.color") : b
        },
        getAlarmLabel: function(a) {
            var b = a.getAlarmState().getHighestNewAlarmSeverity();
            if (b) {
                var c = a.getAlarmState().getNewAlarmCount(b) + b.nickName;
                return a.getAlarmState().hasLessSevereNewAlarms() && (c += "+"),
                c
            }
            return null
        },
        isRemoveElementUIOnInvisible: function() {
            return this._removeElementUIOnInvisible
        },
        setRemoveElementUIOnInvisible: function(a) {
            var b = this._removeElementUIOnInvisible;
            this._removeElementUIOnInvisible = a,
            this.firePropertyChange("removeElementUIOnInvisible", b, a),
            this.invalidateElementVisibility()
        },
        setDefaultInteractions: function(a, b) {
            var c = [new Ib.network.interaction.SelectInteraction(this), new Ib.network.interaction.MoveInteraction(this, a), new Ib.network.interaction.DefaultInteraction(this), new Ib.network.interaction.TouchInteraction(this)];
            b && c.push(new Ib.network.interaction.MoveLinkInteraction(this, a)),
            this.setInteractions(c)
        },
        setPanInteractions: function() {
            this.setInteractions([new Ib.network.interaction.PanInteraction(this), new Ib.network.interaction.DefaultInteraction(this)])
        },
        setEditInteractions: function(a, b) {
            var c = [new Ib.network.interaction.SelectInteraction(this), new Ib.network.interaction.EditInteraction(this, a), new Ib.network.interaction.MoveInteraction(this, a), new Ib.network.interaction.DefaultInteraction(this)];
            b && c.push(new Ib.network.interaction.MoveLinkInteraction(this, a)),
            this.setInteractions(c)
        },
        setCreateElementInteractions: function(a) {
            this.setInteractions([new Ib.network.interaction.CreateElementInteraction(this, a), new Ib.network.interaction.DefaultInteraction(this)])
        },
        setCreateLinkInteractions: function(a) {
            this.setInteractions([new Ib.network.interaction.CreateLinkInteraction(this, a), new Ib.network.interaction.DefaultInteraction(this)])
        },
        setCreateShapeLinkInteractions: function(a) {
            this.setInteractions([new Ib.network.interaction.CreateShapeLinkInteraction(this, a), new Ib.network.interaction.DefaultInteraction(this)])
        },
        setCreateShapeNodeInteractions: function(a) {
            this.setInteractions([new Ib.network.interaction.CreateShapeNodeInteraction(this, a), new Ib.network.interaction.DefaultInteraction(this)])
        },
        setTouchInteractions: function() {
            this.setDefaultInteractions(!1)
        },
        setMSTouchInteractions: function() {
            this.setInteractions([new Ib.network.interaction.MSTouchInteraction(this)])
        },
        setMagnifyInteractions: function() {
            this.setInteractions([new Ib.network.interaction.SelectInteraction(this), new Ib.network.interaction.MoveInteraction(this), new Ib.network.interaction.DefaultInteraction(this), new Ib.network.interaction.MagnifyInteraction(this)])
        },
        hasEditInteraction: function() {
            return this._hasEditInteraction
        },
        setHasEditInteraction: function(a) {
            var b = this._hasEditInteraction;
            this._hasEditInteraction = a,
            this.firePropertyChange("hasEditInteraction", b, a);
        },
        moveSelectedElements: function(a, b, c, d) {
            if (0 !== a || 0 !== b) {
                var e = this.getMovableSelectedElementsRect();
                null != e && (this._limitElementInPositiveLocation && (e.x + a < 0 && (a = -e.x), e.y + b < 0 && (b = -e.y)), Ib.Util.moveElements(this.getMovableSelectedElements(), a, b, c, d, this))
            }
        },
        getMovableSelectedElements: function() {
            return this.getSelectionModel().toSelection(function(a) {
                return this.isMovable(a)
            },
            this)
        },
        hasMovableSelectedElements: function() {
            for (var a = this.getSelectionModel().getSelection(), b = 0; b < a.size(); b++) {
                var c = a.get(b);
                if (this.isMovable(c)) return ! 0
            }
            return ! 1
        },
        getMovableSelectedElementsRect: function() {
            var a = this.getMovableSelectedElements();
            if (0 === a.size()) return null;
            for (var b = null,
            c = 0,
            d = a.size(); d > c; c++) {
                var e = a.get(c);
                if (e instanceof Kd) {
                    var f = this.getElementUI(e);
                    f && (b = Tb.unionRect(b, f.getViewRect()))
                }
            }
            return b
        },
        getLayerByElement: function(a) {
            return this._box.getLayerBox().getLayerByElement(a)
        },
        getPosition: function(a, b, c, d, e) {
            var f, g = b instanceof Ib.network.ElementUI ? b: this.getElementUI(b);
            if (g) if ("from" === a || "to" === a) {
                if (g.getFromPosition && (f = "from" === a ? g.getFromPosition(d, e) : g.getToPosition(d, e))) return {
                    x: f.x - c.width / 2,
                    y: f.y - c.height / 2
                }
            } else f = "hotspot" === a ? g.getHotSpot() : Vb.get(a, g.getBodyRect(), c);
            if (!f && b.getRect && (f = Vb.get(a, b.getRect(), c)), f) return {
                x: f.x + d,
                y: f.y + e
            };
            throw "position '" + a + "' object '" + b + "'"
        },
        getViewRect: function() {
            return this._viewRect ? Jb.clone(this._viewRect) : {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        },
        forEachElementUI: function(a, b, c) {
            b ? this._box.forEachReverse(function(d) {
                if (this.getLayerByElement(d) === b) {
                    var e = this.getElementUI(d);
                    e && (c ? a.call(c, e) : a(e))
                }
            },
            this) : this._layerList.forEachReverse(function(b) {
                this.forEachElementUI(a, b, c)
            },
            this)
        },
        findFirstElement: function(a, b) {
            for (var c = this._layerList.size() - 1, d = this._box.size() - 1, e = c; e >= 0; e--) for (var f = this._layerList.get(e), g = d; g >= 0; g--) {
                var h = this._box.getDataAt(g);
                if (this.getLayerByElement(h) === f) if (b) {
                    if (a.call(b, h) === !0) return h
                } else if (a(h) === !0) return h
            }
            return null
        },
        getElementAt: function(a, b) {
            if (1 === arguments.length && (b = !0), !this.isValidEvent(a)) return null;
            a = this._getPoint(a),
            a || console.log("null");
            var c = a.x,
            d = a.y,
            e = this._selectionTolerance;
            if (e && e > 0) {
                var f = {
                    x: c,
                    y: d,
                    width: 0,
                    height: 0
                };
                Tb.grow(f, e, e)
            }
            return this.findFirstElement(function(a) {
                if (b && !this.isSelectable(a)) return ! 1;
                var e = this.getElementUI(a);
                return e ? f ? !!e.intersectsTest(f) : !!e.hitTest(c, d) : !1
            },
            this)
        },
        _getPoint: function(a) {
            return a ? a.target ? this.getLogicalPoint(a) : a: null
        },
        getElementsAtRect: function(a, c, d, e) {
            var f = new nd;
            return e = e === b ? !0 : e,
            this.forEachElementUI(function(b) {
                b.isVisible() && (!d || d(b._element)) && (e && this.isSelectable(b._element) || !e) && (c ? b.intersectsTest(a) && f.add(b._element) : Tb.contains(a, b.getViewRect()) && f.add(b._element))
            },
            null, this),
            f
        },
        hitTest: function(a) {
            var b = this.getElementAt(a);
            if (!b) return null;
            var c = this.getElementUI(b);
            return c ? (a = this._getPoint(a), c.hitTest(a.x, a.y)) : null
        },
        addElementByInteraction: function(a) {
            a.getParent() || a.setParent(this._currentSubNetwork),
            this._box.add(a),
            this.getSelectionModel().setSelection(a),
            this.fireInteractionEvent({
                kind: "createElement",
                element: a
            })
        },
        getLinkFlowStepping: function(a) {
            var b = parseInt(a.getStyle("link.flow.stepping"));
            return b || (b = Dd.NETWORK_LINK_FLOW_STEPPING),
            b
        },
        getLinkFlowOffset: function(a) {
            var b = a.getStyle("link.flow.offset");
            return isNaN(b) && (b = 0),
            b + this.getLinkFlowStepping(a)
        },
        toCanvas: function(a, b, c) {
            c || (c = Wb.createCanvas()),
            c.setAttribute("width", a),
            c.setAttribute("height", b),
            c._viewRect ? (c._viewRect.width = a, c._viewRect.height = b) : c._viewRect = {
                x: 0,
                y: 0,
                width: a,
                height: b
            };
            var d = c.getContext("2d");
            if (d.clearRect(0, 0, a, b), 0 === this._view.clientWidth || 0 === this._view.clientHeight) return c;
            var e = a / this._view.scrollWidth * this._zoom,
            f = b / this._view.scrollHeight * this._zoom;
            return d.scale(e, f),
            Wb.forEach(this._view,
            function(a) {
                if (("CANVAS" === a.tagName || "IMG" === a.tagName) && !a._isIgnored) {
                    var b = a._viewRect;
                    if (b) try {
                        d.drawImage(a, b.x, b.y, b.width, b.height)
                    } catch(a) {}
                }
            }),
            c
        },
        toCanvasByRegion: function(a, b, c) {
            c || (c = Wb.createCanvas());
            var d = a.width * b,
            e = a.height * b;
            c.setAttribute("width", d),
            c.setAttribute("height", e);
            var f = c.getContext("2d");
            return f.clearRect(0, 0, d, e),
            0 === this._view.clientWidth || 0 === this._view.clientHeight ? c: (f.save(), f.scale(b, b), Wb.forEach(this._view,
            function(b) {
                if (("CANVAS" === b.tagName || "IMG" === b.tagName) && !b._isIgnored) {
                    var c = b._viewRect;
                    if (c && Tb.intersects(c, a)) try {
                        f.drawImage(b, c.x - a.x, c.y - a.y, c.width, c.height)
                    } catch(b) {}
                }
            }), f.restore(), c)
        },
        getGroupChildrenRects: function(a) {
            var b = new nd;
            return a.getChildren().forEach(function(a) {
                if (a instanceof Kd) {
                    var c = this.getElementUI(a);
                    if (c) {
                        var d = c.getViewRect();
                        d && b.add(d)
                    }
                }
            },
            this),
            b
        },
        getLinkPathFunction: function() {
            return this._linkPathFunction
        },
        setLinkPathFunction: function(a) {
            var b = this._linkPathFunction;
            this._linkPathFunction = a,
            this.firePropertyChange("linkPathFunction", b, a),
            this.invalidateElementUIs()
        },
        onClickElement: function(a, b) {},
        onClickBackground: function(a) {},
        onDoubleClickElement: function(a, b) {},
        onDoubleClickBackground: function(a) {},
        onLongClickElement: function(a, b) {},
        onLongClickBackground: function(a) {},
        onMouseMove: function(a, b) {},
        onMouseEnter: function(a, b) {},
        onMouseLeave: function(a, b) {},
        setMovingElement: function(a) {
            if (a != this._movingElement) {
                var b = this._movingElement;
                this._movingElement = a,
                this.firePropertyChange("movingElement", b, a),
                this._box._undoManager._enabled && (a ? this._box._undoManager.startBatch() : this._box._undoManager.endBatch())
            }
        },
        setEditingElement: function(a) {
            if (a != this._editingElement) {
                var b = this._editingElement;
                this._editingElement = a,
                this.firePropertyChange("editingElement", b, a),
                this._box._undoManager._enabled && (a ? this._box._undoManager.startBatch() : this._box._undoManager.endBatch())
            }
        }
    }),
    Ib.network.Overview = function(a) {
        Ib.network.Overview.superClass.constructor.apply(this, arguments),
        this._view = Wb.createView(),
        this._rootDiv = Wb.createDiv(),
        this._imageCanvas = Wb.createCanvas(),
        this._imageDiv = Wb.createDiv(),
        this._maskCanvas = Wb.createCanvas(),
        this._selectDiv = Wb.createDiv(),
        this._isNetworkDirty = !1,
        this._isMaskDirty = !1,
        Wb.setVisible(this._selectDiv, !1),
        this._view.appendChild(this._rootDiv),
        this._rootDiv.appendChild(this._imageDiv),
        this._rootDiv.appendChild(this._maskCanvas),
        this._rootDiv.appendChild(this._selectDiv),
        this._imageDiv.appendChild(this._imageCanvas),
        this.setNetwork(a);
        var b;
        b = Qb.isMSToucheable ? Ib.network.OverviewMSTouchInteraction: Qb.isTouchable ? Ib.network.OverviewTouchInteraction: Ib.network.OverviewInteraction,
        b && new b(this)
    },
    Jb.ext("twaver.network.Overview", Ib.controls.ControlBase, {
        __accessor: ["fillColor", "outlineColor", "outlineWidth", "selectColor", "selectWidth", "padding", "maxPackingWidth", "maxPackingHeight"],
        __bool: ["animate"],
        _fillColor: Dd.OVERVIEW_FILL_COLOR,
        _outlineColor: Dd.OVERVIEW_OUTLINE_COLOR,
        _outlineWidth: Dd.OVERVIEW_OUTLINE_WIDTH,
        _selectColor: Dd.OVERVIEW_SELECT_COLOR,
        _selectWidth: Dd.OVERVIEW_SELECT_WIDTH,
        _padding: Dd.OVERVIEW_PADDING,
        _animate: Dd.OVERVIEW_ANIMATE,
        _maxPackingWidth: Dd.OVERVIEW_MAX_PACKING_WIDTH,
        _maxPackingHeight: Dd.OVERVIEW_MAX_PACKING_HEIGHT,
        getNetwork: function() {
            return this._network
        },
        onPropertyChanged: function(a) {
            this._invalidateMask()
        },
        setNetwork: function(a) {
            a !== this._network && (this._network && (this._network.removePropertyChangeListener(this._handleNetworkPropertyChange, this), this._network.removeViewListener(this._handleNetworkViewChange, this), Wb.removeEventListener("scroll", "_handleScrollChange", this._network.getView(), this)), this._network = a, this._network && (this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this), this._network.addViewListener(this._handleNetworkViewChange, this), Wb.addEventListener("scroll", "_handleScrollChange", this._network.getView(), this)), this.invalidate())
        },
        _handleNetworkPropertyChange: function(a) { ("zoom" === a.property || "currentSubNetwork" === a.property || "elementBox" === a.property || "dataBox" === a.property) && this.invalidate()
        },
        _handleNetworkViewChange: function(a) {
            "validateEnd" === a.kind && this.invalidate()
        },
        _handleScrollChange: function() {
            this._invalidateMask()
        },
        invalidate: function(a) {
            this._isNetworkDirty && this._isMaskDirty || (this._isNetworkDirty || (this._isNetworkDirty = !0), this._isMaskDirty || (this._isMaskDirty = !0), Jb.callLater(this.validate, this, null, a))
        },
        _invalidateMask: function() {
            this._isMaskDirty || (this._isMaskDirty = !0, Jb.callLater(this.validate, this, [], 100))
        },
        validate: function() {
            if ((this._isMaskDirty || this._isNetworkDirty) && this._network && (this._maxPackingWidth > 0 && this._maxPackingHeight > 0 || this._view.clientWidth > 0 && this._view.clientHeight > 0) && 0 !== this._network._view.clientWidth && 0 !== this._network._view.clientHeight) {
                var a, b = this._maxPackingWidth > 0 && this._maxPackingHeight > 0;
                a = b ? {
                    x: 0,
                    y: 0,
                    width: this._maxPackingWidth,
                    height: this._maxPackingHeight
                }: {
                    x: 0,
                    y: 0,
                    width: this._view.clientWidth,
                    height: this._view.clientHeight
                },
                Tb.grow(a, -this._padding, -this._padding);
                var c = Math.min(a.width / this._network._view.scrollWidth, a.height / this._network._view.scrollHeight);
                b && (Wb.setDiv(this._view, {
                    x: 0,
                    y: 0,
                    width: this._imageDiv._viewRect.width,
                    height: this._imageDiv._viewRect.height
                },
                null, 0, null), a.width = this._imageDiv._viewRect.width, a.height = this._imageDiv._viewRect.height);
                var d = this._network._view.scrollWidth * c,
                e = this._network._view.scrollHeight * c,
                f = a.x + (a.width - d) / 2,
                g = a.y + (a.height - e) / 2;
                if (this._isNetworkDirty) {
                    var h = {
                        x: f,
                        y: g,
                        width: d,
                        height: e
                    };
                    this._network.toCanvas(h.width, h.height, this._imageCanvas),
                    Wb.setDiv(this._imageDiv, h, null, 0, null),
                    this._network.getElementBox && (this._imageDiv.style.backgroundColor = (this._network.getCurrentSubNetwork() || this._network.getElementBox()).getStyle("background.color") || ""),
                    this._isNetworkDirty = !1
                }
                if (this._isMaskDirty) {
                    var i = {
                        x: this._network._view.scrollLeft * c,
                        y: this._network._view.scrollTop * c,
                        width: d * this._network._view.clientWidth / this._network._view.scrollWidth,
                        height: e * this._network._view.clientHeight / this._network._view.scrollHeight
                    },
                    j = Wb.setCanvas(this._maskCanvas, f, g, d, e);
                    j.lineWidth = 0,
                    j.fillStyle = this._fillColor,
                    j.beginPath(),
                    Xb.drawVector(j, "rectangle", null, f, g, d, e),
                    j.fill(),
                    j.clearRect(f + i.x, g + i.y, i.width, i.height);
                    var k = this._outlineWidth < 0 ? 0 : this._outlineWidth;
                    j.lineWidth = k,
                    j.strokeStyle = this._outlineColor,
                    j.beginPath(),
                    Xb.drawVector(j, "rectangle", null, f + i.x + k, g + i.y + k, i.width - 2 * k, i.height - 2 * k),
                    k >= 0 && j.stroke(),
                    this._isMaskDirty = !1
                }
            } else this._isNetworkDirty = !1,
            this._isMaskDirty = !1
        },
        getLogicalPoint: function(a) {
            return Wb.getLogicalPoint(this._view, a, 1, this._rootDiv)
        },
        centerNetwork: function(a, b) {
            var c = this._imageDiv._viewRect;
            Tb.containsPoint(c, a) && (this._network.centerByLogicalPoint((a.x - c.x) / c.width * this._network._view.scrollWidth / this._network.getZoom(), (a.y - c.y) / c.height * this._network._view.scrollHeight / this._network.getZoom(), b), this._invalidateMask())
        }
    }),
    Ib.network.OverviewTouchInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.network.OverviewTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            this.clear(),
            this.endPoint = this.overview.getLogicalPoint(a),
            zc.isMultiTouch(a) && (this.distance = zc.getDistance(a), this.zoom = this.network.getZoom()),
            Wb.addEventListener("touchmove", "handleTouchmove", this.view, this),
            Wb.addEventListener("touchend", "handleTouchend", this.view, this)
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), this.moved || (this.moved = !0), this.endPoint = this.overview.getLogicalPoint(a), zc.isSingleTouch(a)) this.overview.centerNetwork(this.endPoint, !1);
            else if (this.distance) {
                var b = zc.getDistance(a) / this.distance;
                this.network.setZoom(this.zoom * b, !1)
            }
        },
        handleTouchend: function(a) {
            if (!this.moved) {
                this.endPoint = this.overview.getLogicalPoint(a);
                var b = this.lastPoint && this.lastTouchStartTime && (new Date).getTime() - this.lastTouchStartTime.getTime() <= 300 && Math.abs(this.endPoint.x - this.lastPoint.x) <= 10 && Math.abs(this.endPoint.y - this.lastPoint.y) <= 10;
                b ? (this.lastPoint = null, this.lastTouchStartTime = null) : (this.lastPoint = this.endPoint, this.lastTouchStartTime = new Date),
                b ? Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]) : this.overview.centerNetwork(this.endPoint, this.overview._animate)
            }
            this.clear()
        },
        clear: function() {
            this.endPoint && (this.endPoint = null, Wb.removeEventListener("touchmove", this.view, this), Wb.removeEventListener("touchend", this.view, this)),
            this.moved = !1
        }
    }),
    Ib.network.OverviewInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        Wb.addEventListener("mousedown", "handleMousedown", this.view, this)
    },
    Jb.ext("twaver.network.OverviewInteraction", Object, {
        handleMousedown: function(a) {
            0 === a.button && (this.clear(), this.endPoint = this.overview.getLogicalPoint(a), Jb.isCtrlDown(a) && (this.startPoint = this.endPoint, Wb.setVisible(this.overview._selectDiv, !0)), Wb.addEventListener("mousemove", "handleMousemove", this.view, this), Wb.addEventListener("mouseup", "handleMouseup", this.view, this))
        },
        handleMouseup: function(a) {
            if (this.endPoint = this.overview.getLogicalPoint(a), "detail" in a && 2 === a.detail) Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            else if (Wb.isVisible(this.overview._selectDiv) && this.startPoint) {
                var b = this.overview._imageDiv._viewRect,
                c = this.overview._selectDiv._viewRect.x,
                d = this.overview._selectDiv._viewRect.y,
                e = b.width / this.overview._selectDiv._viewRect.width,
                f = b.height / this.overview._selectDiv._viewRect.height,
                g = Math.min(e, f),
                h = this.network._view.scrollWidth / this.network.getZoom() * ((c - b.x + this.overview._selectDiv._viewRect.width / 2) / b.width),
                i = this.network._view.scrollHeight / this.network.getZoom() * ((d - b.y + this.overview._selectDiv._viewRect.height / 2) / b.height);
                this.network.setZoom(g * Math.min(this.network._view.clientWidth / this.network._view.scrollWidth, this.network._view.clientHeight / this.network._view.scrollHeight) * this.network.getZoom(), !1),
                Jb.callLater(this.network.centerByLogicalPoint, this.network, [h, i, this.overview._animate]),
                Wb.setVisible(this.overview._selectDiv, !1),
                Wb.setDiv(this.overview._selectDiv, {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                null, 0, null),
                this.startPoint = null
            } else this.overview.centerNetwork(this.endPoint, this.overview._animate);
            this.clear()
        },
        handleMousemove: function(a) {
            var b = this.overview.getLogicalPoint(a);
            if (this.endPoint = b, Wb.isVisible(this.overview._selectDiv) && this.startPoint) {
                var c = b.x > this.startPoint.x ? this.startPoint.x: b.x,
                d = b.x > this.startPoint.x ? this.startPoint.y: b.y;
                b.x > this.startPoint.x && b.y < this.startPoint.y && (d = b.y),
                b.x < this.startPoint.x && b.y > this.startPoint.y && (d = this.startPoint.y);
                var e = this.overview._imageDiv._viewRect;
                c < e.x && (c = e.x),
                c > e.x + e.width && (c = e.x + e.width),
                d < e.y && (d = e.y),
                d > e.y + e.height && (d = e.y + e.height);
                var f = Math.abs(b.x - this.startPoint.x),
                g = Math.abs(b.y - this.startPoint.y);
                c + f > e.x + e.width && (f = e.x + e.width - c),
                d + g > e.y + e.height && (g = e.y + e.height - d),
                Wb.setDiv(this.overview._selectDiv, {
                    x: c,
                    y: d,
                    width: f,
                    height: g
                },
                null, this.overview._selectWidth, this.overview._selectColor)
            } else this.overview.centerNetwork(b, !1)
        },
        clear: function() {
            this.endPoint && (this.endPoint = null, Wb.removeEventListener("mousemove", this.view, this), Wb.removeEventListener("mouseup", this.view, this))
        }
    }),
    Ib.network.OverviewMSTouchInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        this._pointerMap = {},
        this._pointerIdArray = [];
        var b = this;
        this.view.addEventListener("MSPointerDown",
        function(a) {
            b.handleTouchstart(a)
        },
        !1),
        this.view.addEventListener("MSPointerMove",
        function(a) {
            b.handleTouchmove(a)
        },
        !1),
        this.view.addEventListener("MSPointerUp",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.view.addEventListener("MSPointerCancel",
        function(a) {
            b.handleTouchend(a)
        },
        !1)
    },
    Jb.ext("twaver.network.OverviewMSTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            a.isPrimary && this._pointerIdArray.length > 0 && (this._pointerMap = {},
            this._pointerIdArray = []),
            !this._pointerMap[a.pointerId] && this.overview.getLogicalPoint(a) && (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a),
            1 == this._pointerIdArray.length ? (this._startTouchPoint = this.overview.getLogicalPoint(a), this._startTouchTime = new Date) : 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.network.getZoom())
        },
        handleTouchmove: function(a) {
            if (0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10)) if (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length) {
                var b = this._getDistance() / this._distance;
                this.network.setZoom(this._zoom * b, !1)
            } else if (1 == this._pointerIdArray.length && this._startTouchPoint) {
                var c = this.overview.getLogicalPoint(a);
                if (null == c) return;
                this._startTouchPoint = c,
                this.overview.centerNetwork(this._startTouchPoint, !1)
            }
        },
        handleTouchend: function(a) {
            var b = this.overview.getLogicalPoint(a);
            if (1 == this._pointerIdArray.length && b) {
                var c = this._endTouchPoint && this._endTouchTime && (new Date).getTime() - this._endTouchTime.getTime() <= 500 && Tb.getDistance(this._endTouchPoint, b) <= 10;
                c ? (this._endTouchPoint = null, this._endTouchTime = null) : (this._endTouchPoint = b, this._endTouchTime = new Date),
                c ? Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]) : this.overview.centerNetwork(this._endTouchPoint, this.overview._animate)
            }
            this._pointerMap = {},
            this._pointerIdArray = []
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        }
    }),
    Ib.network.ElementUI = function(a, b) {
        this._view = Wb.createDiv(),
        this._bodyView = Wb.createDiv(),
        this._view.appendChild(this._bodyView),
        this._network = a,
        this._element = b,
        this._attachments = new nd,
        this._bodyBounds = new nd,
        this.invalidate(!0)
    },
    Jb.ext("twaver.network.ElementUI", Object, {
        _invalidateFlag: !1,
        _invalidateAttachmentsFlag: !1,
        getElement: function() {
            return this._element
        },
        getNetwork: function() {
            return this._network
        },
        getAttachments: function() {
            return this._attachments
        },
        getStyle: function(a) {
            return this._element.getStyle(a)
        },
        getFont: function(a) {
            var b = this._element.getStyle(a);
            return b ? b: Dd.FONT
        },
        getDyeColor: function(a) {
            return this._innerColor ? this._innerColor: this.getStyle(a)
        },
        getInnerColor: function() {
            return this._innerColor
        },
        getOuterColor: function() {
            return this._outerColor
        },
        getShadowColor: function() {
            return this._shadowColor
        },
        getLabelAttachment: function() {
            return this._labelAttachment
        },
        getAlarmAttachment: function() {
            return this._alarmAttachment
        },
        getIconsAttachment: function() {
            return this._iconsAttachment
        },
        getEditAttachment: function() {
            return this._editAttachment
        },
        getHotSpot: function() {
            return this._hotSpot ? Jb.clone(this._hotSpot) : {
                x: 0,
                y: 0
            }
        },
        setHotSpot: function(a) {
            this._hotSpot = a
        },
        getUnionBodyBounds: function() {
            return Jb.clone(this._unionBodyBounds)
        },
        getBodyRect: function() {
            return this._bodyRect || (this._bodyRect = this.createBodyRect()),
            Jb.clone(this._bodyRect)
        },
        invalidate: function(a) {
            a === b && (a = !0),
            a && (this._invalidateAttachmentsFlag = !0),
            this._invalidateFlag || (this._bodyRect = null, this._invalidateFlag = !0, this._network.invalidateElementVisibility())
        },
        updateMeasure: function() {},
        validate: function() {
            if (this._invalidateFlag) {
                this._invalidateAttachmentsFlag && (this._invalidateAttachmentsFlag = !1, this.checkAttachments()),
                this._invalidateFlag = !1,
                this._bodyBounds.clear(),
                Wb.clear(this._bodyView),
                this._innerColor = this._network.getInnerColor(this._element),
                this._outerColor = this._network.getOuterColor(this._element),
                this._shadowColor = this._network.getShadowColor(this._element),
                this._shadowXOffset = this._element.getStyle("shadow.xoffset"),
                this._shadowYOffset = this._element.getStyle("shadow.yoffset"),
                this._shadowBlur = this._element.getStyle("shadow.blur"),
                this.updateMeasure();
                var a = this._element.getStyle("whole.alpha");
                this._view.style.opacity = a,
                this._attachments.forEach(function(b) {
                    b.updateMeasure();
                    var c = b.getAlpha();
                    b._view.style.opacity = b.isShowInAttachmentDiv() ? c * a: c
                });
                var b;
                this._bodyBounds.forEach(function(a) {
                    b = Tb.unionRect(b, a)
                }),
                this._unionBodyBounds = Jb.clone(b),
                this._attachments.forEach(function(a) {
                    b = Tb.unionRect(b, a.getViewRect())
                }),
                this._viewRect = b
            }
        },
        cleanUp: function(a) {
            for (var b = a.length,
            c = 0; b > c; c++) {
                var d = a[c],
                e = this[d];
                e && !e.parentNode && (this[d] = null)
            }
        },
        setVisible: function(a) {
            this.isVisible() !== a && (Wb.setVisible(this._view, a), this._attachments.forEach(function(b) {
                b.isShowInAttachmentDiv() && Wb.setVisible(b._view, a)
            }), this.invalidate(!0))
        },
        isVisible: function() {
            return Wb.isVisible(this._view)
        },
        checkAttachments: function() {
            this.checkLabelAttachment(),
            this.checkAlarmAttachment(),
            this.checkIconsAttachment(),
            this.checkEditAttachment()
        },
        checkLabelAttachment: function() {
            var a = this._network.getLabel(this._element);
            null != a && "" !== a ? this._labelAttachment || (this._labelAttachment = new Ib.network.LabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._network.getAlarmLabel(this._element);
            null != a && "" !== a ? this._alarmAttachment || (this._alarmAttachment = new Ib.network.AlarmAttachment(this, Dd.SHOW_ALARM_IN_ATTACHMENT_DIV), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        },
        checkIconsAttachment: function() {
            var a = this._network.getIconsNames(this._element);
            a && a.length > 0 ? this._iconsAttachment || (this._iconsAttachment = new Ib.network.IconsAttachment(this), this.addAttachment(this._iconsAttachment)) : this._iconsAttachment && (this.removeAttachment(this._iconsAttachment), this._iconsAttachment = null)
        },
        checkEditAttachment: function() {
            this.isEditable() && this._network.hasEditInteraction() && this._network.isSelected(this._element) && this._network.isEditable(this._element) ? this._editAttachment || (this._editAttachment = new Ib.network.EditAttachment(this), this.addAttachment(this._editAttachment)) : this._editAttachment && (this.removeAttachment(this._editAttachment), this._editAttachment = null)
        },
        isEditable: function() {
            return ! 0
        },
        handlePropertyChange: function(a) {
            this.invalidate(!0)
        },
        handleSelectionChange: function(a) {
            this.invalidate(!0)
        },
        dispose: function() {
            this._attachments.forEach(function(a) {
                a.getView().parentNode && a.getView().parentNode.removeChild(a.getView()),
                a.dispose()
            }),
            this._attachments.clear()
        },
        addAttachment: function(a) {
            this._attachments.add(a),
            a.isShowInAttachmentDiv() ? this._network.getAttachmentDiv().appendChild(a.getView()) : this._view.appendChild(a.getView()),
            this.invalidate(!1)
        },
        removeAttachment: function(a) {
            this._attachments.remove(a),
            a.getView().parentNode && a.getView().parentNode.removeChild(a.getView()),
            a.dispose(),
            this.invalidate(!1)
        },
        addBodyBounds: function(a) {
            a && this._bodyBounds.add(a)
        },
        addComponent: function(a) {
            this._bodyView.appendChild(a)
        },
        getBodyView: function() {
            return this._bodyView
        },
        getView: function() {
            return this._view
        },
        getViewRect: function() {
            return Jb.clone(this._viewRect)
        },
        setShadow: function(a, b, c) {
            var d = a.isShadowable() && this._shadowColor && !this._editAttachment;
            d && (this._shadowXOffset > 0 ? c.width += this._shadowXOffset: (c.x += this._shadowXOffset, c.width += -this._shadowXOffset), this._shadowYOffset > 0 ? c.height += this._shadowYOffset: (c.y += this._shadowYOffset, c.height += -this._shadowYOffset), Tb.grow(c, this._shadowBlur, this._shadowBlur));
            var e = Wb.setCanvas(b, c);
            return d && (e.shadowOffsetX = this._shadowXOffset, e.shadowOffsetY = this._shadowYOffset, e.shadowBlur = this._shadowBlur, e.shadowColor = this._shadowColor),
            e
        },
        isShadowable: function() {
            return this._shadowColor && this._network.isSelected(this._element) && "shadow" === this._element.getStyle("select.style") ? !0 : !1
        },
        hit: function(a, b) {
            return ! 1
        },
        hitCanvas: function(a, b, c) {
            for (var d = c.length,
            e = 0; d > e; e++) {
                var f = c[e],
                g = this[f];
                if (Xb.hit(g, a, b, this._network.getSelectionTolerance())) return ! 0
            }
            return ! 1
        },
        hitComponent: function(a, b, c) {
            for (var d = c.length,
            e = 0; d > e; e++) {
                var f = c[e],
                g = this[f];
                if (g && Tb.containsPoint(g._viewRect, a, b)) return ! 0
            }
            return ! 1
        },
        hitTest: function(a, b) {
            if (!this.isVisible() || !Tb.containsPoint(this._viewRect, a, b)) return null;
            var c, d, e = this._attachments.size();
            for (c = e - 1; c >= 0; c--) if (d = this._attachments.get(c), d.isShowInAttachmentDiv() && d.hit(a, b)) return d;
            for (c = e - 1; c >= 0; c--) if (d = this._attachments.get(c), !d.isShowInAttachmentDiv() && d.hit(a, b)) return d;
            return Tb.containsPoint(this._unionBodyBounds, a, b) && this.hit(a, b) ? this: null
        },
        intersects: function(a) {
            return ! 1
        },
        intersectsComponent: function(a, b) {
            for (var c = b.length,
            d = 0; c > d; d++) {
                var e = b[d],
                f = this[e];
                if (f && Tb.intersects(f._viewRect, a)) return ! 0
            }
            return ! 1
        },
        intersectsCanvas: function(a, b) {
            for (var c = b.length,
            d = 0; c > d; d++) {
                var e = b[d],
                f = this[e];
                if (Xb.intersects(f, a)) return ! 0
            }
            return ! 1
        },
        intersectsTest: function(a) {
            if (!this.isVisible() || !Tb.intersects(this._viewRect, a)) return null;
            var b, c, d = this._attachments.size();
            for (b = d - 1; b >= 0; b--) if (c = this._attachments.get(b), c.isShowInAttachmentDiv() && c.intersects(a)) return c;
            for (b = d - 1; b >= 0; b--) if (c = this._attachments.get(b), !c.isShowInAttachmentDiv() && c.intersects(a)) return c;
            return Tb.intersects(this._unionBodyBounds, a) && this.intersects(a) ? this: null
        }
    }),
    Ib.network.Attachment = function(a, b) {
        this._view = Wb.createDiv(),
        this._ui = a,
        this._element = this._ui.getElement(),
        this._network = a.getNetwork(),
        this._isShowInAttachmentDiv = b === !0,
        this._isShowInAttachmentDiv && Wb.setVisible(this._view, a.isVisible())
    },
    Jb.ext("twaver.network.Attachment", Object, {
        getElement: function() {
            return this._element
        },
        getElementUI: function() {
            return this._ui
        },
        getNetwork: function() {
            return this._network
        },
        getStyle: function(a) {
            return this._ui.getStyle(a)
        },
        getFont: function(a) {
            return this._ui.getFont(a)
        },
        isShowInAttachmentDiv: function() {
            return this._isShowInAttachmentDiv
        },
        getView: function() {
            return this._view
        },
        getViewRect: function() {
            return Jb.clone(this._viewRect)
        },
        getAlpha: function() {
            return 1
        },
        updateMeasure: function() {},
        dispose: function() {},
        hit: function(a, b) {
            return Tb.containsPoint(this._viewRect, a, b)
        },
        intersects: function(a) {
            return Tb.intersects(this._viewRect, a)
        }
    }),
    Ib.network.BasicAttachment = function(a, b) {
        Ib.network.BasicAttachment.superClass.constructor.call(this, a, b),
        this._roundRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._contentRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._attachmentCanvas = Wb.createCanvas(),
        this._view.insertBefore(this._attachmentCanvas, this._view.firstChild)
    },
    Jb.ext("twaver.network.BasicAttachment", Ib.network.Attachment, {
        calculateMeasure: function() {
            var a = this.getContentWidth(),
            b = this.getContentHeight(),
            c = this.getCornerRadius(),
            d = this.getPointerLength(),
            e = this.getPointerWidth(),
            f = this.getPosition(),
            g = this.getXOffset(),
            h = this.getYOffset(),
            i = this._roundRect;
            i.width = a + 2 * c,
            i.height = b;
            var j;
            if (d > 0) {
                var k = this.getDirection();
                j = this._network.getPosition(f, this._ui, null, g, h);
                var l;
                if ("aboveleft" === k) i.y = j.y - d - i.height,
                i.x = j.x - (i.width - c),
                l = Math.max(j.x - e, i.x + c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y - d
                },
                {
                    x: l,
                    y: j.y - d
                }];
                else if ("aboveright" === k) i.y = j.y - d - i.height,
                i.x = j.x - c,
                l = Math.min(j.x + e, i.x + i.width - c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y - d
                },
                {
                    x: l,
                    y: j.y - d
                }];
                else if ("belowleft" === k) i.y = j.y + d,
                i.x = j.x - (i.width - c),
                l = Math.max(j.x - e, i.x + c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y + d
                },
                {
                    x: l,
                    y: j.y + d
                }];
                else if ("belowright" === k) i.y = j.y + d,
                i.x = j.x - c,
                l = Math.min(j.x + e, i.x + i.width - c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y + d
                },
                {
                    x: l,
                    y: j.y + d
                }];
                else if ("leftabove" === k) i.y = j.y + c - i.height,
                i.x = j.x - d - i.width,
                l = Math.max(j.y - e, i.y + c / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y
                },
                {
                    x: j.x - d,
                    y: l
                }];
                else if ("leftbelow" === k) i.y = j.y - c,
                i.x = j.x - d - i.width,
                l = Math.min(j.y + e, i.y + i.height - c / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y
                },
                {
                    x: j.x - d,
                    y: l
                }];
                else if ("rightabove" === k) i.y = j.y + c - i.height,
                i.x = j.x + d,
                l = Math.max(j.y - e, i.y + c / 2),
                this._pointers = [j, {
                    x: j.x + d,
                    y: j.y
                },
                {
                    x: j.x + d,
                    y: l
                }];
                else if ("rightbelow" === k) i.y = j.y - c,
                i.x = j.x + d,
                l = Math.min(j.y + e, i.y + i.height - c / 2),
                this._pointers = [j, {
                    x: j.x + d,
                    y: j.y
                },
                {
                    x: j.x + d,
                    y: l
                }];
                else if ("above" === k) i.y = j.y - d - i.height,
                i.x = j.x - i.width / 2,
                l = Math.min(a / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - l,
                    y: j.y - d
                },
                {
                    x: j.x + l,
                    y: j.y - d
                }];
                else if ("below" === k) i.y = j.y + d,
                i.x = j.x - i.width / 2,
                l = Math.min(a / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - l,
                    y: j.y + d
                },
                {
                    x: j.x + l,
                    y: j.y + d
                }];
                else if ("left" === k) i.y = j.y - i.height / 2,
                i.x = j.x - d - i.width,
                l = Math.min(b / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y + l
                },
                {
                    x: j.x - d,
                    y: j.y - l
                }];
                else {
                    if ("right" !== k) throw "Can not resolve '" + k + "' attachment direction";
                    i.y = j.y - i.height / 2,
                    i.x = j.x + d,
                    l = Math.min(b / 2, e / 2),
                    this._pointers = [j, {
                        x: j.x + d,
                        y: j.y + l
                    },
                    {
                        x: j.x + d,
                        y: j.y - l
                    }]
                }
            } else j = this._network.getPosition(f, this._ui, {
                width: i.width,
                height: i.height
            },
            g, h),
            i.x = j.x,
            i.y = j.y,
            this._pointers = null;
            this._contentRect.x = i.x + (i.width - a) / 2,
            this._contentRect.y = i.y + (i.height - b) / 2,
            this._contentRect.width = a,
            this._contentRect.height = b;
            var m = this.getPadding();
            0 != m && Tb.grow(i, m, m),
            m = this.getPaddingLeft(),
            0 != m && (i.x -= m, i.width += m),
            m = this.getPaddingRight(),
            0 != m && (i.width += m),
            m = this.getPaddingTop(),
            0 != m && (i.y -= m, i.height += m),
            m = this.getPaddingBottom(),
            0 != m && (i.height += m),
            i.width < 0 && (i.width = i.width, i.x -= i.width),
            i.height < 0 && (i.height = -i.height, i.y -= i.height)
        },
        updateMeasure: function() {
            Ib.network.BasicAttachment.superClass.updateMeasure.call(this),
            this.calculateMeasure();
            var a = this.isFill(),
            b = this.getOutlineWidth();
            this._viewRect = Tb.getRect(this._pointers),
            this._viewRect = Tb.unionRect(this._viewRect, this._roundRect),
            b > 0 && Tb.grow(this._viewRect, b / 2, b / 2);
            var c = this._ui.setShadow(this, this._attachmentCanvas, this._viewRect);
            if ((b > 0 || a) && (c.beginPath(), Xb.drawRoundRect(c, this._roundRect.x, this._roundRect.y, this._roundRect.width, this._roundRect.height, this.getCornerRadius()), this._pointers && (c.moveTo(this._pointers[0].x, this._pointers[0].y), c.lineTo(this._pointers[1].x, this._pointers[1].y), c.lineTo(this._pointers[2].x, this._pointers[2].y)), c.closePath(), b > 0 && (c.lineWidth = b, c.strokeStyle = this.getOutlineColor(), c.lineCap = this.getCap(), c.lineJoin = this.getJoin(), c.stroke()), a)) {
                var d = this.getFillColor(),
                e = this.getGradient();
                e ? Xb.fill(c, d, e, this.getGradientColor(), this._viewRect) : c.fillStyle = d,
                c.fill()
            }
            return c
        },
        getRoundRect: function() {
            return Jb.clone(this._roundRect)
        },
        getContentRect: function() {
            return Jb.clone(this._contentRect)
        },
        getContent: function() {
            return this._content
        },
        setContent: function(a) {
            this._content !== a && (this._content && this._view.removeChild(this._content), this._content = a, a && this._view.appendChild(a))
        },
        getContentWidth: function() {
            return Dd.ATTACHMENT_CONTENT_WIDTH
        },
        getContentHeight: function() {
            return Dd.ATTACHMENT_CONTENT_HEIGHT
        },
        getCornerRadius: function() {
            return Dd.ATTACHMENT_CORNER_RADIUS
        },
        getPointerLength: function() {
            return Dd.ATTACHMENT_POINTER_LENGTH
        },
        getPointerWidth: function() {
            return Dd.ATTACHMENT_POINTER_WIDTH
        },
        getPosition: function() {
            return Dd.ATTACHMENT_POSITION
        },
        getXOffset: function() {
            return Dd.ATTACHMENT_XOFFSET
        },
        getYOffset: function() {
            return Dd.ATTACHMENT_YOFFSET
        },
        getPadding: function() {
            return Dd.ATTACHMENT_PADDING
        },
        getPaddingLeft: function() {
            return Dd.ATTACHMENT_PADDING_LEFT
        },
        getPaddingRight: function() {
            return Dd.ATTACHMENT_PADDING_RIGHT
        },
        getPaddingTop: function() {
            return Dd.ATTACHMENT_PADDING_TOP
        },
        getPaddingBottom: function() {
            return Dd.ATTACHMENT_PADDING_BOTTOM
        },
        getDirection: function() {
            return Dd.ATTACHMENT_DIRECTION
        },
        isFill: function() {
            return Dd.ATTACHMENT_FILL
        },
        getFillColor: function() {
            return Dd.ATTACHMENT_FILL_COLOR
        },
        getGradient: function() {
            return Dd.ATTACHMENT_GRADIENT
        },
        getGradientColor: function() {
            return Dd.ATTACHMENT_GRADIENT_COLOR
        },
        getOutlineWidth: function() {
            return Dd.ATTACHMENT_OUTLINE_WIDTH
        },
        getOutlineColor: function() {
            return Dd.ATTACHMENT_OUTLINE_COLOR
        },
        getCap: function() {
            return Dd.ATTACHMENT_CAP
        },
        getJoin: function() {
            return Dd.ATTACHMENT_JOIN
        },
        isShadowable: function() {
            return Dd.ATTACHMENT_SHADOWABLE
        },
        hit: function(a, b) {
            return Tb.containsPoint(this._viewRect, a, b) ? Tb.containsPoint(this._contentRect, a, b) ? !0 : Xb.hit(this._attachmentCanvas, a, b) : !1
        },
        intersects: function(a) {
            return Tb.intersects(this._viewRect, a) ? Tb.intersects(this._contentRect, a) ? !0 : Xb.intersects(this._attachmentCanvas, a) : !1
        }
    }),
    Ib.network.LabelAttachment = function(a, b) {
        Ib.network.LabelAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.LabelAttachment", Ib.network.BasicAttachment, {
        updateMeasure: function() {
            var a = this.getFont("label.font"),
            b = this.getLabel();
            this._textSize = Xb.getTextSize(a, b);
            var c = Ib.network.LabelAttachment.superClass.updateMeasure.call(this),
            d = this._element.getStyle("label.align");
            Xb.drawText(c, b, this._contentRect, a, this.getStyle("label.color"), d)
        },
        getLabel: function() {
            return this._network.getLabel(this._element);
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("label.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("label.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("label.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("label.position")
        },
        getXOffset: function() {
            return this.getStyle("label.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("label.yoffset")
        },
        getPadding: function() {
            return this.getStyle("label.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("label.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("label.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("label.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("label.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("label.direction")
        },
        isFill: function() {
            return this.getStyle("label.fill")
        },
        getFillColor: function() {
            return this.getStyle("label.fill.color")
        },
        getGradient: function() {
            return this.getStyle("label.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("label.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("label.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("label.outline.color")
        },
        getCap: function() {
            return this.getStyle("label.cap")
        },
        getJoin: function() {
            return this.getStyle("label.join")
        },
        getAlpha: function() {
            return this.getStyle("label.alpha")
        },
        isShadowable: function() {
            return this.getStyle("label.shadowable")
        }
    }),
    Ib.network.AlarmAttachment = function(a, b) {
        Ib.network.AlarmAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.AlarmAttachment", Ib.network.BasicAttachment, {
        updateMeasure: function() {
            var a = this.getFont("alarm.font"),
            b = this._network.getAlarmLabel(this._element);
            this._textSize = Xb.getTextSize(a, b),
            this._fillColor = this._network.getAlarmFillColor(this._element);
            var c = Ib.network.AlarmAttachment.superClass.updateMeasure.call(this);
            Xb.drawText(c, b, this._contentRect, a, this.getStyle("alarm.color"))
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("alarm.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("alarm.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("alarm.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("alarm.position")
        },
        getXOffset: function() {
            return this.getStyle("alarm.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("alarm.yoffset")
        },
        getPadding: function() {
            return this.getStyle("alarm.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("alarm.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("alarm.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("alarm.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("alarm.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("alarm.direction")
        },
        isFill: function() {
            return null != this._fillColor
        },
        getFillColor: function() {
            return this._fillColor
        },
        getGradient: function() {
            return this.getStyle("alarm.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("alarm.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("alarm.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("alarm.outline.color")
        },
        getCap: function() {
            return this.getStyle("alarm.cap")
        },
        getJoin: function() {
            return this.getStyle("alarm.join")
        },
        getAlpha: function() {
            return this.getStyle("alarm.alpha")
        },
        isShadowable: function() {
            return this.getStyle("alarm.shadowable")
        }
    }),
    Ib.network.LinkHandlerAttachment = function(a, b) {
        Ib.network.LinkHandlerAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.LinkHandlerAttachment", Ib.network.BasicAttachment, {
        updateMeasure: function() {
            var a = this.getFont("link.handler.font"),
            b = this._network.getLinkHandlerLabel(this._element);
            this._textSize = Xb.getTextSize(a, b);
            var c = Ib.network.LabelAttachment.superClass.updateMeasure.call(this);
            Xb.drawText(c, b, this._contentRect, a, this.getStyle("link.handler.color"))
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("link.handler.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("link.handler.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("link.handler.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("link.handler.position")
        },
        getXOffset: function() {
            return this.getStyle("link.handler.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("link.handler.yoffset")
        },
        getPadding: function() {
            return this.getStyle("link.handler.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("link.handler.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("link.handler.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("link.handler.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("link.handler.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("link.handler.direction")
        },
        isFill: function() {
            return this.getStyle("link.handler.fill")
        },
        getFillColor: function() {
            return this.getStyle("link.handler.fill.color")
        },
        getGradient: function() {
            return this.getStyle("link.handler.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("link.handler.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("link.handler.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("link.handler.outline.color")
        },
        getCap: function() {
            return this.getStyle("link.handler.cap")
        },
        getJoin: function() {
            return this.getStyle("link.handler.join")
        },
        getAlpha: function() {
            return this.getStyle("link.handler.alpha")
        },
        isShadowable: function() {
            return this.getStyle("link.handler.shadowable")
        }
    }),
    Ib.network.EditAttachment = function(a, b) {
        Ib.network.EditAttachment.superClass.constructor.call(this, a, b),
        this._attachmentDiv = Wb.createDiv(),
        this._view.appendChild(this._attachmentDiv)
    },
    Jb.ext("twaver.network.EditAttachment", Ib.network.Attachment, {
        updateMeasure: function() {
            Ib.network.EditAttachment.superClass.updateMeasure.call(this),
            this._viewRect = null,
            this._element instanceof Kd && this._addResizingPoint(this._element),
            !(this._network.isRotatable(this._element) && this._element instanceof Kd) || this._element instanceof Ib.ShapeNode || this._element instanceof Ib.Grid || this._element instanceof Ib.Group || this._addRotatePoint(this._element),
            this._element instanceof Ib.ShapeNode && (this._addResizingPoint(this._element), this._addShapeNodePoint(this._element)),
            this._ui instanceof Ib.network.ShapeLinkUI && this._addShapeLinkPoints(this._ui),
            this._ui instanceof Ib.network.LinkUI && this._addLinkControlPoint(this._ui)
        },
        _addRotatePoint: function(a) {
            var b = this._network.getRotatePointSize();
            if (! (0 >= b)) {
                var c = a.getOriginalRect();
                if (!this._rotateDiv) {
                    var d = Wb.createDiv();
                    this._attachmentDiv.appendChild(d),
                    this._rotateDiv = d
                }
                var e, f = this._network.getRotatePointOutlineWidth(),
                g = this._network.getRotatePointOutlineColor(),
                h = this._network.getRotatePointFillColor(),
                b = this._network.getRotatePointSize(),
                i = 2 * b,
                j = {
                    x: c.x + c.width / 2 - b,
                    y: c.y - this._network.getRotatePointOffset() - i,
                    width: i,
                    height: i
                };
                e = 0 == a.angle ? j: this._getRotateRect(j, a.getAngle(), {
                    x: c.x + c.width / 2,
                    y: c.y + c.height / 2
                });
                var k = Tb.unionRect(a.getRect(), e);
                this._viewRect = Tb.unionRect(k, this._viewRect),
                Wb.setDiv(this._rotateDiv, j, h, f, g),
                this._rotateDiv._viewRect = e,
                Wb.setBorderRaidus(this._rotateDiv, i + "px"),
                this._rotateAttachments(this._rotateDiv, i / 2, f)
            }
        },
        _addResizingPoint: function(a) {
            var b = this._network.getResizePointSize();
            if (! (0 >= b)) {
                var c = a.getOriginalRect(),
                d = new nd([{
                    x: c.x,
                    y: c.y
                },
                {
                    x: c.x + c.width / 2,
                    y: c.y
                },
                {
                    x: c.x + c.width,
                    y: c.y
                },
                {
                    x: c.x,
                    y: c.y + c.height / 2
                },
                {
                    x: c.x + c.width,
                    y: c.y + c.height / 2
                },
                {
                    x: c.x,
                    y: c.y + c.height
                },
                {
                    x: c.x + c.width / 2,
                    y: c.y + c.height
                },
                {
                    x: c.x + c.width,
                    y: c.y + c.height
                }]);
                if (!this._resizeDivs) {
                    this._resizeDivs = new Array;
                    for (var e = 0; 8 > e; e++) {
                        var f = Wb.createDiv();
                        this._attachmentDiv.appendChild(f),
                        this._resizeDivs[e] = f
                    }
                }
                if (this._resizeDivs) {
                    this._resizeRects = new Array;
                    for (var e = 0; 8 > e; e++) {
                        var g, h = d.get(e),
                        i = {
                            x: h.x - b,
                            y: h.y - b,
                            width: 2 * b,
                            height: 2 * b
                        };
                        g = 0 == a.getAngle() ? i: this._getRotateRect(i, a.getAngle(), {
                            x: c.x + c.width / 2,
                            y: c.y + c.height / 2
                        }),
                        this._resizeRects[e] = g
                    }
                }
                var j = this._network.getResizePointOutlineWidth(),
                k = this._network.getResizePointOutlineColor(),
                l = this._network.getResizePointFillColor();
                this._addPoints(a.getRect(), d, j, k, l, !0)
            }
        },
        _addPoints: function(a, b, c, d, e, f) {
            var g = f ? this._network.getResizePointSize() : this._network.getEditPointSize();
            if (! (0 >= g)) {
                var h = g + c;
                Tb.grow(a, h, h),
                this._viewRect = Tb.unionRect(a, this._viewRect);
                var i, j, k, l, m = 2 * g,
                n = new nd;
                for (i = 0, j = b.size(); j > i; i++) k = b.get(i),
                l = {
                    x: k.x - g,
                    y: k.y - g,
                    width: m,
                    height: m
                },
                n.add(l);
                var o;
                if (f) o = this._resizeDivs;
                else {
                    if (this._controlDivs || (this._controlDivs = new Array), this._controlDivs.length < j) for (i = this._controlDivs.length; j > i; i++) {
                        var p = Wb.createDiv();
                        this._attachmentDiv.appendChild(p),
                        this._controlDivs[i] = p
                    } else if (this._controlDivs.length > j) {
                        for (i = j; i < this._controlDivs.length; i++) this._attachmentDiv.removeChild(this._controlDivs[i]);
                        this._controlDivs.splice(j)
                    }
                    o = this._controlDivs
                }
                for (i = 0, j = n.size(); j > i; i++) l = n.get(i),
                Wb.setDiv(o[i], l, e, c, d),
                Wb.setBorderRaidus(o[i], (f ? "0": m) + "px"),
                this._rotateAttachments(o[i], m / 2, c, b.get(i))
            }
        },
        _rotateAttachments: function(a, b, c, d) {
            if (this._element instanceof Kd) {
                var e = this._element.getAngle();
                if (0 == e) return;
                var f = this._element.getOriginalRect(),
                g = a.style.left.split("px")[0],
                h = a.style.top.split("px")[0];
                f.x + f.width / 2,
                f.y + f.height / 2,
                d || (d = {
                    x: parseFloat(g) + b + c,
                    y: parseFloat(h) + b + c
                });
                var i = Tb.createMatrix(e * Math.PI / 180, f.x + f.width / 2, f.y + f.height / 2),
                j = i.transform(d);
                a.style.webkitTransform = "rotate(" + e + "deg)",
                a.style.mozTransform = "rotate(" + e + "deg)",
                a.style.OTransform = "rotate(" + e + "deg)",
                a.style.msTransform = "rotate(" + e + "deg)",
                a.style.transform = "rotate(" + e + "deg)",
                a.style.left = j.x - b - c + "px",
                a.style.top = j.y - b - c + "px"
            }
        },
        _addShapeLinkPoints: function(a) {
            this._addEditPoints(a._element.getPoints())
        },
        _addShapeNodePoint: function(a) {
            this._addEditPoints(a.getPoints())
        },
        _addLinkControlPoint: function(a) {
            if (xc.isOrthogonalLink(a._element)) {
                var b = a.getControlPoint();
                if (b) {
                    var c = new nd;
                    c.add(b),
                    this._addEditPoints(c)
                }
            }
        },
        _addEditPoints: function(a) {
            var b = Tb.getRect(a);
            if (b) {
                var c = this._network.getEditPointOutlineWidth(),
                d = this._network.getEditPointOutlineColor(),
                e = this._network.getEditPointFillColor();
                this._addPoints(b, a, c, d, e, !1)
            }
        },
        hit: function(a, b) {
            if (!Tb.containsPoint(this._viewRect, a, b)) return ! 1;
            var c;
            if (this._resizeDivs) for (c = this._resizeDivs.length - 1; c >= 0; c--) if (Tb.containsPoint(this._resizeRects[c], a, b)) return ! 0;
            if (this._rotateDiv && Tb.containsPoint(this._rotateDiv._viewRect, a, b)) return ! 0;
            if (this._controlDivs) for (c = this._controlDivs.length - 1; c >= 0; c--) if (Tb.containsPoint(this._controlDivs[c]._viewRect, a, b)) return ! 0;
            return ! 1
        },
        intersects: function(a) {
            if (!Tb.intersects(this._viewRect, a)) return ! 1;
            var b;
            if (this._resizeDivs) for (b = this._resizeDivs.length - 1; b >= 0; b--) if (Tb.intersects(this._resizeRects[b], a)) return ! 0;
            if (this._rotateDiv && Tb.containsPoint(this._rotateDiv._viewRect, a)) return ! 0;
            if (this._controlDivs) for (b = this._controlDivs.length - 1; b >= 0; b--) if (Tb.intersects(this._controlDivs[b]._viewRect, a)) return ! 0;
            return Tb.intersects(this._viewRect, a) ? !1 : !1
        },
        _getRotateRect: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x, c.y),
            e = {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            },
            f = d.transform(e),
            g = new Ib.List([{
                x: f.x - a.width / 2,
                y: f.y - a.height / 2
            },
            {
                x: f.x + a.width / 2,
                y: f.y - a.height / 2
            },
            {
                x: f.x + a.width / 2,
                y: f.y + a.height / 2
            },
            {
                x: f.x - a.width / 2,
                y: f.y + a.height / 2
            }]);
            return Tb.getRect(g)
        }
    }),
    Ib.network.IconsAttachment = function(a, b) {
        Ib.network.IconsAttachment.superClass.constructor.call(this, a, b),
        this._iconsCanvas = null
    },
    Jb.ext("twaver.network.IconsAttachment", Ib.network.Attachment, {
        isShadowable: function() {
            return Dd.ATTACHMENT_SHADOWABLE
        },
        updateMeasure: function() {
            Ib.network.IconsAttachment.superClass.updateMeasure.call(this);
            var a = this._network.getIconsNames(this._element);
            if (a && 0 != a.length) {
                var b = this._network.getIconsColors(this._element),
                c = this._element.getStyle("icons.orientation"),
                d = this._element.getStyle("icons.position"),
                e = this._element.getStyle("icons.xoffset");
                e = e instanceof Array ? e[0] : e;
                var f = this._element.getStyle("icons.yoffset");
                f = f instanceof Array ? f[0] : f;
                var g = this._element.getStyle("icons.xgap");
                g = g instanceof Array ? g[0] : g;
                var h = this._element.getStyle("icons.ygap");
                h = h instanceof Array ? h[0] : h;
                var i = this._getIconsSize(a, c, g, h);
                if (i) {
                    var j = this._network.getPosition(d, this._ui, i, e, f);
                    this._viewRect = {
                        x: j.x,
                        y: j.y,
                        width: i.width,
                        height: i.height
                    },
                    "top" === c ? j.y += i.height: "left" === c && (j.x += i.width),
                    this._iconsCanvas || (this._iconsCanvas = Wb.createCanvas(), this._view.appendChild(this._iconsCanvas));
                    var k = this._ui.setShadow(this, this._iconsCanvas, Jb.clone(this._viewRect)),
                    l = j.x,
                    m = j.y,
                    n = 0;
                    for (var o in a) {
                        var p = null,
                        q = null;
                        b && b.length > n && (q = b[n++]);
                        var r = Jb.getImageAsset(a[o]);
                        if (null != r) {
                            if ("right" === c) p = {
                                x: l,
                                y: m,
                                width: r.getWidth(),
                                height: r.getHeight()
                            },
                            l += p.width + g;
                            else if ("left" === c) p = {
                                x: l - r.getWidth(),
                                y: m,
                                width: r.getWidth(),
                                height: r.getHeight()
                            },
                            l -= p.width + g;
                            else if ("top" === c) p = {
                                x: l,
                                y: m - r.getHeight(),
                                width: r.getWidth(),
                                height: r.getHeight()
                            },
                            m -= p.height + h;
                            else {
                                if ("bottom" !== c) throw "Can not resolve '" + c + "' orientation";
                                p = {
                                    x: l,
                                    y: m,
                                    width: r.getWidth(),
                                    height: r.getHeight()
                                },
                                m += p.height + h
                            }
                            Nc(k, r.getImage(q, p.width, p.height), q, p, this._element, this._network)
                        }
                    }
                }
            }
        },
        _getIconsSize: function(a, b, c, d) {
            var e = 0,
            f = 0,
            g = null,
            h = null,
            i = null;
            for (var j in a) if (h = Jb.getImageAsset(a[j])) {
                if ("right" === b) g = {
                    x: e,
                    y: f,
                    width: h.getWidth(),
                    height: h.getHeight()
                },
                e += g.width + c;
                else if ("left" === b) g = {
                    x: e - h.getWidth(),
                    y: f,
                    width: h.getWidth(),
                    height: h.getHeight()
                },
                e -= g.width + c;
                else if ("top" === b) g = {
                    x: e,
                    y: f - h.getHeight(),
                    width: h.getWidth(),
                    height: h.getHeight()
                },
                f -= g.height + d;
                else {
                    if ("bottom" !== b) throw "Can not resolve '" + b + "' orientation";
                    g = {
                        x: e,
                        y: f,
                        width: h.getWidth(),
                        height: h.getHeight()
                    },
                    f += g.height + d
                }
                i = null == i ? Jb.clone(g) : Tb.unionRect(i, g)
            }
            return i ? {
                width: Math.abs(i.width),
                height: Math.abs(i.height)
            }: null
        }
    }),
    Ib.network.HTMLBasicAttachment = function(a, b) {
        function c(a, b, c, d, e, f, g) {
            c || (c = this._origin.x),
            d || (d = this._origin.y),
            e || (e = this._location.x),
            f || (f = this._location.y),
            a = a - c - e,
            b = b - d - f;
            var h = Ib.Util.transformPoint({
                x: c + e,
                y: d + f
            },
            g ? this._radian: -this._radian, a, b).point;
            return h
        }
        Ib.network.HTMLBasicAttachment.superClass.constructor.call(this, a, b),
        this._roundRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._contentRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._triangleDiv = Ib.Util.createDiv(),
        this._roundDiv = Ib.Util.createDiv(),
        this._contentDiv = Ib.Util.createDiv(),
        Ib.Util.setCSSStyle(this._triangleDiv, "border-style", "solid"),
        Ib.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");
        var d = this;
        this.hit = function(a, b) {
            if (this._radian && this._origin) {
                var e = c.call(d, a, b);
                a = e.x,
                b = e.y
            }
            return Ib.Util.containsPoint(this._roundRect, a, b) || Ib.Util.containsPoint(this._pointerRect, a, b)
        },
        this.intersects = function(a) {
            var b = {
                x: a.x,
                y: a.y
            },
            e = {
                x: a.x + a.width,
                y: a.y
            },
            f = {
                x: a.x,
                y: a.y + a.height
            },
            g = {
                x: a.x + a.width,
                y: a.y + a.height
            };
            if (this._radian && this._origin) {
                if (a.width * a.height > 50) return ! 1;
                b = c.call(d, b.x, b.y),
                e = c.call(d, e.x, e.y),
                f = c.call(d, f.x, f.y),
                g = c.call(d, g.x, g.y)
            }
            return a = Ib.Util.getRect([b, e, f, g]),
            Ib.Util.intersects(this._roundRect, a) || Ib.Util.intersects(this._pointerRect, a)
        },
        this.getContentWidth = function() {
            return this._contentDiv.scrollWidth || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "width"))
        },
        this.getContentHeight = function() {
            return this._contentDiv.scrollHeight || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "height"))
        },
        this._view.appendChild(this._roundDiv),
        this._roundDiv.appendChild(this._contentDiv)
    },
    Ib.Util.ext("twaver.network.HTMLBasicAttachment", Ib.network.BasicAttachment, {
        calculateMeasure: function() {
            var a = this.getContentWidth(),
            b = this.getContentHeight(),
            c = Math.min(this.getCornerRadius(), b / 2),
            d = this.getPointerLength(),
            e = this.getPointerWidth(),
            f = this.getPosition(),
            g = this.getXOffset(),
            h = this.getYOffset();
            this._contentRect.width = a,
            this._contentRect.height = b,
            this._contentRect.x = c;
            var i = this._roundRect;
            i.width = a + 2 * c,
            i.height = b;
            var j;
            if (d > 0) {
                var k = this.getDirection();
                if (j = this._network.getPosition(f, this._ui, null, g, h), "aboveleft" === k) {
                    i.y = j.y - d - i.height,
                    i.x = j.x - (i.width - c),
                    this._pointers = [j, {
                        x: j.x,
                        y: j.y - d
                    },
                    {
                        x: j.x - Math.min(e, a),
                        y: j.y - d
                    }];
                    var l = d / 2,
                    m = Math.min(e, a) / 2,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px " + m + "px " + l + "px " + m + "px",
                    this._triangleBorderColorStyle = n + " " + n + " transparent transparent",
                    this._triangleDivLocation = this._pointers[2]
                } else if ("aboveright" === k) {
                    i.y = j.y - d - i.height,
                    i.x = j.x - c,
                    this._pointers = [j, {
                        x: j.x,
                        y: j.y - d
                    },
                    {
                        x: j.x + Math.min(e, a),
                        y: j.y - d
                    }];
                    var l = d / 2,
                    m = Math.min(e, a) / 2,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px " + m + "px " + l + "px " + m + "px",
                    this._triangleBorderColorStyle = n + " transparent transparent " + n,
                    this._triangleDivLocation = this._pointers[1]
                } else if ("belowleft" === k) {
                    i.y = j.y + d,
                    i.x = j.x - (i.width - c),
                    this._pointers = [j, {
                        x: j.x,
                        y: j.y + d
                    },
                    {
                        x: j.x - Math.min(e, a),
                        y: j.y + d
                    }];
                    var l = d / 2,
                    m = Math.min(e, a) / 2,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px " + m + "px " + l + "px " + m + "px",
                    this._triangleBorderColorStyle = " transparent " + n + " " + n + " transparent",
                    this._triangleDivLocation = {
                        x: this._pointers[2].x,
                        y: j.y
                    }
                } else if ("belowright" === k) {
                    i.y = j.y + d,
                    i.x = j.x - c,
                    this._pointers = [j, {
                        x: j.x,
                        y: j.y + d
                    },
                    {
                        x: j.x + Math.min(e, a),
                        y: j.y + d
                    }];
                    var l = d / 2,
                    m = Math.min(e, a) / 2,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px " + m + "px " + l + "px " + m + "px",
                    this._triangleBorderColorStyle = "transparent transparent " + n + " " + n,
                    this._triangleDivLocation = this._pointers[0]
                } else if ("above" === k) {
                    i.y = j.y - d - i.height,
                    i.x = j.x - i.width / 2,
                    this._pointers = [j, {
                        x: j.x - Math.min(e, a) / 2,
                        y: j.y - d
                    },
                    {
                        x: j.x + Math.min(e, a) / 2,
                        y: j.y - d
                    }];
                    var l = d,
                    m = Math.min(e, a) / 2,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px " + m + "px 0px " + m + "px",
                    this._triangleBorderColorStyle = n + " transparent transparent transparent",
                    this._triangleDivLocation = this._pointers[1]
                } else if ("below" === k) {
                    i.y = j.y + d,
                    i.x = j.x - i.width / 2,
                    this._pointers = [j, {
                        x: j.x - Math.min(e, a) / 2,
                        y: j.y + d
                    },
                    {
                        x: j.x + Math.min(e, a) / 2,
                        y: j.y + d
                    }];
                    var l = d,
                    m = Math.min(e, a) / 2,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = "0px " + m + "px " + l + "px " + m + "px",
                    this._triangleBorderColorStyle = "transparent transparent " + n + " transparent ",
                    this._triangleDivLocation = {
                        x: this._pointers[1].x,
                        y: j.y
                    }
                } else if ("left" === k) {
                    i.y = j.y - i.height / 2,
                    i.x = j.x - i.width - d,
                    this._pointers = [j, {
                        x: j.x - d,
                        y: j.y - Math.min(e, b) / 2
                    },
                    {
                        x: j.x - d,
                        y: j.y + Math.min(e, b) / 2
                    }];
                    var l = Math.min(e, b) / 2,
                    m = d,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px 0px " + l + "px " + m + "px",
                    this._triangleBorderColorStyle = "transparent transparent  transparent " + n,
                    this._triangleDivLocation = this._pointers[1]
                } else {
                    if ("right" !== k) throw "Can not resolve '" + k + "' attachment direction";
                    i.y = j.y - i.height / 2,
                    i.x = j.x + d,
                    this._pointers = [j, {
                        x: j.x + d,
                        y: j.y - Math.min(e, b) / 2
                    },
                    {
                        x: j.x + d,
                        y: j.y + Math.min(e, b) / 2
                    }];
                    var l = Math.min(e, b) / 2,
                    m = d,
                    n = this.getFillColor();
                    this._triangleBorderWidthStyle = l + "px " + m + "px " + l + "px 0px",
                    this._triangleBorderColorStyle = "transparent " + n + " transparent  transparent ",
                    this._triangleDivLocation = {
                        x: j.x,
                        y: this._pointers[1].y
                    }
                }
            } else j = this._network.getPosition(f, this._ui, {
                width: i.width,
                height: i.height
            },
            g, h),
            i.x = j.x,
            i.y = j.y,
            this._pointers = null;
            this._location = j
        },
        updateMeasure: function() {
            if (this.calculateMeasure(), this._ui.isShadowable() && this.isShadowable() ? Ib.Util.setCSSStyle(this._roundDiv, "text-shadow", this._ui._shadowXOffset + "px " + this._ui._shadowYOffset + "px " + this._ui._shadowBlur + "px " + this._ui._shadowColor) : Ib.Util.removeCSSStyle(this._roundDiv, "text-shadow"), this._pointerRect = Ib.Util.getRect(this._pointers), this._viewRect = Ib.Util.unionRect(this._pointerRect, this._roundRect), Ib.Util.setCSSStyle(this._contentDiv, "left", this._contentRect.x + "px"), Ib.Util.setCSSStyle(this._contentDiv, "top", this._contentRect.y + "px"), Ib.Util.setCSSStyle(this._roundDiv, "left", this._roundRect.x + "px"), Ib.Util.setCSSStyle(this._roundDiv, "top", this._roundRect.y + "px"), Ib.Util.setCSSStyle(this._roundDiv, "width", this._roundRect.width + "px"), Ib.Util.setCSSStyle(this._roundDiv, "height", this._roundRect.height + "px"), Ib.Util.setCSSStyle(this._roundDiv, "background", this.isFill() ? this.getFillColor() : null), Ib.Util.setCSSStyle(this._roundDiv, "-webkit-border-radius", this.getCornerRadius() + "px"), Ib.Util.setCSSStyle(this._roundDiv, "-moz-border-radius", this.getCornerRadius() + "px"), Ib.Util.setCSSStyle(this._roundDiv, "border-radius", this.getCornerRadius() + "px"), this._pointers ? (Ib.Util.setCSSStyle(this._triangleDiv, "left", this._triangleDivLocation.x + "px"), Ib.Util.setCSSStyle(this._triangleDiv, "top", this._triangleDivLocation.y + "px"), Ib.Util.setCSSStyle(this._triangleDiv, "border-width", this._triangleBorderWidthStyle), Ib.Util.setCSSStyle(this._triangleDiv, "border-color", this._triangleBorderColorStyle), this._view.appendChild(this._triangleDiv)) : this._triangleDiv.parentNode == this._view && this._view.removeChild(this._triangleDiv), this._element.getStyle("label.rotatable") && this.label) {
                var a = this._ui.getFromPoint(),
                b = this._ui.getToPoint(),
                c = this._ui.getLinkPoints();
                c.size() % 2 == 0 && (a = c.get(c.size() / 2 - 1), b = c.get(c.size() / 2)),
                this._radian = a.x > b.x ? Ib.Util.getRadiansBetweenLines(b, a) : Ib.Util.getRadiansBetweenLines(a, b),
                this._origin = {
                    x: this._contentRect.width / 2,
                    y: 0
                };
                var d = "rotate(" + Ib.Util.toDegrees(this._radian) + "deg)",
                e = this._origin.x + "px " + this._origin.y + "px";
                Ib.Util.isChrome || Ib.Util.isSafari ? (Ib.Util.setCSSStyle(this._roundDiv, "-webkit-transform", d), Ib.Util.setCSSStyle(this._roundDiv, "-webkit-transform-origin", e)) : Ib.Util.isIE ? (Ib.Util.setCSSStyle(this._roundDiv, "-ms-transform", d), Ib.Util.setCSSStyle(this._roundDiv, "-ms-transform-origin", e)) : (Ib.Util.setCSSStyle(this._roundDiv, "transform", d), Ib.Util.setCSSStyle(this._roundDiv, "transform-origin", e))
            } else Ib.Util.removeCSSStyle(this._roundDiv, "-webkit-transform"),
            Ib.Util.removeCSSStyle(this._roundDiv, "-webkit-transform-origin"),
            Ib.Util.removeCSSStyle(this._roundDiv, "-ms-transform"),
            Ib.Util.removeCSSStyle(this._roundDiv, "-ms-transform-origin"),
            Ib.Util.removeCSSStyle(this._roundDiv, "transform"),
            Ib.Util.removeCSSStyle(this._roundDiv, "transform-origin"),
            delete this._origin,
            delete this._radian
        }
    }),
    Ib.network.HTMLLabelAttachment = function(a, b) {
        Ib.network.HTMLBasicAttachment.call(this, a, b),
        this.label = !0
    },
    Ib.Util.ext("twaver.network.HTMLLabelAttachment", Ib.network.LabelAttachment, {
        updateMeasure: function() {
            var a = this.getFont("label.font"),
            b = this.getLabel();
            this._contentDiv.innerHTML = b,
            Ib.Util.setCSSStyle(this._contentDiv, "font", a),
            Ib.network.HTMLBasicAttachment.prototype.updateMeasure.call(this),
            Ib.Util.removeCSSStyle(this._contentDiv, "font")
        },
        calculateMeasure: Ib.network.HTMLBasicAttachment.prototype.calculateMeasure
    }),
    Ib.network.HTMLAlarmAttachment = function(a, b) {
        Ib.network.HTMLBasicAttachment.call(this, a, b),
        this.alarm = !0
    },
    Ib.Util.ext("twaver.network.HTMLAlarmAttachment", Ib.network.AlarmAttachment, {
        updateMeasure: function() {
            var a = this.getFont("alarm.font");
            this._contentDiv.innerHTML = this._network.getAlarmLabel(this._element),
            Ib.Util.setCSSStyle(this._contentDiv, "font", a),
            this._fillColor = this._network.getAlarmFillColor(this._element),
            Ib.network.HTMLBasicAttachment.prototype.updateMeasure.call(this),
            Ib.Util.removeCSSStyle(this._contentDiv, "font")
        },
        calculateMeasure: Ib.network.HTMLBasicAttachment.prototype.calculateMeasure
    }),
    Ib.network.NodeUI = function(a, b) {
        Ib.network.NodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.NodeUI", Ib.network.ElementUI, {
        createBodyRect: function() {
            return this._element.getRect()
        },
        invalidate: function(a) {
            Ib.network.NodeUI.superClass.invalidate.call(this, a);
            var b = this._element.getAgentLinks();
            b && b.forEach(function(a) {
                this._network.invalidateElementUI(a, !1)
            },
            this)
        },
        updateMeasure: function() {
            Ib.network.NodeUI.superClass.updateMeasure.call(this);
            var a = this.getStyle("vector.shape"),
            b = this.getBodyRect();
            this._hotSpot = Tb.getHotSpot(b.x, b.y, b.width, b.height, a),
            this.drawBody(),
            this._outerColor && this.drawOuterBorder(),
            !this._editAttachment && "border" === this.getStyle("select.style") && this._network.isSelected(this._element) && this.drawSelectBorder(),
            this.cleanUp(["_selectCanvas", "_nodeCanvas", "_nodeImage", "_nodeComponent", "_vectorCanvas", "_outerCanvas"]);
            var c = this._element.getParent();
            c instanceof Md && this._network.invalidateElementUI(c, !1)
        },
        drawBody: function() {
            var a = this.getStyle("body.type");
            "default" === a ? this.drawDefaultBody() : "vector" === a ? this.drawVectorBody() : "default.vector" === a ? (this.drawVectorBody(), this.drawDefaultBody()) : "vector.default" === a ? (this.drawDefaultBody(), this.drawVectorBody()) : this.addBodyBounds({
                x: this._element.getX(),
                y: this._element.getY(),
                width: 0,
                height: 0
            })
        },
        drawOuterBorder: function() {
            var a = this._element,
            b = a.getStyle("outer.width");
            if (b > 0) {
                var c = this.getBodyRect();
                Tb.addPadding(c, a, "outer.padding", 1),
                this._outerCanvas || (this._outerCanvas = Wb.createCanvas());
                var d = Jb.clone(c);
                Tb.grow(d, b / 2, b / 2);
                var e = Wb.setCanvas(this._outerCanvas, d);
                e.lineWidth = b,
                e.lineCap = a.getStyle("outer.cap"),
                e.lineJoin = a.getStyle("outer.join"),
                e.strokeStyle = this._outerColor,
                Xb.drawVector(e, a.getStyle("outer.shape"), null, c),
                e.stroke(),
                this.addComponent(this._outerCanvas),
                this.addBodyBounds(d)
            }
        },
        drawSelectBorder: function() {
            var a = this._element,
            b = a.getStyle("select.width");
            if (b > 0) {
                var c = this.getBodyRect();
                Tb.addPadding(c, a, "select.padding", 1),
                this._selectCanvas || (this._selectCanvas = Wb.createCanvas());
                var d = Jb.clone(c);
                Tb.grow(d, b / 2, b / 2);
                var e = Wb.setCanvas(this._selectCanvas, d);
                e.lineWidth = b,
                e.lineCap = a.getStyle("select.cap"),
                e.lineJoin = a.getStyle("select.join"),
                e.strokeStyle = a.getStyle("select.color"),
                Xb.drawVector(e, a.getStyle("select.shape"), null, c),
                e.stroke(),
                this.addComponent(this._selectCanvas),
                this.addBodyBounds(d)
            }
        },
        drawDefaultBody: function() {
            var a = this._element,
            b = Jb.getImageAsset(a.getImage()),
            c = this.getBodyRect();
            if (!b) return this.addBodyBounds(c),
            void(this._currentImageAsset = null);
            if (Tb.addPadding(c, this._element, "image.padding", 1), b.getImage()) {
                this._nodeCanvas || (this._nodeCanvas = Wb.createCanvas());
                var d = Jb.clone(c),
                e = this.setShadow(this, this._nodeCanvas, d);
                0 != a.getAngle() && (c = a.getOriginalRect(), Ib.Util.rotateCanvas(e, c, a.getAngle())),
                Nc(e, a.getImage(), this.getInnerColor(), c, a, this._network),
                c = d,
                this.addComponent(this._nodeCanvas)
            } else if (b.getSrc()) this._nodeImage || (this._nodeImage = Wb.createImg()),
            Wb.setImg(this._nodeImage, b.getSrc(), c),
            this.addComponent(this._nodeImage);
            else {
                if (!b.getFunction()) throw "ImageAsset '" + a.getImage() + " ' is empty";
                this._nodeComponent = this._currentImageAsset !== b ? b.getFunction()(this, c) : b.getFunction()(this, c, this._nodeComponent),
                this.addComponent(this._nodeComponent),
                this._nodeComponent._viewRect = Jb.clone(c)
            }
            this.addBodyBounds(c),
            this._currentImageAsset = b
        },
        hit: function(a, b) {
            if (this._network._transparentSelectionEnable) {
                var c = this.getBodyRect();
                if (Jb.math.containsPoint(c, a, b)) return ! 0
            }
            return this.hitCanvas(a, b, ["_nodeCanvas", "_outerCanvas", "_vectorCanvas"]) ? !0 : this.hitComponent(a, b, ["_nodeImage", "_nodeComponent"])
        },
        intersects: function(a) {
            if (this._network._transparentSelectionEnable) {
                var b = this.getBodyRect();
                if (Jb.math.intersects(b, a)) return ! 0
            }
            return this.intersectsCanvas(a, ["_nodeCanvas", "_outerCanvas", "_vectorCanvas"]) ? !0 : this.intersectsComponent(a, ["_nodeImage", "_nodeComponent"])
        },
        drawVectorBody: function() {
            this._vectorCanvas || (this._vectorCanvas = Wb.createCanvas());
            var a = Xb.drawPath(this, this._vectorCanvas, "vector", !0, this._element.getStyle("vector.outline.pattern")),
            b = this.getStyle("vector.deep"),
            c = this._vectorCanvas.getContext("2d"),
            d = this.getBodyRect(),
            e = this.getStyle("vector.fill.color");
            if (0 !== b && e) {
                var f = this._element.getAngle();
                0 != f && (d = this._element.getOriginalRect(), Ib.Util.rotateCanvas(c, d, -f), Ib.Util.rotateCanvas(c, d, f)),
                "rectangle" === this.getStyle("vector.shape") && Xb.draw3DRect(c, e, b, d)
            }
            this.addBodyBounds(a),
            this.addComponent(this._vectorCanvas)
        }
    }),
    Ib.network.LinkUI = function(a, b) {
        Ib.network.LinkUI.superClass.constructor.call(this, a, b),
        this._linkCanvas = Wb.createCanvas()
    },
    Jb.ext("twaver.network.LinkUI", Ib.network.ElementUI, {
        isEditable: function() {
            return xc.isOrthogonalLink(this._element) && this.getControlPoint() ? !0 : !1
        },
        createBodyRect: function() {
            var a = this.getHotSpot();
            return a ? {
                x: a.x - 1,
                y: a.y - 1,
                width: 2,
                height: 2
            }: null
        },
        hit: function(a, b) {
            return this.hitCanvas(a, b, ["_linkCanvas"])
        },
        intersects: function(a) {
            return this.intersectsCanvas(a, ["_linkCanvas"])
        },
        checkAttachments: function() {
            Ib.network.LinkUI.superClass.checkAttachments.call(this),
            this.checkLinkHandlerAttachment()
        },
        checkLinkHandlerAttachment: function() {
            var a = this._network.getLinkHandlerLabel(this._element);
            null != a && "" !== a ? this._linkHandlerAttachment || (this._linkHandlerAttachment = new Ib.network.LinkHandlerAttachment(this), this.addAttachment(this._linkHandlerAttachment)) : this._linkHandlerAttachment && (this.removeAttachment(this._linkHandlerAttachment), this._linkHandlerAttachment = null)
        },
        getLinkHandlerAttachment: function() {
            return this._linkHandlerAttachment
        },
        getLinkPoints: function() {
            return this._linkPoints || (this._linkPoints = this.createLinkPoints(), this._lineLength = Tb.calculateLineLength(this._linkPoints)),
            this._linkPoints
        },
        invalidate: function(a) {
            this._linkPoints = null,
            this._fromPoint = null,
            this._toPoint = null,
            Ib.network.LinkUI.superClass.invalidate.call(this, a)
        },
        getFromPosition: function(a, b) {
            var c = this.getFromPoint();
            return c ? {
                x: c.x + a,
                y: c.y + b
            }: null
        },
        getToPosition: function(a, b) {
            var c = this.getToPoint();
            return c ? {
                x: c.x + a,
                y: c.y + b
            }: null
        },
        getFromPoint: function() {
            return this._fromPoint || (this._fromPoint = xc.createFromPoint(this)),
            this._fromPoint
        },
        getToPoint: function() {
            return this._toPoint || (this._toPoint = xc.createToPoint(this)),
            this._toPoint
        },
        updateMeasure: function() {
            Ib.network.LinkUI.superClass.updateMeasure.call(this),
            this.drawBody()
        },
        createLinkPoints: function() {
            var a = this.getFromPoint(),
            b = this.getToPoint(),
            c = this.getStyle("link.type"),
            d = new nd;
            if (xc.isOrthogonalOrFlexionalLink(this._element)) d = xc.orthogonalAndFlexional(this, c);
            else if (this._element.isLooped()) {
                var e = this._network.getElementUI(this._element.getFromAgent());
                null != e && (this._hotSpot = xc.fillLoopedPoints(this, e.getBodyRect(), d))
            } else {
                if ("arc" !== c && "triangle" !== c && "parallel" !== c) throw "Can not resolve link type '" + c + "'";
                this._hotSpot = xc.fillBundlePoints(this, c, a, b, d)
            }
            if (this._network._linkPathFunction) {
                var f = this._network._linkPathFunction(this, d);
                f && (d = f)
            }
            return d
        },
        drawLinePoints: function(a, b, c, d, e) {
            if (a.lineWidth = c, a.strokeStyle = d, this._element.getStyle("link.flow") === !0 && e && e.length > 1) {
                var f = new uc(a, e[0], e[1]),
                g = this._element.getStyle("link.flow.offset");
                this._element.getStyle("link.flow.converse") ? g < e[0] ? f.overflow = e[0] - g: g >= e[0] && g <= e[0] + e[1] ? (f.overflow = e[1] - (g - e[0]), f.overflow && (f.isLine = !1)) : (g -= e[0] + e[1], f.overflow = e[0] - g) : g <= e[1] ? (f.overflow = g, g && (f.isLine = !1)) : g > e[1] && g <= e[0] + e[1] ? f.overflow = g - e[1] : (g -= e[0] + e[1], g && (f.isLine = !1), f.overflow = g),
                this._element._styleMap["link.flow.offset"] = g,
                a.beginPath(),
                Xb._drawLine(b, a),
                a.stroke(),
                a.shadowColor = "transparent",
                a.beginPath();
                var h = this._element.getStyle("link.flow.color");
                h = h ? h: Dd.NETWORK_LINK_FLOW_COLOR,
                a.strokeStyle = h,
                Xb._drawLine(b, f),
                a.stroke(),
                a.shadowColor = this._shadowColor
            } else a.beginPath(),
            Xb.drawLinePoints(a, b, e),
            a.stroke()
        },
        drawBody: function() {
            var a = this.getLinkPoints();
            if (a && !(a.size() < 2)) {
                var b = this._element,
                c = Tb.getLineRect(a),
                d = b.getStyle("link.width"),
                e = d;
                if (this._outerColor) {
                    var f = b.getStyle("outer.width");
                    e += 2 * f
                }
                var g = !this._editAttachment && "border" === b.getStyle("select.style") && this._network.isSelected(this._element);
                if (g) {
                    var h = b.getStyle("select.width");
                    e += 2 * h
                }
                Tb.grow(c, e / 2, e / 2),
                b.getStyle("arrow.from") && (c = Tb.unionRect(c, od.getArrowRect(a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), b.getStyle("arrow.from.xoffset"), b.getStyle("arrow.from.yoffset")))),
                b.getStyle("arrow.to") && (c = Tb.unionRect(c, od.getArrowRect(a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), b.getStyle("arrow.to.xoffset"), b.getStyle("arrow.to.yoffset"))));
                var i = this.setShadow(this, this._linkCanvas, c);
                i.lineCap = b.getStyle("link.cap"),
                i.lineJoin = b.getStyle("link.join");
                var j = b.getStyle("link.pattern");
                g && this.drawLinePoints(i, a, e, b.getStyle("select.color"), j),
                this._outerColor && this.drawLinePoints(i, a, d + 2 * f, this._outerColor, j),
                this.drawLinePoints(i, a, d, this._innerColor || b.getStyle("link.color"), j),
                this.addBodyBounds(c),
                this.addComponent(this._linkCanvas),
                od.drawLinkArrow(this, i, a)
            }
        },
        getControlPoint: function() {
            return xc.getControlPoint(this._element, this)
        },
        setControlPoint: function(a) {
            if (a) {
                var b = this.getStyle("link.type");
                if (xc.hasControlPoint(b)) {
                    var c = xc.getLinkSourceBounds(this),
                    d = xc.getLinkTargetBounds(this);
                    xc.setParamsByControlPoint(a, c, d, b, this._element)
                }
            }
        },
        getLineLength: function() {
            return this._lineLength
        }
    }),
    Ib.network.HTMLLinkUI = function(a, b) {
        Ib.network.HTMLLinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.HTMLLinkUI", Ib.network.LinkUI, {
        checkAttachments: function() {
            Ib.network.LinkUI.prototype.checkAttachments.call(this)
        },
        checkLabelAttachment: function() {
            var a = this._element.getStyle("attachment.label.style");
            if (a && "none" === a) return void Ib.network.HTMLLinkUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel(this._element);
            null != b && "" !== b ? this._labelAttachment || (this._labelAttachment = new Ib.network.HTMLLabelAttachment(this), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._element.getStyle("attachment.alarm.style");
            if (a && "none" === a) return void Ib.network.HTMLLinkUI.superClass.checkAlarmAttachment.call(this);
            var b = this._network.getAlarmLabel(this._element);
            null != b && "" !== b ? this._alarmAttachment || (this._alarmAttachment = new Ib.network.HTMLAlarmAttachment(this, !1), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        }
    }),
    Ib.network.GroupUI = function(a, b) {
        Ib.network.GroupUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.GroupUI", Ib.network.NodeUI, {
        isEditable: function() {
            return ! this._element.isExpanded()
        },
        drawBody: function() {
            this.getBodyRect(),
            this._shapeRect ? this.drawExpandedGroup() : Ib.network.GroupUI.superClass.drawBody.call(this)
        },
        drawExpandedGroup: function() {
            this._nodeCanvas || (this._nodeCanvas = Wb.createCanvas());
            var a = Xb.drawPath(this, this._nodeCanvas, "group", !1, this._element.getStyle("vector.outline.pattern")),
            b = this.getStyle("group.deep"),
            c = this.getStyle("group.fill.color");
            0 !== b && c && "rectangle" === this.getStyle("group.shape") && Xb.draw3DRect(this._nodeCanvas.getContext("2d"), c, b, this._bodyRect),
            this.addBodyBounds(a),
            this.addComponent(this._nodeCanvas)
        },
        getChildrenRects: function() {
            return this._network.getGroupChildrenRects(this._element)
        },
        createBodyRect: function() {
            this._shapeRect = null;
            var a = this._element;
            if (a.isExpanded()) {
                var b = this.getChildrenRects();
                if (!b.isEmpty()) {
                    var c = a.getStyle("group.shape"),
                    d = Ub[c];
                    if (!d) throw "Can not resolve group shape '" + c + "'";
                    this._shapeRect = d(b)
                }
            }
            return this._shapeRect ? (Tb.addPadding(this._shapeRect, a, "group.padding", 1), this._shapeRect) : Ib.network.GroupUI.superClass.createBodyRect.call(this)
        }
    }),
    Ib.network.GridUI = function(a, b) {
        Ib.network.GridUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.GridUI", Ib.network.NodeUI, {
        drawDefaultBody: function() {
            this._element.getImage() ? Ib.network.GridUI.superClass.drawDefaultBody.call(this) : this.drawGridBody()
        },
        drawGridBody: function() {
            var a = this.getStyle("grid.fill"),
            b = this.getStyle("grid.deep"),
            c = this.getStyle("grid.cell.deep");
            if (a || 0 !== b || 0 !== c) {
                var d = this.getBodyRect(),
                e = this.getDyeColor("grid.fill.color");
                this._nodeCanvas || (this._nodeCanvas = Wb.createCanvas());
                var f = Jb.clone(d),
                g = this.setShadow(this, this._nodeCanvas, f);
                if (g.rect(d.x, d.y, d.width, d.height), this.addComponent(this._nodeCanvas), a && (g.fillStyle = e, g.fill()), 0 != b && Xb.draw3DRect(g, e, b, d.x, d.y, d.width, d.height), 0 != c) for (var h = this.getStyle("grid.row.count"), i = this.getStyle("grid.column.count"), j = 0; h > j; j++) for (var k = 0; i > k; k++) {
                    var l = this._element.getCellRect(j, k);
                    null != l && Xb.draw3DRect(g, e, c, l.x, l.y, l.width, l.height)
                }
                this.addBodyBounds(f)
            }
        }
    }),
    Ib.network.ShapeNodeUI = function(a, b) {
        Ib.network.ShapeNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.ShapeNodeUI", Ib.network.NodeUI, {
        drawDefaultBody: function() {
            if (this._element._points.size() < 2) return void this.addBodyBounds({
                x: this._element.getX(),
                y: this._element.getY(),
                width: 0,
                height: 0
            });
            this._nodeCanvas || (this._nodeCanvas = Wb.createCanvas());
            var a = Xb.drawPath(this, this._nodeCanvas, "vector", !0, this._element.getStyle("vector.outline.pattern"), this._element._points, this._element._segments, this._element.getStyle("shapenode.closed"));
            this.addBodyBounds(a),
            this.addComponent(this._nodeCanvas),
            od.drawLinkArrow(this, this._nodeCanvas.getContext("2d"), Tb.getPointObject(this._element._points, this._element._segments))
        },
        drawSelectBorder: function() {
            var a = this._element,
            b = a.getStyle("select.width");
            if (b > 0) {
                var c = this.getBodyRect();
                Tb.addPadding(c, a, "select.padding", 1);
                var d = a.getStyle("vector.outline.width");
                d > 0 && Tb.grow(c, d / 2, d / 2),
                this._selectCanvas || (this._selectCanvas = Wb.createCanvas());
                var e = Jb.clone(c);
                Tb.grow(e, b / 2, b / 2);
                var f = Wb.setCanvas(this._selectCanvas, e);
                f.lineWidth = b,
                f.lineCap = a.getStyle("select.cap"),
                f.lineJoin = a.getStyle("select.join"),
                f.strokeStyle = a.getStyle("select.color"),
                Xb.drawVector(f, a.getStyle("select.shape"), null, c),
                f.stroke(),
                this.addComponent(this._selectCanvas),
                this.addBodyBounds(e)
            }
        }
    }),
    Ib.network.ShapeLinkUI = function(a, b) {
        Ib.network.ShapeLinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.ShapeLinkUI", Ib.network.LinkUI, {
        isEditable: function() {
            return ! 0
        },
        createLinkPoints: function() {
            var a = this.getFromPoint(),
            b = this.getToPoint(),
            c = new nd,
            d = this.getStyle("shapelink.type");
            c.add(a),
            null != this._element._points && c.addAll(this._element._points),
            c.add(b);
            var e = c.size(),
            f = Math.floor(e / 2);
            if (e % 2 === 0) {
                var g = c.get(f),
                h = c.get(f - 1);
                this._hotSpot = {
                    x: (g.x + h.x) / 2,
                    y: (g.y + h.y) / 2
                }
            } else this._hotSpot = Jb.clone(c.get(f));
            var i, j, k;
            if ("lineto" === d);
            else if ("quadto" === d) {
                for (i = new nd(c.get(0)), j = 1, e = c.size(); e > j; j++) i.add(e - 1 > j ? new nd([c.get(j++), c.get(j)]) : c.get(j));
                c = i
            } else if ("cubicto" === d) {
                for (i = new nd(c.get(0)), j = 1, e = c.size(); e > j; j++) i.add(e - 2 > j ? new nd([c.get(j++), c.get(j++), c.get(j)]) : e - 1 > j ? new nd([c.get(j++), c.get(j)]) : c.get(j));
                c = i
            } else {
                if ("orthogonalto" !== d) throw "Can not resolve shapelink type '" + d + "'";
                for (k = c.get(0), i = new nd(k), j = 1, e = c.size(); e > j; j++) if (e - 1 > j) {
                    var l = Jb.clone(c.get(j)),
                    m = l.x,
                    n = l.y,
                    o = m - k.x,
                    p = n - k.y;
                    Math.abs(o) > Math.abs(p) ? (l.x = m, l.y = k.y) : (l.x = k.x, l.y = n),
                    k = l,
                    i.add(k)
                } else i.add(c.get(j));
                c = i
            }
            return c
        }
    }),
    Ib.network.RotatableNodeUI = function(a, b) {
        Ib.network.RotatableNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.network.RotatableNodeUI", Ib.network.NodeUI, {
        isEditable: function() {
            return ! 1
        },
        drawDefaultBody: function() {
            var a = this._element,
            b = Jb.getImageAsset(a.getImage()),
            c = this.getBodyRect();
            if (!b) return this.addBodyBounds(c),
            void(this._currentImageAsset = null);
            if (Tb.addPadding(c, this._element, "image.padding", 1), b.getImage()) {
                this._nodeCanvas || (this._nodeCanvas = Wb.createCanvas());
                var d = Jb.clone(c),
                e = this.setShadow(this, this._nodeCanvas, d),
                f = this._element._getOrignalWidth(),
                g = this._element._getOrignalHeight(),
                h = this._element._getRotateRect();
                e.save(),
                e.translate(c.x - h.x + f / 2, c.y - h.y + g / 2),
                e.rotate(this._element._angle * Math.PI / 180);
                var c = {
                    x: -f / 2,
                    y: -g / 2,
                    width: f,
                    height: g
                };
                Nc(e, b.getImage(this._innerColor, c.width, c.height), this._innerColor, c, a, this._network),
                e.restore(),
                this.addComponent(this._nodeCanvas)
            } else if (b.getSrc());
            else if (!b.getFunction()) throw "ImageAsset '" + a.getImage() + " ' is empty";
            this.addBodyBounds(c),
            this._currentImageAsset = b
        }
    }),
    Ib.network.HTMLNodeUI = function(a, b) {
        Ib.network.HTMLNodeUI.superClass.constructor.call(this, a, b)
    },
    Ib.Util.ext("twaver.network.HTMLNodeUI", Ib.network.NodeUI, {
        checkAttachments: function() {
            Ib.network.NodeUI.prototype.checkAttachments.call(this)
        },
        checkLabelAttachment: function() {
            var a = this._element.getStyle("attachment.label.style");
            if (a && "none" === a) return void Ib.network.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel(this._element);
            null != b && "" !== b ? this._labelAttachment || (this._labelAttachment = new Ib.network.HTMLLabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._element.getStyle("attachment.alarm.style");
            if (a && "none" === a) return void Ib.network.HTMLNodeUI.superClass.checkAlarmAttachment.call(this);
            var b = this._network.getAlarmLabel(this._element);
            null != b && "" !== b ? this._alarmAttachment || (this._alarmAttachment = new Ib.network.HTMLAlarmAttachment(this, !1), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        }
    }),
    Ib.network.interaction.BaseInteraction = function(a) {
        this.network = a
    },
    Jb.ext("twaver.network.interaction.BaseInteraction", Object, {
        setUp: function() {},
        tearDown: function() {},
        addListener: function() {
            for (var a = 0; a < arguments.length; a++) {
                var b = arguments[a];
                Wb.addEventListener(b, "handle_" + b, this.network.getView(), this)
            }
        },
        removeListener: function() {
            for (var a = 0; a < arguments.length; a++) Wb.removeEventListener(arguments[a], this.network.getView(), this)
        },
        _handle_mousedown: function(a) {
            0 === a.button && (this._startLogical = this.network.getLogicalPoint(a), this._startClient = Wb.getClientPoint(a), this._startLogical && Wb.handle_mousedown(this, a))
        },
        _handle_mousemove: function(a) {
            this._endLogical = {
                x: this._startLogical.x + (a.clientX - this._startClient.x) / this.network.getZoom(),
                y: this._startLogical.y + (a.clientY - this._startClient.y) / this.network.getZoom()
            }
        },
        _handle_mouseup: function(a) {
            delete this._startClient,
            delete this._startLogical,
            delete this._endLogical
        }
    }),
    Ib.network.interaction.SelectInteraction = function(a) {
        Ib.network.interaction.SelectInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.SelectInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown")
        },
        tearDown: function() {
            this.removeListener("mousedown"),
            this.end()
        },
        handle_mousedown: function(a) {
            if (this._button = a.button, this.network.isValidEvent(a) && !this.network.isMovingElement() && !this.network.isEditingElement() && !a.shiftKey) {
                var b = this.network.getElementAt(a),
                c = this.network.getSelectionModel();
                b ? Jb.isCtrlDown(a) ? c.contains(b) ? c.removeSelection(b) : c.appendSelection(b) : c.contains(b) || c.setSelection(b) : (Jb.isCtrlDown(a) || c.clearSelection(), this.end(a), this.network.getLogicalPoint(a) && this.network.isRectSelectEnabled() && this._handle_mousedown(a))
            }
        },
        handle_mouseup: function(a) {
            this.end(a)
        },
        handle_mousemove: function(a) {
            if (0 !== this._button || this.network.isMovingElement() || this.network.isEditingElement()) return void this.end(a);
            this._handle_mousemove(a),
            this.mark ? this.network.fireInteractionEvent({
                kind: "selectBetween",
                event: a
            }) : (this.mark = Wb.createDiv(), this.network.getTopDiv().appendChild(this.mark), this.network.setSelectingElement(!0), this.network.fireInteractionEvent({
                kind: "selectStart",
                event: a
            }));
            var b = Tb.getRect([this._startLogical, this._endLogical]);
            Wb.setDiv(this.mark, b, this.getIntersectMode() ? this.network.getSelectFillColor() : null, this.network.getSelectOutlineWidth(), this.network.getSelectOutlineColor())
        },
        end: function(a) {
            if (this._startLogical) {
                if (this.mark) {
                    if (this._endLogical && this._startLogical.x !== this._endLogical.x && this._startLogical.y !== this._endLogical.y) {
                        var b = this.network.getElementsAtRect(this.mark._viewRect, this.getIntersectMode(), this.network.getRectSelectFilter());
                        if (b && b.size() > 0) {
                            var c = this.network.getSelectionModel(),
                            d = c.toSelection();
                            b.forEach(function(a) {
                                c.contains(a) ? d.remove(a) : d.add(a)
                            },
                            this),
                            c.setSelection(d)
                        }
                        this.network.fireInteractionEvent({
                            kind: "selectEnd",
                            event: a
                        })
                    }
                    var e = this;
                    setTimeout(function() {
                        e.mark && (e.network.getTopDiv().removeChild(e.mark), e.mark = null)
                    },
                    0),
                    this.network.setSelectingElement(!1)
                }
                this._handle_mouseup(a)
            }
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this._startLogical.x > this._endLogical.x && this._startLogical.y > this._endLogical.y
        }
    }),
    Ib.network.interaction.MoveInteraction = function(a, b) {
        this.lazyMode = b,
        this.xoffset = 0,
        this.yoffset = 0,
        Ib.network.interaction.MoveInteraction.superClass.constructor.call(this, a),
        this.currentKeyEvent = null
    },
    Jb.ext("twaver.network.interaction.MoveInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "keydown")
        },
        tearDown: function() {
            this.removeListener("mousedown", "keydown"),
            this.end()
        },
        handle_keydown: function(a) {
            this.currentKeyEvent = a,
            this.addListener("keyup")
        },
        handle_keyup: function(a) {
            this.currentKeyEvent = null,
            this.removeListener("keyup")
        },
        isParenting: function() {
            return this._startLogical && null != this.currentKeyEvent && 80 === this.currentKeyEvent.keyCode
        },
        parentProcess: function(a, b) {
            var c = null;
            null != this.parent && (c = this.network.getElementUI(this.parent).getViewRect(), this.parent = null);
            var d = this;
            if (a = this.network.getLogicalPoint(a), !b && this.isParenting()) {
                var e = {};
                e.x = a.x - 1,
                e.y = a.y - 1,
                e.width = 2,
                e.height = 2;
                var f = this.network.getElementsAtRect(e, !0);
                if (f && f.size() > 0) for (var g = f.size(), h = 0; g > h; h++) {
                    var i = f.get(h);
                    if (!d.network.getElementBox().getSelectionModel().contains(i)) {
                        d.parent = i;
                        break
                    }
                }
            }
            null != this.parent && (c = this.network.getElementUI(this.parent).getViewRect()),
            null == c || b ? this.parentMark && (this.network.getTopDiv().removeChild(this.parentMark), this.parentMark = null) : (this.parentMark || (this.parentMark = Jb.html.createDiv(), this.network.getTopDiv().appendChild(this.parentMark)), Jb.html.setDiv(this.parentMark, c, this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null, this.network.getLazyMoveOutlineWidth(), this.network.getLazyMoveOutlineColor()))
        },
        handle_mousedown: function(a) {
            if (0 === a.button && !this.network.isSelectingElement() && !this.network.isEditingElement()) {
                var b = this.network.getElementAt(a);
                this.network.isMovable(b) && (this.end(a), this._handle_mousedown(a))
            }
        },
        handle_mouseup: function(a) {
            this.end(a)
        },
        handle_mousemove: function(a) {
            if (this.network.isSelectingElement() || this.network.isEditingElement() || !this.network.hasMovableSelectedElements() || !this._startLogical) return void this.end(a);
            if (this._handle_mousemove(a), this.xoffset = this._endLogical.x - this._startLogical.x, this.yoffset = this._endLogical.y - this._startLogical.y, this.lazyMode) {
                if (this.mark) this.network.fireInteractionEvent({
                    kind: "lazyMoveBetween",
                    event: a
                });
                else {
                    this.mark = Wb.createDiv();
                    var b;
                    this.network.getMovableSelectedElements().forEach(function(a) {
                        var c = this.getElementUI(a);
                        c && (b = Tb.unionRect(b, c.getViewRect()))
                    },
                    this.network),
                    this.network.getTopDiv().appendChild(this.mark),
                    this.network.setMovingElement(!0),
                    Wb.setDiv(this.mark, b, this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null, this.network.getLazyMoveOutlineWidth(), this.network.getLazyMoveOutlineColor()),
                    this.network.fireInteractionEvent({
                        kind: "lazyMoveStart",
                        event: a
                    })
                }
                this.mark.style.left = this.xoffset + this.mark._viewRect.x + "px",
                this.mark.style.top = this.yoffset + this.mark._viewRect.y + "px"
            } else this._startLogical = this._endLogical,
            this._startClient = Wb.getClientPoint(a),
            this.network.isMovingElement() ? this.network.fireInteractionEvent({
                kind: "liveMoveBetween",
                event: a
            }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                kind: "liveMoveStart",
                event: a
            })),
            this.network.moveSelectedElements(this.xoffset, this.yoffset);
            this.parentProcess(a, !1)
        },
        end: function(a) {
            if (this._startLogical) {
                if (this.lazyMode) {
                    if (this.mark) {
                        var b = this,
                        c = function() {
                            b.network.fireInteractionEvent({
                                kind: "lazyMoveEnd",
                                event: a
                            }),
                            b.mark && (b.network.getTopDiv().removeChild(b.mark), b.mark = null, b.network.setMovingElement(!1))
                        };
                        this.network.moveSelectedElements(this.xoffset, this.yoffset, this.network.isLazyMoveAnimate(), c)
                    }
                } else this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                    kind: "liveMoveEnd",
                    event: a
                }));
                if (this.isParenting()) {
                    null == this.parent && (this.parent = this.network.getCurrentSubNetwork());
                    var b = this;
                    this.network.getMovableSelectedElements().forEach(function(a) {
                        a.setParent(b.parent)
                    },
                    this.network)
                }
                this.parentProcess(a, !0),
                this._handle_mouseup(a)
            }
        }
    }),
    Ib.network.interaction.DefaultInteraction = function(a) {
        Ib.network.interaction.DefaultInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.DefaultInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove", "keydown")
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove", "keydown")
        },
        handle_mousedown: function(a) {
            if (this.network.isValidEvent(a)) {
                this.network.isFocusOnClick() && Ib.Util.setFocus(this.network.getView());
                var b = this.network.getElementAt(a);
                2 === a.detail ? this.handleDoubleClicked(a, b) : this.handleClicked(a, b)
            }
        },
        handleClicked: function(a, b) {
            Cc.handleClicked(this.network, a, b)
        },
        handleDoubleClicked: function(a, b) {
            Cc.handleDoubleClicked(this.network, a, b)
        },
        handle_keydown: function(a) {
            Cc.handleKeyDown(this.network, a)
        },
        handle_mousemove: function(a) {
            var b = this.network.getElementAt(a),
            c = this._preElement,
            d = Dc(c),
            e = Dc(b);
            c !== b && (c && (d && d.onMouseLeave && d.onMouseLeave(c, this.network), this.network.onMouseLeave(c, a)), b && (e && e.onMouseEnter && e.onMouseEnter(b, this.network), this.network.onMouseEnter(b, a))),
            b && e && e.onMouseMove && e.onMouseMove(b, this.network),
            this.network.onMouseMove(b, a),
            this._preElement = b
        }
    }),
    Ib.network.interaction.PanInteraction = function(a) {
        Ib.network.interaction.PanInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.PanInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown"),
            this._oldCursor = this.network.getView().style.cursor
        },
        tearDown: function() {
            this.removeListener("mousedown")
        },
        handle_mousedown: function(a) {
            this._startLogical = this.network.getLogicalPoint(a),
            this._startLogical && (this._handle_mousedown(a), this.network.getView().style.cursor = "pointer")
        },
        handle_mouseup: function(a) {
            this._clear()
        },
        handle_mousemove: function(a) {
            if (this._startLogical) {
                this._handle_mousemove(a);
                var b = this._startLogical.x - this._endLogical.x,
                c = this._startLogical.y - this._endLogical.y;
                this.network.panByOffset(b, c),
                this._startLogical = this._endLogical,
                this._startClient = Wb.getClientPoint(a)
            }
        },
        _clear: function(a) {
            this._startLogical && (this._handle_mouseup(a), this.network.getView().style.cursor = this._oldCursor)
        }
    }),
    Ib.network.interaction.EditInteraction = function(a, b) {
        this.lazyMode = b,
        this.pointIndex = -1,
        this.editPointSize = a.getEditPointSize(),
        this.resizePointSize = a.getResizePointSize(),
        this.rotatePointSize = a.getRotatePointSize(),
        Ib.network.interaction.EditInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.EditInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove"),
            this.oldCursor = this.network.getView().style.cursor,
            this.network.setHasEditInteraction(!0)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.network.getView().style.cursor = this.oldCursor,
            this.network.setHasEditInteraction(!1),
            this.clear()
        },
        clear: function() {
            this.network.setEditingElement(!1),
            this.network.setRotatingElement(!1),
            this.isStart = !1,
            this.isStartRotate = !1,
            this.node = null,
            this.shapeNode = null,
            this.shapeLink = null,
            this.linkUI = null,
            this.resizingRect = null,
            this.resizeDirection = null,
            this.pointIndex = -1,
            this._removeCursor(),
            this.oldCursor = null,
            this.mouseMoved = !1,
            this.horizontal = !1,
            this.vertical = !1,
            this.mark && (this.network.getTopDiv().removeChild(this.mark), this.mark = null),
            this.rotateScale && this.network.getTopDiv().contains(this.rotateScale) && (this.network.getTopDiv().removeChild(this.rotateScale), this.rotateScale = null)
        },
        _removeCursor: function() {
            this.cursorID && (this.network.getView().style.cursor = this.oldCursor || "default", this.cursorID = null),
            this.resizeDirection = null,
            this.isCrossCursor = !1
        },
        _setCrossCursor: function() {
            this.isCrossCursor || (this._removeCursor(), this._setCursor("crosshair"), this.isCrossCursor = !0)
        },
        _setCursor: function(a) {
            this.cursorID = a,
            this.network.getView().style.cursor !== this.cursorID && (this.network.getView().style.cursor = this.cursorID)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) if (!Jb.isAltDown(a) || this.network.isEditingElement()) ! this.network.isEditingElement() || this.isStart || this.isStartRotate || (this.node && this.resizeDirection ? (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: this.lazyMode ? "lazyResizeStart": "liveResizeStart",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            })) : this.shapeNode && this.pointIndex >= 0 ? Jb.isAltDown(a) ? (this.shapeNode.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                kind: "removePoint",
                event: a,
                element: this.shapeNode
            })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.shapeNode,
                pointIndex: this.pointIndex
            })) : this.shapeLink && this.pointIndex >= 0 ? Jb.isAltDown(a) ? (this.shapeLink.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                kind: "removePoint",
                event: a,
                element: this.shapeLink
            })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.shapeLink,
                pointIndex: this.pointIndex
            })) : this.linkUI ? (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.linkUI._element
            })) : this.node && (this.isStartRotate = !0, this._handle_mousedown(a)));
            else {
                var b = this.network.getElementAt(a),
                c = this.network.getLogicalPoint(a);
                if (b instanceof Ib.ShapeNode) {
                    var d = this.getPointIndex(b.getPoints(), c, !0);
                    d > 0 && (this._handle_mousedown(a), this.pointIndex = d, this.shapeNode = b, b.addPoint(c, d), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: b,
                        pointIndex: d
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: b,
                        pointIndex: d
                    }))
                }
                if (b instanceof Ib.ShapeLink) {
                    var e = new Ib.List(b.getPoints()),
                    f = this.network.getElementUI(b);
                    e.add(f.getFromPoint(), 0),
                    e.add(f.getToPoint());
                    var d = this.getPointIndex(e, c) - 1;
                    d > 0 && (this._handle_mousedown(a), this.pointIndex = d, this.shapeLink = b, b.addPoint(c, d), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: b,
                        pointIndex: d
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: b,
                        pointIndex: d
                    }))
                }
            }
        },
        handle_mouseup: function(a) {
            if (this.isStart) {
                var b = Jb.clone(this._endLogical);
                if (this.resizingRect) if (this.lazyMode) if (this.network.isResizeAnimate()) {
                    var c = this,
                    d = new Ib.animate.AnimateBounds(this.node, this.resizingRect,
                    function() {
                        c.network.fireInteractionEvent({
                            kind: "lazyResizeEnd",
                            event: a,
                            element: c.node,
                            resizeDirection: c.resizeDirection
                        }),
                        c.clear()
                    });
                    Ib.animate.AnimateManager.start(d)
                } else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "lazyResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "liveResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else if (this.shapeNode && this.pointIndex >= 0 && b) {
                    var e = this.shapeNode.getPoints().get(this.pointIndex);
                    this.horizontal && (b.y = e.y),
                    this.vertical && (b.x = e.x),
                    this.shapeNode.setPoint(this.pointIndex, b),
                    this.network.fireInteractionEvent({
                        kind: "liveMovePointEnd",
                        event: a,
                        element: this.shapeNode,
                        pointIndex: this.pointIndex
                    })
                } else if (this.shapeLink && this.pointIndex >= 0 && b) {
                    var e = this.shapeLink.getPoints().get(this.pointIndex);
                    this.horizontal && (b.y = e.y),
                    this.vertical && (b.x = e.x),
                    this.shapeLink.setPoint(this.pointIndex, b),
                    this.network.fireInteractionEvent({
                        kind: "liveMovePointEnd",
                        event: a,
                        element: this.shapeLink,
                        pointIndex: this.pointIndex
                    })
                } else this.linkUI && b && (this.linkUI.setControlPoint(b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.linkUI._element
                }))
            }
            this._handle_mouseup(a),
            this.lazyMode || this.clear()
        },
        handle_mousemove: function(a) {
            if (this.isStartRotate && this.node) return this._handleRotateElement(a, this.node),
            void(this.network.isShowRotateScale() && this.showRotateScale());
            if (this.isStart) {
                if (this.shapeNode && this.pointIndex >= 0) return void this._handleMovingShapeNodePoint(a);
                if (this.shapeLink && this.pointIndex >= 0) return void this._handleMovingShapeLinkPoint(a);
                if (this.node && this.resizeDirection) return void this._handleResizing(a);
                if (this.linkUI) return void this._handleMovingLinkControlPoint(a)
            } else if (this.network.isValidEvent(a)) {
                if (this.network.isSelectingElement() || this.network.isMovingElement() || 0 === this.network.getSelectionModel().size()) return void this.clear();
                var b = this.network.getElementAt(a),
                c = this.network.getElementUI(b);
                if (!c || !c.getEditAttachment()) return void this.clear();
                var d = this.network.getLogicalPoint(a);
                if (b instanceof Kd) {
                    if (this.node = b, this._isEditingShapeNode(d) || this._isResizingNode(d)) return void this.network.setEditingElement(!0);
                    if (this._isRotatingElement(d)) return this.network.setRotatingElement(!0),
                    void this.network.setEditingElement(!0)
                } else if (b instanceof Ib.ShapeLink) {
                    if (this.shapeLink = b, this._isEditingShapeLink(d)) return void this.network.setEditingElement(!0)
                } else if (c instanceof Ib.network.LinkUI && xc.isOrthogonalLink(c._element)) {
                    this.linkUI = c;
                    var e = this.linkUI.getControlPoint();
                    return void(e && this._contains(d, e, this.editPointSize) && (this._setCrossCursor(), this.network.setEditingElement(!0)))
                }
                this.clear()
            }
        },
        _isRotatingElement: function(a) {
            var b = this.network.getRotatePointSize();
            if (0 >= b) return ! 1;
            var c = this.node.getOriginalRect(),
            d = this.node.getAngle();
            return this._isRotating(a, "crosshair", c, d)
        },
        _isRotating: function(a, b, c, d) {
            var e = this.network.getRotatePointSize(),
            f = {
                x: c.x + c.width / 2,
                y: c.y - this.network.getRotatePointOffset() - e
            },
            g = this._rotatePoint(f, d, c),
            h = {
                x: g.x - e,
                y: g.y - e,
                width: 2 * e,
                height: 2 * e
            };
            return Tb.containsPoint(h, a) ? (this._removeCursor(), this._setCursor(b), !0) : !1
        },
        _handleRotateElement: function(a, b) {
            this._handle_mousemove(a);
            var c = this._calculateAngle(this.network.getLogicalPoint(a), b);
            b.setAngle(c)
        },
        _calculateAngle: function(a, b) {
            var c = b.getCenterLocation();
            return Math.round(180 * Math.atan2(c.x - a.x, a.y - c.y) / Math.PI + 180)
        },
        _handleMovingShapeNodePoint: function(a) {
            if (this._handle_mousemove(a), !this.mouseMoved && Jb.isCtrlDown(a)) {
                var b = this._endLogical.x - this._startLogical.x,
                c = this._endLogical.y - this._startLogical.y;
                this.horizontal = Math.abs(b) >= Math.abs(c),
                this.vertical = !this.horizontal,
                this.mouseMoved = !0
            }
            var d = this.shapeNode.getPoints().get(this.pointIndex),
            e = Jb.clone(this._endLogical);
            this.horizontal && (e.y = d.y),
            this.vertical && (e.x = d.x),
            this.shapeNode.setPoint(this.pointIndex, e),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.shapeNode,
                pointIndex: this.pointIndex
            })
        },
        _handleMovingShapeLinkPoint: function(a) {
            if (this._handle_mousemove(a), !this.mouseMoved && Jb.isCtrlDown(a)) {
                var b = this._endLogical.x - this._startLogical.x,
                c = this._endLogical.y - this._startLogical.y;
                this.horizontal = Math.abs(b) >= Math.abs(c),
                this.vertical = !this.horizontal,
                this.mouseMoved = !0
            }
            var d = this.shapeLink.getPoints().get(this.pointIndex),
            e = Jb.clone(this._endLogical);
            this.horizontal && (e.y = d.y),
            this.vertical && (e.x = d.x),
            this.shapeLink.setPoint(this.pointIndex, e),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.shapeLink,
                pointIndex: this.pointIndex
            })
        },
        _handleMovingLinkControlPoint: function(a) {
            this._handle_mousemove(a),
            this.linkUI.setControlPoint(Jb.clone(this._endLogical)),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.linkUI._element
            })
        },
        _handleResizing: function(a) {
            this._handle_mousemove(a);
            var b = this.node.getAngle(),
            c = this.node.getLocation(),
            d = this.node.getWidth() / 2,
            e = this.node.getHeight() / 2,
            f = {
                x: c.x + d,
                y: c.y + e
            },
            g = {
                x: -d,
                y: -e
            },
            h = {
                x: -d,
                y: e
            },
            i = {
                x: d,
                y: e
            },
            j = {
                x: d,
                y: -e
            },
            k = {
                x: 0,
                y: -e
            },
            l = {
                x: d,
                y: 0
            },
            m = {
                x: 0,
                y: e
            },
            n = {
                x: -d,
                y: 0
            };
            if ("northwest" === this.resizeDirection && (this._transformPoint(i, f, b), g.x = this._endLogical.x, g.y = this._endLogical.y, f.x = (g.x + i.x) / 2, f.y = (g.y + i.y) / 2, this._reversPoint(g, f, b), this._reversPoint(i, f, b), this.resizingRect = {
                x: g.x,
                y: g.y,
                width: i.x - g.x,
                height: i.y - g.y
            }), "north" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                k.y = o.y - f.y,
                this._transformPoint(k, f, b),
                this._transformPoint(m, f, b),
                f.x = (k.x + m.x) / 2,
                f.y = (k.y + m.y) / 2,
                this._reversPoint(k, f, b),
                this._reversPoint(m, f, b),
                this.resizingRect = {
                    x: f.x - this.node.getWidth() / 2,
                    y: f.y - (m.y - k.y) / 2,
                    width: this.node.getWidth(),
                    height: m.y - k.y
                }
            }
            if ("northeast" === this.resizeDirection && (this._transformPoint(h, f, b), j.x = this._endLogical.x, j.y = this._endLogical.y, f.x = (h.x + j.x) / 2, f.y = (h.y + j.y) / 2, this._reversPoint(h, f, b), this._reversPoint(j, f, b), this.resizingRect = {
                x: h.x,
                y: j.y,
                width: j.x - h.x,
                height: h.y - j.y
            }), "west" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                n.x = o.x - f.x,
                this._transformPoint(l, f, b),
                this._transformPoint(n, f, b),
                f.x = (l.x + n.x) / 2,
                f.y = (l.y + n.y) / 2,
                this._reversPoint(l, f, b),
                this._reversPoint(n, f, b),
                this.resizingRect = {
                    x: f.x - (l.x - n.x) / 2,
                    y: f.y - this.node.getHeight() / 2,
                    width: l.x - n.x,
                    height: this.node.getHeight()
                }
            }
            if ("east" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                l.x = o.x - f.x,
                this._transformPoint(l, f, b),
                this._transformPoint(n, f, b),
                f.x = (l.x + n.x) / 2,
                f.y = (l.y + n.y) / 2,
                this._reversPoint(l, f, b),
                this._reversPoint(n, f, b),
                this.resizingRect = {
                    x: f.x - (l.x - n.x) / 2,
                    y: f.y - this.node.getHeight() / 2,
                    width: l.x - n.x,
                    height: this.node.getHeight()
                }
            }
            if ("southwest" === this.resizeDirection && (this._transformPoint(j, f, b), h.x = this._endLogical.x, h.y = this._endLogical.y, f.x = (h.x + j.x) / 2, f.y = (h.y + j.y) / 2, this._reversPoint(h, f, b), this._reversPoint(j, f, b), this.resizingRect = {
                x: h.x,
                y: j.y,
                width: j.x - h.x,
                height: h.y - j.y
            }), "south" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                m.y = o.y - f.y,
                this._transformPoint(k, f, b),
                this._transformPoint(m, f, b),
                f.x = (k.x + m.x) / 2,
                f.y = (k.y + m.y) / 2,
                this._reversPoint(k, f, b),
                this._reversPoint(m, f, b),
                this.resizingRect = {
                    x: f.x - this.node.getWidth() / 2,
                    y: f.y - (m.y - k.y) / 2,
                    width: this.node.getWidth(),
                    height: m.y - k.y
                }
            }
            "southeast" === this.resizeDirection && (this._transformPoint(g, f, b), i.x = this._endLogical.x, i.y = this._endLogical.y, f.x = (g.x + i.x) / 2, f.y = (g.y + i.y) / 2, this._reversPoint(g, f, b), this._reversPoint(i, f, b), this.resizingRect = {
                x: g.x,
                y: g.y,
                width: i.x - g.x,
                height: i.y - g.y
            }),
            this.lazyMode ? (this.mark || (this.mark = Wb.createDiv(), this.mark.style.webkitTransform = "rotate(" + b + "deg)", this.mark.style.mozTransform = "rotate(" + b + "deg)", this.mark.style.OTransform = "rotate(" + b + "deg)", this.mark.style.msTransform = "rotate(" + b + "deg)", this.mark.style.transform = "rotate(" + b + "deg)", this.network.getTopDiv().appendChild(this.mark)), Wb.setDiv(this.mark, this.resizingRect, null, this.network.getResizeLineWidth(), this.network.getResizeLineColor()), this.network.fireInteractionEvent({
                kind: "lazyResizeBetween",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            })) : (this.node.setSize(this.resizingRect.width, this.resizingRect.height), this.node.setLocation(this.resizingRect.x, this.resizingRect.y), this.network.fireInteractionEvent({
                kind: "liveResizeBetween",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            }))
        },
        _isEditingShapeNode: function(a) {
            if (this.node instanceof Ib.ShapeNode) {
                this.shapeNode = this.node;
                for (var b = this.shapeNode.getPoints(), c = 0, d = b.size(); d > c; c++) {
                    var e = b.get(c);
                    if (this._contains(a, e, this.editPointSize)) return this._setCrossCursor(),
                    this.pointIndex = c,
                    !0
                }
            }
            return this.pointIndex = -1,
            !1
        },
        _isEditingShapeLink: function(a) {
            for (var b = this.shapeLink.getPoints(), c = 0, d = b.size(); d > c; c++) {
                var e = b.get(c);
                if (this._contains(a, e, this.editPointSize)) return this._setCrossCursor(),
                this.pointIndex = c,
                !0
            }
            return this.pointIndex = -1,
            !1
        },
        _isResizingNode: function(a) {
            var b = this.network.getResizePointSize();
            if (0 >= b) return ! 1;
            var c = this.node.getOriginalRect(),
            d = this.node.getAngle(),
            e = {
                x: c.x,
                y: c.y
            },
            f = this._rotatePoint(e, d, c);
            return this._isResizing(a, f.x, f.y, "northwest", "nwse-resize") ? !0 : (e = {
                x: c.x + c.width / 2,
                y: c.y
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "north", "ns-resize") ? !0 : (e = {
                x: c.x + c.width,
                y: c.y
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "northeast", "nesw-resize") ? !0 : (e = {
                x: c.x,
                y: c.y + c.height / 2
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "west", "ew-resize") ? !0 : (e = {
                x: c.x + c.width,
                y: c.y + c.height / 2
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "east", "ew-resize") ? !0 : (e = {
                x: c.x,
                y: c.y + c.height
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "southwest", "nesw-resize") ? !0 : (e = {
                x: c.x + c.width / 2,
                y: c.y + c.height
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "south", "ns-resize") ? !0 : (e = {
                x: c.x + c.width,
                y: c.y + c.height
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "southeast", "nwse-resize") ? !0 : !1)))))))
        },
        _rotatePoint: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x + c.width / 2, c.y + c.height / 2),
            e = d.transform(a);
            return e
        },
        _isResizing: function(a, b, c, d, e) {
            return this._contains(a, {
                x: b,
                y: c
            },
            this.resizePointSize) ? (this.resizeDirection !== d && (this._removeCursor(), e = this._changeCursorWithAngle(d, this.node.getAngle()), this._setCursor(e), this.resizeDirection = d), !0) : !1
        },
        _getRect: function(a, b, c, d) {
            var e = c > a ? a: c,
            f = d > b ? b: d,
            g = Math.abs(a - c),
            h = Math.abs(b - d);
            return {
                x: e,
                y: f,
                width: g,
                height: h
            }
        },
        _contains: function(a, b, c) {
            var d = {
                x: b.x - c,
                y: b.y - c,
                width: 2 * c,
                height: 2 * c
            };
            return Tb.containsPoint(d, a)
        },
        getPointIndex: function(a, b, c) {
            if (a.size() < 2) return 0;
            for (var d, e = a.get(0), f = 1; f < a.size(); f++) {
                if (d = a.get(f), this.isPointOnLine(b, e, d, 6)) return f;
                e = d
            }
            return e = a.get(0),
            c && this.isPointOnLine(b, e, d, 6) ? a.size() : 0
        },
        showRotateScale: function() {
            this.rotateScale || (this.rotateScale = Jb.html.createCanvas());
            var a, b, c, d, e, f = (new Ib.List, this.network.getRotateScaleWidth()),
            g = this.network.getRotateScaleHeight(),
            h = this.network.getRotatePointSize(),
            i = this.node.getAngle(),
            j = this.node.getOriginalRect(),
            k = {
                x: j.x + j.width / 2,
                y: j.y - this.network.getRotatePointOffset() - h
            },
            l = this._rotatePoint(k, i, j),
            m = "13px Arial",
            n = i + "°";
            this.node.getAngle() >= 0 && this.node.getAngle() <= 180 ? (b = {
                x: l.x + h,
                y: l.y
            },
            c = {
                x: b.x + f,
                y: b.y
            },
            d = {
                x: c.x,
                y: c.y - g
            },
            e = {
                x: b.x,
                y: d.y
            }) : this.node.getAngle() > 180 && this.node.getAngle() <= 360 && (b = {
                x: l.x - h,
                y: l.y
            },
            c = {
                x: b.x - f,
                y: b.y
            },
            d = {
                x: c.x,
                y: c.y - g
            },
            e = {
                x: b.x,
                y: d.y
            });
            var o = new Ib.List([b, c, d, e]),
            a = Jb.math.getRect(o),
            p = Jb.html.setCanvas(this.rotateScale, a);
            p.fillStyle = this.network.getRotateScaleFillColor(),
            p.fillRect(a.x, a.y, a.width, a.height),
            p.fillStyle = this.network.getRotateScaleFontColor(),
            p.textBaseline = "middle",
            p.textAlign = "center",
            p.font = m,
            p.fillText(n, a.x + a.width / 2, a.y + a.height / 2),
            this.network.getTopDiv().appendChild(this.rotateScale)
        },
        isPointOnLine: function(a, b, c, d) {
            0 > d && (d = 0);
            var e = this.getDistanceFromPointToLine(a, b, c);
            return d >= e && a.x >= Math.min(b.x, c.x) - d && a.x <= Math.max(b.x, c.x) + d && a.y >= Math.min(b.y, c.y) - d && a.y <= Math.max(b.y, c.y) + d
        },
        getDistanceFromPointToLine: function(a, b, c) {
            if (b.x === c.x) return Math.abs(a.x - b.x);
            var d = (c.y - b.y) / (c.x - b.x),
            e = (c.x * b.y - b.x * c.y) / (c.x - b.x);
            return Math.abs(d * a.x - a.y + e) / Math.sqrt(d * d + 1)
        },
        _transformPoint: function(a, b, c) {
            var d = Math.cos(c * Math.PI / 180),
            e = Math.sin(c * Math.PI / 180),
            f = a.x,
            g = a.y,
            h = f * d - g * e,
            i = f * e + g * d;
            a.x = h + b.x,
            a.y = i + b.y
        },
        _reversPoint: function(a, b, c) {
            c *= -1;
            var d = Math.cos(c * Math.PI / 180),
            e = Math.sin(c * Math.PI / 180),
            f = a.x - b.x,
            g = a.y - b.y,
            h = f * d - g * e,
            i = f * e + g * d;
            a.x = h + b.x,
            a.y = i + b.y
        },
        _changeCursorWithAngle: function(a, b) {
            var c, d = ["auto", "nwse-resize", "ns-resize", "nesw-resize", "ew-resize", "nwse-resize", "ns-resize", "nesw-resize", "ew-resize"];
            switch (a) {
            case "northwest":
                c = 1;
                break;
            case "north":
                c = 2;
                break;
            case "northeast":
                c = 3;
                break;
            case "east":
                c = 4;
                break;
            case "southeast":
                c = 5;
                break;
            case "south":
                c = 6;
                break;
            case "southwest":
                c = 7;
                break;
            case "west":
                c = 8;
                break;
            default:
                c = 0
            }
            return (b >= 360 || -360 >= b) && (b %= 360),
            b > 22.5 && 67.5 >= b && (c += 1),
            -22.5 > b && b >= -67.5 && (c -= 1),
            b > 67.5 && 112.5 >= b && (c += 2),
            -67.5 > b && b >= -112.5 && (c -= 2),
            b > 112.5 && 157.5 >= b && (c += 3),
            -112.5 > b && b >= -157.5 && (c -= 3),
            b > 157.5 && 202.5 >= b && (c += 4),
            -157.5 > b && b >= -202.5 && (c -= 4),
            b > 202.5 && 247.5 >= b && (c += 5),
            -202.5 > b && b >= -247.5 && (c -= 5),
            b > 247.5 && 292.5 >= b && (c += 6),
            -247.5 > b && b >= -292.5 && (c -= 6),
            b > 292.5 && 337.5 >= b && (c += 7),
            -292.5 > b && b >= -337.5 && (c -= 7),
            c > 8 && (c -= 8),
            0 >= c && (c += 8),
            d[c]
        }
    }),
    Ib.network.interaction.CreateElementInteraction = function(a, b) {
        b || (b = Kd),
        this.elementFunction = Ib.Util.isTypeOf(b, Kd) ?
        function(a) {
            var c = new b;
            return c instanceof Kd && c.setCenterLocation(a),
            c
        }: b,
        Ib.network.interaction.CreateElementInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.CreateElementInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown")
        },
        tearDown: function() {
            this.removeListener("mousedown")
        },
        handle_mousedown: function(a) {
            var b = this.network.getLogicalPoint(a);
            if (b) {
                var c = this.elementFunction(b);
                c && this.network.addElementByInteraction(c)
            }
        }
    }),
    Ib.network.interaction.CreateLinkInteraction = function(a, b) {
        b || (b = Ib.Link),
        this.linkFunction = Ib.Util.isTypeOf(b, Ib.Link) ?
        function(a, c) {
            var d = new b;
            return d instanceof Ib.Link && (d.setFromNode(a), d.setToNode(c)),
            d
        }: b,
        Ib.network.interaction.CreateLinkInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.CreateLinkInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove")
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.clear()
        },
        clear: function() {
            var a = this;
            setTimeout(function() {
                a._fromRectangle && (a.network.getTopDiv().removeChild(a._fromRectangle), a._fromRectangle = null),
                a._currentRectangle && (a.network.getTopDiv().removeChild(a._currentRectangle), a._currentRectangle = null),
                a._line && (a.network.getTopDiv().removeChild(a._line), a._line = null)
            }),
            this.currentPoint = null,
            this.currentNode = null,
            this.fromNode = null,
            this.toNode = null
        },
        createLink: function() {
            return this.linkFunction(this.fromNode, this.toNode)
        },
        handle_mousedown: function(a) {
            if (this.network.isValidEvent(a)) if (this.fromNode) {
                if (this.toNode = this.currentNode, this.toNode) {
                    var b = this.createLink();
                    b && this.network.addElementByInteraction(b)
                }
                this.clear()
            } else this.fromNode = this.currentNode,
            this.currentNode = null,
            this.currentPoint = null,
            this.updateMark()
        },
        handle_mousemove: function(a) {
            var b = this.network.getLogicalPoint(a);
            if (b) {
                if (this.network.isMovingElement() || this.network.isEditingElement()) return void this.clear();
                var c = null;
                this.fromNode ? (this.currentNode = this.getToNode(a), this.currentPoint = b, this.updateMark()) : (c = this.getFromNode(a), this.currentNode !== c && (this.currentNode = c, this.updateMark()))
            }
        },
        getFromNode: function(a) {
            return this.getNode(a)
        },
        getToNode: function(a) {
            return this.getNode(a)
        },
        getNode: function(a) {
            var b = this.network.getElementAt(a);
            return b instanceof Kd && this.network.isLinkable(b) ? b: null
        },
        updateMark: function() {
            var a;
            this.fromNode && !this._fromRectangle && this._currentRectangle && (this._fromRectangle = this._currentRectangle, this._currentRectangle = null),
            !this.fromNode && this._fromRectangle && (this.network.getTopDiv().removeChild(this._fromRectangle), this._fromRectangle = null),
            this.currentNode && !this._currentRectangle && (a = this.network.getElementUI(this.currentNode), this._currentRectangle = Wb.createDiv(), this.network.getTopDiv().appendChild(this._currentRectangle), Wb.setDiv(this._currentRectangle, a._viewRect, null, this.network.getEditLineWidth(), this.network.getEditLineColor())),
            !this.currentNode && this._currentRectangle && (this.network.getTopDiv().removeChild(this._currentRectangle), this._currentRectangle = null),
            this.updateLine()
        },
        updateLine: function() {
            if (this.currentPoint) {
                var a = this.fromNode.getCenterLocation(),
                b = a.x,
                c = a.y,
                d = this.currentPoint.x,
                e = this.currentPoint.y;
                this._line || (this._line = Wb.createCanvas(), this.network.getTopDiv().appendChild(this._line));
                var f = Wb.setCanvas(this._line, Math.min(b, d), Math.min(c, e), Math.abs(b - d), Math.abs(c - e));
                f.lineWidth = this.network.getEditLineWidth(),
                f.strokeStyle = this.network.getEditLineColor(),
                f.beginPath(),
                f.moveTo(b, c),
                f.lineTo(d, e),
                f.stroke()
            } else this._line && (this.network.getTopDiv().removeChild(this._line), this._line = null)
        }
    }),
    Ib.network.interaction.CreateShapeNodeInteraction = function(a, b) {
        b || (b = Ib.ShapeNode),
        this.shapeNodeFunction = Ib.Util.isTypeOf(b, Ib.ShapeNode) ?
        function(a) {
            var c = new b;
            return c instanceof Ib.ShapeNode && a && c.setPoints(a),
            c
        }: b,
        Ib.network.interaction.CreateShapeNodeInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.CreateShapeNodeInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove")
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.clear()
        },
        clear: function() {
            this.network.setEditingElement(!1),
            this.points = null,
            this.currentPoint = null,
            this.lastPoint = null,
            this.horizontal = !1,
            this.vertical = !1,
            this.mark && (this.network.getTopDiv().removeChild(this.mark), this.mark = null)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) {
                var b = this.network.getLogicalPoint(a);
                if (b) if (2 === a.detail) {
                    if (this.points) {
                        var c = this.shapeNodeFunction(this.points);
                        this.network.addElementByInteraction(c),
                        this.clear();
                        var d = this;
                        setTimeout(function() {
                            d.network.setEditingElement(!1)
                        },
                        0)
                    }
                } else {
                    if (this.network.isEditingElement() || this.network.setEditingElement(!0), this.points || (this.points = new nd), this.points.size() > 0) {
                        var e = this.points.get(this.points.size() - 1);
                        if (e.x === b.x && e.y === b.y) return
                    }
                    this._handle_mousedown(a),
                    this.points.size() > 0 && Jb.isCtrlDown(a) && (this.horizontal && (b.y = e.y), this.vertical && (b.x = e.x), this.horizontal = !1, this.vertical = !1),
                    this.lastPoint = b,
                    this.points.add(b),
                    this.updateMark()
                }
            }
        },
        handle_mousemove: function(a) {
            if (this.points) {
                if (this.currentPoint = this.network.getLogicalPoint(a), Jb.isCtrlDown(a)) {
                    var b = this.currentPoint.x - this.lastPoint.x,
                    c = this.currentPoint.y - this.lastPoint.y;
                    this.horizontal = Math.abs(b) >= Math.abs(c),
                    this.vertical = !this.horizontal
                } else this.horizontal = !1,
                this.vertical = !1;
                this.horizontal && (this.currentPoint.y = this.lastPoint.y),
                this.vertical && (this.currentPoint.x = this.lastPoint.x),
                this.updateMark()
            }
        },
        updateMark: function(a) {
            if (this.points && this.points.size() > 0 && this.currentPoint) {
                this.mark || (this.mark = Wb.createCanvas(), this.network.getTopDiv().appendChild(this.mark));
                var b = new nd(this.points);
                b.add(this.currentPoint);
                var c = Tb.getRect(b),
                d = this.network.getEditLineWidth();
                Jb.math.grow(c, d, d);
                var e = Wb.setCanvas(this.mark, c);
                e.lineWidth = d,
                e.strokeStyle = this.network.getEditLineColor(),
                e.beginPath(),
                Xb.drawLinePoints(e, b),
                e.stroke()
            }
        }
    }),
    Ib.network.interaction.CreateShapeLinkInteraction = function(a, b) {
        Ib.network.interaction.CreateShapeLinkInteraction.superClass.constructor.call(this, a),
        b || (b = Ib.ShapeLink),
        this.linkFunction = Ib.Util.isTypeOf(b, Ib.ShapeLink) ?
        function(a, c, d) {
            var e = new b;
            return e instanceof Ib.ShapeLink && (e.setFromNode(a), e.setToNode(c), d && e.setPoints(d)),
            e
        }: b
    },
    Jb.ext("twaver.network.interaction.CreateShapeLinkInteraction", Ib.network.interaction.CreateLinkInteraction, {
        clear: function() {
            this.network.setEditingElement(!1),
            this.points = null,
            this.polyline && (this.network.getTopDiv().removeChild(this.polyline), this.polyline = null),
            Ib.network.interaction.CreateShapeLinkInteraction.superClass.clear.call(this)
        },
        createLink: function() {
            return this.linkFunction(this.fromNode, this.toNode, this.points)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) {
                var b = this.network.getLogicalPoint(a);
                if (b) if (this.fromNode) if (this.toNode = this.currentNode, this.toNode) {
                    var c = this.createLink();
                    c && this.network.addElementByInteraction(c),
                    this.clear()
                } else {
                    if (this.points || (this.points = new nd), this.points.size() > 0) {
                        var d = this.points.get(this.points.size() - 1);
                        if (d.x === b.x && d.y === b.y) return
                    }
                    this.points.add(b),
                    this.updateMark()
                } else this.fromNode = this.currentNode,
                this.fromNode && (this.polyline || (this.polyline = Wb.createCanvas(), this.network.getTopDiv().appendChild(this.polyline))),
                this.points = null,
                this.currentNode = null,
                this.currentPoint = null,
                this.updateMark()
            }
        },
        updateLine: function() {
            if (this.currentPoint && this.polyline) {
                var a = new nd(this.points);
                a.add(this.fromNode.getCenterLocation(), 0),
                a.add(this.currentPoint);
                var b = Tb.getRect(a),
                c = Wb.setCanvas(this.polyline, b);
                c.lineWidth = this.network.getEditLineWidth(),
                c.strokeStyle = this.network.getEditLineColor(),
                c.beginPath(),
                Xb.drawLinePoints(c, a),
                c.stroke()
            }
        }
    }),
    Ib.network.interaction.CreateOrthogonalLinkInteraction = function(a, b, c, d, e, f) {
        Ib.network.interaction.CreateOrthogonalLinkInteraction.superClass.constructor.call(this, a, b),
        this.linkType = c || "orthogonal",
        this.isByControlPoint = d,
        this.splitPercent = e,
        this.isSplitByPercent = f,
        this.link = new Ib.Link,
        this.link.setStyle("link.type", this.linkType),
        this.link.setStyle("link.split.by.percent", this.isSplitByPercent),
        xc.isFlexionalTypeLink(this.linkType) || xc.isExtendTypeLink(this.linkType) ? (this.splitPercent < 0 && (this.splitPercent = Ib.Styles.getStyle("link.extend")), this.link.setStyle("link.extend", this.splitPercent)) : xc.isSplitTypeLink(this.linkType) && (this.splitPercent < 0 && (this.splitPercent = Ib.Styles.getStyle(this.isSplitByPercent ? "link.split.percent": "link.split.value")), this.isSplitByPercent ? this.link.setStyle("link.split.percent", this.splitPercent) : this.link.setStyle("link.split.value", this.splitPercent))
    },
    Jb.ext("twaver.network.interaction.CreateOrthogonalLinkInteraction", Ib.network.interaction.CreateLinkInteraction, {
        clear: function() {
            this.path && (this.network.getTopDiv().removeChild(this.path), this.path = null),
            Ib.network.interaction.CreateOrthogonalLinkInteraction.superClass.clear.call(this)
        },
        createLink: function() {
            var a = Ib.network.interaction.CreateOrthogonalLinkInteraction.superClass.createLink.call(this);
            if (a.setStyle("link.type", this.linkType), a.setStyle("link.split.by.percent", this.isSplitByPercent), this.isByControlPoint) {
                var b = xc.getControlPoint(a);
                if (b) return a.SetStyle("link.control.point", b),
                a
            } else xc.isFlexionalTypeLink(this.linkType) || xc.isExtendTypeLink(this.linkType) ? (this.splitPercent < 0 && (this.splitPercent = Ib.Styles.getStyle("link.extend")), a.setStyle("link.extend", this.splitPercent)) : xc.isSplitTypeLink(this.linkType) && (this.splitPercent < 0 && (this.splitPercent = Ib.Styles.getStyle(this.isSplitByPercent ? "link.split.percent": "link.split.value")), this.isSplitByPercent ? a.setStyle("link.split.percent", this.splitPercent) : a.setStyle("link.split.value", this.splitPercent));
            return a
        },
        updateLine: function() {
            if (this.currentPoint) {
                if (!this.fromNode || this.currentNode === this.fromNode) return;
                var a, b = this.network.getElementUI(this.fromNode);
                if (!b) return;
                if (a = b.getBodyRect(), null == a) return;
                var c;
                if (this.currentNode && this.currentNode !== this.fromNode) {
                    var d = this.network.getElementUI(this.currentNode);
                    if (!d) return;
                    c = d.getBodyRect()
                } else c = {
                    x: this.currentPoint.x,
                    y: this.currentPoint.y,
                    width: 1,
                    height: 1
                };
                if (!c) return;
                var e = xc.calculateOrthogonalAndFlexionalLinkPoints(this.linkType, a, c, this.link);
                if (xc.drawCorner(e, this.link), e.size() < 2) return;
                this.line || (this.line = Wb.createCanvas(), this.network.getTopDiv().appendChild(this.line));
                var f = Wb.setCanvas(this.line, Tb.getLineRect(e));
                f.lineWidth = this.network.getEditLineWidth(),
                f.strokeStyle = this.network.getEditLineColor(),
                f.beginPath(),
                Xb.drawLinePoints(f, e),
                f.stroke()
            } else this.line && (this.network.getTopDiv().removeChild(this.line), this.line = null)
        }
    }),
    Ib.network.interaction.MagnifyInteraction = function(a, b, c, d, e) {
        Ib.network.interaction.MagnifyInteraction.superClass.constructor.call(this, a),
        this.zoom = b || 2,
        this.xRadius = c || 100,
        this.yRadius = d || 100,
        this.shape = e || "circle",
        this.borderColor = "black",
        this.borderWidth = 1,
        this.backgroundColor = "white",
        this.markCanvas = Wb.createCanvas(),
        this.markCanvas._isIgnored = !0
    },
    Jb.ext("twaver.network.interaction.MagnifyInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousemove")
        },
        tearDown: function() {
            this.removeListener("mousemove"),
            this._clear()
        },
        handle_mousemove: function(a) {
            var b = this.network.getLogicalPoint(a);
            b && (this.lastPoint || this.network.getView().appendChild(this.markCanvas), this.lastPoint = b, this.updateMark())
        },
        updateMark: function() {
            var a, b = this.network._zoom,
            c = this.zoom * b,
            d = this.lastPoint.x * b - this.xRadius,
            e = this.lastPoint.y * b - this.yRadius,
            f = 2 * this.xRadius,
            g = 2 * this.yRadius,
            h = {
                x: this.lastPoint.x - this.xRadius / c,
                y: this.lastPoint.y - this.yRadius / c,
                width: f / c,
                height: g / c
            },
            i = this.borderWidth,
            j = Wb.createCanvas();
            j.width = f,
            j.height = g,
            this.network.toCanvasByRegion(h, c, j),
            Wb.setCanvas(this.markCanvas, d, e, f, g),
            a = this.markCanvas.getContext("2d"),
            a.save(),
            a.beginPath(),
            Xb.drawVector(a, this.shape, null, d, e, f, g),
            a.clip(),
            a.fillStyle = this.backgroundColor,
            a.beginPath(),
            a.rect(d, e, f, g),
            a.fill(),
            a.drawImage(j, d, e),
            a.restore(),
            a.beginPath(),
            a.lineWidth = i,
            Xb.drawVector(a, this.shape, null, d + i / 2, e + i / 2, f - i, g - i),
            a.strokeStyle = this.borderColor,
            a.stroke()
        },
        _clear: function(a) {
            this.lastPoint && (this.network.getView().removeChild(this.markCanvas), this.lastPoint = null)
        },
        getZoom: function() {
            return this.zoom
        },
        setZoom: function(a) {
            this.zoom = a,
            this.updateMark()
        },
        getShape: function() {
            return this.shape
        },
        setShape: function(a) {
            this.shape = a,
            this.updateMark()
        },
        getXRadius: function() {
            return this.xRadius
        },
        setXRadius: function(a) {
            this.xRadius = a,
            this.updateMark()
        },
        getYRadius: function() {
            return this.yRadius
        },
        setYRadius: function(a) {
            this.yRadius = a,
            this.updateMark()
        },
        getBorderColor: function() {
            return this.borderColor
        },
        setBorderColor: function(a) {
            this.borderColor = a,
            this.updateMark()
        },
        getBorderWidth: function() {
            return this.borderWidth
        },
        setBorderWidth: function(a) {
            this.borderWidth = a,
            this.updateMark()
        },
        getBackgroundColor: function() {
            return this.backgroundColor
        },
        setBackgroundColor: function(a) {
            this.backgroundColor = a,
            this.updateMark()
        }
    }),
    Ib.network.interaction.TouchInteraction = function(a) {
        Ib.network.interaction.TouchInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.network.interaction.TouchInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            var a = this.network.getView();
            Wb.addEventListener("touchstart", "handleTouchstart", a, this),
            Wb.addEventListener("touchmove", "handleTouchmove", a, this),
            Wb.addEventListener("touchend", "handleTouchend", a, this),
            Wb.addEventListener("touchcancel", "handleTouchend", a, this)
        },
        tearDown: function() {
            var a = this.network.getView();
            Wb.removeEventListener("touchstart", a, this),
            Wb.removeEventListener("touchmove", a, this),
            Wb.removeEventListener("touchend", a, this),
            Wb.removeEventListener("touchcancel", a, this)
        },
        handleTouchstart: function(a) {
            if (Wb.preventDefault(a), a.touches && 1 == a.touches.length) {
                var b = this.network.getLogicalPoint(a),
                c = this.network.getElementAt(b);
                this._startTouchTime = new Date,
                this._startTouchPoint = b;
                var d = this;
                c ? (this._haveElementUnderTouch = !0, this._startTouchElement = c) : (this._haveElementUnderTouch = !1, this._startTouchElement = null),
                this.timer = setTimeout(function() {
                    Cc.handleLongClicked(d.network, a, c)
                },
                1e3)
            } else a.touches && 2 == a.touches.length && (this._distance = zc.getDistance(a), this._zoom = this.network.getZoom(), this._startTouchPoint = {
                x: a.touches[0].clientX,
                y: a.touches[0].clientY
            });
            this._touchCount = a.touches.length
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), 2 == this._touchCount && a.touches && 2 == a.touches.length) if (this.timer && clearTimeout(this.timer), Math.abs(this._distance - zc.getDistance(a)) >= Dd.TOUCH_ZOOM_THRESHOLD || this._zoomFlag) {
                this._zoomFlag = !0;
                var b = zc.getDistance(a) / this._distance;
                this.network.setTouchZoom(this._zoom * b, !1)
            } else {
                var c = a.touches[0],
                d = this._startTouchPoint.x - c.clientX,
                e = this._startTouchPoint.y - c.clientY,
                f = this.network.panByOffset(d, e);
                this._startTouchPoint.x -= d - f.x,
                this._startTouchPoint.y -= e - f.y
            } else if (1 == this._touchCount && a.touches && 1 == a.touches.length) if (this._haveElementUnderTouch || !this.network.isRectSelectEnabled()) {
                var g = this.network.getLogicalPoint(a),
                h = this.network.getElementAt(g);
                if (this.network.isMovingElement() || null != this._startTouchElement && this._startTouchElement == h && this.network.getMovableSelectedElements().contains(h)) {
                    var d = g.x - this._startTouchPoint.x,
                    e = g.y - this._startTouchPoint.y; (Math.abs(d) >= Dd.TOUCH_MOVE_THRESHOLD || Math.abs(e) >= Dd.TOUCH_MOVE_THRESHOLD) && (this._startTouchPoint = g, this.network.moveSelectedElements(d, e), this.network.isMovingElement() ? this.network.fireInteractionEvent({
                        kind: "liveMoveBetween",
                        event: a
                    }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                        kind: "liveMoveStart",
                        event: a
                    }), this.timer && clearTimeout(this.timer)))
                } else {
                    var d = g.x - this._startTouchPoint.x,
                    e = g.y - this._startTouchPoint.y; (Math.abs(d) >= Dd.TOUCH_MOVE_THRESHOLD || Math.abs(e) >= Dd.TOUCH_MOVE_THRESHOLD) && this.timer && clearTimeout(this.timer)
                }
            } else {
                this._moveTouchPoint = this.network.getLogicalPoint(a);
                var d = this._moveTouchPoint.x - this._startTouchPoint.x,
                e = this._moveTouchPoint.y - this._startTouchPoint.y;
                if (Math.abs(d) >= Dd.TOUCH_RECT_SELECT_THRESHOLD && Math.abs(e) >= Dd.TOUCH_RECT_SELECT_THRESHOLD) {
                    this.mark ? this.network.fireInteractionEvent({
                        kind: "selectBetween",
                        event: a
                    }) : (this.mark = Wb.createDiv(), this.network.getTopDiv().appendChild(this.mark), this.network.setSelectingElement(!0), this.network.fireInteractionEvent({
                        kind: "selectStart",
                        event: a
                    }), this.timer && clearTimeout(this.timer));
                    var i = Tb.getRect([this._startTouchPoint, this._moveTouchPoint]);
                    Wb.setDiv(this.mark, i, this.getIntersectMode() ? this.network.getSelectFillColor() : null, this.network.getSelectOutlineWidth(), this.network.getSelectOutlineColor())
                }
            }
        },
        handleTouchend: function(a) {
            if (Wb.preventDefault(a), this.network.isMovingElement()) this.network.setMovingElement(!1),
            this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            });
            else if (this.network.isSelectingElement()) {
                var b = this.network.getElementsAtRect(this.mark._viewRect, this.getIntersectMode(), this.network.getRectSelectFilter());
                if (b && b.size() > 0) {
                    var c = this.network.getSelectionModel(),
                    d = c.toSelection();
                    b.forEach(function(a) {
                        c.contains(a) ? d.remove(a) : d.add(a)
                    },
                    this),
                    c.setSelection(d)
                }
                this.network.fireInteractionEvent({
                    kind: "selectEnd",
                    event: a
                }),
                this.network.getTopDiv().removeChild(this.mark),
                this.mark = null,
                this.network.setSelectingElement(!1),
                this.timer && clearTimeout(this.timer)
            } else if (this._startTouchPoint) {
                this._zoomFlag = !1;
                var e = new Date,
                f = this.network.getLogicalPoint(a),
                g = this.network.getElementAt(this._startTouchPoint);
                this._startTouchPoint && f && e.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, f) <= 20 && (g ? this.network.getSelectionModel().contains(g) || this.network.getSelectionModel().setSelection(g) : this.network.getSelectionModel().clearSelection(), Cc.handleClicked(this.network, a, g), this.timer && clearTimeout(this.timer), this._endTouchTime && e.getTime() - this._endTouchTime.getTime() <= 500 && Tb.getDistance(this._endTouchPoint, f) <= 20 ? (delete this._endTouchTime, delete this._endTouchPoint, Cc.handleDoubleClicked(this.network, a, g), this.timer && clearTimeout(this.timer)) : (this._endTouchTime = e, this._endTouchPoint = f))
            }
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y
        }
    }),
    Ib.network.interaction.MSTouchInteraction = function(a) {
        Ib.network.interaction.MSTouchInteraction.superClass.constructor.call(this, a),
        this._pointerMap = {},
        this._pointerIdArray = []
    },
    Jb.ext("twaver.network.interaction.MSTouchInteraction", Ib.network.interaction.BaseInteraction, {
        setUp: function() {
            var a = this.network.getView();
            Wb.addEventListener("MSPointerDown", "handleTouchstart", a, this),
            Wb.addEventListener("MSPointerMove", "handleTouchmove", a, this),
            Wb.addEventListener("MSPointerUp", "handleTouchend", a, this),
            Wb.addEventListener("MSPointerCancel", "handleTouchend", a, this)
        },
        tearDown: function() {
            var a = this.network.getView();
            Wb.removeEventListener("MSPointerDown", a, this),
            Wb.removeEventListener("MSPointerMove", a, this),
            Wb.removeEventListener("MSPointerUp", a, this),
            Wb.removeEventListener("MSPointerCancel", a, this)
        },
        handleTouchstart: function(a) {
            if (this.network.isFocusOnClick() && Ib.Util.setFocus(this.network._view), !this.network.isSelectingElement() || a.pointerType != a.MSPOINTER_TYPE_MOUSE) {
                var b = this.network.getLogicalPoint(a),
                c = new Date;
                if (a.isPrimary && this._pointerIdArray.length > 0 && this.handle_mouseup(a), this._pointerMap[a.pointerId] || (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a), 1 == this._pointerIdArray.length) {
                    var d = this.network.getElementAt(b);
                    this._startTouchElement = d,
                    this._startClientPoint = {
                        x: a.clientX,
                        y: a.clientY
                    },
                    Cc.handleClicked(this.network, a, d),
                    this._startTouchTime && this._startTouchPoint && c.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 20 ? (Cc.handleDoubleClicked(this.network, a, d), this._doubleClick = !0) : (Wb.handle_mousedown(this, a), this._startTouchPoint = b, this._startTouchTime = c);
                    var e = this.network.getSelectionModel();
                    d ? Jb.isCtrlDown(a) ? e.contains(d) ? e.removeSelection(d) : e.appendSelection(d) : e.contains(d) || e.setSelection(d) : Jb.isCtrlDown(a) || e.clearSelection()
                } else 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.network.getZoom())
            }
        },
        handleTouchmove: function(a) {
            if (null != this._startTouchPoint && 0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10) && (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length)) {
                var b = this._getDistance() / this._distance;
                this.network.setZoom(this._zoom * b, !1)
            }
        },
        handleTouchend: function(a) {
            if (this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            })), this.network.isSelectingElement()) {
                var b = this.network.getElementsAtRect(this.mark._viewRect, this.getIntersectMode(), this.network.getRectSelectFilter());
                if (b && b.size() > 0) {
                    var c = this.network.getSelectionModel(),
                    d = c.toSelection();
                    b.forEach(function(a) {
                        c.contains(a) ? d.remove(a) : d.add(a)
                    },
                    this),
                    c.setSelection(d)
                }
                this.network.fireInteractionEvent({
                    kind: "selectEnd",
                    event: a
                }),
                this.network.getTopDiv().removeChild(this.mark),
                this.mark = null,
                this.network.setSelectingElement(!1)
            }
            this._doubleClick && (delete this._doubleClick, delete this._startTouchPoint, delete this._startTouchTime);
            for (var e = -1,
            f = 0; f < this._pointerIdArray.length; f++) if (this._pointerIdArray[f] == a.pointerId) {
                e = f;
                break
            }
            e >= 0 && this._pointerIdArray.splice(e, 1),
            delete this._pointerMap[a.pointerId]
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y
        },
        handle_mousemove: function(a) {
            if (this._startTouchPoint && 1 == this._pointerIdArray.length) {
                if (this._moveTouchPoint = {
                    x: this._startTouchPoint.x + (a.clientX - this._startClientPoint.x) / this.network.getZoom(),
                    y: this._startTouchPoint.y + (a.clientY - this._startClientPoint.y) / this.network.getZoom()
                },
                Tb.getDistance(this._startTouchPoint, this._moveTouchPoint) < 3) return;
                if (null == this._startTouchElement && this.network.isRectSelectEnabled()) {
                    this.mark ? this.network.fireInteractionEvent({
                        kind: "selectBetween",
                        event: a
                    }) : (this.mark = Wb.createDiv(), this.network.getTopDiv().appendChild(this.mark), this.network.setSelectingElement(!0), this.network.fireInteractionEvent({
                        kind: "selectStart",
                        event: a
                    }));
                    var b = Tb.getRect([this._startTouchPoint, this._moveTouchPoint]);
                    Wb.setDiv(this.mark, b, this.getIntersectMode() ? this.network.getSelectFillColor() : null, this.network.getSelectOutlineWidth(), this.network.getSelectOutlineColor())
                } else {
                    var c = this.network.getElementAt(this._moveTouchPoint),
                    d = this._moveTouchPoint.x - this._startTouchPoint.x,
                    e = this._moveTouchPoint.y - this._startTouchPoint.y;
                    null != this._startTouchElement || this.network.isRectSelectEnabled() ? (this.network.isMovingElement() || null != this._startTouchElement && c == this._startTouchElement && this.network.getMovableSelectedElements().contains(c)) && (this.network.moveSelectedElements(d, e), this.network.isMovingElement() ? this.network.fireInteractionEvent({
                        kind: "liveMoveBetween",
                        event: a
                    }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                        kind: "liveMoveStart",
                        event: a
                    }))) : this.network.panByOffset( - d, -e),
                    this._startClientPoint.x = a.clientX,
                    this._startClientPoint.y = a.clientY
                }
            }
        },
        handle_mouseup: function(a) {
            this.handleTouchend(a),
            this._pointerIdArray = [],
            this._pointerMap = {}
        }
    });
    var Nd = {
        _hitCanvas: null,
        getHitCanvas: function(a, b) {
            null == this._hitCanvas && (this._hitCanvas = Wb.createCanvas()),
            0 == arguments.length && (a = 2, b = 2),
            this._hitCanvas.setAttribute("width", "" + a - 1),
            this._hitCanvas.setAttribute("height", "" + b - 1),
            this._hitCanvas.setAttribute("width", "" + a),
            this._hitCanvas.setAttribute("height", "" + b);
            var c = this.getCtx(this._hitCanvas);
            return c.clearRect(0, 0, a, b),
            this._hitCanvas
        },
        disposeHitCanvas: function() {
            this._hitCanvas = null
        },
        getCtx: function(a) {
            return a.getContext("2d")
        },
        render: function(a, c, d) {
            c != b && (a.fillStyle = c, a.fill()),
            d != b && (a.strokeStyle = d, a.stroke())
        },
        text: function(a, b, c, d, e, f) {
            a.textAlign = "center",
            a.textBaseline = "middle",
            null != e && (a.fillStyle = e, a.fillText(b, c, d)),
            f && (a.strokeStyle = f, a.strokeText(b, c, d))
        },
        circle: function(a, b, c, d, e, f) {
            a.arc(b, c, d, 0, 2 * Math.PI, !0),
            a.closePath(),
            this.render(a, e, f)
        },
        rect: function(a, b, c, d, e, f, g) {
            a.rect(b, c, d, e),
            a.closePath(),
            this.render(a, f, g)
        },
        OUT_LEFT: 1,
        OUT_TOP: 2,
        OUT_RIGHT: 4,
        OUT_BOTTOM: 8,
        outcode: function(a, b, c, d, e, f) {
            var g = 0;
            return 0 >= e ? g |= this.OUT_LEFT | this.OUT_RIGHT: c > a ? g |= this.OUT_LEFT: a > c + e && (g |= this.OUT_RIGHT),
            0 >= f ? g |= this.OUT_TOP | this.OUT_BOTTOM: d > b ? g |= this.OUT_TOP: b > d + f && (g |= this.OUT_BOTTOM),
            g
        },
        intersectsLine: function(a, b, c, d, e, f, g, h) {
            var i, j;
            if (0 == (j = this.outcode(c, d, e, f, g, h))) return ! 0;
            for (; 0 != (i = this.outcode(a, b, e, f, g, h));) {
                if (0 != (i & j)) return ! 1;
                if (0 != (i & (this.OUT_LEFT | this.OUT_RIGHT))) {
                    var k = e;
                    0 != (i & this.OUT_RIGHT) && (k += g),
                    b += (k - a) * (d - b) / (c - a),
                    a = k
                } else {
                    var l = f;
                    0 != (i & this.OUT_BOTTOM) && (l += h),
                    a += (l - b) * (c - a) / (d - b),
                    b = l
                }
            }
            return ! 0
        }
    };
    Ib.canvas = {},
    Ib.canvas.interaction = {},
    Ib.canvas.Network = function(a) {
        Ib.canvas.Network.superClass.constructor.apply(this, arguments),
        this._rootCanvas = Wb.createCanvas(),
        this._topCanvas = Wb.createCanvas(),
        this.realWidth = 0,
        this.realHeight = 0,
        this._unionBounds = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._zoom = 1,
        this._elementUIMap = {},
        this._visibleMap = {},
        this.viewRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this.hScrollBarVisible = !1,
        this.vScrollBarVisible = !1,
        this.markerList = new Ib.List,
        this._topAttachmentList = new Ib.List,
        this.setElementBox(a ? a: new Ib.ElementBox),
        Mb || (this._view = Wb.createView("hidden"), this._view.appendChild(this._rootCanvas), this._view.appendChild(this._topCanvas), Qb.isMSToucheable ? this.setMSTouchInteractions() : this.setDefaultInteractions(!1), this.setToolTipEnabled(Ib.Defaults.NETWORK_TOOLTIP_ENABLED));
        var b = this;
        this._flowLink = function() {
            if (! (b.isMovingElement() || b.isSelectingElement() || b.isEditingElement() || b._box._layoutMovingElements)) {
                b._flowLinkQuickFinder || (b._flowLinkQuickFinder = new Ib.QuickFinder(b._box, "link.flow", "style"));
                var a = b._flowLinkQuickFinder.find(!0);
                a.forEach(function(a) {
                    a._styleMap["link.flow.offset"] = b.getLinkFlowOffset(a);
                    var c = b.getElementUI(a);
                    c.invalidate(!1)
                })
            }
        }
    },
    Jb.ext("twaver.canvas.Network", Ib.controls.View, {
        __accessor: ["selectMode", "makeVisibleOnSelected", "movableFunction", "editPointSize", "editPointFillColor", "scrollBarWidth", "editPointOutlineWidth", "editPointOutlineColor", "editLineColor", "editLineWidth", "resizePointSize", "resizePointFillColor", "resizePointOutlineWidth", "resizePointOutlineColor", "resizeLineColor", "resizeLineWidth", "rotatePointSize", "rotatePointFillColor", "rotatePointOffset", "rotatePointOutlineWidth", "rotatePointOutlineColor", "rotateScaleFillColor", "rotateScaleFontColor", "rotateScaleWidth", "rotateScaleHeight", "selectOutlineColor", "selectOutlineWidth", "selectFillColor", "lazyMoveOutlineColor", "lazyMoveOutlineWidth", "lazyMoveFillColor", "rectSelectFilter", "paddingRight", "paddingBottom", "selectionTolerance"],
        __bool: ["doubleClickToUpSubNetwork", "doubleClickToSubNetwork", "doubleClickToEmptySubNetwork", "doubleClickToLinkBundle", "doubleClickToGroupExpand", "scrollBarVisible", "limitViewInCanvas", "autoValidateCanvasSize", "subNetworkAnimate", "lazyMoveAnimate", "resizeAnimate", "noAgentLinkVisible", "keyboardRemoveEnabled", "keyboardSelectEnabled", "sendToTopOnSelected", "lazyMoveFill", "editingElement", "rotatingElement", "movingElement", "selectingElement", "rectSelectEnabled", "limitElementInPositiveLocation", "showRotateScale", "transparentSelectionEnable", "debug", "showShadowInEdit"],
        _currentSubNetwork: null,
        _subNetworkAnimate: Ib.Defaults.NETWORK_SUBNETWORK_ANIMATE,
        _scrollBarWidth: 10,
        _scrollBarVisible: !0,
        _limitViewInCanvas: !0,
        _autoValidateCanvasSize: !0,
        _makeVisibleOnSelected: Ib.Defaults.NETWORK_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Ib.Defaults.NETWORK_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Ib.Defaults.NETWORK_KEYBOARD_SELECT_ENABLED,
        _rectSelectEnabled: Dd.NETWORK_RECT_SELECT_ENABLED,
        _rectSelectFilter: null,
        _elementUIFunction: Ib.Defaults.CANVASUI_FUNCTION,
        _doubleClickToUpSubNetwork: Ib.Defaults.NETWORK_DOUBLECLICK_TO_UPSUBNETWORK,
        _doubleClickToSubNetwork: Ib.Defaults.NETWORK_DOUBLECLICK_TO_SUBNETWORK,
        _doubleClickToEmptySubNetwork: Ib.Defaults.NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK,
        _doubleClickToLinkBundle: Ib.Defaults.NETWORK_DOUBLECLICK_TO_LINKBUNDLE,
        _doubleClickToGroupExpand: Ib.Defaults.NETWORK_DOUBLECLICK_TO_GROUPEXPAND,
        _selectOutlineColor: Ib.Defaults.NETWORK_SELECT_OUTLINE_COLOR,
        _selectOutlineWidth: Ib.Defaults.NETWORK_SELECT_OUTLINE_WIDTH,
        _selectFillColor: Ib.Defaults.NETWORK_SELECT_FILL_COLOR,
        _sendToTopOnSelected: Ib.Defaults.NETWORK_SENDTOTOP_ON_SELECTED,
        _lazyMoveOutlineColor: Ib.Defaults.NETWORK_LAZYMOVE_OUTLINE_COLOR,
        _lazyMoveOutlineWidth: Ib.Defaults.NETWORK_LAZYMOVE_OUTLINE_WIDTH,
        _lazyMoveFillColor: Ib.Defaults.NETWORK_LAZYMOVE_FILL_COLOR,
        _lazyMoveFill: Ib.Defaults.NETWORK_LAZYMOVE_FILL,
        _lazyMoveAnimate: Ib.Defaults.NETWORK_LAZYMOVE_ANIMATE,
        _resizePointSize: Ib.Defaults.NETWORK_RESIZE_POINT_SIZE,
        _resizePointFillColor: Ib.Defaults.NETWORK_RESIZE_POINT_FILL_COLOR,
        _resizePointOutlineColor: Ib.Defaults.NETWORK_RESIZE_POINT_OUTLINE_COLOR,
        _resizePointOutlineWidth: Ib.Defaults.NETWORK_RESIZE_POINT_OUTLINE_WIDTH,
        _resizeLineColor: Ib.Defaults.NETWORK_RESIZE_LINE_COLOR,
        _resizeLineWidth: Ib.Defaults.NETWORK_RESIZE_LINE_WIDTH,
        _resizeAnimate: Ib.Defaults.NETWORK_RESIZE_ANIMATE,
        _editPointSize: Ib.Defaults.NETWORK_EDIT_POINT_SIZE,
        _editPointFillColor: Ib.Defaults.NETWORK_EDIT_POINT_FILL_COLOR,
        _editPointOutlineColor: Ib.Defaults.NETWORK_EDIT_POINT_OUTLINE_COLOR,
        _editPointOutlineWidth: Ib.Defaults.NETWORK_EDIT_POINT_OUTLINE_WIDTH,
        _editLineColor: Ib.Defaults.NETWORK_EDIT_LINE_COLOR,
        _editLineWidth: Ib.Defaults.NETWORK_EDIT_LINE_WIDTH,
        _rotatePointSize: Ib.Defaults.NETWORK_ROTATE_POINT_SIZE,
        _rotatePointFillColor: Ib.Defaults.NETWORK_ROTATE_POINT_FILL_COLOR,
        _rotatePointOffset: Ib.Defaults.NETWORK_ROTATE_POINT_OFFSET,
        _rotatePointOutlineWidth: Ib.Defaults.NETWORK_ROTATE_POINT_OUTLINE_WIDTH,
        _rotatePointOutlineColor: Ib.Defaults.NETWORK_ROTATE_POINT_OUTLINE_COLOR,
        _rotateScaleWidth: Dd.NETWORK_ROTATE_SCALE_WIDTH,
        _rotateScaleHeight: Dd.NETWORK_ROTATE_SCALE_HEIGHT,
        _rotateScaleFillColor: Dd.NETWORK_ROTATE_SCALE_FILL_COLOR,
        _rotateScaleFontColor: Dd.NETWORK_ROTATE_SCALE_FONT_COLOR,
        _limitElementInPositiveLocation: Dd.NETWORK_LIMIT_ELEMENT_INPOSITIVE_LOCATION,
        _linkFlowInterval: Dd.NETWORK_LINK_FLOW_INTERVAL,
        _selectionTolerance: Dd.NETWORK_SELECTION_TOLERANCE,
        _invalidateElementVisibility: !1,
        _invalidateViewRectFlag: !1,
        _repaintTopFlag: !1,
        _invalidateCanvasSizeFlag: !1,
        _isEditingElement: !1,
        _isRotatingElement: !1,
        _isMovingElement: !1,
        _isSelectingElement: !1,
        _hasEditInteraction: !1,
        _showRotateScale: !0,
        _paddingRight: 0,
        _paddingBottom: 0,
        _transparentSelectionEnable: Ib.Defaults.NETWORK_TRANSPARENT_SELECTION_ENABLE,
        _debug: !1,
        _showShadowInEdit: !1,
        adjustBounds: function(a) {
            if (Mb) this._rootCanvas = new Lb(a.width, a.height),
            this._topCanvas = new Lb(a.width, a.height),
            this.setViewRect(a.x, a.y, a.width, a.height);
            else {
                var b = !1,
                c = this._view.style;
                if (c.left == a.x + "px" && c.top == a.y + "px" && c.width == a.width + "px" && c.height == a.height + "px" && (b = !0), Ib.canvas.Network.superClass.adjustBounds.apply(this, arguments), 1 == b) return;
                var d = this._view.offsetWidth,
                e = this._view.offsetHeight;
                this._rootCanvas.setAttribute("width", d),
                this._rootCanvas.setAttribute("height", e),
                this._topCanvas.setAttribute("width", d),
                this._topCanvas.setAttribute("height", e),
                this.setViewRect(this.viewRect.x, this.viewRect.y, d, e)
            }
            "undefined" == typeof Ib.gis && (Ib.Util.makeHighRes(this._rootCanvas), Ib.Util.makeHighRes(this._topCanvas)),
            this.invalidateElementVisibility()
        },
        getLabel: function(a) {
            return a.getStyle("network.label") || a.getName()
        },
        getBackgroundImage: function() {
            return this._backgroundImage
        },
        setBackgroundImage: function(a) {
            if (this._backgroundImage != a) {
                var b = this._backgroundImage;
                this._backgroundImage = a;
                var c = this._backgroundImage;
                if (c && !c._viewRect) if (c.width > 0) c._viewRect = {
                    x: 0,
                    y: 0,
                    width: c.width,
                    height: c.height
                },
                this.validateCanvasSize(),
                this.firePropertyChange("backgroundImage", b, c);
                else {
                    var d = this;
                    c.onload = function() {
                        c._viewRect = {
                            x: 0,
                            y: 0,
                            width: c.width,
                            height: c.height
                        },
                        d.validateCanvasSize(),
                        d.firePropertyChange("backgroundImage", b, c),
                        c.onload = null
                    }
                } else this.firePropertyChange("backgroundImage", b, c),
                this.validateCanvasSize()
            }
        },
        getRootCanvas: function() {
            return this._rootCanvas
        },
        getTopCanvas: function() {
            return this._topCanvas
        },
        validateImpl: function() {
            if (!Mb && oc.twm(this), 1 == this._invalidateElementVisibility) {
                this._invalidateElementVisibility = !1;
                var a, b, c, d = this.getElementBox().getDatas()._as,
                e = d.length,
                f = {},
                g = this._visibleFunction,
                h = 1 === this._box._layerBox.size() ? this._box._layerBox._defaultLayer: null;
                for (a = 0; e > a; a++) b = d[a],
                f[b._id] = this.isVisible(b, g, h);
                if (this._visibleMap) for (a = 0; e > a; a++) b = d[a],
                f[b._id] !== this._visibleMap[b._id] && (c = this._elementUIMap[b._id], c && c.invalidate());
                for (a = 0; e > a; a++) b = d[a],
                c = this._elementUIMap[b._id],
                c && c.validate();
                this._visibleMap = f,
                this.paintRoot()
            }
            this.validateCanvasSize(),
            1 == this._repaintTopFlag && (this._repaintTopFlag = !1, this.paintTopCanvas())
        },
        isLinkFlowEnabled: function() {
            return this._linkFlowEnabled ? !0 : !1
        },
        setLinkFlowEnabled: function(a) {
            a ? (this._linkFlowEnabled || (this._linkFlowEnabled = !0, this.firePropertyChange("linkFlowEnabled", !1, !0)), clearInterval(this._linkFlowTimerId), this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval)) : (this._linkFlowEnabled && (this._linkFlowEnabled = !1, this.firePropertyChange("linkFlowEnabled", !0, !1)), clearInterval(this._linkFlowTimerId), delete this._linkFlowTimerId)
        },
        getLinkFlowInterval: function() {
            return this._linkFlowInterval
        },
        setLinkFlowInterval: function(a) {
            var b = this._linkFlowInterval;
            this._linkFlowInterval = a,
            this.firePropertyChange("linkFlowInterval", b, a),
            clearInterval(this._linkFlowTimerId),
            this.isLinkFlowEnabled() && (this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval))
        },
        getElementBox: function() {
            return this._box
        },
        setElementBox: function(a) {
            if (!a) throw "ElementBox can not be null";
            if (this._box !== a) {
                var b = this._box;
                b && (b.removeDataBoxChangeListener(this.handleElementBoxChange, this), b.removeDataPropertyChangeListener(this.handleElementPropertyChange, this), b.removePropertyChangeListener(this.handleElementBoxPropertyChange, this), b.removeIndexChangeListener(this.handleIndexChange, this), b.getLayerBox().removeDataBoxChangeListener(this.handleLayerBoxChange, this), b.getLayerBox().removeDataPropertyChangeListener(this.handleLayerPropertyChange, this), b.getLayerBox().removeHierarchyChangeListener(this.handleLayerHierarchyChange, this), this._selectionModel || b.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this)),
                this._box = a,
                this._box.addDataBoxChangeListener(this.handleElementBoxChange, this),
                this._box.addDataPropertyChangeListener(this.handleElementPropertyChange, this),
                this._box.addPropertyChangeListener(this.handleElementBoxPropertyChange, this),
                this._box.addIndexChangeListener(this.handleIndexChange, this),
                this._box.getLayerBox().addDataBoxChangeListener(this.handleLayerBoxChange, this),
                this._box.getLayerBox().addDataPropertyChangeListener(this.handleLayerPropertyChange, this),
                this._box.getLayerBox().addHierarchyChangeListener(this.handleLayerHierarchyChange, this),
                this._flowLinkQuickFinder && (this._flowLinkQuickFinder.dispose(), this._flowLinkQuickFinder = new Ib.QuickFinder(this._box, "link.flow", "style")),
                this._selectionModel ? this._selectionModel._setDataBox(a) : this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
                this._elementUIMap = {},
                this._box.forEach(this.createElementUI, this),
                this.invalidateElementVisibility(),
                this.invalidateCanvasSize(),
                this.firePropertyChange("elementBox", b, this._box)
            }
        },
        handleElementBoxChange: function(a) {
            var b = a.data;
            if ("add" === a.kind) this.createElementUI(b),
            this.invalidateBundleLink(b);
            else if ("remove" === a.kind) {
                var c = this.getElementUI(b);
                c && (c.dispose(), delete this._elementUIMap[b.getId()]),
                b === this._currentSubNetwork && null != this._currentSubNetwork && this._setCurrentSubNetwork(null)
            } else "clear" === a.kind && (this._elementUIMap = {},
            null != this._currentSubNetwork && this._setCurrentSubNetwork(null));
            this.invalidateElementVisibility(),
            this.invalidateCanvasSize()
        },
        handleElementPropertyChange: function(a) {
            var b = a.source,
            c = this.getElementUI(b);
            c && c.handlePropertyChange(a),
            this.invalidateBundleLink(b),
            this.invalidateElementVisibility(),
            this.invalidateCanvasSize()
        },
        handleElementBoxPropertyChange: function() {
            this.invalidateElementVisibility()
        },
        handleIndexChange: function(a) {
            this.invalidateElementVisibility()
        },
        handleLayerBoxChange: function() {
            this.invalidateElementVisibility()
        },
        handleLayerPropertyChange: function(a) {
            "editable" === a.property && this.invalidateSelectedElementUIs(!0),
            this.invalidateElementVisibility()
        },
        handleLayerHierarchyChange: function() {
            this.invalidateElementVisibility()
        },
        handleSelectionChange: function(a) {
            a.datas.forEach(function(b) {
                var c = this.getElementUI(b);
                c && c.handleSelectionChange(a)
            },
            this);
            var b = this.getSelectionModel().getLastData();
            b && ("append" === a.kind || "set" === a.kind) && (this.isMakeVisibleOnSelected() && this.makeVisible(b), this.isSendToTopOnSelected() && this.sendToTop(b)),
            this.invalidateElementVisibility()
        },
        sendToTop: function(a) {
            if (this._box.contains(a)) {
                for (var b = a; b._parent && this.isVisible(b._parent) && (b = b._parent););
                b !== a && this._box.adjustElementIndex(b),
                this._box.adjustElementIndex(a)
            }
        },
        getViewRect: function() {
            return this.viewRect ? Jb.clone(this.viewRect) : {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        },
        getCanvasSize: function() {
            return {
                width: this.realWidth,
                height: this.realHeight
            }
        },
        setViewOffSet: function(a, b) {
            var c = this.viewRect.x,
            d = this.viewRect.y,
            e = this.viewRect.width,
            f = this.viewRect.height;
            this.setViewRect(c + a, d + b, e, f)
        },
        setViewRect: function(a, b, c, d) {
            1 == this.isLimitViewInCanvas() && (0 > a && (a = 0), c > this.realWidth ? a = 0 : a + c > this.realWidth && (a = this.realWidth - c), 0 > b && (b = 0), d > this.realHeight ? b = 0 : b + d > this.realHeight && (b = this.realHeight - d));
            var e = this.viewRect; (null == this.viewRect || a != this.viewRect.x || b != this.viewRect.y || c != this.viewRect.width || d != this.viewRect.height) && (this.viewRect = {
                x: a,
                y: b,
                width: c,
                height: d
            },
            this.firePropertyChange("viewRect", e, this.viewRect), this.invalidateElementVisibility())
        },
        isHScrollBarVisible: function() {
            return this.hScrollBarVisible
        },
        setHScrollBarVisible: function(a) {
            this.hScrollBarVisible = a
        },
        isVScrollBarVisible: function() {
            return this.vScrollBarVisible
        },
        setVScrollBarVisible: function(a) {
            this.vScrollBarVisible = a
        },
        dispose: function() {
            for (var a in this._elementUIMap) {
                var b = this._elementUIMap[a];
                b.curInterval && clearTimeout(b.curInterval)
            }
        },
        invalidateElementVisibility: function() {
            this._invalidateElementVisibility || (this._invalidateElementVisibility = !0, this.invalidate())
        },
        repaintTopCanvas: function() {
            this._repaintTopFlag || (this._repaintTopFlag = !0, this.invalidate())
        },
        invalidateCanvasSize: function(a) {
            this._invalidateCanvasSizeFlag || (this._invalidateCanvasSizeFlag = !0, this.invalidate())
        },
        validateCanvasSize: function() {
            0 != this._invalidateCanvasSizeFlag && (this._invalidateCanvasSizeFlag = !1, this._validateCanvasSize())
        },
        _validateCanvasSize: function() {
            if (!this.isMovingElement()) {
                if (0 == this.isAutoValidateCanvasSize()) return this.realWidth = 0,
                this.realHeight = 0,
                void(this._unionBounds = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                });
                var a = this.getElementBox().getDatas(),
                b = a.size();
                if (b > 0) {
                    for (var c = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    },
                    d = 0; b > d; d++) {
                        var e = a.get(d);
                        if (this._visibleMap[e._id]) {
                            var f = this._elementUIMap[e._id];
                            f && (c = Tb.unionRect(c, f._viewRect))
                        }
                    }
                    var g = this.getBackgroundImage();
                    if (g && (c = Tb.unionRect(c, g._viewRect)), c.x < 0 && (c.width += c.x, c.x = 0), c.y < 0 && (c.height += c.y, c.y = 0), this.realWidth == (c.x + c.width) * this.getZoom() && this.realHeight == (c.y + c.height) * this.getZoom()) return;
                    var h = this.getZoom();
                    this.realWidth = (c.x + c.width) * h + this._paddingRight,
                    this.realHeight = (c.y + c.height) * h + this._paddingBottom,
                    this._unionBounds = {
                        x: c.x * h,
                        y: c.y * h,
                        width: c.width * h + this._paddingRight,
                        height: c.height * h + this._paddingRight
                    }
                } else this.realWidth = 0,
                this.realHeight = 0,
                this._unionBounds = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                this.setViewRect(this.viewRect.x, this.viewRect.y, this.viewRect.width, this.viewRect.height),
                this.firePropertyChange("canvasSizeChange", null, this.viewRect)
            }
        },
        getElementUI: function(a) {
            return null == a ? null: this._elementUIMap[a._id]
        },
        createElementUI: function(a) {
            var b = this._elementUIMap[a.getId()];
            b || (b = this._elementUIFunction(this, a), b && (this._elementUIMap[a.getId()] = b))
        },
        getElementUIFunction: function() {
            return this._elementUIFunction
        },
        setElementUIFunction: function(a) {
            if (!a) throw "ElementUIFunction can not be null";
            if (this._elementUIFunction !== a) {
                var b = this._elementUIFunction;
                this._elementUIFunction = a,
                this.firePropertyChange("elementUIFunction", b, a),
                this._box.isEmpty() || (this._elementUIMap = {},
                this._box.forEach(this.createElementUI, this), this.invalidateElementVisibility(), this.invalidateCanvasSize())
            }
        },
        invalidateElementUI: function(a, b) {
            var c = this.getElementUI(a);
            c && c.invalidate(b)
        },
        invalidateElementUIs: function(a) {
            for (var b in this._elementUIMap) {
                var c = this._elementUIMap[b];
                c.invalidate(a)
            }
        },
        invalidateSelectedElementUIs: function(a) {
            this.getSelectionModel().getSelection().forEach(function(b) {
                this.invalidateElementUI(b, a)
            },
            this)
        },
        invalidateBundleLink: function(a) {
            if (a instanceof Ib.Link && a._bundleLinks) {
                var b = this._elementUIMap;
                a._bundleLinks.forEachSiblingLink(function(c) {
                    if (c !== a) {
                        var d = b[c._id];
                        d && d.invalidate(!1)
                    }
                },
                this)
            }
        },
        paintRoot: function() {
            var a = this._rootCanvas.getContext("2d");
            if (a.clearRect(0, 0, this._rootCanvas.width, this._rootCanvas.height), this.visibleList = new Ib.List, this._topAttachmentList = new Ib.List, null != this.getElementBox()) {
                ld.draw(a, this);
                var c = this.getElementBox().getDatas()._as,
                d = c.length;
                a.save(),
                a.scale(this.getZoom(), this.getZoom()),
                a.translate( - this.viewRect.x / this.getZoom(), -this.viewRect.y / this.getZoom()),
                this.paintBottom(a);
                var e = {
                    x: this.viewRect.x / this.getZoom(),
                    y: this.viewRect.y / this.getZoom(),
                    width: this.viewRect.width / this.getZoom(),
                    height: this.viewRect.height / this.getZoom()
                },
                f = this.getBackgroundImage(),
                g = this.getBackgroundImageRect();
                if (f instanceof Pb && (g ? a.drawImage(f, g.x, g.y, g.width, g.height) : a.drawImage(f, 0, 0, f.width, f.height), f._viewRect = {
                    x: 0,
                    y: 0,
                    width: f.width,
                    height: f.height
                }), "string" == typeof f) {
                    var h = Jb.getImageAsset(f),
                    i = {
                        x: 0,
                        y: 0,
                        width: h.getWidth(),
                        height: h.getHeight()
                    };
                    Nc(a, f, null, i, null, this)
                }
                var j, k, l, m, n = this._box._layerBox;
                if (1 === n.size()) for (j = 0; d > j; j++) k = c[j],
                this._visibleMap[k._id] && (l = this._elementUIMap[k._id], null != l && this._isInView(l, e) ? (l.paint(a), l.setAttachmentVisible && l.setAttachmentVisible(!0), this.visibleList.add(k)) : l.setAttachmentVisible && l.setAttachmentVisible(!1));
                else n.forEachByDepthFirst(function(b) {
                    for (j = 0; d > j; j++) k = c[j],
                    n.getLayerByElement(k) === b && this._visibleMap[k._id] && (l = this._elementUIMap[k._id], null != l && this._isInView(l, e) ? (l.paint(a), l.setAttachmentVisible && l.setAttachmentVisible(!0), this.visibleList.add(k)) : l.setAttachmentVisible && l.setAttachmentVisible(!1))
                },
                null, this);
                for (d = this._topAttachmentList.size(), j = 0; d > j; j++) m = this._topAttachmentList.get(j),
                m.getElementUI().paintAttachment(a, m);
                if (this._xyz) {
                    var d, o = this._xyz,
                    p = o.markText,
                    q = o.type,
                    r = (o.expired, o.innerHTML),
                    s = 0,
                    t = 0,
                    u = this.viewRect;
                    a.translate(this.viewRect.x / this.getZoom(), this.viewRect.y / this.getZoom()),
                    a.scale(1 / this.getZoom(), 1 / this.getZoom()),
                    this.getZoom(),
                    p != b && null != p && "" != p || "2" == q ? (a.font = "15px Arial sans-serif", d = Jb.g.getTextSize(a.font, r), a.fillStyle = "red", s = u.width - d.width, t = u.height - 20) : (a.font = "10px Arial sans-serif", d = Jb.g.getTextSize(a.font, r), s = u.width / 2 - d.width / 2, t = u.height / 2),
                    a.fillText(r, s, t)
                }
                a.restore()
            }
        },
        paintBottom: function(a) {},
        _isInView: function(a, b) {
            return Tb.intersects(b, a._viewRect)
        },
        paintTopCanvas: function() {
            var a = this._topCanvas.getContext("2d");
            a.clearRect(0, 0, this._topCanvas.width, this._topCanvas.height),
            this.paintMarker(a)
        },
        paintMarker: function(a) {
            for (var b = this.markerList.size(), c = 0; b > c; c++) {
                var d = this.markerList.get(c);
                d.paint(a)
            }
        },
        getLayerByElement: function(a) {
            return this._box.getLayerBox().getLayerByElement(a)
        },
        getLogicalPoint: function(a) {
            var b;
            if (Qb.isTouchable && a.changedTouches && a.changedTouches.length > 0) {
                var c = this._view.getBoundingClientRect(),
                d = a.changedTouches[0],
                e = Qb.isAndroid ? 0 : zc.scrollLeft(),
                f = Qb.isAndroid ? 0 : zc.scrollTop();
                return b = {
                    x: (d.clientX + this.viewRect.x - c.left - e) / this._zoom,
                    y: (d.clientY + this.viewRect.y - c.top - f) / this._zoom
                }
            }
            return b = Qb.isFirefox ? {
                x: (a.layerX + this.viewRect.x) / this.getZoom(),
                y: (a.layerY + this.viewRect.y) / this.getZoom()
            }: {
                x: (a.offsetX + this.viewRect.x) / this.getZoom(),
                y: (a.offsetY + this.viewRect.y) / this.getZoom()
            }
        },
        getElementAt: function(a, b) {
            if (null == this.visibleList) return null;
            1 === arguments.length && (b = !0);
            var c, d;
            if (a.target ? c = this.getLogicalPoint(a) : a.event ? a.event.target && (c = this.getLogicalPoint(a.event)) : c = a, null != this._topAttachmentList) for (var e = this._topAttachmentList.size(), f = e - 1; f >= 0; f--) {
                var g = this._topAttachmentList.get(f);
                if (d = g.getElement(), (!b || this.isSelectable(d)) && g.hit(c.x, c.y)) return d
            }
            if (null != this.visibleList) for (var h = this.visibleList.size(), i = h - 1; i >= 0; i--) {
                var j = this.visibleList.get(i),
                k = this.getElementUI(j);
                if ((!b || this.isSelectable(j)) && k && k.hit(c.x, c.y)) return j
            }
            return null
        },
        hitTest: function(a) {
            var b = this.getElementAt(a);
            if (!b) return null;
            var c = this.getElementUI(b);
            if (!c) return null;
            var d;
            return d = a.target ? this.getLogicalPoint(a) : a,
            c.hitTest(d.x, d.y)
        },
        getElementsAtRect: function(a, c, d, e) {
            var f = new Ib.List;
            if (null == this.visibleList) return f;
            e = e === b ? !0 : e;
            for (var g = this.visibleList.size(), h = g - 1; h >= 0; h--) {
                var i = this.visibleList.get(h),
                j = this.getElementUI(i);
                j && (!d || d(j._element)) && (e && this.isSelectable(j._element) || !e) && (c ? j.intersects(a) && f.add(i) : Tb.contains(a, j.getViewRect()) && f.add(i))
            }
            return f
        },
        getPosition: function(a, b, c, d, e) {
            var f, g = b instanceof Ib.canvas.ElementUI ? b: this.getElementUI(b);
            if (g) if ("from" === a || "to" === a) {
                if (g.getFromPosition && (f = "from" === a ? g.getFromPosition(d, e) : g.getToPosition(d, e))) return c ? {
                    x: f.x - c.width / 2,
                    y: f.y - c.height / 2
                }: f
            } else f = "hotspot" === a ? g.getHotSpot() : Vb.get(a, g.getBodyRect(), c);
            if (!f && b.getRect && (f = Vb.get(a, b.getRect(), c)), f) return {
                x: f.x + d,
                y: f.y + e
            };
            throw "position '" + a + "' object '" + b + "'"
        },
        isValidEvent: function(a) {
            if (!a) return ! 1;
            var b, c;
            if (a.currentTarget === this._view) {
                if (Qb.isFirefox ? (b = a.layerX, c = a.layerY) : (b = a.offsetX, c = a.offsetY), 1 == this.isHScrollBarVisible() && c >= this.viewRect.height - this.getScrollBarWidth()) return ! 1;
                if (1 == this.isVScrollBarVisible() && b >= this.viewRect.width - this.getScrollBarWidth()) return ! 1
            }
            return ! 0
        },
        addMarker: function(a) {
            this.markerList.add(a),
            this.repaintTopCanvas()
        },
        removeMarker: function(a) {
            this.markerList.remove(a),
            this.repaintTopCanvas()
        },
        clearMarker: function() {
            this.markerList.clear(),
            this.repaintTopCanvas()
        },
        isMovable: function(a) {
            return this._box.contains(a) ? a instanceof Ib.Link ? !1 : this._movableFunction && !this._movableFunction(a) ? !1 : this.getLayerByElement(a).isMovable() : !1
        },
        hasMovableSelectedElements: function() {
            for (var a = this.getSelectionModel().getSelection(), b = 0; b < a.size(); b++) {
                var c = a.get(b);
                if (this.isMovable(c)) return ! 0
            }
            return ! 1
        },
        getMovableSelectedElements: function() {
            return this.getSelectionModel().toSelection(function(a) {
                return this.isMovable(a)
            },
            this)
        },
        moveSelectedElements: function(a, b, c, d) {
            if (0 !== a || 0 !== b) {
                var e = this.getMovableSelectedElementsRect();
                null != e && (this._limitElementInPositiveLocation && (e.x + a < 0 && (a = -e.x), e.y + b < 0 && (b = -e.y)), Ib.Util.moveElements(this.getMovableSelectedElements(), a, b, c, d, this))
            }
        },
        getMovableSelectedElementsRect: function() {
            var a = this.getMovableSelectedElements();
            if (0 === a.size()) return null;
            for (var b = null,
            c = 0,
            d = a.size(); d > c; c++) {
                var e = a.get(c);
                if (e instanceof Kd) {
                    var f = this.getElementUI(e);
                    f && (b = Tb.unionRect(b, f.getViewRect()))
                }
            }
            return b
        },
        isVisible: function(a, b, c) {
            if (!this._box.contains(a)) return ! 1;
            if (!a.isVisible()) return ! 1;
            if (3 !== arguments.length && (b = this._visibleFunction), b && !b(a)) return ! 1;
            if (! (c || this._box._layerBox.getLayerByElement(a))._visible) return ! 1;
            if (vc.getSubNetwork(a) !== this._currentSubNetwork) return ! 1;
            if (a instanceof Ib.Link) {
                if (!this._noAgentLinkVisible) {
                    if (!a._fromAgent || !a._toAgent) return ! 1;
                    if (!this.isVisible(a._fromAgent, b, c) || !this.isVisible(a._toAgent, b, c)) return ! 1
                }
                if (a.getBundleIndex() > 0 && a.getBundleCount() > 1 && !a.getStyle("link.bundle.expanded")) return ! 1
            } else for (var d = a._parent; d && !d.ISubNetwork;) {
                if (d instanceof Ib.Group && (!d.isExpanded() || !this.isVisible(d, b, c))) return ! 1;
                d = d._parent
            }
            return a.IDummy ? !1 : !0
        },
        getVisibleFunction: function() {
            return this._visibleFunction
        },
        setVisibleFunction: function(a) {
            var b = this._visibleFunction;
            this._visibleFunction = a,
            this.firePropertyChange("visibleFunction", b, a),
            this.invalidateElementVisibility()
        },
        isEditable: function(a) {
            return this._box.contains(a) ? this._editableFunction && !this._editableFunction(a) ? !1 : this.getLayerByElement(a).isEditable() : !1
        },
        getEditableFunction: function() {
            return this._editableFunction
        },
        setEditableFunction: function(a) {
            var b = this._editableFunction;
            this._editableFunction = a,
            this.firePropertyChange("editableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        isRotatable: function(a) {
            return this._rotatableFunction && !this._rotatableFunction(a) ? !1 : !0
        },
        getRotatableFunction: function() {
            return this._rotatableFunction
        },
        setRotatableFunction: function(a) {
            var b = this._rotatableFunction;
            this._rotatableFunction = a,
            this.firePropertyChange("rotatableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        isLinkable: function(a) {
            return null == this._linkableFunction || this._linkableFunction(a)
        },
        getLinkableFunction: function() {
            return this._linkableFunction
        },
        setLinkableFunction: function(a) {
            var b = this._linkableFunction;
            this._linkableFunction = a,
            this.firePropertyChange("linkableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        onShareSelectionModelChanged: function() {
            this.invalidateElementUIs()
        },
        getShadowColor: function(a) {
            var b = a.getStyle("shadow.color");
            return ! b && this.isSelected(a) && "shadow" === a.getStyle("select.style") ? a.getStyle("select.color") : b
        },
        getSelectColor: function(a) {
            return a.getStyle("select.color")
        },
        getAlarmLabel: function(a) {
            var b = a.getAlarmState().getHighestNewAlarmSeverity();
            if (b) {
                var c = a.getAlarmState().getNewAlarmCount(b) + b.nickName;
                return a.getAlarmState().hasLessSevereNewAlarms() && (c += "+"),
                c
            }
            return null
        },
        getLinkHandlerLabel: function(a) {
            return a.isBundleAgent() ? "+(" + a.getBundleCount() + ")": null
        },
        setInteractions: function(a) {
            var b = this._interactions;
            b && b.forEach(function(a) {
                a.tearDown()
            }),
            this._interactions = a,
            a && a.forEach(function(a) {
                a.setUp()
            }),
            this.invalidateSelectedElementUIs(!0),
            this.firePropertyChange("interactions", b, a)
        },
        getInteractions: function() {
            return this._interactions
        },
        setDefaultInteractions: function(a) {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.SelectInteraction(this), new Ib.canvas.interaction.MoveInteraction(this, a), new Ib.canvas.interaction.ScrollInteraction(this), new Ib.canvas.interaction.TouchInteraction(this)])
        },
        setTouchInteractions: function() {
            this.setDefaultInteractions(!1)
        },
        setMSTouchInteractions: function() {
            this.setInteractions([new Ib.canvas.interaction.ScrollInteraction(this), new Ib.canvas.interaction.MSTouchInteraction(this)])
        },
        setEditInteractions: function(a) {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.SelectInteraction(this), new Ib.canvas.interaction.EditInteraction(this, a), new Ib.canvas.interaction.MoveInteraction(this, a), new Ib.canvas.interaction.ScrollInteraction(this)])
        },
        setCreateElementInteractions: function(a) {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.CreateElementInteraction(this, a)])
        },
        setCreateLinkInteractions: function(a) {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.CreateLinkInteraction(this, a), new Ib.canvas.interaction.ScrollInteraction(this)])
        },
        setCreateShapeLinkInteractions: function(a) {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.CreateShapeLinkInteraction(this, a), new Ib.canvas.interaction.ScrollInteraction(this)])
        },
        setCreateShapeNodeInteractions: function(a) {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.CreateShapeNodeInteraction(this, a), new Ib.canvas.interaction.ScrollInteraction(this)])
        },
        setPanInteractions: function() {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.PanInteraction(this), new Ib.canvas.interaction.ScrollInteraction(this)])
        },
        setMagnifyInteractions: function() {
            this.setInteractions([new Ib.canvas.interaction.DefaultInteraction(this), new Ib.canvas.interaction.SelectInteraction(this), new Ib.canvas.interaction.MoveInteraction(this), new Ib.canvas.interaction.ScrollInteraction(this), new Ib.canvas.interaction.MagnifyInteraction(this)])
        },
        hasEditInteraction: function() {
            return this._hasEditInteraction
        },
        setHasEditInteraction: function(a) {
            var b = this._hasEditInteraction;
            this._hasEditInteraction = a,
            this.firePropertyChange("hasEditInteraction", b, a)
        },
        addElementByInteraction: function(a) {
            a.getParent() || a.setParent(this._currentSubNetwork),
            this._box.add(a),
            this.getSelectionModel().setSelection(a),
            this.fireInteractionEvent({
                kind: "createElement",
                element: a
            })
        },
        getToolTip: function(a) {
            if (a) {
                var b = a.getToolTip();
                return b ? b: a.getName()
            }
            return null
        },
        isToolTipEnabled: function() {
            return this._toolTipEnabled ? !0 : !1
        },
        setToolTipEnabled: function(a) {
            if (this._toolTipEnabled = a, a) {
                if (!this._toolTipListener) {
                    var b = this;
                    this._toolTipListener = function(a) {
                        if (b.isMovingElement()) return void Bc.hideToolTip();
                        var c = b.getElementAt(a);
                        if (b._preElement !== c) if (b._preElement = c, c) {
                            var d = b.getToolTip(c);
                            Bc.showToolTip({
                                x: a.pageX,
                                y: a.pageY
                            },
                            d);
                            var e = Bc.getToolTipDiv(),
                            e = Bc.getToolTipDiv();
                            if (e.children.length > 0) {
                                var f = b._view.getBoundingClientRect(),
                                g = e.getBoundingClientRect();
                                g.width + g.left > f.width + f.left && (e.style.left = f.width + f.left - g.width + (Ob.documentElement.scrollLeft || Ob.body.scrollLeft) + "px"),
                                g.height + g.top > f.height + f.top && (e.style.top = f.height + f.top - g.height + (Ob.documentElement.scrollTop || Ob.body.scrollTop) + "px")
                            }
                        } else Bc.hideToolTip()
                    },
                    this._view.addEventListener("mousemove", this._toolTipListener, !1),
                    this.firePropertyChange("toolTipEnabled", !1, !0)
                }
            } else this._toolTipListener && (Bc.hideToolTip(), this._view.removeEventListener("mousemove", this._toolTipListener, !1), delete this._toolTipListener, this.firePropertyChange("toolTipEnabled", !0, !1))
        },
        setZoom: function(a) {
            a = this.checkZoom(a);
            var b = this._zoom;
            if (this._zoom != a) {
                var c = {
                    x: (this.viewRect.x + this.viewRect.width / 2) / this.getZoom() * a,
                    y: (this.viewRect.y + this.viewRect.height / 2) / this.getZoom() * a
                };
                this._zoom = a,
                this.invalidateElementVisibility(),
                this.invalidateCanvasSize(),
                this.validateCanvasSize(),
                this.setViewRect(c.x - this.viewRect.width / 2, c.y - this.viewRect.height / 2, this.viewRect.width, this.viewRect.height),
                this.firePropertyChange("zoom", b, this._zoom)
            }
        },
        getZoom: function() {
            return this._zoom
        },
        setTouchZoom: function(a) {
            this.setZoom(a, !1)
        },
        zoomOverview: function(a) {
            if (! (this.realWidth <= 0 || this.realHeight <= 0)) {
                var b = this.realWidth / this.getZoom(),
                c = this.realHeight / this.getZoom(),
                d = this.viewRect.width / b,
                e = this.viewRect.height / c,
                f = Math.min(d, e);
                this.setZoom(f)
            }
        },
        zoomReset: function() {
            this.setZoom(1)
        },
        zoomIn: function() {
            this.setZoom(1.2 * this.getZoom())
        },
        zoomOut: function() {
            this.setZoom(this.getZoom() / 1.2)
        },
        upSubNetwork: function(a, b) {
            this._currentSubNetwork && this.setCurrentSubNetwork(vc.getSubNetwork(this._currentSubNetwork), a, b)
        },
        getCurrentSubNetwork: function() {
            return this._currentSubNetwork
        },
        setCurrentSubNetwork: function(a, b, c) {
            if (Ib.animate.AnimateManager.endAnimate(), b) {
                if (this._currentSubNetwork === a) return;
                if (a && !this._box.contains(a)) throw a + " is not contained in this network's elementBox";
                var d = new Ib.animate.AnimateSubNetwork(this, a, c);
                Ib.animate.AnimateManager.start(d)
            } else this._setCurrentSubNetwork(a),
            c && c()
        },
        _setCurrentSubNetwork: function(a) {
            if (this._currentSubNetwork !== a) {
                if (a && !this._box.contains(a)) throw a + " is not contained in this network's elementBox";
                var b = this._currentSubNetwork;
                this._currentSubNetwork = a,
                this.firePropertyChange("currentSubNetwork", b, a),
                this.invalidateElementVisibility(),
                this.invalidateCanvasSize()
            }
        },
        makeVisible: function(a) {
            var b = this.getElementUI(a);
            if (b) {
                var c = vc.getSubNetwork(a);
                if (c !== this._currentSubNetwork) {
                    var d = this;
                    return void this.setCurrentSubNetwork(c, this.isSubNetworkAnimate(),
                    function() {
                        Jb.callLater(d.makeVisible, d, [a])
                    })
                }
                for (var e = a; (e = e.getParent()) && e !== c;) e instanceof Ib.Group && e.setExpanded(!0);
                var f = b.getViewRect();
                if (f) {
                    var g = {
                        x: f.x * this.getZoom(),
                        y: f.y * this.getZoom(),
                        width: f.width * this.getZoom(),
                        height: f.height * this.getZoom()
                    };
                    Tb.intersects(this.viewRect, g) || this.isVisible(a) && Jb.callLater(this.centerByLogicalPoint, this, [g.x + g.width / 2, g.y + g.height / 2])
                }
            }
        },
        centerByLogicalPoint: function(a, b, c) {
            var d = a - this.viewRect.width / 2,
            e = b - this.viewRect.height / 2;
            this.setViewRect(d, e, this.viewRect.width, this.viewRect.height)
        },
        panByOffset: function(a, b) {
            this.setViewOffSet(a, b)
        },
        getIconsNames: function(a) {
            return a.getStyle("icons.names")
        },
        getIconsColors: function(a) {
            return a.getStyle("icons.colors")
        },
        getLinkFlowStepping: function(a) {
            var b = parseInt(a.getStyle("link.flow.stepping"));
            return b || (b = Dd.NETWORK_LINK_FLOW_STEPPING),
            b
        },
        getLinkFlowOffset: function(a) {
            var b = a.getStyle("link.flow.offset");
            return isNaN(b) && (b = 0),
            b + this.getLinkFlowStepping(a)
        },
        toCanvas: function(a, b, c) {
            c || (c = Wb.createCanvas()),
            c.setAttribute("width", a),
            c.setAttribute("height", b),
            c._viewRect ? (c._viewRect.width = a, c._viewRect.height = b) : c._viewRect = {
                x: 0,
                y: 0,
                width: a,
                height: b
            };
            var d = c.getContext("2d");
            if (d.clearRect(0, 0, a, b), ld.draw(d, this), 0 === this._view.clientWidth || 0 === this._view.clientHeight) return c;
            var e = a / this.realWidth * this._zoom,
            f = b / this.realHeight * this._zoom;
            d.scale(e, f);
            var g = this.getBackgroundImage();
            if (g && g._viewRect) {
                var h = g._viewRect;
                try {
                    d.drawImage(g, h.x, h.y, h.width, h.height)
                } catch(i) {}
            }
            var j = this.getElementBox().getDatas()._as,
            k = j.length;
            this._topAttachmentList = new Ib.List;
            var l, m, n, o, p, q, r = this.getElementBox().getLayerBox(),
            s = r.getRoots(),
            t = s.size();
            if (1 === t) for (n = 0; k > n; n++) o = j[n],
            this._visibleMap[o._id] && (p = this._elementUIMap[o._id], null != p && p.paint(d));
            else for (l = 0; t > l; l++) for (m = s.get(l), n = 0; k > n; n++) o = j[n],
            r.getLayerByElement(o) === m && this._visibleMap[o._id] && (p = this._elementUIMap[o._id], null != p && p.paint(d));
            for (k = this._topAttachmentList.size(), n = 0; k > n; n++) q = this._topAttachmentList.get(n),
            q.getElementUI().paintAttachment(d, q);
            return c
        },
        toCanvasByRegion: function(a, b, c) {
            c || (c = Wb.createCanvas());
            var d = a.width * b,
            e = a.height * b;
            c.setAttribute("width", d),
            c.setAttribute("height", e),
            c._viewRect ? (c._viewRect.width = d, c._viewRect.height = e) : c._viewRect = {
                x: 0,
                y: 0,
                width: d,
                height: e
            };
            var f = c.getContext("2d");
            if (f.clearRect(0, 0, d, e), ld.draw(f, this), 0 === this._view.clientWidth || 0 === this._view.clientHeight) return c;
            f.save(),
            f.scale(b, b),
            f.beginPath(),
            f.translate( - a.x, -a.y);
            var g = this.getElementBox().getDatas()._as,
            h = g.length;
            this._topAttachmentList = new Ib.List;
            var i = this.getBackgroundImage();
            if (i && i._viewRect && Tb.intersects(a, i._viewRect)) {
                var a = Tb.intersection(a, i._viewRect),
                j = i._viewRect;
                try {
                    f.drawImage(i, j.x, j.y, j.width, j.height)
                } catch(k) {}
            }
            var l, m, n, o, p, q, r = this.getElementBox().getLayerBox(),
            s = r.getRoots(),
            t = s.size();
            if (1 === t) for (n = 0; h > n; n++) o = g[n],
            this._visibleMap[o._id] && (p = this._elementUIMap[o._id], null != p && Tb.intersects(a, p._viewRect) && p.paint(f));
            else for (l = 0; t > l; l++) for (m = s.get(l), n = 0; h > n; n++) o = g[n],
            r.getLayerByElement(o) === m && this._visibleMap[o._id] && (p = this._elementUIMap[o._id], null != p && Tb.intersects(a, p._viewRect) && p.paint(f));
            for (h = this._topAttachmentList.size(), n = 0; h > n; n++) q = this._topAttachmentList.get(n),
            q.getElementUI().paintAttachment(f, q);
            return f.restore(),
            c
        },
        getGroupChildrenRects: function(a) {
            var b = new nd;
            return a.getChildren().forEach(function(a) {
                if (a instanceof Kd) {
                    var c = this.getElementUI(a);
                    if (c) {
                        var d = c.getViewRect();
                        d && b.add(d)
                    }
                }
            },
            this),
            b
        },
        getBackgroundImageRect: function() {
            return null
        },
        getLinkPathFunction: function() {
            return this._linkPathFunction
        },
        setLinkPathFunction: function(a) {
            var b = this._linkPathFunction;
            this._linkPathFunction = a,
            this.firePropertyChange("linkPathFunction", b, a),
            this.invalidateElementUIs()
        },
        onClickElement: function(a, b) {},
        onClickBackground: function(a) {},
        onDoubleClickElement: function(a, b) {},
        onDoubleClickBackground: function(a) {},
        onLongClickElement: function(a, b) {},
        onLongClickBackground: function(a) {},
        onMouseMove: function(a, b) {},
        onMouseEnter: function(a, b) {},
        onMouseLeave: function(a, b) {},
        setMovingElement: function(a) {
            if (a != this._movingElement) {
                var b = this._movingElement;
                this._movingElement = a,
                this.firePropertyChange("movingElement", b, a),
                this._box._undoManager._enabled && (a ? this._box._undoManager.startBatch() : this._box._undoManager.endBatch())
            }
        },
        setEditingElement: function(a) {
            if (a != this._editingElement) {
                var b = this._editingElement;
                this._editingElement = a,
                this.firePropertyChange("editingElement", b, a),
                this._box._undoManager._enabled && (a ? this._box._undoManager.startBatch() : this._box._undoManager.endBatch())
            }
        }
    }),
    Ib.canvas.Overview = function(a) {
        Ib.canvas.Overview.superClass.constructor.apply(this, a),
        this._view = Wb.createView(),
        this._rootDiv = Wb.createDiv(),
        this._imageCanvas = Wb.createCanvas(),
        this._imageDiv = Wb.createDiv(),
        this._maskCanvas = Wb.createCanvas(),
        this._selectDiv = Wb.createDiv(),
        this._isNetworkDirty = !1,
        this._isMaskDirty = !1,
        Wb.setVisible(this._selectDiv, !1),
        this._view.appendChild(this._rootDiv),
        this._rootDiv.appendChild(this._imageDiv),
        this._rootDiv.appendChild(this._maskCanvas),
        this._rootDiv.appendChild(this._selectDiv),
        this._imageDiv.appendChild(this._imageCanvas),
        this.setNetwork(a);
        var b;
        b = Qb.isMSToucheable ? Ib.canvas.OverviewMSTouchInteraction: Qb.isTouchable ? Ib.canvas.OverviewTouchInteraction: Ib.canvas.OverviewInteraction,
        b && new b(this)
    },
    Jb.ext("twaver.canvas.Overview", Ib.controls.ControlBase, {
        __accessor: ["fillColor", "outlineColor", "outlineWidth", "selectColor", "selectWidth", "padding", "maxPackingWidth", "maxPackingHeight"],
        __bool: ["animate"],
        _fillColor: Dd.OVERVIEW_FILL_COLOR,
        _outlineColor: Dd.OVERVIEW_OUTLINE_COLOR,
        _outlineWidth: Dd.OVERVIEW_OUTLINE_WIDTH,
        _selectColor: Dd.OVERVIEW_SELECT_COLOR,
        _selectWidth: Dd.OVERVIEW_SELECT_WIDTH,
        _padding: Dd.OVERVIEW_PADDING,
        _animate: Dd.OVERVIEW_ANIMATE,
        _maxPackingWidth: Dd.OVERVIEW_MAX_PACKING_WIDTH,
        _maxPackingHeight: Dd.OVERVIEW_MAX_PACKING_HEIGHT,
        getNetwork: function() {
            return this._network
        },
        onPropertyChanged: function(a) {
            this._invalidateMask()
        },
        setNetwork: function(a) {
            a !== this._network && (this._network && (this._network.removePropertyChangeListener(this._handleNetworkPropertyChange, this), this._network.removeViewListener(this._handleNetworkViewChange, this), Wb.removeEventListener("scroll", "_handleScrollChange", this._network.getView(), this)), this._network = a, this._network && (this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this), this._network.addViewListener(this._handleNetworkViewChange, this), Wb.addEventListener("scroll", "_handleScrollChange", this._network.getView(), this)), this.invalidate())
        },
        _handleNetworkPropertyChange: function(a) { ("zoom" === a.property || "currentSubNetwork" === a.property || "elementBox" === a.property || "dataBox" === a.property || "canvasSizeChange" === a.property) && this.invalidate()
        },
        _handleNetworkViewChange: function(a) {
            "validateEnd" === a.kind && this.invalidate()
        },
        _handleScrollChange: function() {
            this._invalidateMask()
        },
        invalidate: function(a) {
            this._isNetworkDirty && this._isMaskDirty || (this._isNetworkDirty || (this._isNetworkDirty = !0), this._isMaskDirty || (this._isMaskDirty = !0), Jb.callLater(this.validate, this, null, a))
        },
        _invalidateMask: function() {
            this._isMaskDirty || (this._isMaskDirty = !0, Jb.callLater(this.validate, this, [], 100))
        },
        validate: function() {
            if ((this._isMaskDirty || this._isNetworkDirty) && this._network && (this._maxPackingWidth > 0 && this._maxPackingHeight > 0 || this._view.clientWidth > 0 && this._view.clientHeight > 0) && 0 !== this._network.getViewRect().width && 0 !== this._network.getViewRect().height && !this._network._invalidate) {
                var a, b = this._maxPackingWidth > 0 && this._maxPackingHeight > 0;
                a = b ? {
                    x: 0,
                    y: 0,
                    width: this._maxPackingWidth,
                    height: this._maxPackingHeight
                }: {
                    x: 0,
                    y: 0,
                    width: this._view.clientWidth,
                    height: this._view.clientHeight
                },
                Tb.grow(a, -this._padding, -this._padding);
                var c = Math.min(a.width / this._network.getCanvasSize().width, a.height / this._network.getCanvasSize().height);
                b && (Wb.setDiv(this._view, {
                    x: 0,
                    y: 0,
                    width: this._imageDiv._viewRect.width,
                    height: this._imageDiv._viewRect.height
                },
                null, 0, null), a.width = this._imageDiv._viewRect.width, a.height = this._imageDiv._viewRect.height);
                var d = this._network.getCanvasSize().width * c,
                e = this._network.getCanvasSize().height * c,
                f = a.x + (a.width - d) / 2,
                g = a.y + (a.height - e) / 2;
                if (this._isNetworkDirty) {
                    var h = {
                        x: f,
                        y: g,
                        width: d,
                        height: e
                    };
                    this._network.toCanvas(h.width, h.height, this._imageCanvas),
                    Wb.setDiv(this._imageDiv, h, null, 0, null),
                    this._network.getElementBox && (this._imageDiv.style.backgroundColor = (this._network.getCurrentSubNetwork() || this._network.getElementBox()).getStyle("background.color") || ""),
                    this._isNetworkDirty = !1
                }
                if (this._isMaskDirty) {
                    var i = {
                        x: this._network.getViewRect().x * c,
                        y: this._network.getViewRect().y * c,
                        width: d * this._network._view.clientWidth / this._network.getCanvasSize().width,
                        height: e * this._network._view.clientHeight / this._network.getCanvasSize().height
                    };
                    i.x = i.x < 0 ? 0 : i.x,
                    i.y = i.y < 0 ? 0 : i.y;
                    var j = Wb.setCanvas(this._maskCanvas, f, g, d, e);
                    j.lineWidth = 0,
                    j.fillStyle = this._fillColor,
                    j.beginPath(),
                    Xb.drawVector(j, "rectangle", null, f, g, d, e),
                    j.fill(),
                    j.clearRect(f + i.x, g + i.y, i.width, i.height);
                    var k = this._outlineWidth < 0 ? 0 : this._outlineWidth;
                    j.lineWidth = k,
                    j.strokeStyle = this._outlineColor;
                    var l = i.width - 2 * k,
                    m = i.height - 2 * k;
                    l = Math.min(l, d - 2 - i.x - this._outlineWidth),
                    m = Math.min(m, e - 2 - i.y - this._outlineWidth),
                    j.beginPath(),
                    Xb.drawVector(j, "rectangle", null, f + i.x + k, g + i.y + k, l, m),
                    k >= 0 && j.stroke(),
                    this._isMaskDirty = !1
                }
            } else this._isNetworkDirty = !1,
            this._isMaskDirty = !1
        },
        getLogicalPoint: function(a) {
            return Wb.getLogicalPoint(this._view, a, 1, this._rootDiv)
        },
        centerNetwork: function(a, b) {
            var c = this._imageDiv._viewRect;
            Tb.containsPoint(c, a) && (this._network.centerByLogicalPoint((a.x - c.x) / c.width * this._network.getCanvasSize().width, (a.y - c.y) / c.height * this._network.getCanvasSize().height, b), this._invalidateMask())
        }
    }),
    Ib.canvas.OverviewTouchInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.canvas.OverviewTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            this.clear(),
            this.endPoint = this.overview.getLogicalPoint(a),
            zc.isMultiTouch(a) && (this.distance = zc.getDistance(a), this.zoom = this.network.getZoom()),
            Wb.addEventListener("touchmove", "handleTouchmove", this.view, this),
            Wb.addEventListener("touchend", "handleTouchend", this.view, this)
        },
        handleTouchmove: function(a) {
            if (this.moved || (this.moved = !0), this.endPoint = this.overview.getLogicalPoint(a), zc.isSingleTouch(a)) this.overview.centerNetwork(this.endPoint, !1);
            else if (this.distance) {
                var b = zc.getDistance(a) / this.distance;
                this.network.setZoom(this.zoom * b, !1)
            }
        },
        handleTouchend: function(a) {
            if (!this.moved) {
                this.endPoint = this.overview.getLogicalPoint(a);
                var b = this.lastPoint && this.lastTouchStartTime && (new Date).getTime() - this.lastTouchStartTime.getTime() <= 300 && Math.abs(this.endPoint.x - this.lastPoint.x) <= 10 && Math.abs(this.endPoint.y - this.lastPoint.y) <= 10;
                b ? (this.lastPoint = null, this.lastTouchStartTime = null) : (this.lastPoint = this.endPoint, this.lastTouchStartTime = new Date),
                b ? Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]) : this.overview.centerNetwork(this.endPoint, this.overview._animate)
            }
            this.clear()
        },
        clear: function() {
            this.endPoint && (this.endPoint = null, Wb.removeEventListener("touchmove", this.view, this), Wb.removeEventListener("touchend", this.view, this)),
            this.moved = !1
        }
    }),
    Ib.canvas.OverviewMSTouchInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        this._pointerMap = {},
        this._pointerIdArray = [];
        var b = this;
        this.view.addEventListener("MSPointerDown",
        function(a) {
            b.handleTouchstart(a)
        },
        !1),
        this.view.addEventListener("MSPointerMove",
        function(a) {
            b.handleTouchmove(a)
        },
        !1),
        this.view.addEventListener("MSPointerUp",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.view.addEventListener("MSPointerCancel",
        function(a) {
            b.handleTouchend(a)
        },
        !1)
    },
    Jb.ext("twaver.canvas.OverviewMSTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            a.isPrimary && this._pointerIdArray.length > 0 && (this._pointerMap = {},
            this._pointerIdArray = []),
            !this._pointerMap[a.pointerId] && this.overview.getLogicalPoint(a) && (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a),
            1 == this._pointerIdArray.length ? (this._startTouchPoint = this.overview.getLogicalPoint(a), this._startTouchTime = new Date) : 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.network.getZoom())
        },
        handleTouchmove: function(a) {
            if (0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10)) if (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length) {
                var b = this._getDistance() / this._distance;
                this.network.setZoom(this._zoom * b, !1)
            } else if (1 == this._pointerIdArray.length && this._startTouchPoint) {
                var c = this.overview.getLogicalPoint(a);
                if (null == c) return;
                this._startTouchPoint = c,
                this.overview.centerNetwork(this._startTouchPoint, !1)
            }
        },
        handleTouchend: function(a) {
            var b = this.overview.getLogicalPoint(a);
            if (1 == this._pointerIdArray.length && b) {
                var c = this._endTouchPoint && this._endTouchTime && (new Date).getTime() - this._endTouchTime.getTime() <= 500 && Tb.getDistance(this._endTouchPoint, b) <= 10;
                c ? (this._endTouchPoint = null, this._endTouchTime = null) : (this._endTouchPoint = b, this._endTouchTime = new Date),
                c ? Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]) : this.overview.centerNetwork(this._endTouchPoint, this.overview._animate)
            }
            this._pointerMap = {},
            this._pointerIdArray = []
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        }
    }),
    Ib.canvas.OverviewInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        Wb.addEventListener("mousedown", "handleMousedown", this.view, this)
    },
    Jb.ext("twaver.canvas.OverviewInteraction", Object, {
        handleMousedown: function(a) {
            0 === a.button && (this.clear(), this.endPoint = this.overview.getLogicalPoint(a), Jb.isCtrlDown(a) && (this.startPoint = this.endPoint, Wb.setVisible(this.overview._selectDiv, !0)), Wb.addEventListener("mousemove", "handleMousemove", this.view, this), Wb.addEventListener("mouseup", "handleMouseup", this.view, this))
        },
        handleMouseup: function(a) {
            if (this.endPoint = this.overview.getLogicalPoint(a), "detail" in a && 2 === a.detail) Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            else if (Wb.isVisible(this.overview._selectDiv) && this.startPoint) {
                var b = this.overview._imageDiv._viewRect,
                c = this.overview._selectDiv._viewRect.x,
                d = this.overview._selectDiv._viewRect.y,
                e = b.width / this.overview._selectDiv._viewRect.width,
                f = b.height / this.overview._selectDiv._viewRect.height,
                g = Math.min(e, f);
                this.network.setZoom(g * Math.min(this.network.getViewRect().width / this.network.getCanvasSize().width, this.network.getViewRect().height / this.network.getCanvasSize().height) * this.network.getZoom(), !1);
                var h = this.network.getCanvasSize().width * ((c - b.x + this.overview._selectDiv._viewRect.width / 2) / b.width),
                i = this.network.getCanvasSize().height * ((d - b.y + this.overview._selectDiv._viewRect.height / 2) / b.height);
                Jb.callLater(this.network.centerByLogicalPoint, this.network, [h, i, this.overview._animate]),
                Wb.setVisible(this.overview._selectDiv, !1),
                Wb.setDiv(this.overview._selectDiv, {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                null, 0, null),
                this.startPoint = null
            } else this.overview.centerNetwork(this.endPoint, this.overview._animate);
            this.clear()
        },
        handleMousemove: function(a) {
            var b = this.overview.getLogicalPoint(a);
            if (this.endPoint = b, Wb.isVisible(this.overview._selectDiv) && this.startPoint) {
                var c = b.x > this.startPoint.x ? this.startPoint.x: b.x,
                d = b.x > this.startPoint.x ? this.startPoint.y: b.y;
                b.x > this.startPoint.x && b.y < this.startPoint.y && (d = b.y),
                b.x < this.startPoint.x && b.y > this.startPoint.y && (d = this.startPoint.y);
                var e = this.overview._imageDiv._viewRect;
                c < e.x && (c = e.x),
                c > e.x + e.width && (c = e.x + e.width),
                d < e.y && (d = e.y),
                d > e.y + e.height && (d = e.y + e.height);
                var f = Math.abs(b.x - this.startPoint.x),
                g = Math.abs(b.y - this.startPoint.y);
                c + f > e.x + e.width && (f = e.x + e.width - c),
                d + g > e.y + e.height && (g = e.y + e.height - d),
                Wb.setDiv(this.overview._selectDiv, {
                    x: c,
                    y: d,
                    width: f,
                    height: g
                },
                null, this.overview._selectWidth, this.overview._selectColor)
            } else this.overview.centerNetwork(b, !1)
        },
        clear: function() {
            this.endPoint && (this.endPoint = null, Wb.removeEventListener("mousemove", this.view, this), Wb.removeEventListener("mouseup", this.view, this))
        }
    }),
    Ib.canvas.ElementUI = function(a, b) {
        this._network = a,
        this._element = b,
        this._attachments = new Ib.List,
        this._bodyBounds = new Ib.List,
        this._hitTest = !1,
        this._hitTest = !1,
        this._intersectTest = !1,
        this.invalidate(!0)
    },
    Jb.ext("twaver.canvas.ElementUI", Object, {
        getElement: function() {
            return this._element
        },
        getNetwork: function() {
            return this._network
        },
        handlePropertyChange: function(a) {
            this.invalidate(!0)
        },
        handleSelectionChange: function(a) {
            this.invalidate(!0)
        },
        invalidate: function(a) {
            a === b && (a = !0),
            a && (this._invalidateAttachmentsFlag = !0),
            this._invalidateFlag || (this._hotSpot = null, this._bodyRect = null, this._invalidateFlag = !0, this._network.invalidateElementVisibility())
        },
        updateStyle: function() {
            this._innerColor = this._network.getInnerColor(this._element),
            this._outerColor = this._network.getOuterColor(this._element),
            this._shadowColor = this._network.getShadowColor(this._element),
            this._shadowXOffset = this._element.getStyle("shadow.xoffset"),
            this._shadowYOffset = this._element.getStyle("shadow.yoffset"),
            this._shadowBlur = this._element.getStyle("shadow.blur"),
            this._wholeAlpha = this._element.getStyle("whole.alpha")
        },
        validate: function() {
            if (0 != this._invalidateFlag) {
                this._bodyBounds.clear(),
                this._invalidateAttachmentsFlag && (this._invalidateAttachmentsFlag = !1, this.checkAttachments()),
                this._invalidateFlag = !1,
                this.updateStyle(),
                this.validateImpl(),
                this._attachments.forEach(function(a) {
                    a.validate()
                });
                var a;
                this._bodyBounds.forEach(function(b) {
                    a = Tb.unionRect(a, b)
                }),
                this._unionBodyBounds = Jb.clone(a),
                this._attachments.forEach(function(b) {
                    a = Tb.unionRect(a, b.getViewRect())
                }),
                this._viewRect = a
            }
        },
        validateImpl: function() {},
        setShadow: function(a, b) {
            var c = a.isShadowable() && this._shadowColor && !this._editAttachment;
            return b.shadowOffsetX === this._shadowXOffset && b.shadowOffsetY === this._shadowYOffset && b.shadowBlur === this._shadowBlur ? b: ((c || this._network._showShadowInEdit) && (b.shadowOffsetX = this._shadowXOffset, b.shadowOffsetY = this._shadowYOffset, b.shadowBlur = this._shadowBlur, b.shadowColor = this._shadowColor), b)
        },
        clearShadow: function(a) { (0 != a.shadowOffsetX || 0 != a.shadowOffsetY || 0 != a.shadowBlur) && (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0)
        },
        appendShadowBound: function(a, b) {
            var c = a.isShadowable() && this._shadowColor && !this._editAttachment;
            return c && (this._shadowXOffset > 0 ? b.width += this._shadowXOffset: (b.x += this._shadowXOffset, b.width += -this._shadowXOffset), this._shadowYOffset > 0 ? b.height += this._shadowYOffset: (b.y += this._shadowYOffset, b.height += -this._shadowYOffset), Tb.grow(b, this._shadowBlur, this._shadowBlur)),
            b
        },
        isShadowable: function() {
            return this._shadowColor && this._network.isSelected(this._element) && "shadow" === this._element.getStyle("select.style") ? !0 : !1
        },
        addAttachment: function(a) {
            this._attachments.add(a)
        },
        removeAttachment: function(a) {
            this._attachments.remove(a)
        },
        getAttachments: function() {
            return this._attachments
        },
        checkAttachments: function() {
            this.checkLabelAttachment(),
            this.checkAlarmAttachment(),
            this.checkIconsAttachment(),
            this.checkEditAttachment()
        },
        checkLabelAttachment: function() {
            var a = this._network.getLabel(this._element);
            null != a && "" !== a ? this._labelAttachment || (this._labelAttachment = new Ib.canvas.LabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._network.getAlarmLabel(this._element);
            null != a && "" !== a ? this._alarmAttachment || (this._alarmAttachment = new Ib.canvas.AlarmAttachment(this, Dd.SHOW_ALARM_IN_ATTACHMENT_DIV), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        },
        checkIconsAttachment: function() {
            var a = this._network.getIconsNames(this._element);
            a && a.length > 0 ? this._iconsAttachment || (this._iconsAttachment = new Ib.canvas.IconsAttachment(this), this.addAttachment(this._iconsAttachment)) : this._iconsAttachment && (this.removeAttachment(this._iconsAttachment), this._iconsAttachment = null)
        },
        checkEditAttachment: function() {
            this._network.hasEditInteraction() && this._network.isSelected(this._element) && this._network.isEditable(this._element) && this.isEditable() ? this._editAttachment || (this._editAttachment = new Ib.canvas.EditAttachment(this), this.addAttachment(this._editAttachment)) : this._editAttachment && (this.removeAttachment(this._editAttachment), this._editAttachment = null)
        },
        getLabelAttachment: function() {
            return this._labelAttachment
        },
        getAlarmAttachment: function() {
            return this._alarmAttachment
        },
        getIconsAttachment: function() {
            return this._iconsAttachment
        },
        getEditAttachment: function() {
            return this._editAttachment
        },
        isEditable: function() {
            return ! 0
        },
        getInnerColor: function() {
            return this._innerColor
        },
        getOuterColor: function() {
            return this._outerColor
        },
        getShadowColor: function() {
            return this._shadowColor
        },
        getDyeColor: function(a) {
            return this._innerColor ? this._innerColor: this.getStyle(a)
        },
        getStyle: function(a) {
            return this._element.getStyle(a)
        },
        getFont: function(a) {
            var b = this._element.getStyle(a);
            return b ? b: Ib.Defaults.FONT
        },
        paint: function(a) {
            a.save(),
            a.globalAlpha = this._wholeAlpha,
            a.beginPath(),
            this.paintBody(a),
            this.clearShadow(a),
            a.closePath(),
            a.beginPath(),
            this.paintAttachments(a),
            a.closePath(),
            a.restore()
        },
        paintBody: function(a) {},
        paintAttachments: function(a) {
            a.beginPath();
            for (var b = this._attachments.size(), c = 0; b > c; c++) {
                var d = this._attachments.get(c);
                1 == this._hitTest && 0 == d.isShowOnTop() && this.paintAttachment(a, d),
                1 == this._intersectTest && this.paintAttachment(a, d),
                0 == this._hitTest && 0 == this._intersectTest && (d.isShowOnTop() ? this._network._topAttachmentList.add(d) : this.paintAttachment(a, d))
            }
        },
        paintAttachment: function(a, b) {
            a.beginPath(),
            b.paint(a),
            this.clearShadow(a)
        },
        getViewRect: function() {
            return Jb.clone(this._viewRect)
        },
        getUnionBodyBounds: function() {
            return Jb.clone(this._unionBodyBounds)
        },
        addBodyBounds: function(a) {
            a && this._bodyBounds.add(a)
        },
        getBodyRect: function() {
            return this._bodyRect || (this._bodyRect = this.createBodyRect()),
            Jb.clone(this._bodyRect)
        },
        getHotSpot: function() {
            return this._hotSpot ? Jb.clone(this._hotSpot) : {
                x: 0,
                y: 0
            }
        },
        setHotSpot: function(a) {
            this._hotSpot = a
        },
        hit: function(a, b) {
            return ! 1
        },
        intersects: function(a) {
            return Tb.contains(a, this.getViewRect()) ? !0 : !1
        },
        hitCanvasRectAtBody: function(a) {
            var b = Nd.getHitCanvas(a.width, a.height),
            c = Nd.getCtx(b);
            if (c.save(), c.translate( - a.x, -a.y), this._element.getImage) {
                var d = Jb.getImageAsset(this._element.getImage());
                if (d && d.getImage() instanceof Gd) return 1
            }
            this.paintBody(c);
            try {
                for (var e = c.getImageData(0, 0, a.width, a.height), f = e.data, g = 0; g < e.width; g++) for (var h = 0; h < e.height; h++) {
                    var i = 4 * (h * e.width + g),
                    j = f[i + 3];
                    if (0 !== j) return c.restore(),
                    1
                }
            } catch(k) {
                if (Nd.disposeHitCanvas(), Tb.contains(this.getUnionBodyBounds(), a)) return 0
            }
            return c.restore(),
            -1
        },
        hitCanvasRectAtAttachments: function(a) {
            var b = Nd.getHitCanvas(a.width, a.height),
            c = Nd.getCtx(b);
            c.save(),
            c.translate( - a.x, -a.y),
            this.paintAttachments(c);
            try {
                for (var d = c.getImageData(0, 0, a.width, a.height), e = d.data, f = 0; f < d.width; f++) for (var g = 0; g < d.height; g++) {
                    var h = 4 * (g * d.width + f),
                    i = e[h + 3];
                    if (0 !== i) return c.restore(),
                    1
                }
            } catch(j) {
                Nd.disposeHitCanvas()
            }
            return c.restore(),
            -1
        },
        hitCanvasRect: function(a) {
            this._intersectTest = !0,
            1 == this._hitTest && (this._intersectTest = !1);
            var b = Tb.intersection(a, this._viewRect),
            c = this.hitCanvasRectAtBody(b);
            if (1 == c) return this._intersectTest = !1,
            !0;
            var d = this.hitCanvasRectAtAttachments(b);
            return 1 == d ? (this._intersectTest = !1, !0) : (this._intersectTest = !1, 0 == c)
        },
        hitCanvasPoint: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            if (d && d > 0 && Tb.grow(c, d, d), !Tb.intersects(this._viewRect, c)) return ! 1;
            this._hitTest = !0;
            var e = this.hitCanvasRect(c);
            return this._hitTest = !1,
            e
        },
        hitTest: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            if (d && d > 0 && Tb.grow(c, d, d), !Tb.intersects(this._viewRect, c)) return null;
            var e = Tb.intersection(c, this._viewRect),
            f = this.hitCanvasRectAtBody(e);
            if (1 == f) return this;
            for (var g = this._attachments.size(), h = 0; g > h; h++) {
                var i = this._attachments.get(h);
                if (i.hit(a, b)) return i
            }
            return 0 == f ? this: null
        },
        dispose: function() {
            this._attachments.forEach(function(a) {
                a.dispose()
            }),
            this._attachments.clear()
        }
    }),
    Ib.canvas.NodeUI = function(a, b) {
        Ib.canvas.NodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.NodeUI", Ib.canvas.ElementUI, {
        invalidate: function(a) {
            Ib.canvas.NodeUI.superClass.invalidate.call(this, a),
            this.curInterval && clearInterval(this.curInterval);
            var b = this._element.getAgentLinks();
            b && b.forEach(function(a) {
                this._network.invalidateElementUI(a, !1)
            },
            this);
            var c = this._element.getParent();
            c instanceof Ib.Group && this._network.invalidateElementUI(c, !1)
        },
        createBodyRect: function() {
            return this._element.getRect()
        },
        validateImpl: function() {
            Ib.canvas.NodeUI.superClass.validateImpl.call(this);
            var a = this.getStyle("vector.shape"),
            b = this.getBodyRect();
            this._hotSpot = Tb.getHotSpot(b.x, b.y, b.width, b.height, a),
            this.validateBodyBounds()
        },
        validate: function() {
            0 != this._invalidateFlag && Ib.canvas.NodeUI.superClass.validate.call(this)
        },
        validateBodyBounds: function() {
            var a = this.getStyle("body.type");
            "default" === a ? this.addBodyBounds(this.getDefaultBodyRect()) : "vector" === a ? this.addBodyBounds(this.getVectorBody()) : "default.vector" === a ? (this.addBodyBounds(this.getVectorBody()), this.addBodyBounds(this.getDefaultBodyRect())) : "vector.default" === a && (this.addBodyBounds(this.getDefaultBodyRect()), this.addBodyBounds(this.getVectorBody())),
            this._outerColor && this.addBodyBounds(this.getOuterBorderRect()),
            !this._editAttachment && "border" === this.getStyle("select.style") && this._network.isSelected(this._element) && this.addBodyBounds(this.getSelectBorderRect())
        },
        getDefaultBodyRect: function() {
            var a = this._element,
            b = Jb.getImageAsset(a.getImage()),
            c = this.getBodyRect();
            if (!b) return c;
            Tb.addPadding(c, this._element, "image.padding", 1),
            this._defaultRect = c;
            var d = Jb.clone(c);
            return this.appendShadowBound(this, d),
            c = d
        },
        getVectorBody: function() {
            var a = this.getPathRect("vector");
            return a
        },
        getOuterBorderRect: function() {
            return this._getBorderRect("outer")
        },
        getSelectBorderRect: function() {
            return this._getBorderRect("select")
        },
        _getBorderRect: function(a) {
            var b = this._element,
            c = b.getStyle(a + ".width");
            if (c > 0) {
                var d = this.getBodyRect();
                Tb.addPadding(d, b, a + ".padding", 1);
                var e = Jb.clone(d);
                return Tb.grow(e, c / 2, c / 2),
                e
            }
            return null
        },
        getPathRect: function(a, b) {
            var c = this._element,
            d = this.getBodyRect();
            b && Tb.addPadding(d, c, a + ".padding", 1);
            var e = Jb.clone(d),
            f = c.getStyle(a + ".outline.width");
            return f > 0 && Tb.grow(e, f / 2, f / 2),
            this.appendShadowBound(this, e),
            e
        },
        paintBody: function(a) {
            this.curInterval && clearInterval(this.curInterval);
            var b = this.getStyle("body.type");
            "default" === b ? this.drawDefaultBody(a) : "vector" === b ? this.drawVectorBody(a) : "default.vector" === b ? (this.drawVectorBody(a), this.drawDefaultBody(a)) : "vector.default" === b && (this.drawDefaultBody(a), this.drawVectorBody(a)),
            this._outerColor && this.drawOuterBorder(a),
            "border" === this.getStyle("select.style") && this._network.isSelected(this._element) && this.drawSelectBorder(a)
        },
        drawOuterBorder: function(a) {
            var b = this._element,
            c = b.getStyle("outer.width");
            if (c > 0) {
                var d = this.getBodyRect();
                Tb.addPadding(d, b, "outer.padding", 1),
                a.lineWidth = c,
                a.lineCap = b.getStyle("outer.cap"),
                a.lineJoin = b.getStyle("outer.join"),
                a.strokeStyle = this._outerColor,
                Xb.drawVector(a, b.getStyle("outer.shape"), null, d),
                a.stroke()
            }
        },
        drawDefaultBody: function(a) {
            var b = this._element,
            c = Jb.getImageAsset(b.getImage()),
            d = this._defaultRect;
            if (c && c.getImage()) {
                if (0 != b.getAngle() && (a.save(), d = b.getOriginalRect(), Ib.Util.rotateCanvas(a, d, b.getAngle())), this.setShadow(this, a), c.getImage() instanceof Gd) {
                    var e, f = c.getImage().frames,
                    g = c.getImage().size,
                    h = 0;
                    e = Id(f, g, 0),
                    a.drawImage(e, d.x, d.y, d.width, d.height),
                    this.curInterval = setInterval(function() {
                        h = (h + f.length) % f.length,
                        e = Id(f, g, h),
                        a.drawImage(e, d.x, d.y, d.width, d.height),
                        h++
                    },
                    100)
                } else Nc(a, b.getImage(), this.getInnerColor(), d, b, this._network);
                0 != b.getAngle() && a.restore()
            }
        },
        drawSelectBorder: function(a) {
            var b = this._element,
            c = b.getStyle("select.width");
            if (c > 0) {
                var d = this.getBodyRect();
                Tb.addPadding(d, b, "select.padding", 1);
                var e = Jb.clone(d);
                Tb.grow(e, c / 2, c / 2),
                a.lineWidth = c,
                a.lineCap = b.getStyle("select.cap"),
                a.lineJoin = b.getStyle("select.join"),
                a.strokeStyle = b.getStyle("select.color"),
                Xb.drawVector(a, b.getStyle("select.shape"), null, d),
                a.stroke()
            }
        },
        drawVectorBody: function(a) {
            this.drawPath(a, "vector", !0, this._element.getStyle("vector.outline.pattern"));
            var b = this.getStyle("vector.deep"),
            c = this.getStyle("vector.fill.color"),
            d = this.getBodyRect();
            if (0 !== b && c) {
                var e = this._element.getAngle();
                0 != e && (a.save(), d = this._element.getOriginalRect(), Ib.Util.rotateCanvas(a, d, e)),
                "rectangle" === this.getStyle("vector.shape") && Xb.draw3DRect(a, c, b, d),
                0 != e && a.restore()
            }
        },
        drawPath: function(a, b, c, d, e, f, g) {
            var h = this._element,
            i = this.getBodyRect();
            c && Tb.addPadding(i, h, b + ".padding", 1);
            var j = h.getStyle(b + ".outline.width");
            this.setShadow(this, a),
            0 != h.getAngle() && (h instanceof Md || (i = h.getOriginalRect()), a.save(), Ib.Util.rotateCanvas(a, i, h.getAngle()));
            var k, l = h.getStyle(b + ".fill");
            if (l) {
                k = this._innerColor && !vc.hasDefault(this._element) ? this._innerColor: h.getStyle(b + ".fill.color");
                var m = h.getStyle(b + ".gradient");
                m ? Xb.fill(a, k, m, h.getStyle(b + ".gradient.color"), i) : a.fillStyle = k
            }
            var n = h.getStyle(b + ".shape"),
            o = h.getStyle("group.shape.roundrect.radius");
            l && (a.beginPath(), e ? Xb.drawLinePoints(a, e, null, f, g) : "roundrect" === n && "group" === b ? Xb.drawVector(a, n, null, i, o) : Xb.drawVector(a, n, null, i), a.fill()),
            j > 0 && (a.lineWidth = j, a.lineCap = h.getStyle(b + ".cap"), a.lineJoin = h.getStyle(b + ".join"), a.strokeStyle = h.getStyle(b + ".outline.color"), a.beginPath(), e ? Xb.drawLinePoints(a, e, d, f, g) : "roundrect" === n && "group" === b ? Xb.drawVector(a, n, d, i, o) : Xb.drawVector(a, n, d, i), a.stroke()),
            0 != h.getAngle() && a.restore()
        },
        hit: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            if (d && d > 0 && Tb.grow(c, d, d), this._network._transparentSelectionEnable) {
                var e = this.getBodyRect();
                if (Jb.math.intersects(e, c)) return ! 0
            }
            return Tb.intersects(this.getViewRect(), c) ? this.hitCanvasPoint(a, b) : !1
        },
        intersects: function(a) {
            var b = Ib.canvas.NodeUI.superClass.intersects.apply(this, arguments);
            if (1 == b) return ! 0;
            if (this._network._transparentSelectionEnable) {
                var c = this.getBodyRect();
                if (Jb.math.intersects(c, a)) return ! 0
            }
            return Tb.intersects(a, this.getViewRect()) ? this.hitCanvasRect(a) : !1
        }
    }),
    Ib.canvas.LinkUI = function(a, b) {
        Ib.canvas.LinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.LinkUI", Ib.canvas.ElementUI, {
        isEditable: function() {
            return xc.isOrthogonalLink(this._element) && this.getControlPoint() ? !0 : !1
        },
        invalidate: function(a) {
            this._linkPoints = null,
            this._fromPoint = null,
            this._toPoint = null,
            this._angle = null,
            Ib.canvas.LinkUI.superClass.invalidate.call(this, a)
        },
        validateImpl: function() {
            this.validateBodyBounds(),
            Ib.canvas.LinkUI.superClass.validateImpl.call(this)
        },
        validateBodyBounds: function() {
            var a = this.getLinkPoints();
            if (a && !(a.size() < 2)) {
                var b = this._element,
                c = Tb.getLineRect(a),
                d = b.getStyle("link.width"),
                e = d;
                if (this._outerColor) {
                    var f = b.getStyle("outer.width");
                    e += 2 * f
                }
                var g = !this._editAttachment && "border" === b.getStyle("select.style") && this._network.isSelected(this._element);
                if (g) {
                    var h = b.getStyle("select.width");
                    e += 2 * h
                }
                Tb.grow(c, e / 2, e / 2),
                b.getStyle("arrow.from") && (this._network._debug && (this._arrowFromRect = od.getArrowRect(this, a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), b.getStyle("arrow.from.xoffset"), b.getStyle("arrow.from.yoffset"))), c = Tb.unionRect(c, od.getArrowRect(this, a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), b.getStyle("arrow.from.xoffset"), b.getStyle("arrow.from.yoffset")))),
                b.getStyle("arrow.to") && (this._network._debug && (this._arrowToRect = od.getArrowRect(this, a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), b.getStyle("arrow.to.xoffset"), b.getStyle("arrow.to.yoffset"))), c = Tb.unionRect(c, od.getArrowRect(this, a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), b.getStyle("arrow.to.xoffset"), b.getStyle("arrow.to.yoffset")))),
                this.appendShadowBound(this, c),
                this.addBodyBounds(c)
            }
        },
        createBodyRect: function() {
            var a = this.getHotSpot();
            return a ? {
                x: a.x - 1,
                y: a.y - 1,
                width: 2,
                height: 2
            }: null
        },
        paintBody: function(a) {
            var b = this._linkPoints;
            if (b && !(b.size() < 2)) {
                var c = this._element,
                d = c.getStyle("link.width"),
                e = d;
                if (this._outerColor) {
                    var f = c.getStyle("outer.width");
                    e += 2 * f
                }
                var g = !this._editAttachment && "border" === c.getStyle("select.style") && this._network.isSelected(this._element);
                if (g) {
                    var h = c.getStyle("select.width");
                    e += 2 * h
                }
                this.setShadow(this, a),
                a.lineCap = c.getStyle("link.cap"),
                a.lineJoin = c.getStyle("link.join");
                var i = c.getStyle("link.pattern");
                g && this.drawLinePoints(a, b, e, c.getStyle("select.color"), i),
                this._outerColor && this.drawLinePoints(a, b, d + 2 * f, this._outerColor, i),
                this.drawLinePoints(a, b, d, this._innerColor || c.getStyle("link.color"), i),
                od.drawLinkArrow(this, a, b)
            }
        },
        drawLinePoints: function(a, b, c, d, e) {
            if (a.lineWidth = c, a.strokeStyle = d, this._element.getStyle("link.flow") === !0 && e && e.length > 1) {
                var f = new uc(a, e[0], e[1]),
                g = this._element.getStyle("link.flow.offset"),
                h = Math.floor(g / (e[0] + e[1]));
                h > 2 && (g -= (e[0] + e[1]) * h),
                this._element.getStyle("link.flow.converse") ? g < e[0] ? f.overflow = e[0] - g: g >= e[0] && g <= e[0] + e[1] ? (f.overflow = e[1] - (g - e[0]), f.overflow && (f.isLine = !1)) : (g -= e[0] + e[1], f.overflow = e[0] - g) : g <= e[1] ? (f.overflow = g, g && (f.isLine = !1)) : g > e[1] && g <= e[0] + e[1] ? f.overflow = g - e[1] : (g -= e[0] + e[1], g && (f.isLine = !1), f.overflow = g),
                this._element._styleMap["link.flow.offset"] = g,
                a.beginPath(),
                Xb._drawLine(b, a),
                a.stroke(),
                a.shadowColor = "transparent",
                a.beginPath();
                var i = this._element.getStyle("link.flow.color");
                i = i ? i: Dd.NETWORK_LINK_FLOW_COLOR,
                a.strokeStyle = i,
                Xb._drawLine(b, f),
                a.stroke(),
                a.shadowColor = this._shadowColor
            } else a.beginPath(),
            Xb.drawLinePoints(a, b, e),
            a.stroke()
        },
        getLinkPoints: function() {
            return this._linkPoints || (this._linkPoints = this.createLinkPoints(), this._lineLength = Tb.calculateLineLength(this._linkPoints)),
            this._linkPoints
        },
        getFromPosition: function(a, b) {
            var c = this.getFromPoint();
            return c ? {
                x: c.x + a,
                y: c.y + b
            }: null
        },
        getToPosition: function(a, b) {
            var c = this.getToPoint();
            return c ? {
                x: c.x + a,
                y: c.y + b
            }: null
        },
        getFromPoint: function() {
            return this._fromPoint || (this._fromPoint = xc.createFromPoint(this)),
            this._fromPoint
        },
        getToPoint: function() {
            return this._toPoint || (this._toPoint = xc.createToPoint(this)),
            this._toPoint
        },
        createLinkPoints: function() {
            var a = this.getFromPoint(),
            b = this.getToPoint(),
            c = this.getStyle("link.type"),
            d = new Ib.List;
            if (xc.isOrthogonalOrFlexionalLink(this._element)) d = xc.orthogonalAndFlexional(this, c);
            else if (this._element.isLooped()) {
                var e = this._network.getElementUI(this._element.getFromAgent());
                null != e && (this._hotSpot = xc.fillLoopedPoints(this, e.getBodyRect(), d))
            } else {
                if ("arc" !== c && "triangle" !== c && "parallel" !== c) throw "Can not resolve link type '" + c + "'";
                this._hotSpot = xc.fillBundlePoints(this, c, a, b, d)
            }
            if (this._network._linkPathFunction) {
                var f = this._network._linkPathFunction(this, d);
                f && (d = f)
            }
            return d
        },
        checkAttachments: function() {
            Ib.canvas.LinkUI.superClass.checkAttachments.call(this),
            this.checkLinkHandlerAttachment()
        },
        checkLinkHandlerAttachment: function() {
            var a = this._network.getLinkHandlerLabel(this._element);
            null != a && "" !== a ? this._linkHandlerAttachment || (this._linkHandlerAttachment = new Ib.canvas.LinkHandlerAttachment(this), this.addAttachment(this._linkHandlerAttachment)) : this._linkHandlerAttachment && (this.removeAttachment(this._linkHandlerAttachment), this._linkHandlerAttachment = null)
        },
        getLinkHandlerAttachment: function() {
            return this._linkHandlerAttachment
        },
        getControlPoint: function() {
            return xc.getControlPoint(this._element, this)
        },
        setControlPoint: function(a) {
            if (a) {
                var b = this.getStyle("link.type");
                if (xc.hasControlPoint(b)) {
                    var c = xc.getLinkSourceBounds(this),
                    d = xc.getLinkTargetBounds(this);
                    xc.setParamsByControlPoint(a, c, d, b, this._element)
                }
            }
        },
        getLineLength: function() {
            return this._lineLength
        },
        hit: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            return d && d > 0 && Tb.grow(c, d, d),
            Tb.intersects(this.getViewRect(), c) ? this.hitCanvasPoint(a, b) : !1
        },
        intersects: function(a) {
            var b = Ib.canvas.LinkUI.superClass.intersects.apply(this, arguments);
            if (1 == b) return ! 0;
            if (0 == Tb.intersects(a, this.getViewRect())) return ! 1;
            var c = this.getLinkPoints(),
            d = c.size();
            if (2 == d) for (var e = 0; d > e; e += 2) {
                var f = c.get(e);
                if (d > e + 1) {
                    var g = c.get(e + 1);
                    if (Nd.intersectsLine(f.x, f.y, g.x, g.y, a.x, a.y, a.width, a.height)) return ! 0
                }
            }
            return this.hitCanvasRect(a)
        },
        getAngle: function() {
            return ! this._angle && this._fromPoint && this._toPoint && (this._angle = Tb.getAngle(this._fromPoint, this._toPoint)),
            this._angle || 0
        }
    }),
    Ib.canvas.GroupUI = function(a, b) {
        Ib.canvas.GroupUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.GroupUI", Ib.canvas.NodeUI, {
        isEditable: function() {
            return ! this._element.isExpanded()
        },
        paintBody: function(a) {
            this._shapeRect ? this.drawExpandedGroup(a) : Ib.canvas.GroupUI.superClass.paintBody.apply(this, arguments)
        },
        validateBodyBounds: function() {
            this.getBodyRect(),
            this._shapeRect ? this.addBodyBounds(this.getPathRect("group", !1)) : Ib.canvas.GroupUI.superClass.validateBodyBounds.call(this)
        },
        drawExpandedGroup: function(a) {
            this.drawPath(a, "group", !1, this._element.getStyle("vector.outline.pattern"));
            var b = this.getStyle("group.deep"),
            c = this.getStyle("group.fill.color");
            0 !== b && c && "rectangle" === this.getStyle("group.shape") && Xb.draw3DRect(a, c, b, this._bodyRect)
        },
        getChildrenRects: function() {
            return this._network.getGroupChildrenRects(this._element)
        },
        createBodyRect: function() {
            this._shapeRect = null;
            var a = this._element,
            b = this._network;
            if (a.isExpanded()) {
                a.getChildren().forEach(function(a) {
                    var c = b.getElementUI(a);
                    c && c.validate()
                });
                var c = this.getChildrenRects();
                if (!c.isEmpty()) {
                    var d = a.getStyle("group.shape"),
                    e = Ub[d];
                    if (!e) throw "Can not resolve group shape '" + d + "'";
                    this._shapeRect = e(c)
                }
            }
            return this._shapeRect ? (Tb.addPadding(this._shapeRect, a, "group.padding", 1), this._shapeRect) : Ib.canvas.GroupUI.superClass.createBodyRect.call(this)
        }
    }),
    Ib.canvas.ShapeNodeUI = function(a, b) {
        Ib.canvas.ShapeNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.ShapeNodeUI", Ib.canvas.NodeUI, {
        getDefaultBodyRect: function() {
            return this._element._points.size() < 2 ? null: this.getPathRect("vector", !0)
        },
        drawDefaultBody: function(a) {
            this._element._points.size() < 2 || (this.drawPath(a, "vector", !0, this._element.getStyle("vector.outline.pattern"), this._element._points, this._element._segments, this._element.getStyle("shapenode.closed")), od.drawLinkArrow(this, a, Tb.getPointObject(this._element._points, this._element._segments)))
        },
        drawSelectBorder: function(a) {
            var b = this._element,
            c = b.getStyle("select.width");
            if (c > 0) {
                var d = this.getBodyRect();
                Tb.addPadding(d, b, "select.padding", 1),
                Tb.grow(d, c / 2, c / 2);
                var e = b.getStyle("vector.outline.width");
                e > 0 && Tb.grow(d, e / 2, e / 2),
                a.lineWidth = c,
                a.lineCap = b.getStyle("select.cap"),
                a.lineJoin = b.getStyle("select.join"),
                a.strokeStyle = b.getStyle("select.color"),
                Xb.drawVector(a, b.getStyle("select.shape"), null, d),
                a.stroke()
            }
        }
    }),
    Ib.canvas.ShapeLinkUI = function(a, b) {
        Ib.canvas.ShapeLinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.ShapeLinkUI", Ib.canvas.LinkUI, {
        isEditable: function() {
            return ! 0
        },
        createLinkPoints: function() {
            var a = this.getFromPoint(),
            b = this.getToPoint(),
            c = new Ib.List,
            d = this.getStyle("shapelink.type");
            c.add(a),
            null != this._element._points && c.addAll(this._element._points),
            c.add(b);
            var e, f, g, h, i, j, k, l = Tb.calculateLineLength(c) / 2,
            m = c.size(),
            n = 0,
            o = 0;
            for (e = 0; m > e; e++) if (h = c.get(e), 0 != e) {
                if (g = h, g instanceof nd && (g = g._as), g instanceof Array ? (i = Tb.calculateCurveLength(f, g, 1), f = g[g.length - 1]) : (k = h.y - f.y, j = h.x - f.x, i = Math.sqrt(j * j + k * k), f = g), o += i, l >= n && o >= l) {
                    var p = l - n,
                    q = c.get(e - 1);
                    q instanceof nd && (q = q._as, q instanceof Array && (q = q[q.length - 1]));
                    var r = c.get(e),
                    s = Tb.getPathInfo(r, q, p, 0, -1).point;
                    this._hotSpot = Jb.clone(s)
                }
                n = o
            } else f = h;
            var t, u, v;
            if ("lineto" === d);
            else if ("quadto" === d) {
                for (t = new Ib.List(c.get(0)), u = 1, pointCount = c.size(); u < pointCount; u++) t.add(u < pointCount - 1 ? new Ib.List([c.get(u++), c.get(u)]) : c.get(u));
                c = t
            } else if ("cubicto" === d) {
                for (t = new Ib.List(c.get(0)), u = 1, pointCount = c.size(); u < pointCount; u++) t.add(u < pointCount - 2 ? new Ib.List([c.get(u++), c.get(u++), c.get(u)]) : u < pointCount - 1 ? new Ib.List([c.get(u++), c.get(u)]) : c.get(u));
                c = t
            } else {
                if ("orthogonalto" !== d) throw "Can not resolve shapelink type '" + d + "'";
                for (v = c.get(0), t = new Ib.List(v), u = 1, pointCount = c.size(); u < pointCount; u++) if (u < pointCount - 1) {
                    var h = Jb.clone(c.get(u)),
                    w = h.x,
                    x = h.y,
                    j = w - v.x,
                    k = x - v.y;
                    Math.abs(j) > Math.abs(k) ? (h.x = w, h.y = v.y) : (h.x = v.x, h.y = x),
                    v = h,
                    t.add(v)
                } else t.add(c.get(u));
                c = t
            }
            return c
        }
    }),
    Ib.canvas.GridUI = function(a, b) {
        Ib.canvas.GridUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.GridUI", Ib.canvas.NodeUI, {
        drawDefaultBody: function(a) {
            this._element.getImage() ? Ib.canvas.GridUI.superClass.drawDefaultBody.apply(this, arguments) : this.drawGridBody(a)
        },
        validateBodyBounds: function() {
            if (this._element.getImage()) Ib.canvas.GridUI.superClass.validateBodyBounds.call(this);
            else {
                var a = this.getBodyRect(),
                b = Jb.clone(a);
                this.appendShadowBound(this, b),
                this.addBodyBounds(b)
            }
        },
        drawGridBody: function(a) {
            var b = this.getStyle("grid.fill"),
            c = this.getStyle("grid.deep"),
            d = this.getStyle("grid.cell.deep");
            if (b || 0 !== c || 0 !== d) {
                a.beginPath();
                var e = this._element.getRect(),
                f = this.getDyeColor("grid.fill.color");
                if (this.setShadow(this, a), b && (a.fillStyle = f, a.rect(e.x, e.y, e.width, e.height), a.fill()), a.closePath(), this.clearShadow(a), a.beginPath(), 0 != c && Xb.draw3DRect(a, f, c, e.x, e.y, e.width, e.height), a.closePath(), 0 != d) for (var g = this.getStyle("grid.row.count"), h = this.getStyle("grid.column.count"), i = 0; g > i; i++) for (var j = 0; h > j; j++) {
                    var k = this._element.getCellRect(i, j);
                    null != k && (a.beginPath(), Xb.draw3DRect(a, f, d, k.x, k.y, k.width, k.height), a.closePath())
                }
            }
        }
    }),
    Ib.canvas.RotatableNodeUI = function(a, b) {
        Ib.canvas.RotatableNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.RotatableNodeUI", Ib.canvas.NodeUI, {
        isEditable: function() {
            return ! 1
        },
        getDefaultBodyRect: function() {
            var a = this._element,
            b = Jb.getImageAsset(a.getImage()),
            c = this.getBodyRect();
            return b ? (Tb.addPadding(c, this._element, "image.padding", 1), c) : c
        },
        drawDefaultBody: function(a) {
            var b = this._element,
            c = Jb.getImageAsset(b.getImage()),
            d = this.getBodyRect();
            if (Tb.addPadding(d, this._element, "image.padding", 1), c.getImage()) {
                var e = this._element._getOrignalWidth(),
                f = this._element._getOrignalHeight(),
                g = this._element._getRotateRect();
                a.save(),
                a.translate(d.x - g.x + e / 2, d.y - g.y + f / 2),
                a.rotate(this._element._angle * Math.PI / 180);
                var d = {
                    x: -e / 2,
                    y: -f / 2,
                    width: e,
                    height: f
                };
                Nc(a, c.getImage(this._innerColor, d.width, d.height), this._innerColor, d, b, this._network),
                a.restore()
            } else if (c.getSrc());
            else if (!c.getFunction()) throw "ImageAsset '" + b.getImage() + " ' is empty"
        }
    }),
    Ib.canvas.HTMLNodeUI = function(a, b) {
        Ib.canvas.HTMLNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.HTMLNodeUI", Ib.canvas.NodeUI, {
        checkAttachments: function() {
            Ib.canvas.NodeUI.prototype.checkAttachments.call(this)
        },
        checkLabelAttachment: function() {
            var a = this._element.getStyle("attachment.label.style");
            if (a && "none" === a) return void Ib.canvas.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel(this._element);
            null != b && "" !== b ? this._labelAttachment || (this._labelAttachment = new Ib.canvas.HTMLLabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._element.getStyle("attachment.alarm.style");
            if (a && "none" === a) return void Ib.canvas.HTMLNodeUI.superClass.checkAlarmAttachment.call(this);
            var b = this._network.getAlarmLabel(this._element);
            null != b && "" !== b ? this._alarmAttachment || (this._alarmAttachment = new Ib.canvas.HTMLAlarmAttachment(this, !1), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        },
        setAttachmentVisible: function(a) {
            a ? (this._labelAttachment && this._labelAttachment.setVisibility("visible"), this._alarmAttachment && this._alarmAttachment.setVisibility("visible")) : (this._labelAttachment && this._labelAttachment.setVisibility("hidden"), this._alarmAttachment && this._alarmAttachment.setVisibility("hidden"))
        }
    }),
    Ib.canvas.HTMLLinkUI = function(a, b) {
        Ib.canvas.HTMLLinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.HTMLLinkUI", Ib.canvas.LinkUI, {
        checkAttachments: function() {
            Ib.canvas.LinkUI.prototype.checkAttachments.call(this)
        },
        checkLabelAttachment: function() {
            var a = this._element.getStyle("attachment.label.style");
            if (a && "none" === a) return void Ib.canvas.HTMLLinkUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel(this._element);
            null != b && "" !== b ? this._labelAttachment || (this._labelAttachment = new Ib.canvas.HTMLLabelAttachment(this), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._element.getStyle("attachment.alarm.style");
            if (a && "none" === a) return void Ib.canvas.HTMLLinkUI.superClass.checkAlarmAttachment.call(this);
            var b = this._network.getAlarmLabel(this._element);
            null != b && "" !== b ? this._alarmAttachment || (this._alarmAttachment = new Ib.canvas.HTMLAlarmAttachment(this, !1), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        }
    }),
    Ib.canvas.Attachment = function(a, b) {
        this._ui = a,
        this._element = this._ui.getElement(),
        this._network = a.getNetwork(),
        this._showOnTop = b
    },
    Jb.ext("twaver.canvas.Attachment", Object, {
        getElement: function() {
            return this._element
        },
        getElementUI: function() {
            return this._ui
        },
        getNetwork: function() {
            return this._network
        },
        isShowOnTop: function() {
            return this._showOnTop === !0
        },
        setShowOnTop: function(a) {
            this._showOnTop = a
        },
        getStyle: function(a) {
            return this._ui.getStyle(a)
        },
        getFont: function(a) {
            return this._ui.getFont(a)
        },
        getViewRect: function() {
            return Jb.clone(this._viewRect)
        },
        getAlpha: function() {
            return 1
        },
        validate: function() {},
        paint: function(a) {},
        hit: function(a, b) {
            return Tb.containsPoint(this._viewRect, a, b) ? this.hitCanvasRect({
                x: a - 1,
                y: b - 1,
                width: 2,
                height: 2
            }) : !1
        },
        hitCanvasRect: function(a) {
            var b = Nd.getHitCanvas(a.width, a.height),
            c = Nd.getCtx(b);
            c.save(),
            c.translate( - a.x, -a.y),
            this.paint(c);
            try {
                for (var d = c.getImageData(0, 0, a.width, a.height), e = d.data, f = 0; f < d.width; f++) for (var g = 0; g < d.height; g++) {
                    var h = 4 * (g * d.width + f),
                    i = e[h + 3];
                    if (0 !== i) return c.restore(),
                    !0
                }
            } catch(j) {
                Nd.disposeHitCanvas()
            }
            return c.restore(),
            !1
        },
        dispose: function() {}
    }),
    Ib.canvas.BasicAttachment = function(a, b) {
        Ib.canvas.BasicAttachment.superClass.constructor.call(this, a, b),
        this._roundRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._contentRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    },
    Jb.ext("twaver.canvas.BasicAttachment", Ib.canvas.Attachment, {
        paint: function(a) {
            Ib.canvas.BasicAttachment.superClass.paint.apply(this, arguments);
            var b = this.isFill(),
            c = this.getOutlineWidth();
            if (this.getElementUI().setShadow(this, a), (c > 0 || b) && (Xb.drawRoundRect(a, this._roundRect.x, this._roundRect.y, this._roundRect.width, this._roundRect.height, this.getCornerRadius()), this._pointers && (a.moveTo(this._pointers[0].x, this._pointers[0].y), a.lineTo(this._pointers[1].x, this._pointers[1].y), a.lineTo(this._pointers[2].x, this._pointers[2].y)), a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b)) {
                var d = this.getFillColor(),
                e = this.getGradient();
                e ? Xb.fill(a, d, e, this.getGradientColor(), this._viewRect) : a.fillStyle = d,
                a.fill()
            }
        },
        validate: function() {
            Ib.canvas.BasicAttachment.superClass.validate.call(this),
            this.calculateMeasure();
            var a = this.getOutlineWidth();
            this._viewRect = Tb.getRect(this._pointers),
            this._viewRect = Tb.unionRect(this._viewRect, this._roundRect),
            a > 0 && Tb.grow(this._viewRect, a / 2, a / 2),
            this._viewRect = this._ui.appendShadowBound(this, this._viewRect)
        },
        calculateMeasure: function() {
            var a = this.getContentWidth(),
            b = this.getContentHeight(),
            c = this.getCornerRadius(),
            d = this.getPointerLength(),
            e = this.getPointerWidth(),
            f = this.getPosition(),
            g = this.getXOffset(),
            h = this.getYOffset(),
            i = this._roundRect;
            i.width = a + 2 * c,
            i.height = b;
            var j;
            if (d > 0) {
                var k = this.getDirection();
                if (this._ui._element instanceof Ib.Link) {
                    var l, m = this._ui.getLinkPoints();
                    l = this._ui.getLineLength ? this._ui.getLineLength() : this._ui._element.getLineLength(),
                    Math.abs(g) > 0 && Math.abs(g) < 1 ? "from" === f ? g *= l: "to" === f ? g = l * (1 - g) : (g /= 2, g += .5, g *= l) : "from" === f ? g = g: "to" === f ? g = l - g: g += l / 2;
                    var n, o = Tb.calculatePointInfoAlongLine(m, !0, g, h),
                    p = o.point;
                    o.angle,
                    n = "from" === f ? this._ui.getFromPoint() : "to" === f ? this._ui.getToPoint() : this._ui._hotSpot,
                    g = p.x - n.x,
                    h = p.y - n.y
                }
                j = this._network.getPosition(f, this._ui, null, g, h);
                var q;
                if ("aboveleft" === k) i.y = j.y - d - i.height,
                i.x = j.x - (i.width - c),
                q = Math.max(j.x - e, i.x + c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y - d
                },
                {
                    x: q,
                    y: j.y - d
                }];
                else if ("aboveright" === k) i.y = j.y - d - i.height,
                i.x = j.x - c,
                q = Math.min(j.x + e, i.x + i.width - c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y - d
                },
                {
                    x: q,
                    y: j.y - d
                }];
                else if ("belowleft" === k) i.y = j.y + d,
                i.x = j.x - (i.width - c),
                q = Math.max(j.x - e, i.x + c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y + d
                },
                {
                    x: q,
                    y: j.y + d
                }];
                else if ("belowright" === k) i.y = j.y + d,
                i.x = j.x - c,
                q = Math.min(j.x + e, i.x + i.width - c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y + d
                },
                {
                    x: q,
                    y: j.y + d
                }];
                else if ("leftabove" === k) i.y = j.y + c - i.height,
                i.x = j.x - d - i.width,
                q = Math.max(j.y - e, i.y + c / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y
                },
                {
                    x: j.x - d,
                    y: q
                }];
                else if ("leftbelow" === k) i.y = j.y - c,
                i.x = j.x - d - i.width,
                q = Math.min(j.y + e, i.y + i.height - c / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y
                },
                {
                    x: j.x - d,
                    y: q
                }];
                else if ("rightabove" === k) i.y = j.y + c - i.height,
                i.x = j.x + d,
                q = Math.max(j.y - e, i.y + c / 2),
                this._pointers = [j, {
                    x: j.x + d,
                    y: j.y
                },
                {
                    x: j.x + d,
                    y: q
                }];
                else if ("rightbelow" === k) i.y = j.y - c,
                i.x = j.x + d,
                q = Math.min(j.y + e, i.y + i.height - c / 2),
                this._pointers = [j, {
                    x: j.x + d,
                    y: j.y
                },
                {
                    x: j.x + d,
                    y: q
                }];
                else if ("above" === k) i.y = j.y - d - i.height,
                i.x = j.x - i.width / 2,
                q = Math.min(a / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - q,
                    y: j.y - d
                },
                {
                    x: j.x + q,
                    y: j.y - d
                }];
                else if ("below" === k) i.y = j.y + d,
                i.x = j.x - i.width / 2,
                q = Math.min(a / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - q,
                    y: j.y + d
                },
                {
                    x: j.x + q,
                    y: j.y + d
                }];
                else if ("left" === k) i.y = j.y - i.height / 2,
                i.x = j.x - d - i.width,
                q = Math.min(b / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y + q
                },
                {
                    x: j.x - d,
                    y: j.y - q
                }];
                else {
                    if ("right" !== k) throw "Can not resolve '" + k + "' attachment direction";
                    i.y = j.y - i.height / 2,
                    i.x = j.x + d,
                    q = Math.min(b / 2, e / 2),
                    this._pointers = [j, {
                        x: j.x + d,
                        y: j.y + q
                    },
                    {
                        x: j.x + d,
                        y: j.y - q
                    }]
                }
            } else j = this._network.getPosition(f, this._ui, {
                width: i.width,
                height: i.height
            },
            g, h),
            i.x = j.x,
            i.y = j.y,
            this._pointers = null;
            this._contentRect.x = i.x + (i.width - a) / 2,
            this._contentRect.y = i.y + (i.height - b) / 2,
            this._contentRect.width = a,
            this._contentRect.height = b;
            var r = this.getPadding();
            0 != r && Tb.grow(i, r, r),
            r = this.getPaddingLeft(),
            0 != r && (i.x -= r, i.width += r),
            r = this.getPaddingRight(),
            0 != r && (i.width += r),
            r = this.getPaddingTop(),
            0 != r && (i.y -= r, i.height += r),
            r = this.getPaddingBottom(),
            0 != r && (i.height += r),
            i.width < 0 && (i.width = i.width, i.x -= i.width),
            i.height < 0 && (i.height = -i.height, i.y -= i.height)
        },
        getContentWidth: function() {
            return Ib.Defaults.ATTACHMENT_CONTENT_WIDTH
        },
        getContentHeight: function() {
            return Ib.Defaults.ATTACHMENT_CONTENT_HEIGHT
        },
        getCornerRadius: function() {
            return Ib.Defaults.ATTACHMENT_CORNER_RADIUS
        },
        getPointerLength: function() {
            return Ib.Defaults.ATTACHMENT_POINTER_LENGTH
        },
        getPointerWidth: function() {
            return Ib.Defaults.ATTACHMENT_POINTER_WIDTH
        },
        getPosition: function() {
            return Ib.Defaults.ATTACHMENT_POSITION
        },
        getXOffset: function() {
            return Ib.Defaults.ATTACHMENT_XOFFSET
        },
        getYOffset: function() {
            return Ib.Defaults.ATTACHMENT_YOFFSET
        },
        getPadding: function() {
            return Ib.Defaults.ATTACHMENT_PADDING
        },
        getPaddingLeft: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_LEFT
        },
        getPaddingRight: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_RIGHT
        },
        getPaddingTop: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_TOP
        },
        getPaddingBottom: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_BOTTOM
        },
        getDirection: function() {
            return Ib.Defaults.ATTACHMENT_DIRECTION
        },
        isFill: function() {
            return Ib.Defaults.ATTACHMENT_FILL
        },
        getFillColor: function() {
            return Ib.Defaults.ATTACHMENT_FILL_COLOR
        },
        getGradient: function() {
            return Ib.Defaults.ATTACHMENT_GRADIENT
        },
        getGradientColor: function() {
            return Ib.Defaults.ATTACHMENT_GRADIENT_COLOR
        },
        getOutlineWidth: function() {
            return Ib.Defaults.ATTACHMENT_OUTLINE_WIDTH
        },
        getOutlineColor: function() {
            return Ib.Defaults.ATTACHMENT_OUTLINE_COLOR
        },
        getCap: function() {
            return Ib.Defaults.ATTACHMENT_CAP
        },
        getJoin: function() {
            return Ib.Defaults.ATTACHMENT_JOIN
        },
        isShadowable: function() {
            return Ib.Defaults.ATTACHMENT_SHADOWABLE
        },
        getRoundRect: function() {
            return Jb.clone(this._roundRect)
        },
        getContentRect: function() {
            return Jb.clone(this._contentRect)
        }
    }),
    Ib.canvas.LabelAttachment = function(a, b) {
        Ib.canvas.LabelAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.LabelAttachment", Ib.canvas.BasicAttachment, {
        paint: function(a) {
            var b = this._element instanceof Ib.Link && this._element.getStyle("link.label.rotatable");
            if (b) {
                a.save();
                var c = this._viewRect.x + this._viewRect.width / 2,
                d = this._viewRect.y + this._viewRect.height / 2;
                a.translate(c, d),
                a.rotate(this._network.getElementUI(this._element).getAngle()),
                a.translate( - c, -d)
            }
            Ib.canvas.LabelAttachment.superClass.paint.apply(this, arguments);
            var e = this._element.getStyle("label.align");
            Xb.drawText(a, this.text, this._contentRect, this.font, this.getStyle("label.color"), e),
            b && a.restore()
        },
        validate: function() {
            this.font = this.getFont("label.font"),
            this.text = this.getLabel(),
            this._textSize = Xb.getTextSize(this.font, this.text),
            Ib.canvas.LabelAttachment.superClass.validate.call(this)
        },
        getLabel: function() {
            return this._network.getLabel(this._element)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("label.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("label.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("label.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("label.position")
        },
        getXOffset: function() {
            return this.getStyle("label.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("label.yoffset")
        },
        getPadding: function() {
            return this.getStyle("label.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("label.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("label.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("label.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("label.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("label.direction")
        },
        isFill: function() {
            return this.getStyle("label.fill")
        },
        getFillColor: function() {
            return this.getStyle("label.fill.color")
        },
        getGradient: function() {
            return this.getStyle("label.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("label.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("label.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("label.outline.color")
        },
        getCap: function() {
            return this.getStyle("label.cap")
        },
        getJoin: function() {
            return this.getStyle("label.join")
        },
        getAlpha: function() {
            return this.getStyle("label.alpha")
        },
        isShadowable: function() {
            return this.getStyle("label.shadowable")
        }
    }),
    Ib.canvas.AlarmAttachment = function(a, b) {
        Ib.canvas.AlarmAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.AlarmAttachment", Ib.canvas.BasicAttachment, {
        paint: function(a) {
            Ib.canvas.AlarmAttachment.superClass.paint.apply(this, arguments),
            Xb.drawText(a, this.text, this._contentRect, this.font, this.getStyle("alarm.color"))
        },
        validate: function() {
            this.font = this.getFont("alarm.font"),
            this.text = this._network.getAlarmLabel(this._element),
            this._textSize = Xb.getTextSize(this.font, this.text),
            this._fillColor = this._network.getAlarmFillColor(this._element),
            Ib.canvas.LabelAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("alarm.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("alarm.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("alarm.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("alarm.position")
        },
        getXOffset: function() {
            return this.getStyle("alarm.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("alarm.yoffset")
        },
        getPadding: function() {
            return this.getStyle("alarm.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("alarm.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("alarm.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("alarm.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("alarm.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("alarm.direction")
        },
        isFill: function() {
            return null != this._fillColor
        },
        getFillColor: function() {
            return this._fillColor
        },
        getGradient: function() {
            return this.getStyle("alarm.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("alarm.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("alarm.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("alarm.outline.color")
        },
        getCap: function() {
            return this.getStyle("alarm.cap")
        },
        getJoin: function() {
            return this.getStyle("alarm.join")
        },
        getAlpha: function() {
            return this.getStyle("alarm.alpha")
        },
        isShadowable: function() {
            return this.getStyle("alarm.shadowable")
        }
    }),
    Ib.canvas.LinkHandlerAttachment = function(a, b) {
        Ib.canvas.LinkHandlerAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.LinkHandlerAttachment", Ib.canvas.BasicAttachment, {
        paint: function(a) {
            Ib.canvas.LinkHandlerAttachment.superClass.paint.apply(this, arguments),
            Xb.drawText(a, this.linkHandlerLabel, this._contentRect, this.linkHandlerFont, this.getStyle("link.handler.color"))
        },
        validate: function() {
            this.linkHandlerFont = this.getFont("link.handler.font"),
            this.linkHandlerLabel = this._network.getLinkHandlerLabel(this._element),
            this._textSize = Xb.getTextSize(this.linkHandlerFont, this.linkHandlerLabel),
            Ib.canvas.LinkHandlerAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("link.handler.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("link.handler.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("link.handler.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("link.handler.position")
        },
        getXOffset: function() {
            return this.getStyle("link.handler.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("link.handler.yoffset")
        },
        getPadding: function() {
            return this.getStyle("link.handler.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("link.handler.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("link.handler.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("link.handler.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("link.handler.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("link.handler.direction")
        },
        isFill: function() {
            return this.getStyle("link.handler.fill")
        },
        getFillColor: function() {
            return this.getStyle("link.handler.fill.color")
        },
        getGradient: function() {
            return this.getStyle("link.handler.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("link.handler.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("link.handler.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("link.handler.outline.color")
        },
        getCap: function() {
            return this.getStyle("link.handler.cap")
        },
        getJoin: function() {
            return this.getStyle("link.handler.join")
        },
        getAlpha: function() {
            return this.getStyle("link.handler.alpha")
        },
        isShadowable: function() {
            return this.getStyle("link.handler.shadowable")
        }
    }),
    Ib.canvas.IconsAttachment = function(a, b) {
        Ib.canvas.IconsAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.IconsAttachment", Ib.canvas.Attachment, {
        isShadowable: function() {
            return Ib.Defaults.ATTACHMENT_SHADOWABLE
        },
        validate: function() {
            if (Ib.canvas.IconsAttachment.superClass.validate.call(this), this.iconsNames = this._network.getIconsNames(this._element), this.iconsNames && 0 != this.iconsNames.length) {
                var a = this._makeGroup(this.iconsNames),
                b = this._makeGroup(this._network.getIconsColors(this._element));
                len = a.length,
                this.iconsOrientation = this._makeArray(this._element.getStyle("icons.orientation"), len, "right"),
                this.iconsPosition = this._makeArray(this._element.getStyle("icons.position"), len, "topleft.bottomright"),
                this.iconsXoffset = this._makeArray(this._element.getStyle("icons.xoffset"), len, 0),
                this.iconsYoffset = this._makeArray(this._element.getStyle("icons.yoffset"), len, 0),
                this.iconsXgap = this._makeArray(this._element.getStyle("icons.xgap"), len, 1),
                this.iconsYgap = this._makeArray(this._element.getStyle("icons.ygap"), len, 1),
                this.locations = [],
                this.iconsSizes = [];
                var c, d;
                for (i = 0; i < len; i++) {
                    var e = a[i],
                    f = this.iconsOrientation[i] || "right",
                    g = this.iconsPosition[i] || "topleft.bottomright",
                    h = this.iconsXgap[i] || 1,
                    j = this.iconsYgap[i] || 1,
                    k = this.iconsXoffset[i] || 0,
                    l = this.iconsYoffset[i] || 0;
                    if (this._ui._element instanceof Ib.Link) {
                        var m, n = this._ui.getLinkPoints();
                        m = this._ui.getLineLength ? this._ui.getLineLength() : this._ui._element.getLineLength(),
                        Math.abs(k) > 0 && Math.abs(k) < 1 ? "from" === g ? k *= m: "to" === g ? k = m * (1 - k) : (k /= 2, k += .5, k *= m) : "from" === g ? k = k: "to" === g ? k = m - k: k += m / 2;
                        var o, p = Tb.calculatePointInfoAlongLine(n, !0, k, l),
                        q = p.point;
                        p.angle,
                        o = "from" === g ? this._ui.getFromPoint() : "to" === g ? this._ui.getToPoint() : this._ui._hotSpot,
                        k = q.x - o.x,
                        l = q.y - o.y
                    }
                    d = null,
                    c = this._getIconsSize(e, f, h, j),
                    c && (d = this._network.getPosition(g, this._ui, c, k, l), "top" === f ? d.y += c.height: "left" === f && (d.x += c.width)),
                    this.locations.push(d),
                    this.iconsSizes.push(c)
                }
                var r = null;
                for (i = 0; i < this.locations.length; i++) d = this.locations[i],
                c = this.iconsSizes[i],
                null != d && (r = null == r ? {
                    x: d.x,
                    y: d.y,
                    width: c.width,
                    height: c.height
                }: Tb.unionRect(r, {
                    x: d.x,
                    y: d.y,
                    width: c.width,
                    height: c.height
                }));
                this._viewRect = r || {
                    x: this._element.getLocation().x,
                    y: this._element.getLocation().y,
                    width: 0,
                    height: 0
                },
                this.iconsGroups = a,
                this.colorGroups = b;
                var s = this._element instanceof Ib.Link && this._element.getStyle("link.icons.rotatable");
                for (i = 0; i < len; i++) if (s instanceof Array && s[i] && this._viewRect) {
                    var t = this._viewRect.x + this._viewRect.width / 2,
                    u = this._viewRect.y + this._viewRect.height / 2,
                    v = Math.sqrt(this._viewRect.height * this._viewRect.height + this._viewRect.width * this._viewRect.width);
                    this._viewRect = {
                        x: t - v / 2,
                        y: u - v / 2,
                        width: v,
                        height: v
                    }
                }
            }
        },
        _makeGroup: function(a) {
            if (!Array.isArray(a)) return [[a]];
            var b, c, d, e = [],
            f = !1,
            g = a.length;
            for (b = 0; g > b; b++) c = a[b],
            Array.isArray(c) ? (f = !0, e.push(c)) : (d = [c], e.push(d));
            return f || (e.length = 0, e.push(a)),
            e
        },
        _makeArray: function(a, b, c) {
            if (Array.isArray(a)) return a;
            for (var d = [], e = 0; b > e; e++) d.push(a || c);
            return d
        },
        paint: function(a) {
            if (Ib.canvas.IconsAttachment.superClass.paint.apply(this, arguments), this.iconsNames && 0 != this.iconsNames.length && this.locations) {
                var b, c, d, e, f, g, h, i, j, k;
                for (b = 0; b < this.iconsGroups.length; b++) if (c = this.locations[b]) {
                    f = c.x,
                    g = c.y,
                    e = this.iconsGroups[b],
                    h = this.colorGroups[b],
                    i = this.iconsOrientation[b],
                    j = this.iconsXgap[b] || 1,
                    k = this.iconsYgap[b] || 1,
                    d = 0;
                    for (var l in e) {
                        var m = null,
                        n = null;
                        h && h.length > d && (n = h[d++]);
                        var o = Jb.getImageAsset(e[l]);
                        if (null != o) {
                            if ("right" === i) m = {
                                x: f,
                                y: g,
                                width: o.getWidth(),
                                height: o.getHeight()
                            },
                            f += m.width + j;
                            else if ("left" === i) m = {
                                x: f - o.getWidth(),
                                y: g,
                                width: o.getWidth(),
                                height: o.getHeight()
                            },
                            f -= m.width + j;
                            else if ("top" === i) m = {
                                x: f,
                                y: g - o.getHeight(),
                                width: o.getWidth(),
                                height: o.getHeight()
                            },
                            g -= m.height + k;
                            else {
                                if ("bottom" !== i) throw "Can not resolve '" + i + "' orientation";
                                m = {
                                    x: f,
                                    y: g,
                                    width: o.getWidth(),
                                    height: o.getHeight()
                                },
                                g += m.height + k
                            }
                            var p = this._element instanceof Ib.Link && this._element.getStyle("link.icons.rotatable");
                            if (p instanceof Array && p[b]) {
                                a.save();
                                var q = m,
                                f = q.x + q.width / 2,
                                g = q.y + q.height / 2;
                                a.translate(f, g),
                                a.rotate(this._network.getElementUI(this._element).getAngle()),
                                a.translate( - f, -g),
                                Nc(a, o.getImage(n, m.width, m.height), n, m, this._element, this._network),
                                a.restore()
                            } else Nc(a, o.getImage(n, m.width, m.height), n, m, this._element, this._network);
                            if (this._network._debug) {
                                var m = this._viewRect;
                                Xb.strokeRect(a, m, "#FCFC00", 1),
                                Xb.strokeRect(a, m, "#FCFC00", 1)
                            }
                        }
                    }
                }
            }
        },
        _getIconsSize: function(a, b, c, d) {
            var e = 0,
            f = 0,
            g = null,
            h = null,
            i = null;
            for (var j in a) if (h = Jb.getImageAsset(a[j])) {
                if ("right" === b) g = {
                    x: e,
                    y: f,
                    width: h.getWidth(),
                    height: h.getHeight()
                },
                e += g.width + c;
                else if ("left" === b) g = {
                    x: e - h.getWidth(),
                    y: f,
                    width: h.getWidth(),
                    height: h.getHeight()
                },
                e -= g.width + c;
                else if ("top" === b) g = {
                    x: e,
                    y: f - h.getHeight(),
                    width: h.getWidth(),
                    height: h.getHeight()
                },
                f -= g.height + d;
                else {
                    if ("bottom" !== b) throw "Can not resolve '" + b + "' orientation";
                    g = {
                        x: e,
                        y: f,
                        width: h.getWidth(),
                        height: h.getHeight()
                    },
                    f += g.height + d
                }
                i = null == i ? Jb.clone(g) : Tb.unionRect(i, g)
            }
            return i ? {
                width: Math.abs(i.width),
                height: Math.abs(i.height)
            }: null
        }
    }),
    Ib.canvas.EditAttachment = function(a, b) {
        Ib.canvas.EditAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.canvas.EditAttachment", Ib.canvas.Attachment, {
        paint: function(a) {
            Ib.canvas.EditAttachment.superClass.paint.apply(this, arguments),
            this._viewRect = null,
            this.paintResizingPoints(a),
            this.paintEditPoints(a),
            this.paintRotatePoints(a)
        },
        paintResizingPoints: function(a) {
            var b = this.resizingPoints.size();
            if (! (0 >= b)) {
                var c = 2 * this.resizePointSize,
                d = 2 * this.resizePointSize,
                e = this._network.getResizePointFillColor(),
                f = this._network.getResizePointOutlineWidth(),
                g = this._network.getResizePointOutlineColor(),
                h = this._element.getAngle(),
                i = this._element.getOriginalRect();
                a.lineWidth = f;
                for (var j = 0; b > j; j++) {
                    var k = this.resizingPoints.get(j),
                    l = {
                        x: k.x - this.resizePointSize,
                        y: k.y - this.resizePointSize,
                        width: 2 * this.resizePointSize,
                        height: 2 * this.resizePointSize
                    },
                    m = this._getRotateRect(l, h, {
                        x: i.x + i.width / 2,
                        y: i.y + i.height / 2
                    });
                    a.save(),
                    Ib.Util.rotateCanvas(a, m, h),
                    Nd.rect(a, m.x, m.y, c, d),
                    a.restore()
                }
                a.fillStyle = e,
                a.strokeStyle = g,
                a.fill(),
                a.stroke()
            }
        },
        paintEditPoints: function(a) {
            var b = this.editPoints.size();
            if (! (0 >= b)) {
                var c = this._network.getEditPointOutlineColor(),
                d = this._network.getEditPointFillColor(),
                e = this._network.getEditPointOutlineWidth();
                a.beginPath(),
                a.lineWidth = e;
                for (var f = 0; b > f; f++) {
                    var g = this.editPoints.get(f);
                    a.beginPath(),
                    Nd.circle(a, g.x, g.y, this.editPointSize, d, c),
                    a.closePath()
                }
            }
        },
        paintRotatePoints: function(a) {
            var b = this.rotatePoints.size();
            if (! (0 >= b)) {
                var c = this._network.getRotatePointOutlineColor(),
                d = this._network.getRotatePointFillColor(),
                e = this._network.getRotatePointOutlineWidth();
                a.beginPath(),
                a.lineWidth = e;
                for (var f = 0; b > f; f++) {
                    var g = this.rotatePoints.get(f);
                    a.beginPath(),
                    Nd.circle(a, g.x, g.y, this.rotatePointSize, d, c),
                    a.closePath()
                }
            }
        },
        validate: function() {
            Ib.canvas.EditAttachment.superClass.validate.call(this),
            this.editPointSize = this._network.getEditPointSize(),
            this.resizePointSize = this._network.getResizePointSize(),
            this.rotatePointSize = this._network.getRotatePointSize(),
            this.resizingPoints = new Ib.List,
            this.editPoints = new Ib.List,
            this.rotatePoints = new Ib.List,
            this._element instanceof Ib.Node && this._addResizingPoint(this._element),
            !(this._network.isRotatable(this._element) && this._element instanceof Kd) || this._element instanceof Ib.ShapeNode || this._element instanceof Ib.Grid || this._element instanceof Ib.Group || this._addRotatePoint(this._element),
            this._element instanceof Ib.ShapeNode && (this._addResizingPoint(this._element), this._addShapeNodePoint(this._element)),
            this._ui instanceof Ib.canvas.ShapeLinkUI && this._addShapeLinkPoints(this._element),
            this._ui instanceof Ib.canvas.LinkUI && this._addLinkControlPoint(this._ui)
        },
        _addResizingPoint: function(a) {
            var b = a.getOriginalRect();
            if (b) {
                var c = this._network.getResizePointSize();
                if (! (0 >= c)) {
                    var d = new nd([{
                        x: b.x,
                        y: b.y
                    },
                    {
                        x: b.x + b.width / 2,
                        y: b.y
                    },
                    {
                        x: b.x + b.width,
                        y: b.y
                    },
                    {
                        x: b.x,
                        y: b.y + b.height / 2
                    },
                    {
                        x: b.x + b.width,
                        y: b.y + b.height / 2
                    },
                    {
                        x: b.x,
                        y: b.y + b.height
                    },
                    {
                        x: b.x + b.width / 2,
                        y: b.y + b.height
                    },
                    {
                        x: b.x + b.width,
                        y: b.y + b.height
                    }]),
                    e = this._network.getResizePointOutlineWidth(),
                    f = this._network.getResizePointOutlineColor(),
                    g = this._network.getResizePointFillColor();
                    this._addPoints(a.getRect(), d, e, f, g, !0)
                }
            }
        },
        _addRotatePoint: function(a) {
            var b = a.getOriginalRect();
            if (b) {
                var c = this._network.getRotatePointSize();
                if (! (0 >= c)) {
                    var d = 2 * c,
                    e = new Ib.List([{
                        x: b.x + b.width / 2,
                        y: b.y - this._network.getRotatePointOffset() - d / 2
                    }]),
                    f = a.getAngle();
                    0 != f && (e = this._rotatePointList(e, f, a.getOriginalRect()));
                    var g = e.get(0),
                    h = {
                        x: g.x - d / 2,
                        y: g.y - d / 2,
                        width: d,
                        height: d
                    },
                    i = this._network.getRotatePointOutlineWidth(),
                    j = this.rotatePointSize + i;
                    Tb.grow(b, j, j);
                    var k = Tb.unionRect(a.getRect(), h);
                    this._viewRect = Tb.unionRect(k, this._viewRect),
                    this.rotatePoints = e
                }
            }
        },
        _addShapeNodePoint: function(a) {
            this._addEditPoints(a.getPoints())
        },
        _addShapeLinkPoints: function(a) {
            this._addEditPoints(a.getPoints())
        },
        _addLinkControlPoint: function(a) {
            if (xc.isOrthogonalLink(a._element)) {
                var b = a.getControlPoint();
                if (b) {
                    var c = new Ib.List;
                    c.add(b),
                    this._addEditPoints(c)
                }
            }
        },
        _addEditPoints: function(a) {
            var b = Tb.getRect(a);
            if (b) {
                var c = this._network.getEditPointSize();
                if (! (0 >= c)) {
                    var d = this._network.getEditPointOutlineWidth();
                    this._addPoints(b, a, d, !1)
                }
            }
        },
        _addPoints: function(a, b, c, d, e, f) {
            var g = f ? this._network.getResizePointSize() : this._network.getEditPointSize();
            if (! (0 > g)) {
                var h = g + c;
                Tb.grow(a, h, h),
                this._viewRect = Tb.unionRect(a, this._viewRect),
                1 == f ? this.resizingPoints = b: this.editPoints = b
            }
        },
        _rotatePoint: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x + c.width / 2, c.y + c.height / 2),
            e = d.transform(a);
            return e
        },
        _rotatePointList: function(a, b, c) {
            var d = this,
            e = new Ib.List;
            return a.forEach(function(a) {
                e.add(d._rotatePoint(a, b, c))
            }),
            e
        },
        _getRotateRect: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x, c.y),
            e = {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            },
            f = d.transform(e),
            g = new Ib.List([{
                x: f.x - a.width / 2,
                y: f.y - a.height / 2
            },
            {
                x: f.x + a.width / 2,
                y: f.y - a.height / 2
            },
            {
                x: f.x + a.width / 2,
                y: f.y + a.height / 2
            },
            {
                x: f.x - a.width / 2,
                y: f.y + a.height / 2
            }]);
            return Tb.getRect(g)
        }
    }),
    Ib.canvas.HTMLLabelAttachment = function(a, b) {
        Ib.canvas.HTMLLabelAttachment.superClass.constructor.call(this, a, b),
        this._triangleDiv = Ib.Util.createDiv(),
        this._roundDiv = Ib.Util.createDiv(),
        this._contentDiv = Ib.Util.createDiv();
        var c = this._element.getStyle("attachment.htmllabel.hyperlink");
        c ? (Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "auto"), Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "auto")) : (Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "none"), Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "none")),
        Ib.Util.setCSSStyle(this._triangleDiv, "border-style", "solid"),
        Ib.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap"),
        this._network.getView().appendChild(this._roundDiv),
        this._roundDiv.appendChild(this._contentDiv)
    },
    Jb.ext("twaver.canvas.HTMLLabelAttachment", Ib.canvas.LabelAttachment, {
        validate: function() {
            var a = (this.getFont("label.font"), this.getLabel());
            this._contentDiv.innerHTML = a,
            this._contentDiv.style.visibility = "hidden",
            Ib.canvas.HTMLLabelAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._contentDiv.scrollWidth || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "width"))
        },
        getContentHeight: function() {
            return this._contentDiv.scrollHeight || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "height"))
        },
        paint: function(a) {
            var b = this.isFill(),
            c = this.getOutlineWidth(),
            d = this._contentRect;
            if (this.getElementUI().setShadow(this, a), c > 0 || b) {
                if (Xb.drawRoundRect(a, d.x, d.y, d.width, d.height, this.getCornerRadius()), this._pointers) {
                    var e = this._pointers;
                    a.moveTo(e[0].x, e[0].y),
                    a.lineTo(e[1].x, e[1].y),
                    a.lineTo(e[2].x, e[2].y)
                }
                if (a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b) {
                    var f = this.getFillColor(),
                    g = this.getGradient();
                    g ? Xb.fill(a, f, g, this.getGradientColor(), this._viewRect) : a.fillStyle = f,
                    a.fill()
                }
            }
            var h = (this.getFont("label.font"), this.getLabel(), this._network.getViewRect().x),
            i = this._network.getViewRect().y,
            j = this._network.getZoom(),
            k = {
                x: this._contentRect.x + this._contentRect.width / 2,
                y: this._contentRect.y + this._contentRect.height / 2
            },
            l = k.x * j - h - this._contentDiv.offsetWidth / 2 * j + "px",
            m = k.y * j - i - this._contentDiv.offsetHeight / 2 * j + "px";
            this._contentDiv.style.left = l,
            this._contentDiv.style.top = m,
            this._contentDiv.style.setProperty("-webkit-transform", "scale(" + j + ")", null),
            this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null),
            this._network._debug && Xb.strokeRect(a, this._contentRect, "#AAAAAA")
        },
        setVisibility: function(a) {
            this._contentDiv.style.visibility = a
        },
        dispose: function() {
            this._network.getView().removeChild(this._roundDiv)
        },
        getView: function() {
            return this._roundDiv
        }
    }),
    Ib.canvas.HTMLAlarmAttachment = function(a, b) {
        Ib.canvas.HTMLAlarmAttachment.superClass.constructor.call(this, a, b),
        this._triangleDiv = Ib.Util.createDiv(),
        this._roundDiv = Ib.Util.createDiv(),
        this._contentDiv = Ib.Util.createDiv(),
        Ib.Util.setCSSStyle(this._triangleDiv, "border-style", "solid"),
        Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "none"),
        Ib.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap"),
        Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "none"),
        this._network.getView().appendChild(this._roundDiv),
        this._roundDiv.appendChild(this._contentDiv)
    },
    Jb.ext("twaver.canvas.HTMLAlarmAttachment", Ib.canvas.AlarmAttachment, {
        validate: function() {
            var a = (this.getFont("alarm.font"), this._network.getAlarmLabel(this._element));
            this._contentDiv.innerHTML = a,
            this._contentDiv.style.visibility = "hidden",
            Ib.canvas.HTMLAlarmAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._contentDiv.scrollWidth || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "width"))
        },
        getContentHeight: function() {
            return this._contentDiv.scrollHeight || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "height"))
        },
        paint: function(a) {
            var b = this.isFill(),
            c = this.getOutlineWidth(),
            d = this._contentRect;
            if (this.getElementUI().setShadow(this, a), c > 0 || b) {
                if (Xb.drawRoundRect(a, d.x, d.y, d.width, d.height, this.getCornerRadius()), this._pointers) {
                    var e = this._pointers;
                    a.moveTo(e[0].x, e[0].y),
                    a.lineTo(e[1].x, e[1].y),
                    a.lineTo(e[2].x, e[2].y)
                }
                if (a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b) {
                    var f = this.getFillColor(),
                    g = this.getGradient();
                    g ? Xb.fill(a, f, g, this.getGradientColor(), this._viewRect) : a.fillStyle = f,
                    a.fill()
                }
            }
            var h = (this.getFont("alarm.font"), this._network.getAlarmLabel(this._element), this._network.getViewRect().x),
            i = this._network.getViewRect().y,
            j = this._network.getZoom(),
            k = {
                x: this._contentRect.x + this._contentRect.width / 2,
                y: this._contentRect.y + this._contentRect.height / 2
            },
            l = k.x * j - h - this._contentDiv.offsetWidth / 2 * j + "px",
            m = k.y * j - i - this._contentDiv.offsetHeight / 2 * j + "px";
            this._contentDiv.style.left = l,
            this._contentDiv.style.top = m,
            this._contentDiv.style.setProperty("-webkit-transform", "scale(" + j + ")", null),
            this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null),
            this._network._debug && Xb.strokeRect(a, this._contentRect, "#AAAAAB"),
            Ib.canvas.AlarmAttachment.superClass.paint.apply(this, arguments)
        },
        setVisibility: function(a) {
            this._contentDiv.style.visibility = a
        },
        dispose: function() {
            this._network.getView().removeChild(this._roundDiv)
        },
        getView: function() {
            return this._roundDiv
        }
    }),
    Ib.canvas.interaction.BaseInteraction = function(a) {
        this.network = a
    },
    Jb.ext("twaver.canvas.interaction.BaseInteraction", Object, {
        setUp: function() {},
        tearDown: function() {},
        repaint: function() {
            this.network.repaintTopCanvas()
        },
        convertPointFromView: function(a) {
            var b = a.x * this.network.getZoom() - this.network.getViewRect().x,
            c = a.y * this.network.getZoom() - this.network.getViewRect().y;
            return {
                x: b,
                y: c
            }
        },
        convertFromUIToMarkerRect: function(a, b, c) {
            var d = this.network.getZoom();
            return {
                x: a.x * d - this.network.getViewRect().x + b * d,
                y: a.y * d - this.network.getViewRect().y + c * d,
                width: a.width * d,
                height: a.height * d
            }
        },
        getMarkerPoint: function(a) {
            var b;
            if (Qb.isTouchable && a.changedTouches && a.changedTouches.length > 0) {
                var c = a.changedTouches[0];
                return b = {
                    x: c.clientX,
                    y: c.clientY
                }
            }
            return b = Qb.isFirefox ? {
                x: a.layerX,
                y: a.layerY
            }: {
                x: a.offsetX,
                y: a.offsetY
            }
        },
        paint: function(a) {},
        addListener: function() {
            for (var a = 0; a < arguments.length; a++) {
                var b = arguments[a];
                Wb.addEventListener(b, "handle_" + b, this.network.getView(), this)
            }
        },
        removeListener: function() {
            for (var a = 0; a < arguments.length; a++) Wb.removeEventListener(arguments[a], this.network.getView(), this)
        },
        _handle_mousedown: function(a) {
            0 === a.button && (this._startLogical = this.network.getLogicalPoint(a), this._startClient = Wb.getClientPoint(a), this._startLogical && Wb.handle_mousedown(this, a))
        },
        _handle_mousemove: function(a) {
            this._endLogical = {
                x: this._startLogical.x + (a.clientX - this._startClient.x) / this.network.getZoom(),
                y: this._startLogical.y + (a.clientY - this._startClient.y) / this.network.getZoom()
            }
        },
        _handle_mouseup: function(a) {
            delete this._startClient,
            delete this._startLogical,
            delete this._endLogical
        }
    }),
    Ib.canvas.interaction.SelectInteraction = function(a) {
        Ib.canvas.interaction.SelectInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.SelectInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseup"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseup"),
            this.end(),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            if (null != this.startPoint && null != this.endPoint) {
                var b = this.convertPointFromView(this.startPoint),
                c = this.convertPointFromView(this.endPoint),
                d = b.x,
                e = b.y,
                f = c.x,
                g = c.y,
                h = Tb.getRect([{
                    x: d,
                    y: e
                },
                {
                    x: f,
                    y: g
                }]);
                if (null != h) {
                    a.beginPath();
                    var i = this.network.getSelectOutlineWidth(),
                    j = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
                    a.strokeStyle = this.network.getSelectOutlineColor(),
                    a.lineWidth = i,
                    Nd.rect(a, h.x, h.y, h.width, h.height, j, this.network.getSelectOutlineColor()),
                    a.closePath()
                }
            }
        },
        handle_mousedown: function(a) {
            if (this.network.isValidEvent(a) && !this.network.isMovingElement() && !this.network.isEditingElement() && !a.shiftKey) {
                var b = this.network.getElementAt(a),
                c = this.network.getSelectionModel();
                b ? Jb.isCtrlDown(a) ? c.contains(b) ? c.removeSelection(b) : c.appendSelection(b) : c.contains(b) || c.setSelection(b) : (Jb.isCtrlDown(a) || c.clearSelection(), this.end(a), this.startPoint = this.network.getLogicalPoint(a), this.startPoint && this.network.isRectSelectEnabled() && this.addListener("mousemove"))
            }
        },
        handle_mouseup: function(a) {
            this.end(a)
        },
        handle_mousemove: function(a) {
            if (this.network.isMovingElement() || this.network.isEditingElement()) return void this.end(a);
            var b = this.network.getLogicalPoint(a);
            b && (this.network.setSelectingElement(!0), this.network.fireInteractionEvent(null == this.endPoint ? {
                kind: "selectStart",
                event: a
            }: {
                kind: "selectBetween",
                event: a
            }), this.endPoint = b, this.repaint())
        },
        end: function(a) {
            if (this.startPoint) {
                if (this.endPoint && this.startPoint.x !== this.endPoint.x && this.startPoint.y !== this.endPoint.y) {
                    var b = Tb.getRect([this.startPoint, this.endPoint]),
                    c = this.network.getElementsAtRect(b, this.getIntersectMode(), this.network.getRectSelectFilter());
                    if (c && c.size() > 0) {
                        var d = this.network.getSelectionModel(),
                        e = d.toSelection();
                        c.forEach(function(a) {
                            d.contains(a) ? e.remove(a) : e.add(a)
                        },
                        this),
                        d.setSelection(e)
                    }
                    this.network.fireInteractionEvent({
                        kind: "selectEnd",
                        event: a
                    })
                }
                this.network.setSelectingElement(!1),
                this.removeListener("mousemove"),
                this.startPoint = null,
                this.endPoint = null,
                this.repaint()
            }
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this.startPoint.x > this.endPoint.x && this.startPoint.y > this.endPoint.y
        }
    }),
    Ib.canvas.interaction.MoveInteraction = function(a, b) {
        this.lazyMode = b,
        Ib.canvas.interaction.MoveInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.MoveInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseup", "keydown", "mouseout"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseup", "keydown", "mouseout"),
            this.end(),
            this.network.removeMarker(this)
        },
        handle_keydown: function(a) {
            this.currentKeyEvent = a,
            this.addListener("keyup")
        },
        handle_keyup: function(a) {
            this.currentKeyEvent = null,
            this.removeListener("keyup")
        },
        isParenting: function() {
            return this.pressPoint && null != this.currentKeyEvent && 80 === this.currentKeyEvent.keyCode
        },
        parentProcess: function(a, b) {
            var c = null;
            this.parent = null;
            var d = this;
            if (!b && this.isParenting()) {
                var e = {},
                f = this.network.getLogicalPoint(a);
                e.x = f.x - 1,
                e.y = f.y - 1,
                e.width = 2,
                e.height = 2;
                var g = this.network.getElementsAtRect(e, !0);
                if (g && g.size() > 0) for (var h = g.size(), i = 0; h > i; i++) {
                    var j = g.get(i);
                    if (!d.network.getElementBox().getSelectionModel().contains(j)) {
                        d.parent = j;
                        break
                    }
                }
            } else this.parent = null;
            null != this.parent && (c = this.network.getElementUI(this.parent).getViewRect()),
            this.parentRect = null == c || b ? null: c
        },
        paint: function(a) {
            if (this.lazyMode) {
                if (null == this.pressPoint || null == this.dragPoint) return;
                a.beginPath();
                var b = this.dragPoint.x - this.pressPoint.x,
                c = this.dragPoint.y - this.pressPoint.y,
                d = this.network.getMovableSelectedElements(),
                e = d.size(),
                f = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null,
                g = this.network.getLazyMoveOutlineWidth(),
                h = this.network.getLazyMoveOutlineColor();
                a.strokeStyle = h,
                a.lineWidth = g,
                a.fillStyle = f;
                for (var i = 0; e > i; i++) {
                    var j = d.get(i),
                    k = this.network.getElementUI(j);
                    if (k) {
                        var l = this.convertFromUIToMarkerRect(k.getViewRect(), b, c);
                        Nd.rect(a, l.x, l.y, l.width, l.height)
                    }
                }
                a.fill(),
                a.stroke()
            }
            if (this.parentRect) {
                a.beginPath();
                var f = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null,
                g = this.network.getLazyMoveOutlineWidth(),
                h = this.network.getLazyMoveOutlineColor();
                a.strokeStyle = h,
                a.lineWidth = g,
                a.fillStyle = f;
                var l = this.parentRect;
                Nd.rect(a, l.x, l.y, l.width, l.height),
                a.fill(),
                a.stroke()
            }
        },
        handle_mousedown: function(a) {
            if (0 === a.button && this.network.isValidEvent(a) && !this.network.isSelectingElement() && !this.network.isEditingElement()) {
                var b = this.network.getElementAt(a);
                this.network.isMovable(b) && (this.end(a), this.lastPoint = this.network.getLogicalPoint(a), this.lazyMode && (this.pressPoint = this.lastPoint), this.lastPoint && this.addListener("mousemove"))
            }
        },
        handle_mouseup: function(a) {
            this.end(a)
        },
        handle_mouseout: function(a) {
            this.end(a)
        },
        handle_mousemove: function(a) {
            if (this.network.isSelectingElement() || this.network.isEditingElement() || !this.network.hasMovableSelectedElements()) return void this.end(a);
            var b = this.network.getLogicalPoint(a);
            b && this.lastPoint && (this.xoffset = b.x - this.lastPoint.x, this.yoffset = b.y - this.lastPoint.y, Math.abs(this.xoffset) < 1 && Math.abs(this.yoffset) < 1 || (this.lazyMode ? null == this.dragPoint ? (this.network.fireInteractionEvent({
                kind: "lazyMoveStart",
                event: a
            }), this.network.setMovingElement(!0)) : this.network.fireInteractionEvent({
                kind: "lazyMoveBetween",
                event: a
            }) : (this.lastPoint = b, this.network.isMovingElement() ? this.network.fireInteractionEvent({
                kind: "liveMoveBetween",
                event: a
            }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                kind: "liveMoveStart",
                event: a
            })), this.network.moveSelectedElements(this.xoffset, this.yoffset)), this.parentProcess(a, !1), this.lazyMode && (this.dragPoint = b), (this.lazyMode || this.isParenting()) && this.repaint()))
        },
        end: function(a) {
            if (this.lazyMode) {
                if (null != this.dragPoint && null != this.pressPoint) {
                    var b = this,
                    c = function() {
                        b.network.fireInteractionEvent({
                            kind: "lazyMoveEnd",
                            event: a
                        }),
                        b.network.setMovingElement(!1)
                    },
                    d = this.dragPoint.x - this.pressPoint.x,
                    e = this.dragPoint.y - this.pressPoint.y;
                    this.network.moveSelectedElements(d, e, this.network.isLazyMoveAnimate(), c)
                }
            } else this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            }));
            if (this.isParenting()) {
                null == this.parent && (this.parent = this.network.getCurrentSubNetwork());
                var b = this;
                this.network.getMovableSelectedElements().forEach(function(a) {
                    a.setParent(b.parent)
                },
                this.network)
            }
            this.parentProcess(a, !0),
            this.isParenting() && this.repaint(),
            this.network.invalidateCanvasSize(),
            this.removeListener("mousemove"),
            this.lastPoint = null,
            this.dragPoint = null,
            this.pressPoint = null
        }
    }),
    Ib.canvas.interaction.ScrollInteraction = function(a) {
        Ib.canvas.interaction.ScrollInteraction.superClass.constructor.call(this, a),
        this.hThumbRect = null,
        this.vThumbRect = null,
        this.scrollBarVisible = !1
    },
    Jb.ext("twaver.canvas.interaction.ScrollInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseover", "mouseout"),
            Qb.isFirefox ? Wb.addEventListener("DOMMouseScroll", "handleMouseWheel", this.network.getView(), this) : Wb.addEventListener("mousewheel", "handleMouseWheel", this.network.getView(), this),
            Wb.addEventListener("mouseup", "handleMouseUp", a, this),
            Wb.addEventListener("mousemove", "handleMouseMove", a, this),
            this.network.addPropertyChangeListener(this.handleViewRectChange, this),
            this.validateScrollBar(),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseover", "mouseout"),
            Qb.isFirefox ? Wb.removeEventListener("DOMMouseScroll", this.network.getView(), this) : Wb.removeEventListener("mousewheel", this.network.getView(), this),
            Wb.removeEventListener("mouseup", a, this),
            Wb.removeEventListener("mousemove", a, this),
            this.network.removePropertyChangeListener(this.handleViewRectChange, this),
            this.network.removeMarker(this)
        },
        handleViewRectChange: function(a) { ("viewRect" == a.property || "canvasSizeChange" == a.property) && this.validateScrollBar()
        },
        getScrollBarWidth: function() {
            return this.network.getScrollBarWidth()
        },
        getScrollBarColor: function() {
            return "#cccccc"
        },
        validateScrollBar: function() {
            if (this.hThumbRect = null, this.vThumbRect = null, 0 == this.network.isScrollBarVisible()) return void this.repaint();
            var a = this.network.getViewRect().height,
            b = this.network.getViewRect().width,
            c = this.network.getViewRect().x,
            d = this.network.getViewRect().y,
            e = this.network.getCanvasSize(),
            f = e.width,
            g = e.height;
            if (f > b && (0 > c || c + b > f)) return void this.repaint();
            if (g > a && (0 > d || d + a > g)) return void this.repaint();
            var h = 0,
            i = g > a,
            j = f > b,
            k = this.getScrollBarWidth();
            if (g > a) {
                h = j ? a * (a - k) / g: a * a / g;
                var l = d / (g - a) * (a - h - k);
                this.vThumbRect = {
                    x: b - k,
                    y: l,
                    width: k,
                    height: h
                }
            }
            var m = 0;
            if (f > b) {
                m = i ? b * (b - k) / f: b * b / f;
                var n = c / (f - b) * (b - m - k);
                this.hThumbRect = {
                    x: n,
                    y: a - k,
                    width: m,
                    height: k
                }
            }
            this.network.setHScrollBarVisible(null != this.hThumbRect),
            this.network.setVScrollBarVisible(null != this.vThumbRect),
            this.repaint()
        },
        scrollXOffset: function(a) {
            var b = this.network.getViewRect().height,
            c = this.network.getViewRect().width,
            d = this.network.getViewRect().x,
            e = this.network.getViewRect().y,
            f = 30;
            a && (f = -30),
            this.network.setViewRect(d + f, e, c, b)
        },
        scrollYOffset: function(a) {
            var b = this.network.getViewRect().height,
            c = this.network.getViewRect().width,
            d = this.network.getViewRect().x,
            e = this.network.getViewRect().y,
            f = 30;
            a && (f = -30),
            this.network.setViewRect(d, e + f, c, b)
        },
        handle_mousedown: function(a) {
            if (1 != this.network.isValidEvent(a)) {
                var b = this.getMarkerPoint(a);
                this.hBarDownPoint = null,
                this.vBarDownPoint = null,
                null != this.vThumbRect && Tb.containsPoint(this.vThumbRect, b.x, b.y) && (this.vBarDownPoint = {
                    x: a.screenX,
                    y: a.screenY
                },
                this.vBarDownOffset = this.vBarDownPoint.y - this.vThumbRect.y),
                null != this.hThumbRect && Tb.containsPoint(this.hThumbRect, b.x, b.y) && (this.hBarDownPoint = {
                    x: a.screenX,
                    y: a.screenY
                },
                this.hBarDownOffset = this.hBarDownPoint.x - this.hThumbRect.x)
            }
        },
        handle_mouseover: function(a) {
            1 != this.scrollBarVisible && (this.scrollBarVisible = !0, this.repaint())
        },
        handle_mouseout: function(a) {
            0 != this.scrollBarVisible && (this.scrollBarVisible = !1, this.repaint())
        },
        handleMouseUp: function(a) {
            this.vBarDownPoint = null,
            this.hBarDownPoint = null,
            this.repaint()
        },
        handleMouseMove: function(a) {
            var b = {
                x: a.screenX,
                y: a.screenY
            },
            c = this.network.getCanvasSize(),
            d = this.network.getViewRect().height,
            e = this.network.getViewRect().width,
            f = this.getScrollBarWidth();
            if (null != this.hBarDownPoint) {
                var g = b.x - this.hBarDownPoint.x;
                return this.hBarDownPoint = b,
                void this.network.setViewOffSet(g * c.width / (e - f), 0)
            }
            if (null != this.vBarDownPoint) {
                var h = b.y - this.vBarDownPoint.y;
                return this.vBarDownPoint = b,
                void this.network.setViewOffSet(0, h * c.height / (d - f))
            }
        },
        handleMouseWheel: function(a) {
            var b = !1;
            a.wheelDelta !== a.wheelDeltaX ? (a.wheelDelta ? a.wheelDelta > 0 && (b = !0) : a.detail < 0 && (b = !0), this.scrollYOffset(b)) : (a.wheelDelta ? a.wheelDelta > 0 && (b = !0) : a.detail < 0 && (b = !0), this.scrollYOffset(b))
        },
        paintRoundRect: function(a, b, c, d, e, f, g, h) {
            a.beginPath(),
            a.globalAlpha = c,
            a.fillStyle = b,
            Xb.drawRoundRect(a, d, e, f, g, h),
            a.fill()
        },
        paint: function(a) {
            if (0 != this.network.isScrollBarVisible() && (0 != this.scrollBarVisible || null != this.hBarDownPoint || null != this.vBarDownPoint)) {
                var b = this.getScrollBarWidth(),
                c = this.network.getViewRect().height,
                d = this.network.getViewRect().width;
                a.save();
                var e, f = this.getScrollBarColor();
                null != this.hThumbRect && (e = a.createLinearGradient(this.hThumbRect.x, this.hThumbRect.y, this.hThumbRect.x, this.hThumbRect.y + this.hThumbRect.height), e.addColorStop(0, f), e.addColorStop(1, "#666666"), this.paintRoundRect(a, this.getScrollBarColor(), .5, 0, c - b, d - b, b, b / 2), this.paintRoundRect(a, e, .9, this.hThumbRect.x, this.hThumbRect.y + 1, this.hThumbRect.width, this.hThumbRect.height - 2, b / 2)),
                null != this.vThumbRect && (e = a.createLinearGradient(this.vThumbRect.x, this.vThumbRect.y, this.vThumbRect.x + this.vThumbRect.width, this.vThumbRect.y), e.addColorStop(0, f), e.addColorStop(1, "#666666"), this.paintRoundRect(a, this.getScrollBarColor(), .5, d - b, 0, b, c - b, b / 2), this.paintRoundRect(a, e, .9, this.vThumbRect.x + 1, this.vThumbRect.y, this.vThumbRect.width - 2, this.vThumbRect.height, b / 2)),
                a.restore()
            }
        }
    }),
    Ib.canvas.interaction.DefaultInteraction = function(a) {
        Ib.canvas.interaction.DefaultInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.DefaultInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove", "keydown")
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove", "keydown")
        },
        handle_mousedown: function(a) {
            if (this.network.isValidEvent(a)) {
                this.network.isFocusOnClick() && Ib.Util.setFocus(this.network.getView());
                var b = this.network.getElementAt(a);
                2 === a.detail ? this.handleDoubleClicked(a, b) : this.handleClicked(a, b)
            }
        },
        handleClicked: function(a, b) {
            Cc.handleClicked(this.network, a, b)
        },
        handleDoubleClicked: function(a, b) {
            Cc.handleDoubleClicked(this.network, a, b)
        },
        handle_keydown: function(a) {
            Cc.handleKeyDown(this.network, a)
        },
        handle_mousemove: function(a) {
            var b = this.network.getElementAt(a),
            c = this._preElement,
            d = Dc(c),
            e = Dc(b);
            c !== b && (c && (d && d.onMouseLeave && d.onMouseLeave(c, this.network), this.network.onMouseLeave(c, a)), b && (e && e.onMouseEnter && e.onMouseEnter(b, this.network), this.network.onMouseEnter(b, a))),
            b && e && e.onMouseMove && e.onMouseMove(b, this.network),
            this.network.onMouseMove(b, a),
            this._preElement = b
        }
    }),
    Ib.canvas.interaction.PanInteraction = function(a) {
        Ib.canvas.interaction.PanInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.PanInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseup"),
            this._oldCursor = this.network.getView().style.cursor
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseup")
        },
        handle_mousedown: function(a) {
            this.network.isValidEvent(a) && (this.lastPoint = this.getMarkerPoint(a), this.lastPoint && (this.addListener("mousemove"), this.network.getView().style.cursor = "pointer"))
        },
        handle_mouseup: function(a) {
            this._clear()
        },
        handle_mousemove: function(a) {
            if (this.lastPoint) {
                var b = this.getMarkerPoint(a);
                if (b) {
                    var c = b.x - this.lastPoint.x,
                    d = b.y - this.lastPoint.y;
                    this.network.panByOffset( - c, -d),
                    this.lastPoint = b
                }
            }
        },
        _clear: function(a) {
            this.lastPoint && (this.lastPoint = null, this.network.getView().style.cursor = this._oldCursor, this.removeListener("mousemove"))
        }
    }),
    Ib.canvas.interaction.CreateElementInteraction = function(a, b) {
        b || (b = Ib.Node),
        this.elementFunction = Ib.Util.isTypeOf(b, Ib.Node) ?
        function(a) {
            var c = new b;
            return c instanceof Ib.Node && c.setCenterLocation(a),
            c
        }: b,
        Ib.canvas.interaction.CreateElementInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.CreateElementInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown")
        },
        tearDown: function() {
            this.removeListener("mousedown")
        },
        handle_mousedown: function(a) {
            var b = this.network.getLogicalPoint(a);
            if (b) {
                var c = this.elementFunction(b);
                c && this.network.addElementByInteraction(c)
            }
        }
    }),
    Ib.canvas.interaction.EditInteraction = function(a, b) {
        this.lazyMode = b,
        this.pointIndex = -1,
        this.editPointSize = a.getEditPointSize(),
        this.resizePointSize = a.getResizePointSize(),
        this.rotatePointSize = a.getRotatePointSize(),
        Ib.canvas.interaction.EditInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.EditInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseup", "mousemove"),
            this.oldCursor = this.network.getView().style.cursor,
            this.network.setHasEditInteraction(!0),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseup", "mousemove"),
            this.network.getView().style.cursor = this.oldCursor,
            this.network.setHasEditInteraction(!1),
            this.clear(),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            if (1 == this.lazyMode && null != this.resizingRect) {
                a.lineWidth = this.network.getResizeLineWidth();
                var b = this.convertFromUIToMarkerRect(this.resizingRect, 0, 0);
                a.save(),
                Ib.Util.rotateCanvas(a, b, this.node.getAngle()),
                a.beginPath(),
                Nd.rect(a, b.x, b.y, b.width, b.height, null, this.network.getResizeLineColor()),
                a.restore()
            }
            this.isStartRotate && this.showRotateScale(a)
        },
        clear: function() {
            this.network.setEditingElement(!1),
            this.network.setRotatingElement(!1),
            this.isStart = !1,
            this.isStartRotate = !1,
            this.node = null,
            this.shapeNode = null,
            this.shapeLink = null,
            this.linkUI = null,
            this.resizingRect = null,
            this.resizeDirection = null,
            this.pointIndex = -1,
            this._removeCursor(),
            this.oldCursor = null,
            this.network.repaintTopCanvas()
        },
        _removeCursor: function() {
            this.cursorID && (this.network.getView().style.cursor = this.oldCursor || "default", this.cursorID = null),
            this.resizeDirection = null,
            this.isCrossCursor = !1
        },
        _setCrossCursor: function() {
            this.isCrossCursor || (this._removeCursor(), this._setCursor("crosshair"), this.isCrossCursor = !0)
        },
        _setCursor: function(a) {
            this.cursorID = a,
            this.network.getView().style.cursor !== this.cursorID && (this.network.getView().style.cursor = this.cursorID)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) if (!Jb.isAltDown(a) || this.network.isEditingElement()) ! this.network.isEditingElement() || this.isStart || this.isStartRotate || (this.node && this.resizeDirection ? (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: this.lazyMode ? "lazyResizeStart": "liveResizeStart",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            })) : this.shapeNode && this.pointIndex >= 0 ? Jb.isAltDown(a) ? (this.shapeNode.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                kind: "removePoint",
                event: a,
                element: this.shapeNode
            })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.shapeNode,
                pointIndex: this.pointIndex
            })) : this.shapeLink && this.pointIndex >= 0 ? Jb.isAltDown(a) ? (this.shapeLink.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                kind: "removePoint",
                event: a,
                element: this.shapeLink
            })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.shapeLink,
                pointIndex: this.pointIndex
            })) : this.linkUI ? (this.isStart = !0, this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.linkUI._element
            })) : this.node && (this.isStartRotate = !0, this._handle_mousedown(a)));
            else {
                var b = this.network.getElementAt(a),
                c = this.network.getLogicalPoint(a);
                if (b instanceof Ib.ShapeNode) {
                    var d = this.getPointIndex(b.getPoints(), c, !0);
                    d > 0 && (this._handle_mousedown(a), this.pointIndex = d, this.shapeNode = b, b.addPoint(c, d), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: b,
                        pointIndex: d
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: b,
                        pointIndex: d
                    }))
                }
                if (b instanceof Ib.ShapeLink) {
                    var e = new Ib.List(b.getPoints()),
                    f = this.network.getElementUI(b);
                    e.add(f.getFromPoint(), 0),
                    e.add(f.getToPoint());
                    var d = this.getPointIndex(e, c) - 1;
                    d > 0 && (this._handle_mousedown(a), this.pointIndex = d, this.shapeLink = b, b.addPoint(c, d), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: b,
                        pointIndex: d
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: b,
                        pointIndex: d
                    }))
                }
            }
        },
        handle_mouseup: function(a) {
            if (this.isStart) {
                var b = this.network.getLogicalPoint(a);
                if (this.resizingRect) if (this.lazyMode) if (this.network.isResizeAnimate()) {
                    var c = this,
                    d = new Ib.animate.AnimateBounds(this.node, this.resizingRect,
                    function() {
                        c.network.fireInteractionEvent({
                            kind: "lazyResizeEnd",
                            event: a,
                            element: c.node,
                            resizeDirection: c.resizeDirection
                        }),
                        c.clear()
                    });
                    Ib.animate.AnimateManager.start(d)
                } else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "lazyResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "liveResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else this.shapeNode && this.pointIndex >= 0 && b ? (this.shapeNode.setPoint(this.pointIndex, b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.shapeNode,
                    pointIndex: this.pointIndex
                })) : this.shapeLink && this.pointIndex >= 0 && b ? (this.shapeLink.setPoint(this.pointIndex, b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.shapeLink,
                    pointIndex: this.pointIndex
                })) : this.linkUI && b && (this.linkUI.setControlPoint(b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.linkUI._element
                }))
            }
            this._handle_mouseup(a),
            this.lazyMode || this.clear()
        },
        handle_mousemove: function(a) {
            if (this.network.isValidEvent(a)) {
                if (this.isStartRotate && this.node) return this._handleRotateElement(a, this.node),
                void(this.network.isShowRotateScale() && this.repaint());
                if (this.isStart) {
                    if (this.shapeNode && this.pointIndex >= 0) return void this._handleMovingShapeNodePoint(a);
                    if (this.shapeLink && this.pointIndex >= 0) return void this._handleMovingShapeLinkPoint(a);
                    if (this.node && this.resizeDirection) return void this._handleResizing(a);
                    if (this.linkUI) return void this._handleMovingLinkControlPoint(a)
                }
                if (this.network.isSelectingElement() || this.network.isMovingElement() || 0 === this.network.getSelectionModel().size()) return void this.clear();
                var b = this.network.getElementAt(a),
                c = this.network.getElementUI(b);
                if (!c || !c.getEditAttachment()) return void this.clear();
                var d = this.network.getLogicalPoint(a);
                if (b instanceof Ib.Node) {
                    if (this.node = b, this._isEditingShapeNode(d) || this._isResizingNode(d)) return void this.network.setEditingElement(!0);
                    if (this._isRotatingElement(d)) return this.network.setRotatingElement(!0),
                    void this.network.setEditingElement(!0)
                } else if (b instanceof Ib.ShapeLink) {
                    if (this.shapeLink = b, this._isEditingShapeLink(d)) return void this.network.setEditingElement(!0)
                } else if (c instanceof Ib.canvas.LinkUI && xc.isOrthogonalLink(c._element)) {
                    this.linkUI = c;
                    var e = this.linkUI.getControlPoint();
                    return void(e && this._contains(d, e, this.editPointSize) && (this._setCrossCursor(), this.network.setEditingElement(!0)))
                }
                this.clear()
            }
        },
        _isRotatingElement: function(a) {
            var b = this.network.getRotatePointSize();
            if (0 >= b) return ! 1;
            var c = this.node.getOriginalRect(),
            d = this.node.getAngle();
            return this._isRotating(a, "crosshair", c, d)
        },
        _isRotating: function(a, b, c, d) {
            var e = this.network.getRotatePointSize(),
            f = {
                x: c.x + c.width / 2,
                y: c.y - this.network.getRotatePointOffset() - e
            },
            g = this._rotatePoint(f, d, c),
            h = {
                x: g.x - e,
                y: g.y - e,
                width: 2 * e,
                height: 2 * e
            };
            return Tb.containsPoint(h, a) ? (this._removeCursor(), this._setCursor(b), !0) : !1
        },
        _handleRotateElement: function(a, b) {
            this._handle_mousemove(a);
            var c = this._calculateAngle(this.network.getLogicalPoint(a), b);
            b.setAngle(c)
        },
        _calculateAngle: function(a, b) {
            var c = b.getCenterLocation();
            return Math.round(180 * Math.atan2(c.x - a.x, a.y - c.y) / Math.PI + 180)
        },
        _handleMovingShapeNodePoint: function(a) {
            var b = this.network.getLogicalPoint(a);
            this.shapeNode.setPoint(this.pointIndex, b),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.shapeNode,
                pointIndex: this.pointIndex
            })
        },
        _handleMovingShapeLinkPoint: function(a) {
            var b = this.network.getLogicalPoint(a);
            this.shapeLink.setPoint(this.pointIndex, b),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.shapeLink,
                pointIndex: this.pointIndex
            })
        },
        _handleMovingLinkControlPoint: function(a) {
            this.linkUI.setControlPoint(this.network.getLogicalPoint(a)),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.linkUI._element
            })
        },
        _handleResizing: function(a) {
            this._handle_mousemove(a);
            var b = this.node.getAngle(),
            c = this.node.getLocation(),
            d = this.node.getWidth() / 2,
            e = this.node.getHeight() / 2,
            f = {
                x: c.x + d,
                y: c.y + e
            },
            g = {
                x: -d,
                y: -e
            },
            h = {
                x: -d,
                y: e
            },
            i = {
                x: d,
                y: e
            },
            j = {
                x: d,
                y: -e
            },
            k = {
                x: 0,
                y: -e
            },
            l = {
                x: d,
                y: 0
            },
            m = {
                x: 0,
                y: e
            },
            n = {
                x: -d,
                y: 0
            };
            if ("northwest" === this.resizeDirection && (this._transformPoint(i, f, b), g.x = this._endLogical.x, g.y = this._endLogical.y, f.x = (g.x + i.x) / 2, f.y = (g.y + i.y) / 2, this._reversPoint(g, f, b), this._reversPoint(i, f, b), this.resizingRect = {
                x: g.x,
                y: g.y,
                width: i.x - g.x,
                height: i.y - g.y
            }), "north" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                k.y = o.y - f.y,
                this._transformPoint(k, f, b),
                this._transformPoint(m, f, b),
                f.x = (k.x + m.x) / 2,
                f.y = (k.y + m.y) / 2,
                this._reversPoint(k, f, b),
                this._reversPoint(m, f, b),
                this.resizingRect = {
                    x: f.x - this.node.getWidth() / 2,
                    y: f.y - (m.y - k.y) / 2,
                    width: this.node.getWidth(),
                    height: m.y - k.y
                }
            }
            if ("northeast" === this.resizeDirection && (this._transformPoint(h, f, b), j.x = this._endLogical.x, j.y = this._endLogical.y, f.x = (h.x + j.x) / 2, f.y = (h.y + j.y) / 2, this._reversPoint(h, f, b), this._reversPoint(j, f, b), this.resizingRect = {
                x: h.x,
                y: j.y,
                width: j.x - h.x,
                height: h.y - j.y
            }), "west" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                n.x = o.x - f.x,
                this._transformPoint(l, f, b),
                this._transformPoint(n, f, b),
                f.x = (l.x + n.x) / 2,
                f.y = (l.y + n.y) / 2,
                this._reversPoint(l, f, b),
                this._reversPoint(n, f, b),
                this.resizingRect = {
                    x: f.x - (l.x - n.x) / 2,
                    y: f.y - this.node.getHeight() / 2,
                    width: l.x - n.x,
                    height: this.node.getHeight()
                }
            }
            if ("east" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                l.x = o.x - f.x,
                this._transformPoint(l, f, b),
                this._transformPoint(n, f, b),
                f.x = (l.x + n.x) / 2,
                f.y = (l.y + n.y) / 2,
                this._reversPoint(l, f, b),
                this._reversPoint(n, f, b),
                this.resizingRect = {
                    x: f.x - (l.x - n.x) / 2,
                    y: f.y - this.node.getHeight() / 2,
                    width: l.x - n.x,
                    height: this.node.getHeight()
                }
            }
            if ("southwest" === this.resizeDirection && (this._transformPoint(j, f, b), h.x = this._endLogical.x, h.y = this._endLogical.y, f.x = (h.x + j.x) / 2, f.y = (h.y + j.y) / 2, this._reversPoint(h, f, b), this._reversPoint(j, f, b), this.resizingRect = {
                x: h.x,
                y: j.y,
                width: j.x - h.x,
                height: h.y - j.y
            }), "south" === this.resizeDirection) {
                var o = {
                    x: this._endLogical.x,
                    y: this._endLogical.y
                };
                this._reversPoint(o, f, b),
                m.y = o.y - f.y,
                this._transformPoint(k, f, b),
                this._transformPoint(m, f, b),
                f.x = (k.x + m.x) / 2,
                f.y = (k.y + m.y) / 2,
                this._reversPoint(k, f, b),
                this._reversPoint(m, f, b),
                this.resizingRect = {
                    x: f.x - this.node.getWidth() / 2,
                    y: f.y - (m.y - k.y) / 2,
                    width: this.node.getWidth(),
                    height: m.y - k.y
                }
            }
            "southeast" === this.resizeDirection && (this._transformPoint(g, f, b), i.x = this._endLogical.x, i.y = this._endLogical.y, f.x = (g.x + i.x) / 2, f.y = (g.y + i.y) / 2, this._reversPoint(g, f, b), this._reversPoint(i, f, b), this.resizingRect = {
                x: g.x,
                y: g.y,
                width: i.x - g.x,
                height: i.y - g.y
            }),
            this.lazyMode ? (this.repaint(), this.network.fireInteractionEvent({
                kind: "lazyResizeBetween",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            })) : (this.node.setLocation(this.resizingRect.x, this.resizingRect.y), this.node.setSize(this.resizingRect.width, this.resizingRect.height), this.network.fireInteractionEvent({
                kind: "liveResizeBetween",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            }))
        },
        _isEditingShapeNode: function(a) {
            if (this.node instanceof Ib.ShapeNode) {
                this.shapeNode = this.node;
                for (var b = this.shapeNode.getPoints(), c = 0, d = b.size(); d > c; c++) {
                    var e = b.get(c);
                    if (this._contains(a, e, this.editPointSize)) return this._setCrossCursor(),
                    this.pointIndex = c,
                    !0
                }
            }
            return this.pointIndex = -1,
            !1
        },
        _isEditingShapeLink: function(a) {
            for (var b = this.shapeLink.getPoints(), c = 0, d = b.size(); d > c; c++) {
                var e = b.get(c);
                if (this._contains(a, e, this.editPointSize)) return this._setCrossCursor(),
                this.pointIndex = c,
                !0
            }
            return this.pointIndex = -1,
            !1
        },
        _isResizingNode: function(a) {
            var b = this.network.getResizePointSize();
            if (0 >= b) return ! 1;
            var c = this.node.getOriginalRect(),
            d = this.node.getAngle(),
            e = {
                x: c.x,
                y: c.y
            },
            f = this._rotatePoint(e, d, c);
            return this._isResizing(a, f.x, f.y, "northwest", "nwse-resize") ? !0 : (e = {
                x: c.x + c.width / 2,
                y: c.y
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "north", "ns-resize") ? !0 : (e = {
                x: c.x + c.width,
                y: c.y
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "northeast", "nesw-resize") ? !0 : (e = {
                x: c.x,
                y: c.y + c.height / 2
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "west", "ew-resize") ? !0 : (e = {
                x: c.x + c.width,
                y: c.y + c.height / 2
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "east", "ew-resize") ? !0 : (e = {
                x: c.x,
                y: c.y + c.height
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "southwest", "nesw-resize") ? !0 : (e = {
                x: c.x + c.width / 2,
                y: c.y + c.height
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "south", "ns-resize") ? !0 : (e = {
                x: c.x + c.width,
                y: c.y + c.height
            },
            f = this._rotatePoint(e, d, c), this._isResizing(a, f.x, f.y, "southeast", "nwse-resize") ? !0 : !1)))))))
        },
        _rotatePoint: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x + c.width / 2, c.y + c.height / 2),
            e = d.transform(a);
            return e
        },
        _isResizing: function(a, b, c, d, e) {
            return this._contains(a, {
                x: b,
                y: c
            },
            this.resizePointSize) ? (this.resizeDirection !== d && (this._removeCursor(), e = this._changeCursorWithAngle(d, this.node.getAngle()), this._setCursor(e), this.resizeDirection = d), !0) : !1
        },
        _getRect: function(a, b, c, d) {
            var e = c > a ? a: c,
            f = d > b ? b: d,
            g = Math.abs(a - c),
            h = Math.abs(b - d);
            return {
                x: e,
                y: f,
                width: g,
                height: h
            }
        },
        _contains: function(a, b, c) {
            var d = {
                x: b.x - c,
                y: b.y - c,
                width: 2 * c,
                height: 2 * c
            };
            return Tb.containsPoint(d, a)
        },
        getPointIndex: function(a, b, c) {
            if (a.size() < 2) return 0;
            for (var d, e = a.get(0), f = 1; f < a.size(); f++) {
                if (d = a.get(f), this.isPointOnLine(b, e, d, 6)) return f;
                e = d
            }
            return e = a.get(0),
            c && this.isPointOnLine(b, e, d, 6) ? a.size() : 0
        },
        showRotateScale: function(a) {
            var b, c, d, e, f, g = (new Ib.List, this.network.getRotateScaleWidth()),
            h = this.network.getRotateScaleHeight(),
            i = this.network.getRotatePointSize(),
            j = this.node.getAngle(),
            k = this.node.getOriginalRect(),
            l = {
                x: k.x + k.width / 2,
                y: k.y - this.network.getRotatePointOffset() - i
            },
            m = this._rotatePoint(l, j, k),
            n = "13px Arial",
            o = j + "°";
            this.node.getAngle() >= 0 && this.node.getAngle() <= 180 ? (c = {
                x: m.x + i,
                y: m.y
            },
            d = {
                x: c.x + g,
                y: c.y
            },
            e = {
                x: d.x,
                y: d.y - h
            },
            f = {
                x: c.x,
                y: e.y
            }) : this.node.getAngle() > 180 && this.node.getAngle() <= 360 && (c = {
                x: m.x - i,
                y: m.y
            },
            d = {
                x: c.x - g,
                y: c.y
            },
            e = {
                x: d.x,
                y: d.y - h
            },
            f = {
                x: c.x,
                y: e.y
            });
            var p = new Ib.List([c, d, e, f]),
            b = Jb.math.getRect(p);
            a.fillStyle = this.network.getRotateScaleFillColor(),
            a.fillRect(b.x, b.y, b.width, b.height),
            a.fillStyle = this.network.getRotateScaleFontColor(),
            a.textBaseline = "middle",
            a.textAlign = "center",
            a.font = n,
            a.fillText(o, b.x + b.width / 2, b.y + b.height / 2)
        },
        isPointOnLine: function(a, b, c, d) {
            0 > d && (d = 0);
            var e = this.getDistanceFromPointToLine(a, b, c);
            return d >= e && a.x >= Math.min(b.x, c.x) - d && a.x <= Math.max(b.x, c.x) + d && a.y >= Math.min(b.y, c.y) - d && a.y <= Math.max(b.y, c.y) + d
        },
        getDistanceFromPointToLine: function(a, b, c) {
            if (b.x === c.x) return Math.abs(a.x - b.x);
            var d = (c.y - b.y) / (c.x - b.x),
            e = (c.x * b.y - b.x * c.y) / (c.x - b.x);
            return Math.abs(d * a.x - a.y + e) / Math.sqrt(d * d + 1)
        },
        _transformPoint: function(a, b, c) {
            var d = Math.cos(c * Math.PI / 180),
            e = Math.sin(c * Math.PI / 180),
            f = a.x,
            g = a.y,
            h = f * d - g * e,
            i = f * e + g * d;
            a.x = h + b.x,
            a.y = i + b.y
        },
        _reversPoint: function(a, b, c) {
            c *= -1;
            var d = Math.cos(c * Math.PI / 180),
            e = Math.sin(c * Math.PI / 180),
            f = a.x - b.x,
            g = a.y - b.y,
            h = f * d - g * e,
            i = f * e + g * d;
            a.x = h + b.x,
            a.y = i + b.y
        },
        _changeCursorWithAngle: function(a, b) {
            var c, d = ["auto", "nwse-resize", "ns-resize", "nesw-resize", "ew-resize", "nwse-resize", "ns-resize", "nesw-resize", "ew-resize"];
            switch (a) {
            case "northwest":
                c = 1;
                break;
            case "north":
                c = 2;
                break;
            case "northeast":
                c = 3;
                break;
            case "east":
                c = 4;
                break;
            case "southeast":
                c = 5;
                break;
            case "south":
                c = 6;
                break;
            case "southwest":
                c = 7;
                break;
            case "west":
                c = 8;
                break;
            default:
                c = 0
            }
            return (b >= 360 || -360 >= b) && (b %= 360),
            b > 22.5 && 67.5 >= b && (c += 1),
            -22.5 > b && b >= -67.5 && (c -= 1),
            b > 67.5 && 112.5 >= b && (c += 2),
            -67.5 > b && b >= -112.5 && (c -= 2),
            b > 112.5 && 157.5 >= b && (c += 3),
            -112.5 > b && b >= -157.5 && (c -= 3),
            b > 157.5 && 202.5 >= b && (c += 4),
            -157.5 > b && b >= -202.5 && (c -= 4),
            b > 202.5 && 247.5 >= b && (c += 5),
            -202.5 > b && b >= -247.5 && (c -= 5),
            b > 247.5 && 292.5 >= b && (c += 6),
            -247.5 > b && b >= -292.5 && (c -= 6),
            b > 292.5 && 337.5 >= b && (c += 7),
            -292.5 > b && b >= -337.5 && (c -= 7),
            c > 8 && (c -= 8),
            0 >= c && (c += 8),
            d[c]
        }
    }),
    Ib.canvas.interaction.CreateLinkInteraction = function(a, b) {
        b || (b = Ib.Link),
        this.linkFunction = Ib.Util.isTypeOf(b, Ib.Link) ?
        function(a, c) {
            var d = new b;
            return d instanceof Ib.Link && (d.setFromNode(a), d.setToNode(c)),
            d
        }: b,
        Ib.canvas.interaction.CreateLinkInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.CreateLinkInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.clear(),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            a.beginPath();
            var b, c;
            a.lineWidth = this.network.getEditLineWidth();
            var d = this.network.getEditLineColor();
            this.currentNode && this.currentNode !== this.fromNode && (b = this.network.getElementUI(this.currentNode).getViewRect(), c = this.convertFromUIToMarkerRect(b, 0, 0), Nd.rect(a, c.x, c.y, c.width, c.height, null, d)),
            this.fromNode && (b = this.network.getElementUI(this.fromNode).getViewRect(), c = this.convertFromUIToMarkerRect(b, 0, 0), Nd.rect(a, c.x, c.y, c.width, c.height, null, d)),
            this.currentPoint && this.paintLine(a),
            a.closePath()
        },
        paintLine: function(a) {
            var b = this.network.getEditLineColor(),
            c = this.convertPointFromView(this.fromNode.getCenterLocation()),
            d = c.x,
            e = c.y,
            f = this.currentPoint.x,
            g = this.currentPoint.y;
            a.strokeStyle = b,
            a.beginPath(),
            a.moveTo(d, e),
            a.lineTo(f, g),
            a.stroke()
        },
        clear: function() {
            this.currentPoint = null,
            this.currentNode = null,
            this.fromNode = null,
            this.toNode = null
        },
        createLink: function() {
            return this.linkFunction(this.fromNode, this.toNode)
        },
        handle_mousedown: function(a) {
            if (this.network.isValidEvent(a)) if (this.fromNode) {
                if (this.toNode = this.currentNode, this.toNode) {
                    var b = this.createLink();
                    b && this.network.addElementByInteraction(b)
                }
                this.clear()
            } else this.fromNode = this.currentNode,
            this.currentNode = null,
            this.currentPoint = null,
            this.repaint()
        },
        handle_mousemove: function(a) {
            var b = this.getMarkerPoint(a);
            if (b) {
                if (this.network.isMovingElement() || this.network.isEditingElement()) return void this.clear();
                var c = null;
                this.fromNode ? (this.currentNode = this.getToNode(a), this.currentPoint = b, this.repaint()) : (c = this.getFromNode(a), this.currentNode !== c && (this.currentNode = c, this.repaint()))
            }
        },
        getFromNode: function(a) {
            return this.getNode(a)
        },
        getToNode: function(a) {
            return this.getNode(a)
        },
        getNode: function(a) {
            var b = this.network.getElementAt(a);
            return b instanceof Kd && this.network.isLinkable(b) ? b: null
        }
    }),
    Ib.canvas.interaction.CreateShapeLinkInteraction = function(a, b) {
        Ib.canvas.interaction.CreateShapeLinkInteraction.superClass.constructor.call(this, a),
        b || (b = Ib.ShapeLink),
        this.linkFunction = Ib.Util.isTypeOf(b, Ib.ShapeLink) ?
        function(a, c, d) {
            var e = new b;
            return e instanceof Ib.ShapeLink && (e.setFromNode(a), e.setToNode(c), d && e.setPoints(d)),
            e
        }: b
    },
    Jb.ext("twaver.canvas.interaction.CreateShapeLinkInteraction", Ib.canvas.interaction.CreateLinkInteraction, {
        clear: function() {
            this.points = null,
            Ib.canvas.interaction.CreateShapeLinkInteraction.superClass.clear.call(this)
        },
        createLink: function() {
            return this.linkFunction(this.fromNode, this.toNode, this.points)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) {
                var b = this.network.getLogicalPoint(a);
                if (b) {
                    if (this.fromNode) if (this.toNode = this.currentNode, this.toNode) {
                        var c = this.createLink();
                        c && this.network.addElementByInteraction(c),
                        this.clear()
                    } else {
                        if (this.points || (this.points = new Ib.List), this.points.size() > 0) {
                            var d = this.points.get(this.points.size() - 1);
                            if (d.x === b.x && d.y === b.y) return
                        }
                        this.points.add(b)
                    } else this.fromNode = this.currentNode,
                    this.points = null,
                    this.currentNode = null,
                    this.currentPoint = null;
                    this.repaint()
                }
            }
        },
        paintLine: function(a) {
            if (this.currentPoint) {
                var b, c = new Ib.List;
                if (b = this.convertPointFromView(this.fromNode.getCenterLocation()), c.add(b, 0), this.points && this.points.size() > 0) for (var d = this.points.size(), e = 0; d > e; e++) b = this.convertPointFromView(this.points.get(e)),
                c.add(b);
                b = this.currentPoint,
                c.add(b),
                a.lineWidth = this.network.getEditLineWidth(),
                a.strokeStyle = this.network.getEditLineColor(),
                a.beginPath(),
                Xb.drawLinePoints(a, c),
                a.stroke()
            }
        }
    }),
    Ib.canvas.interaction.CreateShapeNodeInteraction = function(a, b) {
        b || (b = Ib.ShapeNode),
        this.shapeNodeFunction = Ib.Util.isTypeOf(b, Ib.ShapeNode) ?
        function(a) {
            var c = new b;
            return c instanceof Ib.ShapeNode && a && c.setPoints(a),
            c
        }: b,
        Ib.canvas.interaction.CreateShapeNodeInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.CreateShapeNodeInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.clear(),
            this.network.removeMarker(this),
            this.network.setEditingElement(!1)
        },
        clear: function() {
            this.points = null,
            this.currentPoint = null
        },
        paint: function(a) {
            if (this.points && this.points.size() > 0 && this.currentPoint) {
                for (var b, c = new Ib.List,
                d = this.points.size(), e = 0; d > e; e++) b = this.convertPointFromView(this.points.get(e)),
                c.add(b);
                b = this.convertPointFromView(this.currentPoint),
                c.add(b),
                a.lineWidth = this.network.getEditLineWidth(),
                a.strokeStyle = this.network.getEditLineColor(),
                a.beginPath(),
                Xb.drawLinePoints(a, c),
                a.stroke()
            }
        },
        handle_mousedown: function(a) {
            if (0 === a.button) {
                var b = this.network.getLogicalPoint(a);
                if (b) {
                    if (2 === a.detail) {
                        if (this.points) {
                            var c = this.shapeNodeFunction(this.points);
                            this.network.addElementByInteraction(c),
                            this.clear();
                            var d = this;
                            setTimeout(function() {
                                d.network.setEditingElement(!1)
                            },
                            0)
                        }
                    } else {
                        if (this.network.isEditingElement() || this.network.setEditingElement(!0), this.points || (this.points = new Ib.List), this.points.size() > 0) {
                            var e = this.points.get(this.points.size() - 1);
                            if (e.x === b.x && e.y === b.y) return
                        }
                        this.points.add(b)
                    }
                    this.repaint()
                }
            }
        },
        handle_mousemove: function(a) {
            this.points && (this.currentPoint = this.network.getLogicalPoint(a), this.repaint())
        }
    }),
    Ib.canvas.interaction.MagnifyInteraction = function(a, b, c, d, e) {
        Ib.canvas.interaction.MagnifyInteraction.superClass.constructor.call(this, a),
        this.zoom = b || 2,
        this.xRadius = c || 100,
        this.yRadius = d || 100,
        this.shape = e || "circle",
        this.borderColor = "black",
        this.borderWidth = 1,
        this.backgroundColor = "white",
        this.markCanvas = Wb.createCanvas()
    },
    Jb.ext("twaver.canvas.interaction.MagnifyInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousemove"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousemove"),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            if (this.point) {
                var b = this.network._zoom,
                c = this.zoom * b,
                d = this.point.x * b - this.network.viewRect.x - this.xRadius,
                e = this.point.y * b - this.network.viewRect.y - this.yRadius,
                f = 2 * this.xRadius,
                g = 2 * this.yRadius,
                h = {
                    x: this.point.x - this.xRadius / c,
                    y: this.point.y - this.yRadius / c,
                    width: f / c,
                    height: g / c
                },
                i = this.borderWidth,
                j = Wb.createCanvas();
                j.width = f,
                j.height = g,
                this.network.toCanvasByRegion(h, c, j),
                a.save(),
                a.beginPath(),
                Xb.drawVector(a, this.shape, null, d, e, f, g),
                a.clip(),
                a.fillStyle = this.backgroundColor,
                a.beginPath(),
                a.rect(d, e, f, g),
                a.fill(),
                a.drawImage(j, d, e),
                a.restore(),
                a.beginPath(),
                a.lineWidth = i,
                Xb.drawVector(a, this.shape, null, d + i / 2, e + i / 2, f - i, g - i),
                a.strokeStyle = this.borderColor,
                a.stroke()
            }
        },
        handle_mousemove: function(a) {
            this.point = this.network.getLogicalPoint(a),
            this.point && this.repaint()
        },
        getZoom: function() {
            return this.zoom
        },
        setZoom: function(a) {
            this.zoom = a,
            this.network.repaintTopCanvas()
        },
        getShape: function() {
            return this.shape
        },
        setShape: function(a) {
            this.shape = a,
            this.network.repaintTopCanvas()
        },
        getXRadius: function() {
            return this.xRadius
        },
        setXRadius: function(a) {
            this.xRadius = a,
            this.network.repaintTopCanvas()
        },
        getYRadius: function() {
            return this.yRadius
        },
        setYRadius: function(a) {
            this.yRadius = a,
            this.network.repaintTopCanvas()
        },
        getBorderColor: function() {
            return this.borderColor
        },
        setBorderColor: function(a) {
            this.borderColor = a,
            this.network.repaintTopCanvas()
        },
        getBorderWidth: function() {
            return this.borderWidth
        },
        setBorderWidth: function(a) {
            this.borderWidth = a,
            this.network.repaintTopCanvas()
        },
        getBackgroundColor: function() {
            return this.backgroundColor
        },
        setBackgroundColor: function(a) {
            this.backgroundColor = a,
            this.network.repaintTopCanvas()
        }
    }),
    Ib.canvas.interaction.TouchInteraction = function(a) {
        Ib.canvas.interaction.TouchInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.canvas.interaction.TouchInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            var a = this.network.getView();
            Wb.addEventListener("touchstart", "handleTouchstart", a, this),
            Wb.addEventListener("touchmove", "handleTouchmove", a, this),
            Wb.addEventListener("touchend", "handleTouchend", a, this),
            Wb.addEventListener("touchcancel", "handleTouchend", a, this),
            this.network.addMarker(this)
        },
        tearDown: function() {
            var a = this.network.getView();
            Wb.removeEventListener("touchstart", this.network.getView(), this),
            Wb.removeEventListener("touchmove", a, this),
            Wb.removeEventListener("touchend", a, this),
            Wb.removeEventListener("touchcancel", a, this),
            this.network.removeMarker(this)
        },
        handleTouchstart: function(a) {
            if (Wb.preventDefault(a), a.touches && 1 == a.touches.length) {
                var b = this.network.getLogicalPoint(a),
                c = this.network.getElementAt(b);
                this._startTouchTime = new Date,
                this._startTouchPoint = b,
                this._startTouchClient = this.getMarkerPoint(a),
                c ? (this._haveElementUnderTouch = !0, this._startTouchElement = c) : (this._haveElementUnderTouch = !1, this._startTouchElement = null),
                this.timer = setTimeout(function() {
                    Cc.handleLongClicked(self.network, a, c)
                },
                1e3)
            } else a.touches && 2 == a.touches.length && (this._distance = zc.getDistance(a), this._zoom = this.network.getZoom());
            this._touchCount = a.touches.length
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), 2 == this._touchCount && a.touches && 2 == a.touches.length) if (this.timer && clearTimeout(this.timer), Math.abs(this._distance - zc.getDistance(a)) >= Dd.TOUCH_ZOOM_THRESHOLD || this._zoomFlag) {
                this._zoomFlag = !0;
                var b = zc.getDistance(a) / this._distance;
                this.network.setTouchZoom(this._zoom * b, !1)
            } else {
                var c = this.getMarkerPoint(a),
                d = this._startTouchClient.x - c.x,
                e = this._startTouchClient.y - c.y;
                this.network.panByOffset(d, e),
                this._startTouchClient = c
            } else if (1 == this._touchCount && a.touches && 1 == a.touches.length) if (this._haveElementUnderTouch || !this.network.isRectSelectEnabled()) {
                var f = this.network.getLogicalPoint(a),
                g = this.network.getElementAt(f);
                if (this.network.isMovingElement() || null != this._startTouchElement && this._startTouchElement == g && this.network.getMovableSelectedElements().contains(g)) {
                    var d = f.x - this._startTouchPoint.x,
                    e = f.y - this._startTouchPoint.y; (Math.abs(d) >= Dd.TOUCH_MOVE_THRESHOLD || Math.abs(e) >= Dd.TOUCH_MOVE_THRESHOLD) && (this._startTouchPoint = f, this.network.moveSelectedElements(d, e), this.network.isMovingElement() ? this.network.fireInteractionEvent({
                        kind: "liveMoveBetween",
                        event: a
                    }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                        kind: "liveMoveStart",
                        event: a
                    }), this.timer && clearTimeout(this.timer)))
                } else {
                    var d = f.x - this._startTouchPoint.x,
                    e = f.y - this._startTouchPoint.y; (Math.abs(d) >= Dd.TOUCH_MOVE_THRESHOLD || Math.abs(e) >= Dd.TOUCH_MOVE_THRESHOLD) && this.timer && clearTimeout(this.timer);
                    var c = this.getMarkerPoint(a),
                    d = this._startTouchClient.x - c.x,
                    e = this._startTouchClient.y - c.y;
                    this.network.panByOffset(d, e),
                    this._startTouchClient = c
                }
            } else {
                var h = this.network.getLogicalPoint(a);
                if (!h) return;
                var d = h.x - this._startTouchPoint.x,
                e = h.y - this._startTouchPoint.y;
                Math.abs(d) >= Dd.TOUCH_RECT_SELECT_THRESHOLD && Math.abs(e) >= Dd.TOUCH_RECT_SELECT_THRESHOLD && (this.network.setSelectingElement(!0), this._moveTouchPoint ? this.network.fireInteractionEvent({
                    kind: "selectBetween",
                    event: a
                }) : (this.network.fireInteractionEvent({
                    kind: "selectStart",
                    event: a
                }), this.timer && clearTimeout(this.timer)), this._moveTouchPoint = h, this.repaint())
            }
        },
        handleTouchend: function(a) {
            if (Wb.preventDefault(a), this.network.isMovingElement()) this.network.setMovingElement(!1),
            this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            });
            else if (this.network.isSelectingElement()) {
                var b = Tb.getRect([this._startTouchPoint, this._moveTouchPoint]),
                c = this.network.getElementsAtRect(b, this.getIntersectMode(), this.network.getRectSelectFilter());
                if (c && c.size() > 0) {
                    var d = this.network.getSelectionModel(),
                    e = d.toSelection();
                    c.forEach(function(a) {
                        d.contains(a) ? e.remove(a) : e.add(a)
                    },
                    this),
                    d.setSelection(e)
                }
                this.network.fireInteractionEvent({
                    kind: "selectEnd",
                    event: a
                }),
                this._moveTouchPoint = null,
                this.network.setSelectingElement(!1),
                this.repaint()
            } else if (this._startTouchPoint) {
                this._zoomFlag = !1;
                var f = new Date,
                g = this.network.getLogicalPoint(a),
                h = this.network.getElementAt(this._startTouchPoint);
                g && f.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, g) <= 20 && (h ? this.network.getSelectionModel().contains(h) || this.network.getSelectionModel().setSelection(h) : this.network.getSelectionModel().clearSelection(), Cc.handleClicked(this.network, a, h), this.timer && clearTimeout(this.timer), this._endTouchTime && f.getTime() - this._endTouchTime.getTime() <= 500 && Tb.getDistance(this._endTouchPoint, g) <= 20 ? (delete this._endTouchTime, delete this._endTouchPoint, Cc.handleDoubleClicked(this.network, a, h)) : (this._endTouchTime = f, this._endTouchPoint = g))
            }
        },
        paint: function(a) {
            if (this._startTouchPoint && this._moveTouchPoint) {
                var b = this.convertPointFromView(this._startTouchPoint),
                c = this.convertPointFromView(this._moveTouchPoint),
                d = b.x,
                e = b.y,
                f = c.x,
                g = c.y,
                h = Tb.getRect([{
                    x: d,
                    y: e
                },
                {
                    x: f,
                    y: g
                }]);
                if (null != h) {
                    a.beginPath();
                    var i = this.network.getSelectOutlineWidth(),
                    j = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
                    a.strokeStyle = this.network.getSelectOutlineColor(),
                    a.lineWidth = i,
                    Nd.rect(a, h.x, h.y, h.width, h.height, j, this.network.getSelectOutlineColor()),
                    a.closePath()
                }
            }
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y
        }
    }),
    Ib.canvas.interaction.MSTouchInteraction = function(a) {
        Ib.canvas.interaction.MSTouchInteraction.superClass.constructor.call(this, a),
        this._pointerMap = {},
        this._pointerIdArray = []
    },
    Jb.ext("twaver.canvas.interaction.MSTouchInteraction", Ib.canvas.interaction.BaseInteraction, {
        setUp: function() {
            var a = this.network.getView();
            Wb.addEventListener("MSPointerDown", "handleTouchstart", a, this),
            Wb.addEventListener("MSPointerMove", "handleTouchmove", a, this),
            Wb.addEventListener("MSPointerUp", "handleTouchend", a, this),
            Wb.addEventListener("MSPointerCancel", "handleTouchend", a, this),
            this.network.addMarker(this)
        },
        tearDown: function() {
            var a = this.network.getView();
            Wb.removeEventListener("MSPointerDown", a, this),
            Wb.removeEventListener("MSPointerMove", a, this),
            Wb.removeEventListener("MSPointerUp", a, this),
            Wb.removeEventListener("MSPointerCancel", a, this),
            this.network.removeMarker(this)
        },
        handleTouchstart: function(a) {
            if (this.network.isFocusOnClick() && Ib.Util.setFocus(this.network._view), !this.network.isSelectingElement() || a.pointerType != a.MSPOINTER_TYPE_MOUSE) {
                var b = this.network.getLogicalPoint(a),
                c = new Date;
                if (a.isPrimary && this._pointerIdArray.length > 0 && this.handle_mouseup(a), this._pointerMap[a.pointerId] || (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a), 1 == this._pointerIdArray.length) {
                    var d = this.network.getElementAt(b);
                    this._startTouchElement = d,
                    this._startClientPoint = {
                        x: a.clientX,
                        y: a.clientY
                    },
                    Cc.handleClicked(this.network, a, d),
                    this._startTouchTime && this._startTouchPoint && c.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 20 ? (Cc.handleDoubleClicked(this.network, a, d), this._doubleClick = !0) : (Wb.handle_mousedown(this, a), this._startTouchPoint = b, this._startTouchTime = c);
                    var e = this.network.getSelectionModel();
                    d ? Jb.isCtrlDown(a) ? e.contains(d) ? e.removeSelection(d) : e.appendSelection(d) : e.contains(d) || e.setSelection(d) : Jb.isCtrlDown(a) || e.clearSelection()
                } else 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.network.getZoom())
            }
        },
        handleTouchmove: function(a) {
            if (null != this._startTouchPoint && 0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10) && (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length)) {
                var b = this._getDistance() / this._distance;
                this.network.setZoom(this._zoom * b, !1)
            }
        },
        handleTouchend: function(a) {
            if (this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            })), this.network.isSelectingElement()) {
                var b = Tb.getRect([this._startTouchPoint, this._moveTouchPoint]),
                c = this.network.getElementsAtRect(b, this.getIntersectMode(), this.network.getRectSelectFilter());
                if (c && c.size() > 0) {
                    var d = this.network.getSelectionModel(),
                    e = d.toSelection();
                    c.forEach(function(a) {
                        d.contains(a) ? e.remove(a) : e.add(a)
                    },
                    this),
                    d.setSelection(e)
                }
                this.network.fireInteractionEvent({
                    kind: "selectEnd",
                    event: a
                }),
                this._moveTouchPoint = null,
                this.network.setSelectingElement(!1),
                this.repaint()
            }
            this._doubleClick && (delete this._doubleClick, delete this._startTouchPoint, delete this._startTouchTime);
            for (var f = -1,
            g = 0; g < this._pointerIdArray.length; g++) if (this._pointerIdArray[g] == a.pointerId) {
                f = g;
                break
            }
            f >= 0 && this._pointerIdArray.splice(f, 1),
            delete this._pointerMap[a.pointerId],
            this._startTouchPoint = null,
            this._moveTouchPoint = null
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y
        },
        handle_mousemove: function(a) {
            var b = {
                x: a.clientX,
                y: a.clientY
            };
            if (! (Tb.getDistance(this._startClientPoint, b) < 3) && this._startTouchPoint && 1 == this._pointerIdArray.length) if (this._moveTouchPoint = {
                x: this._startTouchPoint.x + (b.x - this._startClientPoint.x) / this.network.getZoom(),
                y: this._startTouchPoint.y + (b.y - this._startClientPoint.y) / this.network.getZoom()
            },
            null == this._startTouchElement && this.network.isRectSelectEnabled()) {
                var c = this.network.getLogicalPoint(a);
                if (!c) return;
                this.network.setSelectingElement(!0),
                this.network.fireInteractionEvent(this._moveTouchPoint ? {
                    kind: "selectBetween",
                    event: a
                }: {
                    kind: "selectStart",
                    event: a
                }),
                this.repaint()
            } else {
                var d = this.network.getElementAt(this._moveTouchPoint);
                if (null != this._startTouchElement || this.network.isRectSelectEnabled()) {
                    if (this.network.isMovingElement() || null != this._startTouchElement && d == this._startTouchElement && this.network.getMovableSelectedElements().contains(d)) {
                        var e = this._moveTouchPoint.x - this._startTouchPoint.x,
                        f = this._moveTouchPoint.y - this._startTouchPoint.y;
                        this.network.moveSelectedElements(e, f),
                        this.network.isMovingElement() ? this.network.fireInteractionEvent({
                            kind: "liveMoveBetween",
                            event: a
                        }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                            kind: "liveMoveStart",
                            event: a
                        }))
                    }
                } else {
                    var e = this._startClientPoint.x - b.x,
                    f = this._startClientPoint.y - b.y;
                    this.network.panByOffset(e, f)
                }
                this._startClientPoint = b
            }
        },
        handle_mouseup: function(a) {
            this.handleTouchend(a),
            this._pointerIdArray = [],
            this._pointerMap = {}
        },
        paint: function(a) {
            if (this._startTouchPoint && this._moveTouchPoint && !this._startTouchElement && this.network.isRectSelectEnabled()) {
                var b = this.convertPointFromView(this._startTouchPoint),
                c = this.convertPointFromView(this._moveTouchPoint),
                d = b.x,
                e = b.y,
                f = c.x,
                g = c.y,
                h = Tb.getRect([{
                    x: d,
                    y: e
                },
                {
                    x: f,
                    y: g
                }]);
                if (null != h) {
                    a.beginPath();
                    var i = this.network.getSelectOutlineWidth(),
                    j = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
                    a.strokeStyle = this.network.getSelectOutlineColor(),
                    a.lineWidth = i,
                    Nd.rect(a, h.x, h.y, h.width, h.height, j, this.network.getSelectOutlineColor()),
                    a.closePath()
                }
            }
        }
    });
    var Od = function(a, b) {
        Jb.registerImage(a, b),
        Pd[a] = 1
    },
    Pd = {};
    Od("node_image", {
        w: 32,
        h: 24,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M32,23.5c0,0.276-0.224,0.5-0.5,0.5h-31C0.224,24,0,23.776,0,23.5v-2C0,21.224,0.224,21,0.5,21h31  c0.276,0,0.5,0.224,0.5,0.5V23.5z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: "15.9995",
                y1: "21",
                x2: "15.9995",
                y2: "24",
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M15,22.3c0-0.165-0.134-0.3-0.3-0.3H3.3C3.134,22,3,22.135,3,22.3V24h12V22.3z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: "9",
                y1: "22",
                x2: "9",
                y2: "25",
                stop: [{
                    offset: "0",
                    color: "#69B4A5"
                },
                {
                    offset: "0.1",
                    color: "#61AD9C"
                }]
            }
        },
        {
            shape: "path",
            data: "M31,20H1V1c0-0.553,0.448-1,1-1h28c0.553,0,1,0.447,1,1V20z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: "15.9995",
                y1: "-0.1221",
                x2: "15.9995",
                y2: "19.9471",
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 2,
            y: 1,
            w: 28,
            h: 18,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 3,
            y: 2,
            w: 26,
            h: 16,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: "15.9995",
                y1: "2.0654",
                x2: "15.9995",
                y2: "17.3835",
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#0089C1"
                }]
            }
        },
        {
            shape: "path",
            data: "9.649,17.034 6.815,17.034 9.935,2.966 12.768,2.966 z",
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "12.065,17.034 10.815,17.034 13.935,2.966 15.185,2.966 z",
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "14.065,17.034 13.315,17.034 16.435,2.966 17.185,2.966 z",
            fill: "#FFFFFF"
        }]
    }),
    Od("group_image", {
        w: 32,
        h: 24,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M32,16.5c0,0.276-0.224,0.5-0.5,0.5h-24C7.224,17,7,16.776,7,16.5v-1C7,15.224,7.224,15,7.5,15h24   c0.276,0,0.5,0.224,0.5,0.5V16.5z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: "19.5",
                y1: "15",
                x2: "19.5",
                y2: "17",
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M19,16.5c0-0.277-0.224-0.5-0.5-0.5h-8c-0.276,0-0.5,0.223-0.5,0.5V17h9V16.5z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: "14.4995",
                y1: "15.9209",
                x2: "14.4995",
                y2: "17.0459",
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M31,14H8V1c0-0.553,0.448-1,1-1h21c0.553,0,1,0.447,1,1V14z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: "19.5",
                y1: "0",
                x2: "19.5",
                y2: "14.0005",
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 9,
            y: 1,
            w: 21,
            h: 12,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 10,
            y: 2,
            w: 19,
            h: 10,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: "19.5",
                y1: "1.9619",
                x2: "19.5",
                y2: "11.9744",
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M25,23.5c0,0.276-0.224,0.5-0.5,0.5h-24C0.224,24,0,23.776,0,23.5v-1C0,22.224,0.224,22,0.5,22h24   c0.276,0,0.5,0.224,0.5,0.5V23.5z",
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: "12.4995",
                y1: "22",
                x2: "12.4995",
                y2: "24",
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M12,23.5c0-0.277-0.224-0.5-0.5-0.5h-8C3.224,23,3,23.223,3,23.5V24h9V23.5z",
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: "7.5",
                y1: "22.9209",
                x2: "7.5",
                y2: "24.0459",
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M24,21H1V8c0-0.553,0.448-1,1-1h21c0.553,0,1,0.447,1,1V21z",
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: "12.4995",
                y1: "7",
                x2: "12.4995",
                y2: "21.0005",
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 2,
            y: 8,
            w: 21,
            h: 12,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 3,
            y: 9,
            w: 19,
            h: 10,
            gradient: {
                id: "SVGID_8_",
                type: "linear",
                x1: "12.4995",
                y1: "8.9619",
                x2: "12.4995",
                y2: "18.9749",
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#0089C1"
                }]
            }
        }]
    }),
    Od("subnetwork_image", {
        w: 32,
        h: 24,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M32,14.499c0,0.276-0.224,0.5-0.5,0.5h-20c-0.276,0-0.5-0.224-0.5-0.5v-1c0-0.276,0.224-0.5,0.5-0.5  h20c0.276,0,0.5,0.224,0.5,0.5V14.499z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 21.5,
                y1: 12.999,
                x2: 21.5,
                y2: 14.9995,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M22,14.499c0-0.277-0.224-0.5-0.5-0.5h-7c-0.276,0-0.5,0.223-0.5,0.5v0.5h8V14.499z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 18,
                y1: 13.9199,
                x2: 18,
                y2: 15.0449,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M31,11.499c0,0.276-0.224,0.5-0.5,0.5h-18c-0.276,0-0.5-0.224-0.5-0.5v-11c0-0.276,0.224-0.5,0.5-0.5  h18c0.276,0,0.5,0.224,0.5,0.5V11.499z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 21.5,
                y1: -.9502,
                x2: 21.5,
                y2: 12.5498,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 13,
            y: .999,
            w: 17,
            h: 10,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 14,
            y: 1.999,
            w: 15,
            h: 8,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 21.5,
                y1: 1.9312,
                x2: 21.5,
                y2: 9.6537,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M21,23.5c0,0.276-0.224,0.5-0.5,0.5h-20C0.224,24,0,23.776,0,23.5v-1C0,22.224,0.224,22,0.5,22h20  c0.276,0,0.5,0.224,0.5,0.5V23.5z",
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 10.4995,
                y1: 22,
                x2: 10.4995,
                y2: 24,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 22,
            y: 20.5,
            w: 3,
            h: 1.999,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: -464.9424,
                y1: -722.2754,
                x2: -462.9424,
                y2: -722.2754,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "rect",
            x: 28,
            y: 16,
            w: 2,
            h: 3,
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 29,
                y1: 16,
                x2: 29,
                y2: 19,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M11,23.5c0-0.277-0.224-0.5-0.5-0.5h-7C3.224,23,3,23.223,3,23.5V24h8V23.5z",
            gradient: {
                id: "SVGID_8_",
                type: "linear",
                x1: 7,
                y1: 22.9209,
                x2: 7,
                y2: 24.0459,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M20,20.5c0,0.276-0.224,0.5-0.5,0.5h-18C1.224,21,1,20.776,1,20.5v-11C1,9.224,1.224,9,1.5,9h18  C19.776,9,20,9.224,20,9.5V20.5z",
            gradient: {
                id: "SVGID_9_",
                type: "linear",
                x1: 10.4995,
                y1: 8.0508,
                x2: 10.4995,
                y2: 21.5513,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 2,
            y: 10,
            w: 17,
            h: 10,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 3,
            y: 11,
            w: 15,
            h: 8,
            gradient: {
                id: "SVGID_10_",
                type: "linear",
                x1: 10.4995,
                y1: 10.9321,
                x2: 10.4995,
                y2: 18.6551,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#0089C1"
                }]
            }
        },
        {
            shape: "path",
            data: "M32,22.7c0,0.165-0.135,0.3-0.301,0.3h-5.4C26.134,23,26,22.865,26,22.7v-2.4  c0-0.165,0.134-0.3,0.299-0.3h5.4C31.865,20,32,20.135,32,20.3V22.7z",
            gradient: {
                id: "SVGID_11_",
                type: "linear",
                x1: 29,
                y1: 20,
                x2: 29,
                y2: 23,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        }]
    }),
    Od("bus_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "rect",
            x: 4,
            y: 6,
            w: 1,
            h: 1,
            fill: "#232424"
        },
        {
            shape: "path",
            data: "M7,4c0,0.552-0.448,1-1,1H3C2.448,5,2,4.552,2,4V3c0-0.552,0.448-1,1-1h3c0.552,0,1,0.448,1,1V4z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 4.5,
                y1: 2,
                x2: 4.5,
                y2: 5,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 3,
            y: 3,
            w: 3,
            h: 1,
            fill: "#232424"
        },
        {
            shape: "rect",
            x: 3,
            y: 3,
            w: 3,
            h: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "M6,5.5C6,5.776,5.776,6,5.5,6h-2C3.224,6,3,5.776,3,5.5l0,0C3,5.224,3.224,5,3.5,5h2  C5.776,5,6,5.224,6,5.5L6,5.5z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 4.5,
                y1: 6,
                x2: 4.5,
                y2: 5,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 12,
            y: 6,
            w: 1,
            h: 1,
            fill: "#232424"
        },
        {
            shape: "path",
            data: "M15,4c0,0.552-0.447,1-1,1h-3c-0.553,0-1-0.448-1-1V3c0-0.552,0.447-1,1-1h3c0.553,0,1,0.448,1,1V4z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 12.5,
                y1: 2,
                x2: 12.5,
                y2: 5,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 11,
            y: 3,
            w: 3,
            h: 1,
            fill: "#232424"
        },
        {
            shape: "rect",
            x: 11,
            y: 3,
            w: 3,
            h: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "M14,5.5C14,5.776,13.777,6,13.5,6h-2C11.225,6,11,5.776,11,5.5l0,0C11,5.224,11.225,5,11.5,5h2  C13.777,5,14,5.224,14,5.5L14,5.5z",
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 12.5,
                y1: 6,
                x2: 12.5,
                y2: 5,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 8,
            y: 10,
            w: 1,
            h: 1,
            fill: "#232424"
        },
        {
            shape: "path",
            data: "M6,13c0-0.553,0.448-1,1-1h3c0.553,0,1,0.447,1,1v1c0,0.553-0.447,1-1,1H7c-0.552,0-1-0.447-1-1V13z",
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: -1428.3853,
                y1: -571.5747,
                x2: -1428.3853,
                y2: -568.5747,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 7,
            y: 13,
            w: 3,
            h: 1,
            fill: "#232424"
        },
        {
            shape: "rect",
            x: 7,
            y: 13,
            w: 3,
            h: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "M7,11.5C7,11.223,7.224,11,7.5,11h2c0.277,0,0.5,0.223,0.5,0.5l0,0c0,0.275-0.223,0.5-0.5,0.5h-2  C7.224,12,7,11.775,7,11.5L7,11.5z",
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: -1428.3862,
                y1: -567.5737,
                x2: -1428.3862,
                y2: -568.5737,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M15,7.5C15,7.776,14.777,8,14.5,8h-12C2.224,8,2,7.776,2,7.5l0,0C2,7.224,2.224,7,2.5,7h12  C14.777,7,15,7.224,15,7.5L15,7.5z",
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 8.4995,
                y1: 6.1152,
                x2: 8.4995,
                y2: 7.5558,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M15,9.5c0,0.275-0.223,0.5-0.5,0.5h-12C2.224,10,2,9.775,2,9.5l0,0C2,9.223,2.224,9,2.5,9h12  C14.777,9,15,9.223,15,9.5L15,9.5z",
            gradient: {
                id: "SVGID_8_",
                type: "linear",
                x1: 8.4995,
                y1: 8.1147,
                x2: 8.4995,
                y2: 9.556,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        }]
    }),
    Od("data_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M15,12c0,0.553-0.447,1-1,1H7c-0.552,0-1-0.447-1-1V8c0-0.552,0.448-1,1-1h7c0.553,0,1,0.448,1,1V12   z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 10.5,
                y1: 6.959,
                x2: 10.5,
                y2: 12.2259,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 7,
            y: 8,
            w: 7,
            h: 4,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 8,
            y: 9,
            w: 5,
            h: 2,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 10.5,
                y1: 8.6997,
                x2: 10.5,
                y2: 11.0333,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M15,14.5c0,0.275-0.225,0.5-0.5,0.5h-8C6.224,15,6,14.775,6,14.5l0,0C6,14.223,6.224,14,6.5,14h8   C14.775,14,15,14.223,15,14.5L15,14.5z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 10.5,
                y1: 13.125,
                x2: 10.5,
                y2: 14.5518,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 8,
            y: 14,
            w: 1,
            h: 1,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 8.4995,
                y1: 14.0049,
                x2: 8.4995,
                y2: 14.9471,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M12,4H6c0,0-0.152-0.275-0.5-1C5.021,2,5.021,2,4,2C3.057,2,2,2,2,2C1.448,2,1,2.448,1,3v8  c0,0.553,0.448,1,1,1h3v-1H2V3h2.387l1.024,1.998L12,5v1h1V5C13,4.448,12.553,4,12,4z",
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 6.9995,
                y1: 2.0527,
                x2: 6.9995,
                y2: 11.4757,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M12,5L5.411,4.998L4.387,3H2v8h3v-0.645V7.254V7c0-0.552,0.448-1,1-1h0.324h3.032H12V5z",
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 6.9995,
                y1: 2.9902,
                x2: 6.9995,
                y2: 11.0032,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        }]
    }),
    Od("grid_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M15,14c0,0.553-0.447,1-1,1H3c-0.552,0-1-0.447-1-1V3c0-0.552,0.448-1,1-1h11c0.553,0,1,0.448,1,1V14  z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 8.4995,
                y1: 2.1255,
                x2: 8.4995,
                y2: 14.909,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 3,
            y: 3,
            w: 11,
            h: 11,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 3,
            y: 5,
            w: 11,
            h: 1,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 8.4995,
                y1: 3.209,
                x2: 8.4995,
                y2: 13.8043,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 3,
            y: 8,
            w: 11,
            h: 1,
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 8.4995,
                y1: 3.209,
                x2: 8.4995,
                y2: 13.8043,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 3,
            y: 11,
            w: 11,
            h: 1,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 8.4995,
                y1: 3.2095,
                x2: 8.4995,
                y2: 13.8048,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 11,
            y: 3,
            w: 1,
            h: 11,
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 11.5,
                y1: 3.209,
                x2: 11.5,
                y2: 13.8048,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 8,
            y: 3,
            w: 1,
            h: 11,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 8.4995,
                y1: 3.209,
                x2: 8.4995,
                y2: 13.8048,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "rect",
            x: 5,
            y: 3,
            w: 1,
            h: 11,
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 5.5,
                y1: 3.209,
                x2: 5.5,
                y2: 13.8048,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        }]
    }),
    Od("databox_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M14.5,6h-12H2v0.5v7C2,13.776,2.224,14,2.5,14h12c0.276,0,0.5-0.224,0.5-0.5v-7V6H14.5z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 8.4995,
                y1: 6.0625,
                x2: 8.4995,
                y2: 14.063,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M14.776,5.553l-1.553-3.105C13.101,2.201,12.775,2,12.5,2h-8C4.225,2,3.899,2.201,3.776,2.447  L2.224,5.553L2,6h0.5h12H15L14.776,5.553z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 8.5005,
                y1: 3.104,
                x2: 8.5005,
                y2: -5.6467,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "12,2 9.5,2 7.5,2 5,2 3,6 7.5,6 9.5,6 14,6 z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 8.5005,
                y1: 9.2295,
                x2: 8.5005,
                y2: 5.4586,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M11.5,9c0,0.276-0.224,0.5-0.5,0.5H6C5.724,9.5,5.5,9.276,5.5,9l0,0c0-0.276,0.224-0.5,0.5-0.5h5  C11.276,8.5,11.5,8.724,11.5,9L11.5,9z",
            fill: "#FFFFFF"
        }]
    }),
    Od("group_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M15,8.5C15,8.776,14.776,9,14.5,9h-10C4.224,9,4,8.776,4,8.5v-7C4,1.224,4.224,1,4.5,1h10    C14.776,1,15,1.224,15,1.5V8.5z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 9.5,
                y1: .9512,
                x2: 9.5,
                y2: 8.9787,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 5,
            y: 2,
            w: 9,
            h: 6,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 6,
            y: 3,
            w: 7,
            h: 4,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 9.5,
                y1: 3.02,
                x2: 9.5,
                y2: 6.9606,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M16,10.5c0,0.276-0.224,0.5-0.5,0.5h-12C3.224,11,3,10.776,3,10.5l0,0C3,10.224,3.224,10,3.5,10h12    C15.776,10,16,10.224,16,10.5L16,10.5z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 9.5,
                y1: 9.9941,
                x2: 9.5,
                y2: 10.9976,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 6,
            y: 10.001,
            w: 2,
            h: .999,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 7,
                y1: 10.0059,
                x2: 7,
                y2: 10.9472,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M12,12.5c0,0.276-0.224,0.5-0.5,0.5h-10C1.224,13,1,12.776,1,12.5v-7C1,5.224,1.224,5,1.5,5h10    C11.776,5,12,5.224,12,5.5V12.5z",
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 6.4995,
                y1: 4.9512,
                x2: 6.4995,
                y2: 12.9792,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 2,
            y: 6,
            w: 9,
            h: 6,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 3,
            y: 7,
            w: 7,
            h: 4,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 6.4995,
                y1: 7.02,
                x2: 6.4995,
                y2: 10.9611,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M13,14.5c0,0.276-0.224,0.5-0.5,0.5h-12C0.224,15,0,14.776,0,14.5l0,0C0,14.224,0.224,14,0.5,14h12    C12.776,14,13,14.224,13,14.5L13,14.5z",
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 6.4995,
                y1: 13.9941,
                x2: 6.4995,
                y2: 14.9976,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 3,
            y: 14.001,
            w: 2,
            h: .999,
            gradient: {
                id: "SVGID_8_",
                type: "linear",
                x1: 4,
                y1: 14.0059,
                x2: 4,
                y2: 14.9472,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        }]
    }),
    Od("link_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "line",
            p1: {
                x: 2.5,
                y: 2.5
            },
            p2: {
                x: 13.5,
                y: 13.5
            },
            lineColor: "url(#SVGID_1_)",
            lineWidth: 1
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 13,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 11.5371,
                y1: 11.5371,
                x2: 14.2155,
                y2: 14.2155,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 13,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 3,
            cy: 3,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 1.4956,
                y1: 1.4956,
                x2: 4.1473,
                y2: 4.1473,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 3,
            cy: 3,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        }]
    }),
    Od("linksubnetwork_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M15,7.661c0-1.202-0.642-2.247-1.596-2.835C12.848,3.188,11.314,2,9.486,2  c-1.587,0-2.95,0.902-3.649,2.211C4.573,4.22,3.548,5.194,3.438,6.432C3.389,6.429,3.342,6.417,3.292,6.417  C2.026,6.417,1,7.443,1,8.708C1,9.975,2.026,11,3.292,11h8.371l0,0C13.506,11,15,9.506,15,7.661z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 7.9995,
                y1: 1.959,
                x2: 7.9995,
                y2: 11.0921,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M3.292,10C2.58,10,2,9.42,2,8.708c0-0.712,0.58-1.292,1.292-1.292C3.286,7.422,3.332,7.427,3.379,7.43  l0.969,0.058L4.435,6.52C4.5,5.779,5.106,5.216,5.844,5.211l0.595-0.004l0.28-0.524C7.273,3.645,8.334,3,9.486,3  c1.342,0,2.535,0.863,2.971,2.147l0.116,0.341l0.307,0.189C13.581,6.11,14,6.851,14,7.661C14,8.951,12.951,10,11.661,10H3.292z",
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "M3.292,10h8.37c1.11,0,2.04-0.781,2.276-1.821c-0.131-0.615-0.5-1.158-1.058-1.501l-0.307-0.189  l-0.116-0.341C12.021,4.863,10.828,4,9.486,4C8.334,4,7.273,4.645,6.719,5.682l-0.28,0.524L5.844,6.211  C5.106,6.216,4.5,6.779,4.435,7.52L4.349,8.487L3.379,8.43C3.332,8.427,3.286,8.422,3.292,8.417c-0.535,0-0.994,0.328-1.19,0.792  C2.297,9.672,2.757,10,3.292,10z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 8.019,
                y1: 4.084,
                x2: 8.019,
                y2: 9.8062,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "line",
            p1: {
                x: 8.01,
                y: 8.01
            },
            p2: {
                x: 13.186,
                y: 13.186
            },
            lineColor: "url(#SVGID_3_)",
            lineWidth: 1
        },
        {
            shape: "ellipse",
            cx: 8,
            cy: 8,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 6.7881,
                y1: 6.7881,
                x2: 9.9924,
                y2: 9.9924,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 8,
            cy: 8,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 13,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 11.5791,
                y1: 11.5791,
                x2: 14.3132,
                y2: 14.3132,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 13,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        }]
    }),
    Od("node_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M15,11.5c0,0.276-0.224,0.5-0.5,0.5h-13C1.224,12,1,11.776,1,11.5v-9C1,2.224,1.224,2,1.5,2h13  C14.776,2,15,2.224,15,2.5V11.5z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 7.9995,
                y1: 1.939,
                x2: 7.9995,
                y2: 11.9739,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 2,
            y: 3,
            w: 12,
            h: 8,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 3,
            y: 4,
            w: 10,
            h: 6,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 7.9995,
                y1: 4.0513,
                x2: 7.9995,
                y2: 9.865,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M16,14.5c0,0.276-0.224,0.5-0.5,0.5h-15C0.224,15,0,14.776,0,14.5v-1C0,13.224,0.224,13,0.5,13h15  c0.276,0,0.5,0.224,0.5,0.5V14.5z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 7.9995,
                y1: 13.0508,
                x2: 7.9995,
                y2: 14.9258,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M9,14.5C9,14.224,8.776,14,8.5,14h-5C3.224,14,3,14.224,3,14.5V15h6V14.5z",
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 5.9995,
                y1: 14.0508,
                x2: 5.9995,
                y2: 15.9258,
                stop: [{
                    offset: "0",
                    color: "#69B4A5"
                },
                {
                    offset: "0.1",
                    color: "#61AD9C"
                },
                {
                    offset: "0.4637",
                    color: "#449981"
                },
                {
                    offset: "0.7764",
                    color: "#2C8E73"
                },
                {
                    offset: "1",
                    color: "#218A6E"
                }]
            }
        }]
    }),
    Od("shapelink_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "line",
            p1: {
                x: 7.5,
                y: 2.5
            },
            p2: {
                x: 2.5,
                y: 7.5
            },
            lineColor: "url(#SVGID_1_)",
            lineWidth: 1
        },
        {
            shape: "line",
            p1: {
                x: 2.5,
                y: 7.5
            },
            p2: {
                x: 8.5,
                y: 13.5
            },
            lineColor: "url(#SVGID_2_)",
            lineWidth: 1
        },
        {
            shape: "line",
            p1: {
                x: 9,
                y: 13.186
            },
            p2: {
                x: 13.5,
                y: 6.5
            },
            lineColor: "url(#SVGID_3_)",
            lineWidth: 1
        },
        {
            shape: "ellipse",
            cx: 7,
            cy: 3,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 5.5864,
                y1: 1.5864,
                x2: 8.4149,
                y2: 4.4149,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 7,
            cy: 3,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 2,
            cy: 8,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: .5864,
                y1: 6.5864,
                x2: 3.4142,
                y2: 9.4142,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 2,
            cy: 8,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 8,
            cy: 13,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 6.5869,
                y1: 11.5869,
                x2: 9.4147,
                y2: 14.4147,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 8,
            cy: 13,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 7,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 11.5859,
                y1: 5.5859,
                x2: 14.4144,
                y2: 8.4144,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 7,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        }]
    }),
    Od("shapenode_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M14.5,3h-9l-4,4v7h13L9,8.5L14.5,3z M12.086,13H2.5V7.414L5.914,4h6.172l-4.5,4.5L12.086,13z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 7.9995,
                y1: 3.209,
                x2: 7.9995,
                y2: 13.6621,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 6,
            cy: 3,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 4.5859,
                y1: 1.5859,
                x2: 7.4151,
                y2: 4.4151,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 6,
            cy: 3,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 3,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 11.5869,
                y1: 1.5864,
                x2: 14.4153,
                y2: 4.4149,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 13,
            cy: 3,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 9,
            cy: 8,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 7.5864,
                y1: 6.5864,
                x2: 10.4149,
                y2: 9.4149,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 9,
            cy: 8,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 2,
            cy: 7,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: .5859,
                y1: 5.5859,
                x2: 3.4144,
                y2: 8.4144,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 2,
            cy: 7,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 12.825,
            cy: 13,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 11.4111,
                y1: 11.5869,
                x2: 14.2396,
                y2: 14.4153,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 12.825,
            cy: 13,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        }]
    }),
    Od("shapesubnetwork_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "path",
            data: "M15,6.661c0-1.202-0.642-2.247-1.596-2.835C12.848,2.188,11.314,1,9.486,1  c-1.587,0-2.95,0.902-3.649,2.211C4.573,3.22,3.548,4.194,3.438,5.432C3.389,5.429,3.342,5.417,3.292,5.417  C2.026,5.417,1,6.443,1,7.708S2.026,10,3.292,10h8.371l0,0C13.506,10,15,8.505,15,6.661z",
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 7.9995,
                y1: 1.3755,
                x2: 7.9995,
                y2: 9.733,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "M3.292,9C2.58,9,2,8.42,2,7.708s0.58-1.292,1.292-1.292C3.286,6.422,3.332,6.427,3.379,6.43l0.969,0.058  L4.435,5.52C4.5,4.779,5.106,4.216,5.844,4.211l0.595-0.004l0.28-0.524C7.273,2.645,8.334,2,9.486,2  c1.342,0,2.535,0.863,2.971,2.147l0.116,0.341l0.307,0.189C13.581,5.11,14,5.851,14,6.661C14,7.951,12.951,9,11.661,9H3.292z",
            fill: "#FFFFFF"
        },
        {
            shape: "path",
            data: "M3.272,9h8.37c1.11,0,2.039-0.689,2.275-1.729c-0.131-0.615-0.499-1.249-1.057-1.593l-0.307-0.189  l-0.116-0.341C12.002,3.863,10.809,3,9.468,3C8.314,3,7.254,3.645,6.7,4.682L6.42,5.207L5.825,5.211  C5.087,5.216,4.481,5.779,4.416,6.52L4.33,7.487L3.36,7.43C3.313,7.427,3.267,7.422,3.272,7.417c-0.535,0-0.994,0.327-1.19,0.792  C2.278,8.672,2.738,9,3.272,9z",
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 7.9995,
                y1: 3.459,
                x2: 7.9995,
                y2: 8.4597,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M11.516,7.102h-8l2.469,6h8.5L11.516,7.102z M5.024,8.123h5.905l1.938,3.979H6.662L5.024,8.123z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 7.4443,
                y1: 7.1724,
                x2: 10.1111,
                y2: 12.8383,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "path",
            data: "5,8.112 10.904,8.112 12.842,12.092 6.638,12.092 z",
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 5,
            cy: 8,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 3,
                y1: 8,
                x2: 7,
                y2: 8,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 5,
            cy: 8,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 12,
            cy: 8,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 10,
                y1: 8,
                x2: 14,
                y2: 8,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 12,
            cy: 8,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 7,
            cy: 12,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 5,
                y1: 12,
                x2: 9,
                y2: 12,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 7,
            cy: 12,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        },
        {
            shape: "ellipse",
            cx: 14,
            cy: 12,
            rx: 2,
            ry: 2,
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 12,
                y1: 12,
                x2: 16,
                y2: 12,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "ellipse",
            cx: 14,
            cy: 12,
            rx: 1,
            ry: 1,
            fill: "#FFFFFF"
        }]
    }),
    Od("subnetwork_icon", {
        w: 16,
        h: 16,
        origin: {
            x: 0,
            y: 0
        },
        v: [{
            shape: "rect",
            x: 10,
            y: 14.001,
            w: 2,
            h: 1,
            gradient: {
                id: "SVGID_1_",
                type: "linear",
                x1: 11,
                y1: 14.0059,
                x2: 11,
                y2: 14.9481,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "rect",
            x: 14,
            y: 10.001,
            w: 1,
            h: 2,
            gradient: {
                id: "SVGID_2_",
                type: "linear",
                x1: 14.5,
                y1: 10.0117,
                x2: 14.5,
                y2: 11.8962,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M16,6.001c0,0.552-0.447,1-1,1H8c-0.552,0-1-0.448-1-1v-4c0-0.552,0.448-1,1-1h7   c0.553,0,1,0.448,1,1V6.001z",
            gradient: {
                id: "SVGID_3_",
                type: "linear",
                x1: 11.5,
                y1: .96,
                x2: 11.5,
                y2: 6.2265,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 8,
            y: 2.001,
            w: 7,
            h: 4,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 9,
            y: 3.001,
            w: 5,
            h: 2,
            gradient: {
                id: "SVGID_4_",
                type: "linear",
                x1: 11.5,
                y1: 2.7007,
                x2: 11.5,
                y2: 5.0337,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M16,8.501c0,0.276-0.225,0.5-0.5,0.5h-8c-0.276,0-0.5-0.224-0.5-0.5l0,0c0-0.276,0.224-0.5,0.5-0.5   h8C15.775,8.001,16,8.225,16,8.501L16,8.501z",
            gradient: {
                id: "SVGID_5_",
                type: "linear",
                x1: 11.5,
                y1: 7.126,
                x2: 11.5,
                y2: 8.5535,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 9,
            y: 8.001,
            w: 1,
            h: .999,
            gradient: {
                id: "SVGID_6_",
                type: "linear",
                x1: 9.5,
                y1: 8.0063,
                x2: 9.5,
                y2: 8.9477,
                stop: [{
                    offset: "0",
                    color: "#58AC9A"
                },
                {
                    offset: "1",
                    color: "#248576"
                }]
            }
        },
        {
            shape: "path",
            data: "M9,12c0,0.553-0.447,1-1,1H1c-0.552,0-1-0.447-1-1V8c0-0.552,0.448-1,1-1h7c0.553,0,1,0.448,1,1V12z   ",
            gradient: {
                id: "SVGID_7_",
                type: "linear",
                x1: 4.4995,
                y1: 6.959,
                x2: 4.4995,
                y2: 12.2259,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 1,
            y: 8,
            w: 7,
            h: 4,
            fill: "#FFFFFF"
        },
        {
            shape: "rect",
            x: 2,
            y: 9,
            w: 5,
            h: 2,
            gradient: {
                id: "SVGID_8_",
                type: "linear",
                x1: 4.5,
                y1: 8.6997,
                x2: 4.5,
                y2: 11.0333,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M9,14.5C9,14.776,8.775,15,8.5,15h-8C0.224,15,0,14.776,0,14.5l0,0C0,14.224,0.224,14,0.5,14h8   C8.775,14,9,14.224,9,14.5L9,14.5z",
            gradient: {
                id: "SVGID_9_",
                type: "linear",
                x1: 4.4995,
                y1: 13.125,
                x2: 4.4995,
                y2: 14.5518,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        },
        {
            shape: "rect",
            x: 2,
            y: 14,
            w: 1,
            h: 1,
            gradient: {
                id: "SVGID_10_",
                type: "linear",
                x1: 2.5,
                y1: 14.0049,
                x2: 2.5,
                y2: 14.9471,
                stop: [{
                    offset: "0",
                    color: "#61B7D9"
                },
                {
                    offset: "1",
                    color: "#005EAD"
                }]
            }
        },
        {
            shape: "path",
            data: "M16,14.501c0,0.276-0.224,0.5-0.5,0.5h-2c-0.276,0-0.5-0.224-0.5-0.5v-1c0-0.276,0.224-0.5,0.5-0.5  h2c0.276,0,0.5,0.224,0.5,0.5V14.501z",
            gradient: {
                id: "SVGID_11_",
                type: "linear",
                x1: 14.5,
                y1: 13.0117,
                x2: 14.5,
                y2: 14.8962,
                stop: [{
                    offset: "0",
                    color: "#666767"
                },
                {
                    offset: "1",
                    color: "#232424"
                }]
            }
        }]
    });
    var Nd = {
        _hitCanvas: null,
        getHitCanvas: function(a, b) {
            null == this._hitCanvas && (this._hitCanvas = Wb.createCanvas()),
            0 == arguments.length && (a = 2, b = 2),
            this._hitCanvas.setAttribute("width", "" + a - 1),
            this._hitCanvas.setAttribute("height", "" + b - 1),
            this._hitCanvas.setAttribute("width", "" + a),
            this._hitCanvas.setAttribute("height", "" + b);
            var c = this.getCtx(this._hitCanvas);
            return c.clearRect(0, 0, a, b),
            this._hitCanvas
        },
        disposeHitCanvas: function() {
            this._hitCanvas = null
        },
        getCtx: function(a) {
            return a.getContext("2d")
        },
        render: function(a, c, d) {
            c != b && (a.fillStyle = c, a.fill()),
            d != b && (a.strokeStyle = d, a.stroke())
        },
        text: function(a, b, c, d, e, f) {
            a.textAlign = "center",
            a.textBaseline = "middle",
            null != e && (a.fillStyle = e, a.fillText(b, c, d)),
            f && (a.strokeStyle = f, a.strokeText(b, c, d))
        },
        circle: function(a, b, c, d, e, f) {
            a.arc(b, c, d, 0, 2 * Math.PI, !0),
            a.closePath(),
            this.render(a, e, f)
        },
        rect: function(a, b, c, d, e, f, g) {
            a.rect(b, c, d, e),
            a.closePath(),
            this.render(a, f, g)
        },
        OUT_LEFT: 1,
        OUT_TOP: 2,
        OUT_RIGHT: 4,
        OUT_BOTTOM: 8,
        outcode: function(a, b, c, d, e, f) {
            var g = 0;
            return 0 >= e ? g |= this.OUT_LEFT | this.OUT_RIGHT: c > a ? g |= this.OUT_LEFT: a > c + e && (g |= this.OUT_RIGHT),
            0 >= f ? g |= this.OUT_TOP | this.OUT_BOTTOM: d > b ? g |= this.OUT_TOP: b > d + f && (g |= this.OUT_BOTTOM),
            g
        },
        intersectsLine: function(a, b, c, d, e, f, g, h) {
            var i, j;
            if (0 == (j = this.outcode(c, d, e, f, g, h))) return ! 0;
            for (; 0 != (i = this.outcode(a, b, e, f, g, h));) {
                if (0 != (i & j)) return ! 1;
                if (0 != (i & (this.OUT_LEFT | this.OUT_RIGHT))) {
                    var k = e;
                    0 != (i & this.OUT_RIGHT) && (k += g),
                    b += (k - a) * (d - b) / (c - a),
                    a = k
                } else {
                    var l = f;
                    0 != (i & this.OUT_BOTTOM) && (l += h),
                    a += (l - b) * (c - a) / (d - b),
                    b = l
                }
            }
            return ! 0
        }
    };
    Ib.vector = {},
    Ib.vector.interaction = {},
    Ib.vector.Network = function(a) {
        Ib.vector.Network.superClass.constructor.apply(this, arguments),
        this.zoomManager = new Ib.vector.PhysicalZoomManager(this),
        this._view = Wb.createView("hidden"),
        this._rootCanvas = Wb.createCanvas(),
        this._topCanvas = Wb.createCanvas(),
        this._view.appendChild(this._rootCanvas),
        this._view.appendChild(this._topCanvas),
        this.realWidth = 0,
        this.realHeight = 0,
        this._unionBounds = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._zoom = 1,
        this._elementUIMap = {},
        this._zoomMap = {},
        this._viewRectMap = {},
        this.viewRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this.hScrollBarVisible = !1,
        this.vScrollBarVisible = !1,
        this.markerList = new Ib.List,
        this._topAttachmentList = new Ib.List,
        this._hitTestTopAttachmentList = new Ib.List,
        this.setElementBox(a ? a: new Ib.ElementBox),
        Qb.isMSToucheable ? this.setMSTouchInteractions() : this.setDefaultInteractions(!1);
        var b = this;
        this._flowLink = function() {
            if (! (b.isMovingElement() || b.isSelectingElement() || b.isEditingElement() || b._box._layoutMovingElements)) {
                b._flowLinkQuickFinder || (b._flowLinkQuickFinder = new Ib.QuickFinder(b._box, "link.flow", "style"));
                var a = b._flowLinkQuickFinder.find(!0);
                a.forEach(function(a) {
                    a._styleMap["link.flow.offset"] = b.getLinkFlowOffset(a),
                    b.invalidateElementUI(a)
                })
            }
        },
        this.setToolTipEnabled(Ib.Defaults.NETWORK_TOOLTIP_ENABLED),
        this._paintAll = !0,
        this._dirtyRects = new nd,
        this._invalidateMap = {},
        this._invalidateAll = !0,
        b._count = 0,
        b._invalidate = !0,
        function c(a) {
            b._loopId = requestAnimationFrame(c),
            b._invalidate && (b._count++, b._now = a, b.validate())
        } (0)
    },
    Jb.ext("twaver.vector.Network", Ib.controls.View, {
        __accessor: ["selectMode", "makeVisibleOnSelected", "movableFunction", "editPointSize", "editPointFillColor", "scrollBarWidth", "editPointOutlineWidth", "editPointOutlineColor", "editLineColor", "editLineWidth", "resizePointSize", "resizePointFillColor", "resizePointOutlineWidth", "resizePointOutlineColor", "resizeLineColor", "resizeLineWidth", "rotatePointSize", "rotatePointFillColor", "rotatePointOffset", "rotatePointOutlineWidth", "rotatePointOutlineColor", "rotateScaleFillColor", "rotateScaleFontColor", "rotateScaleWidth", "rotateScaleHeight", "selectOutlineColor", "selectOutlineWidth", "selectFillColor", "lazyMoveOutlineColor", "lazyMoveOutlineWidth", "lazyMoveFillColor", "rectSelectFilter", "selectionTolerance"],
        __bool: ["doubleClickToUpSubNetwork", "doubleClickToSubNetwork", "doubleClickToEmptySubNetwork", "doubleClickToLinkBundle", "doubleClickToGroupExpand", "scrollBarVisible", "limitViewInCanvas", "autoValidateCanvasSize", "subNetworkAnimate", "lazyMoveAnimate", "resizeAnimate", "noAgentLinkVisible", "keyboardRemoveEnabled", "keyboardSelectEnabled", "sendToTopOnSelected", "lazyMoveFill", "editingElement", "rotatingElement", "movingElement", "selectingElement", "rectSelectEnabled", "limitElementInPositiveLocation", "showRotateScale", "transparentSelectionEnable", "edgeDetect", "dragToPan", "wheelToZoom", "asyncZoomAndViewRect", "debug", "zoomDivVisible", "showShadowInEdit"],
        _currentSubNetwork: null,
        _subNetworkAnimate: Ib.Defaults.NETWORK_SUBNETWORK_ANIMATE,
        _scrollBarWidth: 10,
        _scrollBarVisible: !0,
        _limitViewInCanvas: !1,
        _autoValidateCanvasSize: !0,
        _makeVisibleOnSelected: Ib.Defaults.NETWORK_MAKE_VISIBLE_ON_SELECTED,
        _keyboardRemoveEnabled: Ib.Defaults.NETWORK_KEYBOARD_REMOVE_ENABLED,
        _keyboardSelectEnabled: Ib.Defaults.NETWORK_KEYBOARD_SELECT_ENABLED,
        _rectSelectEnabled: Dd.NETWORK_RECT_SELECT_ENABLED,
        _rectSelectFilter: null,
        _elementUIFunction: Ib.Defaults.VECTORUI_FUNCTION,
        _doubleClickToUpSubNetwork: Ib.Defaults.NETWORK_DOUBLECLICK_TO_UPSUBNETWORK,
        _doubleClickToSubNetwork: Ib.Defaults.NETWORK_DOUBLECLICK_TO_SUBNETWORK,
        _doubleClickToEmptySubNetwork: Ib.Defaults.NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK,
        _doubleClickToLinkBundle: Ib.Defaults.NETWORK_DOUBLECLICK_TO_LINKBUNDLE,
        _doubleClickToGroupExpand: Ib.Defaults.NETWORK_DOUBLECLICK_TO_GROUPEXPAND,
        _selectOutlineColor: Ib.Defaults.NETWORK_SELECT_OUTLINE_COLOR,
        _selectOutlineWidth: Ib.Defaults.NETWORK_SELECT_OUTLINE_WIDTH,
        _selectFillColor: Ib.Defaults.NETWORK_SELECT_FILL_COLOR,
        _sendToTopOnSelected: Ib.Defaults.NETWORK_SENDTOTOP_ON_SELECTED,
        _lazyMoveOutlineColor: Ib.Defaults.NETWORK_LAZYMOVE_OUTLINE_COLOR,
        _lazyMoveOutlineWidth: Ib.Defaults.NETWORK_LAZYMOVE_OUTLINE_WIDTH,
        _lazyMoveFillColor: Ib.Defaults.NETWORK_LAZYMOVE_FILL_COLOR,
        _lazyMoveFill: Ib.Defaults.NETWORK_LAZYMOVE_FILL,
        _lazyMoveAnimate: Ib.Defaults.NETWORK_LAZYMOVE_ANIMATE,
        _resizePointSize: Ib.Defaults.NETWORK_RESIZE_POINT_SIZE,
        _resizePointFillColor: Ib.Defaults.NETWORK_RESIZE_POINT_FILL_COLOR,
        _resizePointOutlineColor: Ib.Defaults.NETWORK_RESIZE_POINT_OUTLINE_COLOR,
        _resizePointOutlineWidth: Ib.Defaults.NETWORK_RESIZE_POINT_OUTLINE_WIDTH,
        _resizeLineColor: Ib.Defaults.NETWORK_RESIZE_LINE_COLOR,
        _resizeLineWidth: Ib.Defaults.NETWORK_RESIZE_LINE_WIDTH,
        _resizeAnimate: Ib.Defaults.NETWORK_RESIZE_ANIMATE,
        _rotatePointSize: Ib.Defaults.NETWORK_ROTATE_POINT_SIZE,
        _rotatePointFillColor: Ib.Defaults.NETWORK_ROTATE_POINT_FILL_COLOR,
        _rotatePointOffset: Ib.Defaults.NETWORK_ROTATE_POINT_OFFSET,
        _rotatePointOutlineWidth: Ib.Defaults.NETWORK_ROTATE_POINT_OUTLINE_WIDTH,
        _rotatePointOutlineColor: Ib.Defaults.NETWORK_ROTATE_POINT_OUTLINE_COLOR,
        _rotateScaleWidth: Dd.NETWORK_ROTATE_SCALE_WIDTH,
        _rotateScaleHeight: Dd.NETWORK_ROTATE_SCALE_HEIGHT,
        _rotateScaleFillColor: Dd.NETWORK_ROTATE_SCALE_FILL_COLOR,
        _rotateScaleFontColor: Dd.NETWORK_ROTATE_SCALE_FONT_COLOR,
        _editPointSize: Ib.Defaults.NETWORK_EDIT_POINT_SIZE,
        _editPointFillColor: Ib.Defaults.NETWORK_EDIT_POINT_FILL_COLOR,
        _editPointOutlineColor: Ib.Defaults.NETWORK_EDIT_POINT_OUTLINE_COLOR,
        _editPointOutlineWidth: Ib.Defaults.NETWORK_EDIT_POINT_OUTLINE_WIDTH,
        _editLineColor: Ib.Defaults.NETWORK_EDIT_LINE_COLOR,
        _editLineWidth: Ib.Defaults.NETWORK_EDIT_LINE_WIDTH,
        _limitElementInPositiveLocation: !1,
        _linkFlowInterval: Dd.NETWORK_LINK_FLOW_INTERVAL,
        _selectionTolerance: Dd.NETWORK_SELECTION_TOLERANCE,
        _invalidateViewRectFlag: !1,
        _repaintTopFlag: !1,
        _invalidateCanvasSizeFlag: !1,
        _isEditingElement: !1,
        _isRotatingElement: !1,
        _isMovingElement: !1,
        _isSelectingElement: !1,
        _hasEditInteraction: !1,
        _showRotateScale: !0,
        _transparentSelectionEnable: Ib.Defaults.NETWORK_TRANSPARENT_SELECTION_ENABLE,
        _edgeDetect: !1,
        _dragToPan: !0,
        _wheelToZoom: !0,
        _asyncZoomAndViewRect: !1,
        _debug: !1,
        _zoomDivVisible: !0,
        _showShadowInEdit: !1,
        adjustBounds: function(a) {
            var b = !1,
            c = this._view.style;
            if (c.left == a.x + "px" && c.top == a.y + "px" && c.width == a.width + "px" && c.height == a.height + "px" && (b = !0), Ib.vector.Network.superClass.adjustBounds.apply(this, arguments), 1 != b) {
                var d = this._view.offsetWidth,
                e = this._view.offsetHeight;
                this._rootCanvas.setAttribute("width", d),
                this._rootCanvas.setAttribute("height", e),
                this._topCanvas.setAttribute("width", d),
                this._topCanvas.setAttribute("height", e),
                this.setViewRect(this.viewRect.x, this.viewRect.y, d, e),
                "undefined" == typeof Ib.gis && (Ib.Util.makeHighRes(this._rootCanvas), Ib.Util.makeHighRes(this._topCanvas)),
                this.invalidateElementVisibility()
            }
        },
        getLabel: function(a) {
            return a.getStyle("network.label") || a.getName()
        },
        getLabel2: function(a) {
            return a.getStyle("network.label") || a.getName2()
        },
        setZoomManager: function(a) {
            var b = this.zoomManager;
            b != a && (this.zoomManager = a, this.invalidateElementVisibility(), this.invalidateCanvasSize(), this.validateCanvasSize(), this.invalidateElementUIs(), this.firePropertyChange("zoomManager", b, a))
        },
        getZoomManager: function() {
            return this.zoomManager
        },
        getRootCanvas: function() {
            return this._rootCanvas
        },
        getTopCanvas: function() {
            return this._topCanvas
        },
        validateImpl: function() {
            oc.twm(this);
            var a, b, c, d, e = this.getElementBox().getDatas()._as,
            f = e.length,
            g = {},
            h = this._visibleFunction,
            i = 1 === this._box._layerBox.size() ? this._box._layerBox._defaultLayer: null;
            for (a = 0; f > a; a++) c = e[a],
            g[c._id] = this.isVisible(c, h, i);
            var j = this.getGraphicsZoom(),
            k = null,
            l = {
                x: this.viewRect.x / j,
                y: this.viewRect.y / j,
                width: this.viewRect.width / j,
                height: this.viewRect.height / j
            };
            if (this._invalidateAll) {
                if (this._visibleMap) for (a = 0; f > a; a++) c = e[a],
                g[c._id] !== this._visibleMap[c._id] && (d = this._elementUIMap[c._id], d && d.invalidate());
                for (a = 0; f > a; a++) c = e[a],
                d = this._elementUIMap[c._id],
                d && d.validate();
                this._paintAll = !0
            } else if (this._paintAll) {
                for (b in this._invalidateMap) d = this._elementUIMap[b],
                d && d.invalidate();
                for (b in this._invalidateMap) d = this._elementUIMap[b],
                d && d.validate()
            } else {
                for (b in this._invalidateMap) d = this._elementUIMap[b],
                d && (this._dirtyRects.add(d.getZoomViewRect(!1)), d.invalidate());
                for (b in this._invalidateMap) d = this._elementUIMap[b],
                d && (d.validate(), this._dirtyRects.add(d.getZoomViewRect(!0)))
            }
            this._paintAll ? k = l: (this._dirtyRects.forEach(function(a) {
                k = null == k ? Jb.cloneRect(a) : Tb.unionRect(k, a)
            }), k ? (Tb.grow(k, 2, 2), k = Tb.intersection(k, l)) : k = l),
            this._visibleMap = g,
            k && this.paintRoot(k),
            this.validateCanvasSize(),
            1 == this._repaintTopFlag && (this._repaintTopFlag = !1, this.paintTopCanvas())
        },
        isLinkFlowEnabled: function() {
            return this._linkFlowEnabled ? !0 : !1
        },
        setLinkFlowEnabled: function(a) {
            a ? (this._linkFlowEnabled || (this._linkFlowEnabled = !0, this.firePropertyChange("linkFlowEnabled", !1, !0)), clearInterval(this._linkFlowTimerId), this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval)) : (this._linkFlowEnabled && (this._linkFlowEnabled = !1, this.firePropertyChange("linkFlowEnabled", !0, !1)), clearInterval(this._linkFlowTimerId), delete this._linkFlowTimerId)
        },
        getLinkFlowInterval: function() {
            return this._linkFlowInterval
        },
        setLinkFlowInterval: function(a) {
            var b = this._linkFlowInterval;
            this._linkFlowInterval = a,
            this.firePropertyChange("linkFlowInterval", b, a),
            clearInterval(this._linkFlowTimerId),
            this.isLinkFlowEnabled() && (this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval))
        },
        getElementBox: function() {
            return this._box
        },
        setElementBox: function(a) {
            if (!a) throw "ElementBox can not be null";
            if (this._box !== a) {
                var b = this._box;
                b && (b.removeDataBoxChangeListener(this.handleElementBoxChange, this), b.removeDataPropertyChangeListener(this.handleElementPropertyChange, this), b.removePropertyChangeListener(this.handleElementBoxPropertyChange, this), b.removeIndexChangeListener(this.handleIndexChange, this), b.getLayerBox().removeDataBoxChangeListener(this.handleLayerBoxChange, this), b.getLayerBox().removeDataPropertyChangeListener(this.handleLayerPropertyChange, this), b.getLayerBox().removeHierarchyChangeListener(this.handleLayerHierarchyChange, this), this._selectionModel || b.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this)),
                this._box = a,
                this._box.addDataBoxChangeListener(this.handleElementBoxChange, this),
                this._box.addDataPropertyChangeListener(this.handleElementPropertyChange, this),
                this._box.addPropertyChangeListener(this.handleElementBoxPropertyChange, this),
                this._box.addIndexChangeListener(this.handleIndexChange, this),
                this._box.getLayerBox().addDataBoxChangeListener(this.handleLayerBoxChange, this),
                this._box.getLayerBox().addDataPropertyChangeListener(this.handleLayerPropertyChange, this),
                this._box.getLayerBox().addHierarchyChangeListener(this.handleLayerHierarchyChange, this),
                this._flowLinkQuickFinder && (this._flowLinkQuickFinder.dispose(), this._flowLinkQuickFinder = new Ib.QuickFinder(this._box, "link.flow", "style")),
                this._selectionModel ? this._selectionModel._setDataBox(a) : this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
                this._elementUIMap = {},
                this._box.forEach(this.createElementUI, this),
                this.invalidateElementVisibility(),
                this.invalidateCanvasSize(),
                this.firePropertyChange("elementBox", b, this._box)
            }
        },
        handleElementBoxChange: function(a) {
            var b = a.data;
            if ("add" === a.kind) this.createElementUI(b),
            this.invalidateBundleLink(b);
            else if ("remove" === a.kind) {
                var c = this.getElementUI(b);
                c && (this._dirtyRects.add(c.getZoomViewRect()), c.dispose(), delete this._elementUIMap[b.getId()]),
                b === this._currentSubNetwork && null != this._currentSubNetwork && this._setCurrentSubNetwork(null),
                delete this._invalidateMap[b._id]
            } else "clear" === a.kind && (this._elementUIMap = {},
            null != this._currentSubNetwork && this._setCurrentSubNetwork(null), this._paintAll = !0);
            this.invalidateElementVisibility(),
            this.invalidateCanvasSize()
        },
        handleElementPropertyChange: function(a) {
            var b = a.source,
            c = this.getElementUI(b);
            c && (this.invalidateElementUI(b), c.handlePropertyChange(a)),
            this.invalidateBundleLink(b),
            this.invalidateElementVisibility(),
            this.invalidateCanvasSize()
        },
        handleElementBoxPropertyChange: function() {
            this.invalidateElementVisibility()
        },
        handleIndexChange: function(a) {
            this.invalidateElementVisibility()
        },
        handleLayerBoxChange: function() {
            this.invalidateElementVisibility()
        },
        handleLayerPropertyChange: function(a) {
            "editable" === a.property && this.invalidateSelectedElementUIs(!0),
            this.invalidateElementVisibility()
        },
        handleLayerHierarchyChange: function() {
            this.invalidateElementVisibility()
        },
        handleSelectionChange: function(a) {
            var b = this.getSelectionModel().getLastData();
            b && ("append" === a.kind || "set" === a.kind) && (this.isMakeVisibleOnSelected() && this.makeVisible(b), this.isSendToTopOnSelected() && this.sendToTop(b)),
            a.datas.forEach(function(b) {
                var c = this.getElementUI(b);
                c && c.handleSelectionChange(a),
                this.invalidateElementUI(b)
            },
            this),
            this.invalidateElementVisibility()
        },
        sendToTop: function(a) {
            if (this._box.contains(a)) {
                for (var b = a; b._parent && this.isVisible(b._parent) && (b = b._parent););
                b !== a && this._box.adjustElementIndex(b),
                this._box.adjustElementIndex(a)
            }
        },
        getViewRect: function() {
            return this.viewRect ? Jb.cloneRect(this.viewRect) : {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        },
        getCanvasSize: function() {
            return {
                width: this.realWidth,
                height: this.realHeight
            }
        },
        setViewOffSet: function(a, b) {
            var c = this.viewRect.x,
            d = this.viewRect.y,
            e = this.viewRect.width,
            f = this.viewRect.height;
            this.setViewRect(c + a, d + b, e, f)
        },
        setViewRect: function(a, b, c, d) {
            1 == this.isLimitViewInCanvas() && (0 > a && (a = 0), c > this.realWidth ? a = 0 : a + c > this.realWidth && (a = this.realWidth - c), 0 > b && (b = 0), d > this.realHeight ? b = 0 : b + d > this.realHeight && (b = this.realHeight - d));
            var e = this.viewRect; (null == this.viewRect || a != this.viewRect.x || b != this.viewRect.y || c != this.viewRect.width || d != this.viewRect.height) && (this.viewRect = {
                x: a,
                y: b,
                width: c,
                height: d
            },
            this.firePropertyChange("viewRect", e, this.viewRect), this.invalidateElementVisibility(), this._paintAll = !0)
        },
        isHScrollBarVisible: function() {
            return this.hScrollBarVisible
        },
        setHScrollBarVisible: function(a) {
            this.hScrollBarVisible = a
        },
        isVScrollBarVisible: function() {
            return this.vScrollBarVisible
        },
        setVScrollBarVisible: function(a) {
            this.vScrollBarVisible = a
        },
        setZoomVisibilityThresholds: function(a) {
            var b = this._visibilityThresholds;
            this._zoomVisibilityThresholds = a,
            this.firePropertyChange("zoomVisibilityThresholds", b, a),
            this.invalidateElementVisibility()
        },
        getZoomVisibilityThresholds: function() {
            return this._zoomVisibilityThresholds || {}
        },
        invalidateElementVisibility: function() {
            this.invalidate()
        },
        repaintTopCanvas: function() {
            this._repaintTopFlag || (this._repaintTopFlag = !0, this.invalidate())
        },
        invalidateCanvasSize: function(a) {
            this._invalidateCanvasSizeFlag || (this._invalidateCanvasSizeFlag = !0, this.invalidate())
        },
        validateCanvasSize: function() {
            0 != this._invalidateCanvasSizeFlag && (this._invalidateCanvasSizeFlag = !1, this._validateCanvasSize())
        },
        _validateCanvasSize: function() {
            if (0 == this.isAutoValidateCanvasSize()) return this.realWidth = 0,
            this.realHeight = 0,
            void(this._unionBounds = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            var a, b = this.getElementBox().getDatas(),
            c = b.size();
            if (c > 0) {
                for (var d = 0; c > d; d++) {
                    var e = b.get(d);
                    if (this._visibleMap[e._id]) {
                        var f = this._elementUIMap[e._id];
                        f && (a = a ? Tb.unionRect(a, f.getZoomViewRect(!0)) : Jb.cloneRect(f.getZoomViewRect(!0)))
                    }
                }
                null == a && (a = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                });
                var g = this.getGraphicsZoom();
                if (this.realWidth == (a.x + a.width) * g && this.realHeight == (a.y + a.height) * g) return;
                this.realWidth = (a.x + a.width) * g,
                this.realHeight = (a.y + a.height) * g,
                this._unionBounds = {
                    x: a.x * g,
                    y: a.y * g,
                    width: a.width * g,
                    height: a.height * g
                }
            } else this.realWidth = 0,
            this.realHeight = 0,
            this._unionBounds = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this.setViewRect(this.viewRect.x, this.viewRect.y, this.viewRect.width, this.viewRect.height),
            this.firePropertyChange("canvasSizeChange", null, this.viewRect)
        },
        getElementUI: function(a) {
            return null == a ? null: this._elementUIMap[a._id]
        },
        getUnionBounds: function() {
            return this._unionBounds
        },
        getZoomBodyRect: function(a) {
            var b = this.getElementUI(a);
            return b ? b.getZoomBodyRect() : null
        },
        getShapeNodeZoomPoints: function(a, b) {
            if (a._points) {
                var c = this.getElementUI(a);
                if (c) return c._getZoomPoints()
            }
            return null
        },
        createElementUI: function(a) {
            var b = this._elementUIMap[a.getId()];
            if (!b) {
                if (b = this._elementUIFunction(this, a), !b) {
                    var c = a.getClassName(),
                    d = c.substr(c.indexOf(".") + 1) + "UI",
                    e = Ib.vector[d];
                    e && (b = new e(this, a))
                }
                b && (this._elementUIMap[a.getId()] = b)
            }
            return this._invalidateMap && (this._invalidateMap[a._id] = a),
            b
        },
        getElementUIFunction: function() {
            return this._elementUIFunction
        },
        setElementUIFunction: function(a) {
            if (!a) throw "ElementUIFunction can not be null";
            if (this._elementUIFunction !== a) {
                var b = this._elementUIFunction;
                this._elementUIFunction = a,
                this.firePropertyChange("elementUIFunction", b, a),
                this._box.isEmpty() || (this._elementUIMap = {},
                this._box.forEach(this.createElementUI, this), this.invalidateElementVisibility(), this.invalidateCanvasSize())
            }
        },
        invalidateElementUI: function(a, b) {
            if (!this._invalidateAll) {
                if (this._invalidateMap[a._id] = a, this.getElementUI(a), a instanceof Kd) {
                    var c = a.getAgentLinks();
                    null != c && c.forEach(this.invalidateElementUI, this);
                    var d = a.getParent();
                    d instanceof Ib.Group && this.invalidateElementUI(d)
                }
                this.invalidateElementVisibility()
            }
        },
        invalidateElementUIs: function(a) {
            this._invalidateAll = !0,
            this._invalidateMap = {},
            this._visibleMap = {},
            this.invalidateElementVisibility(),
            this.invalidateCanvasSize(),
            this.invalidate()
        },
        invalidateSelectedElementUIs: function(a) {
            this.getSelectionModel().getSelection().forEach(function(b) {
                this.invalidateElementUI(b, a)
            },
            this)
        },
        invalidateBundleLink: function(a) {
            if (a instanceof Ib.Link && a._bundleLinks) {
                var b = this._elementUIMap;
                a._bundleLinks.forEachSiblingLink(function(c) {
                    if (c !== a) {
                        var d = b[c._id];
                        d && d.invalidate(!1)
                    }
                },
                this)
            }
        },
        paintRoot: function(a) {
            var c = this._rootCanvas.getContext("2d");
            c.save();
            var d = this.getGraphicsZoom();
            Qb.isIE && c.clearRect(a.x * d - this.viewRect.x, a.y * d - this.viewRect.y, a.width * d, a.height * d),
            c.beginPath(),
            c.rect(a.x * d - this.viewRect.x, a.y * d - this.viewRect.y, a.width * d, a.height * d),
            c.clip(),
            Qb.isIE || c.clearRect(a.x * d - this.viewRect.x, a.y * d - this.viewRect.y, a.width * d, a.height * d),
            this.visibleList = new Ib.List,
            this._topAttachmentList = new Ib.List,
            ld.draw(c, this);
            var e = this.getElementBox().getDatas()._as,
            f = e.length,
            g = this.zoomManager;
            g._zoomGraphicsBegin(c),
            this.paintBottom(c, a);
            var h, i, j, k, l = this._box._layerBox,
            d = this.getGraphicsZoom(),
            m = {
                x: this.viewRect.x / d,
                y: this.viewRect.y / d,
                width: this.viewRect.width / d,
                height: this.viewRect.height / d
            };
            if (1 === l.size()) for (h = 0; f > h; h++) i = e[h],
            this._visibleMap[i._id] ? (j = this._elementUIMap[i._id], this._debug && Xb.strokeRect(c, a, "red"), null != j && this._isInView(j, a) && (j.paint(c), j.setAttachmentVisible && j.setAttachmentVisible(!0)), null != j && Tb.intersects(m, j.getZoomViewRect()) ? j.setAttachmentVisible && j.setAttachmentVisible(!0) : j.setAttachmentVisible && j.setAttachmentVisible(!1), this.visibleList.add(i)) : (j = this._elementUIMap[i._id], j && j.setAttachmentVisible && j.setAttachmentVisible(!1));
            else l.forEachByDepthFirst(function(b) {
                for (h = 0; f > h; h++) i = e[h],
                l.getLayerByElement(i) === b && this._visibleMap[i._id] ? (j = this._elementUIMap[i._id], null != j && this._isInView(j, a) && (j.paint(c), j.setAttachmentVisible && j.setAttachmentVisible(!0)), null != j && Tb.intersects(m, j.getZoomViewRect()) ? j.setAttachmentVisible && j.setAttachmentVisible(!0) : j.setAttachmentVisible && j.setAttachmentVisible(!1), this.visibleList.add(i)) : (j = this._elementUIMap[i._id], j && j.setAttachmentVisible && j.setAttachmentVisible(!1))
            },
            null, this);
            for (f = this._topAttachmentList.size(), h = 0; f > h; h++) k = this._topAttachmentList.get(h),
            k.getElementUI().paintAttachment(c, k);
            if (this.paintTop(c, a), this._xyz !== b) {
                var f, n = this._xyz,
                o = n.markText,
                p = n.type,
                q = (n.expired, n.innerHTML),
                r = 0,
                s = 0,
                t = this.viewRect;
                c.translate(this.viewRect.x / this.getZoom(), this.viewRect.y / this.getZoom()),
                c.scale(1 / this.getZoom(), 1 / this.getZoom());
                var d = this.getZoom();
                o != b && null != o && "" != o || "2" == p ? (c.font = "15px Arial sans-serif", f = Jb.g.getTextSize(c.font, q), c.fillStyle = "red", r = t.width - f.width, s = t.height - 20) : (c.font = "10px Arial sans-serif", f = Jb.g.getTextSize(c.font, q), r = t.width / 2 - f.width / 2, s = t.height / 2),
                c.fillText(q, r, s)
            }
            c.restore(),
            this._invalidateMap = {},
            this._invalidateAll = !1,
            this._paintAll = !1,
            this._dirtyRects = new nd
        },
        paintBottom: function(a, b) {},
        paintTop: function(a, b) {},
        _isInView: function(a, b) {
            return Tb.intersects(b, a.getZoomViewRect())
        },
        paintTopCanvas: function() {
            var a = this._topCanvas.getContext("2d");
            a.clearRect(0, 0, this._topCanvas.width, this._topCanvas.height),
            this.paintMarker(a)
        },
        paintMarker: function(a) {
            for (var b = this.markerList.size(), c = 0; b > c; c++) {
                var d = this.markerList.get(c);
                d.paint(a)
            }
        },
        getLayerByElement: function(a) {
            return this._box.getLayerBox().getLayerByElement(a)
        },
        getLogicalPoint2: function(a) {
            return this.zoomManager._getLogicalPoint(a)
        },
        getLogicalPoint: function(a) {
            return this.zoomManager._getLogicalPoint(a, !0)
        },
        getElementAt: function(a) {
            if (null == this.visibleList) return null;
            var b;
            if (a.target ? b = this.getLogicalPoint2(a) : a.event ? a.event.target && (b = this.getLogicalPoint2(a.event)) : b = a, null != this._hitTestTopAttachmentList) for (var c = this._hitTestTopAttachmentList.size(), d = c - 1; d >= 0; d--) {
                var e = this._hitTestTopAttachmentList.get(d);
                if (e.hit(b.x, b.y)) return e.getElement()
            }
            if (null != this.visibleList) for (var f = this.visibleList.size(), g = f - 1; g >= 0; g--) {
                var h = this.visibleList.get(g),
                i = this.getElementUI(h);
                if (i && i.hit(b.x, b.y)) return h
            }
            return null
        },
        hitTest: function(a) {
            var b = this.getElementAt(a);
            if (!b) return null;
            var c = this.getElementUI(b);
            if (!c) return null;
            var d;
            return d = a.target ? this.getLogicalPoint2(a) : a.event ? this.getLogicalPoint2(a.event) : a,
            c.hitTest(d.x, d.y)
        },
        getElementsAtRect: function(a, c, d, e) {
            var f = new Ib.List;
            if (null == this.visibleList) return f;
            e = e === b ? !0 : e;
            for (var g = this.visibleList.size(), h = g - 1; h >= 0; h--) {
                var i = this.visibleList.get(h),
                j = this.getElementUI(i);
                j && (!d || d(j._element)) && (e && this.isSelectable(j._element) || !e) && (c ? j.intersects(a) && f.add(i) : Tb.contains(a, j.getZoomViewRect(lc)) && f.add(i))
            }
            return f
        },
        getPosition: function(a, b, c, d, e, f) {
            var g, h = b instanceof Ib.vector.ElementUI ? b: this.getElementUI(b);
            if (h) if ("from" === a || "to" === a) {
                if (h.getFromPosition && (g = "from" === a ? h.getFromPosition(d, e) : h.getToPosition(d, e))) return c ? {
                    x: g.x - c.width / 2,
                    y: g.y - c.height / 2
                }: g
            } else g = "hotspot" === a ? f ? h.getZoomHotSpot(this.zoomManager) : h.getHotSpot() : Vb.get(a, f ? h.getZoomBodyRect() : h.getBodyRect(), c);
            if (!g && b.getRect && (g = Vb.get(a, b.getRect(), c)), g) return {
                x: g.x + d,
                y: g.y + e
            };
            throw "position '" + a + "' object '" + b + "'"
        },
        isValidEvent: function(a) {
            if (!a) return ! 1;
            var b, c;
            if (a.currentTarget === this._view) {
                if (Qb.isFirefox ? (b = a.layerX, c = a.layerY) : (b = a.offsetX, c = a.offsetY), 1 == this.isHScrollBarVisible() && c >= this.viewRect.height - this.getScrollBarWidth()) return ! 1;
                if (1 == this.isVScrollBarVisible() && b >= this.viewRect.width - this.getScrollBarWidth()) return ! 1
            }
            return ! 0
        },
        addMarker: function(a) {
            this.markerList.add(a),
            this.repaintTopCanvas()
        },
        removeMarker: function(a) {
            this.markerList.remove(a),
            this.repaintTopCanvas()
        },
        clearMarker: function() {
            this.markerList.clear(),
            this.repaintTopCanvas()
        },
        isMovable: function(a) {
            return this._box.contains(a) && a.isMovable() ? a instanceof Ib.Link ? !1 : this._movableFunction && !this._movableFunction(a) ? !1 : this.getLayerByElement(a).isMovable() : !1
        },
        hasMovableSelectedElements: function() {
            for (var a = this.getSelectionModel().getSelection(), b = 0; b < a.size(); b++) {
                var c = a.get(b);
                if (this.isMovable(c)) return ! 0
            }
            return ! 1
        },
        getMovableSelectedElements: function() {
            return this.getSelectionModel().toSelection(function(a) {
                return this.isMovable(a)
            },
            this)
        },
        moveSelectedElements: function(a, b, c, d) {
            if (0 !== a || 0 !== b) {
                var e = this.getMovableSelectedElementsRect();
                null != e && (this._limitElementInPositiveLocation && (e.x + a < 0 && (a = -e.x), e.y + b < 0 && (b = -e.y)), Ib.Util.moveElements(this.getMovableSelectedElements(), a, b, c, d, this))
            }
        },
        getMovableSelectedElementsRect: function() {
            var a = this.getMovableSelectedElements();
            if (0 === a.size()) return null;
            for (var b = null,
            c = 0,
            d = a.size(); d > c; c++) {
                var e = a.get(c);
                if (e instanceof Kd) {
                    var f = this.getElementUI(e);
                    f && (b = Tb.unionRect(b, f.getViewRect()))
                }
            }
            return b
        },
        isVisible: function(a, b, c) {
            if (!this._box.contains(a)) return ! 1;
            if (!a.isVisible()) return ! 1;
            if (3 !== arguments.length && (b = this._visibleFunction), b && !b(a)) return ! 1;
            if (! (c || this._box._layerBox.getLayerByElement(a))._visible) return ! 1;
            if (vc.getSubNetwork(a) !== this._currentSubNetwork) return ! 1;
            if (!this.zoomManager.isElementVisible(a)) return ! 1;
            if (a instanceof Ib.Link) {
                if (!this._noAgentLinkVisible) {
                    if (!a._fromAgent || !a._toAgent) return ! 1;
                    if (!this.isVisible(a._fromAgent, b, c) || !this.isVisible(a._toAgent, b, c)) return ! 1
                }
                if (a.getBundleIndex() > 0 && a.getBundleCount() > 1 && !a.getStyle("link.bundle.expanded")) return ! 1
            } else for (var d = a._parent; d && !d.ISubNetwork;) {
                if (d instanceof Ib.Group && (!d.isExpanded() || !this.isVisible(d, b, c))) return ! 1;
                d = d._parent
            }
            return a.IDummy ? !1 : !0
        },
        getVisibleFunction: function() {
            return this._visibleFunction
        },
        setVisibleFunction: function(a) {
            var b = this._visibleFunction;
            this._visibleFunction = a,
            this.firePropertyChange("visibleFunction", b, a),
            this.invalidateElementVisibility()
        },
        isEditable: function(a) {
            return this._box.contains(a) ? this._editableFunction && !this._editableFunction(a) ? !1 : this.getLayerByElement(a).isEditable() : !1
        },
        getEditableFunction: function() {
            return this._editableFunction
        },
        setEditableFunction: function(a) {
            var b = this._editableFunction;
            this._editableFunction = a,
            this.firePropertyChange("editableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        isRotatable: function(a) {
            return this._rotatableFunction && !this._rotatableFunction(a) ? !1 : !0
        },
        getRotatableFunction: function() {
            return this._rotatableFunction
        },
        setRotatableFunction: function(a) {
            var b = this._rotatableFunction;
            this._rotatableFunction = a,
            this.firePropertyChange("rotatableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        isLinkable: function(a, b) {
            return null == this._linkableFunction || this._linkableFunction(a, b)
        },
        getLinkableFunction: function() {
            return this._linkableFunction
        },
        setLinkableFunction: function(a) {
            var b = this._linkableFunction;
            this._linkableFunction = a,
            this.firePropertyChange("linkableFunction", b, a),
            this.invalidateSelectedElementUIs(!0)
        },
        onShareSelectionModelChanged: function() {
            this.invalidateElementUIs()
        },
        getShadowColor: function(a) {
            var b = a.getStyle("shadow.color");
            return ! b && this.isSelected(a) && "shadow" === a.getStyle("select.style") ? a.getStyle("select.color") : b
        },
        getSelectColor: function(a) {
            return a.getStyle("select.color")
        },
        getAlarmLabel: function(a) {
            var b = a.getAlarmState().getHighestNewAlarmSeverity();
            if (b) {
                var c = a.getAlarmState().getNewAlarmCount(b) + b.nickName;
                return a.getAlarmState().hasLessSevereNewAlarms() && (c += "+"),
                c
            }
            return null
        },
        getLinkHandlerLabel: function(a) {
            return a.isBundleAgent() ? "+(" + a.getBundleCount() + ")": null
        },
        setInteractions: function(a) {
            var b = this._interactions;
            b && b.forEach(function(a) {
                a.tearDown()
            }),
            this._interactions = a,
            a && a.forEach(function(a) {
                a.setUp()
            }),
            this.invalidateSelectedElementUIs(!0),
            this.firePropertyChange("interactions", b, a)
        },
        getInteractions: function() {
            return this._interactions
        },
        setDefaultInteractions: function(a) {
            this.setInteractions([new Ib.vector.interaction.DefaultInteraction(this, a), new Ib.vector.interaction.TouchInteraction(this)])
        },
        setTouchInteractions: function() {
            this.setDefaultInteractions(!1)
        },
        setMSTouchInteractions: function() {
            this.setInteractions([new Ib.vector.interaction.MSTouchInteraction(this)])
        },
        setEditInteractions: function(a) {
            this.setInteractions([new Ib.vector.interaction.EditInteraction(this, a), new Ib.vector.interaction.DefaultInteraction(this)])
        },
        setCreateElementInteractions: function(a) {
            this.setInteractions([new Ib.vector.interaction.CreateElementInteraction(this, a), new Ib.vector.interaction.DefaultInteraction(this)])
        },
        setCreateLinkInteractions: function(a) {
            this.setInteractions([new Ib.vector.interaction.CreateLinkInteraction(this, a), new Ib.vector.interaction.DefaultInteraction(this)])
        },
        setCreateShapeLinkInteractions: function(a) {
            this.setInteractions([new Ib.vector.interaction.CreateShapeLinkInteraction(this, a), new Ib.vector.interaction.DefaultInteraction(this)])
        },
        setCreateShapeNodeInteractions: function(a) {
            this.setInteractions([new Ib.vector.interaction.CreateShapeNodeInteraction(this, a), new Ib.vector.interaction.DefaultInteraction(this)])
        },
        setMagnifyInteractions: function() {
            this.setInteractions([new Ib.vector.interaction.DefaultInteraction(this), new Ib.vector.interaction.MagnifyInteraction(this)])
        },
        hasEditInteraction: function() {
            return this._hasEditInteraction
        },
        setHasEditInteraction: function(a) {
            var b = this._hasEditInteraction;
            this._hasEditInteraction = a,
            this.firePropertyChange("hasEditInteraction", b, a)
        },
        addElementByInteraction: function(a) {
            a.getParent() || a.setParent(this._currentSubNetwork),
            this._box.add(a),
            this.getSelectionModel().setSelection(a),
            this.fireInteractionEvent({
                kind: "createElement",
                element: a
            })
        },
        getToolTip: function(a) {
            if (a) {
                var b = a.getToolTip();
                return b ? b: a.getName()
            }
            return null
        },
        isToolTipEnabled: function() {
            return this._toolTipEnabled ? !0 : !1
        },
        setToolTipEnabled: function(a) {
            if (this._toolTipEnabled = a, a) {
                if (!this._toolTipListener) {
                    var b = this;
                    this._toolTipListener = function(a) {
                        if (b.isMovingElement()) return void Bc.hideToolTip();
                        var c = b.getElementAt(a);
                        if (b._preElement !== c) if (b._preElement = c, c) {
                            var d = b.getToolTip(c);
                            Bc.showToolTip({
                                x: a.pageX,
                                y: a.pageY
                            },
                            d);
                            var e = Bc.getToolTipDiv();
                            if (e.children.length > 0) {
                                var f = b._view.getBoundingClientRect(),
                                g = e.getBoundingClientRect();
                                g.width + g.left > f.width + f.left && (e.style.left = f.width + f.left - g.width + (Ob.documentElement.scrollLeft || Ob.body.scrollLeft) + "px"),
                                g.height + g.top > f.height + f.top && (e.style.top = f.height + f.top - g.height + (Ob.documentElement.scrollTop || Ob.body.scrollTop) + "px")
                            }
                        } else Bc.hideToolTip()
                    },
                    this._view.addEventListener("mousemove", this._toolTipListener, !1),
                    this.firePropertyChange("toolTipEnabled", !1, !0)
                }
            } else this._toolTipListener && (Bc.hideToolTip(), this._view.removeEventListener("mousemove", this._toolTipListener, !1), delete this._toolTipListener, this.firePropertyChange("toolTipEnabled", !0, !1))
        },
        setZoom: function(a, b) {
            if (a = this.checkZoom(a), this.isAsyncZoomAndViewRect()) var c = this._zoomMap[this._currentSubNetwork].zoom;
            else var c = this._zoom;
            if (a != c) {
                var d = this.getViewRect();
                b || (b = {
                    x: d.width / 2,
                    y: d.height / 2
                });
                var e = this.viewRect,
                f = b.x - (b.x + e.x) * a / c,
                g = b.y - (b.y + e.y) * a / c;
                this.isAsyncZoomAndViewRect() ? this._zoomMap[this._currentSubNetwork].zoom = a: this._zoom = a,
                this._paintAll = !0,
                this.invalidateElementVisibility(),
                this.invalidateCanvasSize(),
                this.zoomManager._invalidateZoom(),
                this.setViewRect( - f, -g, this.viewRect.width, this.viewRect.height),
                this._asyncZoomAndViewRect ? this.firePropertyChange("zoom", c, this._zoomMap[this._currentSubNetwork].zoom) : this.firePropertyChange("zoom", c, this._zoom)
            }
        },
        getZoom: function() {
            if (this.isAsyncZoomAndViewRect()) {
                var a = this._zoomMap[this._currentSubNetwork];
                return a || (this._zoomMap[this._currentSubNetwork] = {
                    zoom: 1
                }),
                this._zoomMap[this._currentSubNetwork].zoom
            }
            return this._zoom
        },
        getSizeZoom: function(a) {
            return this.zoomManager.getSizeZoom(a)
        },
        getLocationZoom: function() {
            return this.zoomManager.getLocationZoom()
        },
        getGraphicsZoom: function() {
            return this.zoomManager.getGraphicsZoom()
        },
        zoomOverview: function(a) {
            if (! (this._unionBounds.width <= 0 || this._unionBounds.width <= 0)) {
                var b = this.getZoom(),
                c = this._unionBounds,
                d = c.width / b,
                e = c.height / b,
                f = this.viewRect.width / d,
                g = this.viewRect.height / e,
                h = Math.min(f, g);
                this.setZoom(h);
                var i = this.getZoom(),
                j = this.viewRect.width / 2 - this._unionBounds.width / 2 * i / b,
                k = this.viewRect.height / 2 - this._unionBounds.height / 2 * i / b;
                if (this.setViewRect(this._unionBounds.x * i / b - j, this._unionBounds.y * i / b - k, this.viewRect.width, this.viewRect.height), 1 != this.getLocationZoom()) {
                    var l = null == arguments[1] ? 5 : arguments[1];
                    if (l > 0) {
                        l--;
                        var m = this;
                        setTimeout(function() {
                            m.zoomOverview(a, l)
                        },
                        25)
                    }
                }
            }
        },
        zoomReset: function(a) {
            this.setZoom(1, a)
        },
        zoomIn: function(a) {
            this.setZoom(1.2 * this.getZoom(), a)
        },
        zoomOut: function(a) {
            this.setZoom(this.getZoom() / 1.2, a)
        },
        upSubNetwork: function(a, b) {
            this._currentSubNetwork && this.setCurrentSubNetwork(vc.getSubNetwork(this._currentSubNetwork), a, b)
        },
        getCurrentSubNetwork: function() {
            return this._currentSubNetwork
        },
        setCurrentSubNetwork: function(a, b, c) {
            if (Ib.animate.AnimateManager.endAnimate(), b) {
                if (this._currentSubNetwork === a) return;
                if (a && !this._box.contains(a)) throw a + " is not contained in this network's elementBox";
                var d = new Ib.animate.AnimateSubNetwork(this, a, c);
                Ib.animate.AnimateManager.start(d)
            } else this._setCurrentSubNetwork(a),
            c && c()
        },
        _setCurrentSubNetwork: function(a) {
            if (this._currentSubNetwork !== a) {
                if (a && !this._box.contains(a)) throw a + " is not contained in this network's elementBox";
                if (this.isAsyncZoomAndViewRect()) {
                    var b = this._viewRectMap[this._currentSubNetwork];
                    this._viewRectMap[this._currentSubNetwork] = b ? this.viewRect: this.viewRect ? this.viewRect: {
                        x: 0,
                        y: 0,
                        width: this.viewRect.width,
                        height: this.viewRect.height
                    }
                }
                var c = this._currentSubNetwork;
                if (this._currentSubNetwork = a, this.firePropertyChange("currentSubNetwork", c, a), this.isAsyncZoomAndViewRect()) {
                    this._viewRectMap[this._currentSubNetwork] || (this._viewRectMap[this._currentSubNetwork] = {
                        x: 0,
                        y: 0,
                        width: this.viewRect.width,
                        height: this.viewRect.height
                    });
                    var b = this._viewRectMap[this._currentSubNetwork];
                    this.setViewRect(b.x, b.y, b.width, b.height),
                    this.invalidateElementUIs()
                }
                this.invalidateElementVisibility(),
                this.invalidateCanvasSize(),
                this._paintAll = !0
            }
        },
        makeVisible: function(a) {
            var b = this.getElementUI(a);
            if (b) {
                var c = vc.getSubNetwork(a);
                if (c !== this._currentSubNetwork) {
                    var d = this;
                    return void this.setCurrentSubNetwork(c, this.isSubNetworkAnimate(),
                    function() {
                        Jb.callLater(d.makeVisible, d, [a])
                    })
                }
                for (var e = a; (e = e.getParent()) && e !== c;) e instanceof Ib.Group && e.setExpanded(!0);
                var f = b.getViewRect();
                if (f) {
                    var g, h = b.getZoomViewRect(this.zoomManager);
                    g = f.x == h.x && f.y == h.y && f.width == h.width && f.height == h.height ? {
                        x: f.x * this.getGraphicsZoom(),
                        y: f.y * this.getGraphicsZoom(),
                        width: f.width * this.getGraphicsZoom(),
                        height: f.height * this.getGraphicsZoom()
                    }: h,
                    Tb.intersects(this.viewRect, g) || this.isVisible(a) && Jb.callLater(this.centerByLogicalPoint, this, [g.x + g.width / 2, g.y + g.height / 2])
                }
            }
        },
        centerByLogicalPoint: function(a, b, c) {
            var d = a - this.viewRect.width / 2,
            e = b - this.viewRect.height / 2;
            this.setViewRect(d, e, this.viewRect.width, this.viewRect.height)
        },
        panByOffset: function(a, b) {
            this.setViewOffSet(a, b)
        },
        getIconsNames: function(a) {
            return a.getStyle("icons.names")
        },
        getIconsColors: function(a) {
            return a.getStyle("icons.colors")
        },
        getLinkFlowStepping: function(a) {
            var b = parseInt(a.getStyle("link.flow.stepping"));
            return b || (b = Dd.NETWORK_LINK_FLOW_STEPPING),
            b
        },
        getLinkFlowOffset: function(a) {
            var b = a.getStyle("link.flow.offset");
            return isNaN(b) && (b = 0),
            b + this.getLinkFlowStepping(a)
        },
        toCanvas: function(a, b, c, d, e, f) {
            c || (c = Wb.createCanvas()),
            c.setAttribute("width", a),
            c.setAttribute("height", b),
            c._viewRect ? (c._viewRect.width = a, c._viewRect.height = b) : c._viewRect = {
                x: 0,
                y: 0,
                width: a,
                height: b
            };
            var g = c.getContext("2d");
            if (g.translate( - e, -f), g.clearRect(0, 0, a, b), ld.draw(g, this), 0 === this._view.clientWidth || 0 === this._view.clientHeight) return c;
            a / this.realWidth * this.getGraphicsZoom(),
            b / this.realHeight * this.getGraphicsZoom(),
            g.scale(d, d);
            var h = this.getElementBox().getDatas()._as,
            i = h.length;
            this._topAttachmentList = new Ib.List;
            var j, k, l, m, n, o, p = this.getElementBox().getLayerBox(),
            q = p.getRoots(),
            r = q.size();
            if (1 === r) for (l = 0; i > l; l++) m = h[l],
            this._visibleMap[m._id] && (n = this._elementUIMap[m._id], null != n && n.paint(g));
            else for (j = 0; r > j; j++) for (k = q.get(j), l = 0; i > l; l++) m = h[l],
            p.getLayerByElement(m) === k && this._visibleMap[m._id] && (n = this._elementUIMap[m._id], null != n && n.paint(g));
            for (i = this._topAttachmentList.size(), l = 0; i > l; l++) o = this._topAttachmentList.get(l),
            o.getElementUI().paintAttachment(g, o);
            return c
        },
        toCanvasByRegion: function(a, b, c) {
            c || (c = Wb.createCanvas());
            var d = a.width * b,
            e = a.height * b;
            c.setAttribute("width", d),
            c.setAttribute("height", e),
            c._viewRect ? (c._viewRect.width = d, c._viewRect.height = e) : c._viewRect = {
                x: 0,
                y: 0,
                width: d,
                height: e
            };
            var f = c.getContext("2d");
            if (f.clearRect(0, 0, d, e), ld.draw(f, this), 0 === this._view.clientWidth || 0 === this._view.clientHeight) return c;
            f.save(),
            f.scale(b, b),
            f.beginPath(),
            f.translate( - a.x, -a.y);
            var g = this.getElementBox().getDatas()._as,
            h = g.length;
            this._topAttachmentList = new Ib.List;
            var i, j, k, l, m, n, o = this.getElementBox().getLayerBox(),
            p = o.getRoots(),
            q = p.size();
            if (1 === q) for (k = 0; h > k; k++) l = g[k],
            this._visibleMap[l._id] && (m = this._elementUIMap[l._id], null != m && Tb.intersects(a, m.getZoomViewRect()) && m.paint(f));
            else for (i = 0; q > i; i++) for (j = p.get(i), k = 0; h > k; k++) l = g[k],
            o.getLayerByElement(l) === j && this._visibleMap[l._id] && (m = this._elementUIMap[l._id], null != m && Tb.intersects(a, m.getZoomViewRect()) && m.paint(f));
            for (h = this._topAttachmentList.size(), k = 0; h > k; k++) n = this._topAttachmentList.get(k),
            n.getElementUI().paintAttachment(f, n);
            return f.restore(),
            c
        },
        getGroupChildrenRects: function(a) {
            return this.zoomManager._getGroupChildrenRects(a)
        },
        convertPointFromView: function(a) {
            return this.zoomManager._convertPointFromView(a)
        },
        getOffset: function(a, b) {
            return this.zoomManager._getOffset(a, b)
        },
        panToCenter: function() {
            this.setViewRect((this.realWidth - this.viewRect.width) / 2, (this.realHeight - this.viewRect.height) / 2, this.viewRect.width, this.viewRect.height)
        },
        moveElementsToCenter: function() {
            if (this._limitViewInCanvas) {
                var a = this.viewRect,
                b = this._unionBounds,
                c = a.x + a.width / 2 - b.x - b.width / 2,
                d = a.y + a.height / 2 - b.y - b.height / 2;
                Ib.Util.moveElements(this._box.toDatas(), c, d)
            } else {
                var c = this.viewRect.width / 2 - this._unionBounds.width / 2,
                d = this.viewRect.height / 2 - this._unionBounds.height / 2;
                this.setViewRect(this._unionBounds.x - c, this._unionBounds.y - d, this.viewRect.width, this.viewRect.height)
            }
        },
        getLinkPathFunction: function() {
            return this._linkPathFunction
        },
        setLinkPathFunction: function(a) {
            var b = this._linkPathFunction;
            this._linkPathFunction = a,
            this.firePropertyChange("linkPathFunction", b, a),
            this.invalidateElementUIs()
        },
        invalidate: function() {
            this._invalidate || (this._invalidate = !0, this.fireViewEvent({
                kind: "invalidate"
            }))
        },
        validate: function() {
            this._invalidate && (Mb || 0 !== this._view.offsetWidth || 0 !== this._view.offsetHeight) && (this._invalidate = !1, this._isValidating = !0, this.fireViewEvent({
                kind: "validateStart"
            }), this.validateImpl(), this.fireViewEvent({
                kind: "validateEnd"
            }), this._isValidating = !1)
        },
        onClickElement: function(a, b) {},
        onClickBackground: function(a) {},
        onDoubleClickElement: function(a, b) {},
        onDoubleClickBackground: function(a) {},
        onLongClickElement: function(a, b) {},
        onLongClickBackground: function(a) {},
        onMouseMove: function(a, b) {},
        onMouseEnter: function(a, b) {},
        onMouseLeave: function(a, b) {},
        setMovingElement: function(a) {
            if (a != this._movingElement) {
                var b = this._movingElement;
                this._movingElement = a,
                this.firePropertyChange("movingElement", b, a),
                this._box._undoManager._enabled && (a ? this._box._undoManager.startBatch() : this._box._undoManager.endBatch())
            }
        },
        setEditingElement: function(a) {
            if (a != this._editingElement) {
                var b = this._editingElement;
                this._editingElement = a,
                this.firePropertyChange("editingElement", b, a),
                this._box._undoManager._enabled && (a ? this._box._undoManager.startBatch() : this._box._undoManager.endBatch())
            }
        },
        dispose: function() {
            cancelAnimationFrame(this._loopId)
        }
    }),
    Ib.vector.Overview = function(a) {
        Ib.vector.Overview.superClass.constructor.apply(this, a),
        this._view = Wb.createView(),
        this._rootDiv = Wb.createDiv(),
        this._imageCanvas = Wb.createCanvas(),
        this._imageDiv = Wb.createDiv(),
        this._maskCanvas = Wb.createCanvas(),
        this._selectDiv = Wb.createDiv(),
        this._isNetworkDirty = !1,
        this._isMaskDirty = !1,
        Wb.setVisible(this._selectDiv, !1),
        this._view.appendChild(this._rootDiv),
        this._rootDiv.appendChild(this._imageDiv),
        this._rootDiv.appendChild(this._maskCanvas),
        this._rootDiv.appendChild(this._selectDiv),
        this._imageDiv.appendChild(this._imageCanvas),
        this._exportImageCanvas = Wb.createCanvas(),
        this._imageCtx = this._imageCanvas.getContext("2d"),
        this.setNetwork(a);
        var b;
        b = Qb.isMSToucheable ? Ib.vector.OverviewMSTouchInteraction: Qb.isTouchable ? Ib.vector.OverviewTouchInteraction: Ib.vector.OverviewInteraction,
        b && new b(this)
    },
    Jb.ext("twaver.vector.Overview", Ib.controls.ControlBase, {
        __accessor: ["fillColor", "outlineColor", "outlineWidth", "selectColor", "selectWidth", "padding", "maxPackingWidth", "maxPackingHeight"],
        __bool: ["animate"],
        _fillColor: Dd.OVERVIEW_FILL_COLOR,
        _outlineColor: Dd.OVERVIEW_OUTLINE_COLOR,
        _outlineWidth: Dd.OVERVIEW_OUTLINE_WIDTH,
        _selectColor: Dd.OVERVIEW_SELECT_COLOR,
        _selectWidth: Dd.OVERVIEW_SELECT_WIDTH,
        _padding: Dd.OVERVIEW_PADDING,
        _animate: Dd.OVERVIEW_ANIMATE,
        _maxPackingWidth: Dd.OVERVIEW_MAX_PACKING_WIDTH,
        _maxPackingHeight: Dd.OVERVIEW_MAX_PACKING_HEIGHT,
        getNetwork: function() {
            return this._network
        },
        onPropertyChanged: function(a) {
            this._invalidateMask()
        },
        setNetwork: function(a) {
            a !== this._network && (this._network && (this._network.removePropertyChangeListener(this._handleNetworkPropertyChange, this), this._network.removeViewListener(this._handleNetworkViewChange, this), Wb.removeEventListener("scroll", "_handleScrollChange", this._network.getView(), this)), this._network = a, this._network && (this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this), this._network.addViewListener(this._handleNetworkViewChange, this), Wb.addEventListener("scroll", "_handleScrollChange", this._network.getView(), this)), this.invalidate())
        },
        _handleNetworkPropertyChange: function(a) { ("zoom" === a.property || "currentSubNetwork" === a.property || "elementBox" === a.property || "dataBox" === a.property || "canvasSizeChange" === a.property) && this.invalidate()
        },
        _handleNetworkViewChange: function(a) {
            "validateEnd" === a.kind && this.invalidate()
        },
        _handleScrollChange: function() {
            this._invalidateMask()
        },
        invalidate: function(a) {
            this._isNetworkDirty && this._isMaskDirty || (this._isNetworkDirty || (this._isNetworkDirty = !0), this._isMaskDirty || (this._isMaskDirty = !0), Jb.callLater(this.validate, this, null, a))
        },
        _invalidateMask: function() {
            this._isMaskDirty || (this._isMaskDirty = !0, Jb.callLater(this.validate, this, [], 100))
        },
        validate: function() {
            if ((this._isMaskDirty || this._isNetworkDirty) && this._network && (this._maxPackingWidth > 0 && this._maxPackingHeight > 0 || this._view.clientWidth > 0 && this._view.clientHeight > 0) && 0 !== this._network.getViewRect().width && 0 !== this._network.getViewRect().height && !this._network._invalidate) {
                var a, b = this._maxPackingWidth > 0 && this._maxPackingHeight > 0;
                a = b ? {
                    x: 0,
                    y: 0,
                    width: this._maxPackingWidth,
                    height: this._maxPackingHeight
                }: {
                    x: 0,
                    y: 0,
                    width: this._view.clientWidth,
                    height: this._view.clientHeight
                },
                Tb.grow(a, -this._padding, -this._padding),
                b && (Wb.setDiv(this._view, {
                    x: 0,
                    y: 0,
                    width: this._imageDiv._viewRect.width,
                    height: this._imageDiv._viewRect.height
                },
                null, 0, null), a.width = this._imageDiv._viewRect.width, a.height = this._imageDiv._viewRect.height);
                var c = this._network.getGraphicsZoom(),
                d = this._network._unionBounds;
                d = Tb.unionRect(d, {
                    x: this._network.getViewRect().x,
                    y: this._network.getViewRect().y,
                    width: d.x,
                    height: d.y
                }),
                d = {
                    x: d.x / c,
                    y: d.y / c,
                    width: d.width / c,
                    height: d.height / c
                };
                var e = {
                    x: this._network.viewRect.x / c,
                    y: this._network.viewRect.y / c,
                    width: this._network.viewRect.width / c,
                    height: this._network.viewRect.height / c
                },
                f = Tb.unionRect(d, e),
                g = Math.min(a.width / f.width, a.height / f.height),
                h = f.width * g,
                i = f.height * g,
                j = f.width * g,
                k = f.height * g,
                l = a.x + (a.width - j) / 2,
                m = a.y + (a.height - k) / 2;
                if (this._isNetworkDirty) {
                    var n = {
                        x: l,
                        y: m,
                        width: j,
                        height: k
                    };
                    this._network.toCanvas(h, i, this._exportImageCanvas, g, f.x * g, f.y * g),
                    this._imageCanvas.setAttribute("width", j),
                    this._imageCanvas.setAttribute("height", k),
                    this._imageCtx.drawImage(this._exportImageCanvas, (d.x - f.x) * g * c, (d.y - f.y) * g * c, h, i),
                    Wb.setDiv(this._imageDiv, n, null, 0, null),
                    this._network.getElementBox && (this._imageDiv.style.backgroundColor = (this._network.getCurrentSubNetwork() || this._network.getElementBox()).getStyle("background.color") || ""),
                    this._isNetworkDirty = !1
                }
                if (this._isMaskDirty) {
                    var o = {
                        x: (e.x - f.x) * g,
                        y: (e.y - f.y) * g,
                        width: e.width * g,
                        height: e.height * g
                    },
                    p = Wb.setCanvas(this._maskCanvas, l, m, j, k);
                    p.lineWidth = 0,
                    p.fillStyle = this._fillColor,
                    Xb.drawVector(p, "rectangle", null, l, m, j, k),
                    p.closePath(),
                    p.fill(),
                    p.stroke(),
                    p.clearRect(l + o.x, m + o.y, o.width, o.height),
                    p.lineWidth = this._outlineWidth,
                    p.strokeStyle = this._outlineColor;
                    var q = o.width - 2 * this._outlineWidth,
                    r = o.height - 2 * this._outlineWidth;
                    q = Math.min(q, j - 2 - o.x - this._outlineWidth),
                    r = Math.min(r, k - 2 - o.y - this._outlineWidth),
                    Xb.drawVector(p, "rectangle", null, l + o.x + this._outlineWidth, m + o.y + this._outlineWidth, q, r),
                    p.closePath(),
                    p.stroke(),
                    this._isMaskDirty = !1
                }
            } else this._isNetworkDirty = !1,
            this._isMaskDirty = !1
        },
        getLogicalPoint: function(a) {
            return Wb.getLogicalPoint(this._view, a, 1, this._rootDiv)
        },
        centerNetwork: function(a, b) {
            var c = this._imageDiv._viewRect;
            Tb.containsPoint(c, a) && (this._network.centerByLogicalPoint((a.x - c.x) / c.width * this._network.getCanvasSize().width, (a.y - c.y) / c.height * this._network.getCanvasSize().height, b), this._invalidateMask())
        }
    }),
    Ib.vector.OverviewTouchInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        Wb.addEventListener("touchstart", "handleTouchstart", this.view, this)
    },
    Jb.ext("twaver.vector.OverviewTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            this.clear(),
            this.endPoint = this.overview.getLogicalPoint(a),
            zc.isMultiTouch(a) && (this.distance = zc.getDistance(a), this.zoom = this.network.getZoom()),
            Wb.addEventListener("touchmove", "handleTouchmove", this.view, this),
            Wb.addEventListener("touchend", "handleTouchend", this.view, this)
        },
        handleTouchmove: function(a) {
            if (this.moved || (this.moved = !0), this.endPoint = this.overview.getLogicalPoint(a), zc.isSingleTouch(a)) this.overview.centerNetwork(this.endPoint, !1);
            else if (this.distance) {
                var b = zc.getDistance(a) / this.distance;
                this.network.setZoom(this.zoom * b, !1)
            }
        },
        handleTouchend: function(a) {
            if (!this.moved) {
                this.endPoint = this.overview.getLogicalPoint(a);
                var b = this.lastPoint && this.lastTouchStartTime && (new Date).getTime() - this.lastTouchStartTime.getTime() <= 300 && Math.abs(this.endPoint.x - this.lastPoint.x) <= 10 && Math.abs(this.endPoint.y - this.lastPoint.y) <= 10;
                b ? (this.lastPoint = null, this.lastTouchStartTime = null) : (this.lastPoint = this.endPoint, this.lastTouchStartTime = new Date),
                b ? Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]) : this.overview.centerNetwork(this.endPoint, this.overview._animate)
            }
            this.clear()
        },
        clear: function() {
            this.endPoint && (this.endPoint = null, Wb.removeEventListener("touchmove", this.view, this), Wb.removeEventListener("touchend", this.view, this)),
            this.moved = !1
        }
    }),
    Ib.vector.OverviewMSTouchInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        this._pointerMap = {},
        this._pointerIdArray = [];
        var b = this;
        this.view.addEventListener("MSPointerDown",
        function(a) {
            b.handleTouchstart(a)
        },
        !1),
        this.view.addEventListener("MSPointerMove",
        function(a) {
            b.handleTouchmove(a)
        },
        !1),
        this.view.addEventListener("MSPointerUp",
        function(a) {
            b.handleTouchend(a)
        },
        !1),
        this.view.addEventListener("MSPointerCancel",
        function(a) {
            b.handleTouchend(a)
        },
        !1)
    },
    Jb.ext("twaver.vector.OverviewMSTouchInteraction", Object, {
        handleTouchstart: function(a) {
            Wb.preventDefault(a),
            a.isPrimary && this._pointerIdArray.length > 0 && (this._pointerMap = {},
            this._pointerIdArray = []),
            !this._pointerMap[a.pointerId] && this.overview.getLogicalPoint(a) && (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a),
            1 == this._pointerIdArray.length ? (this._startTouchPoint = this.overview.getLogicalPoint(a), this._startTouchTime = new Date) : 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.network.getZoom())
        },
        handleTouchmove: function(a) {
            if (0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10)) if (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length) {
                var b = this._getDistance() / this._distance;
                this.network.setZoom(this._zoom * b, !1)
            } else if (1 == this._pointerIdArray.length && this._startTouchPoint) {
                var c = this.overview.getLogicalPoint(a);
                if (null == c) return;
                this._startTouchPoint = c,
                this.overview.centerNetwork(this._startTouchPoint, !1)
            }
        },
        handleTouchend: function(a) {
            var b = this.overview.getLogicalPoint(a);
            if (1 == this._pointerIdArray.length && b) {
                var c = this._endTouchPoint && this._endTouchTime && (new Date).getTime() - this._endTouchTime.getTime() <= 500 && Tb.getDistance(this._endTouchPoint, b) <= 10;
                c ? (this._endTouchPoint = null, this._endTouchTime = null) : (this._endTouchPoint = b, this._endTouchTime = new Date),
                c ? Jb.callLater(this.network.zoomReset, this.network, [this.overview._animate]) : this.overview.centerNetwork(this._endTouchPoint, this.overview._animate)
            }
            this._pointerMap = {},
            this._pointerIdArray = []
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        }
    }),
    Ib.vector.OverviewInteraction = function(a) {
        this.overview = a,
        this.network = a.getNetwork(),
        this.view = a._view,
        Wb.addEventListener("mousedown", "handleMousedown", this.view, this)
    },
    Jb.ext("twaver.vector.OverviewInteraction", Object, {
        handleMousedown: function(a) {
            this.clear(),
            this.endPoint = this.overview.getLogicalPoint(a),
            Jb.isCtrlDown(a) && (this.startPoint = this.endPoint, Wb.setVisible(this.overview._selectDiv, !0)),
            Wb.addEventListener("mousemove", "handleMousemove", this.view, this),
            Wb.addEventListener("mouseup", "handleMouseup", this.view, this)
        },
        handleMouseup: function(a) {
            if (this.endPoint = this.overview.getLogicalPoint(a), "detail" in a && 2 === a.detail) Jb.callLater(this.network.zoomReset, this.network, [this.endPoint, this.overview._animate]);
            else if (Wb.isVisible(this.overview._selectDiv) && this.startPoint) {
                var b = this.overview._imageDiv._viewRect,
                c = this.overview._selectDiv._viewRect.x,
                d = this.overview._selectDiv._viewRect.y,
                e = b.width / this.overview._selectDiv._viewRect.width,
                f = b.height / this.overview._selectDiv._viewRect.height,
                g = Math.min(e, f);
                this.network.setZoom(g * Math.min(this.network.getViewRect().width / this.network.getCanvasSize().width, this.network.getViewRect().height / this.network.getCanvasSize().height) * this.network.getZoom(), !1);
                var h = this.network.getCanvasSize().width * ((c - b.x + this.overview._selectDiv._viewRect.width / 2) / b.width),
                i = this.network.getCanvasSize().height * ((d - b.y + this.overview._selectDiv._viewRect.height / 2) / b.height);
                Jb.callLater(this.network.centerByLogicalPoint, this.network, [h, i, this.overview._animate]),
                Wb.setVisible(this.overview._selectDiv, !1),
                Wb.setDiv(this.overview._selectDiv, {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                null, 0, null),
                this.startPoint = null
            } else this.overview.centerNetwork(this.endPoint, this.overview._animate);
            this.clear()
        },
        handleMousemove: function(a) {
            var b = this.overview.getLogicalPoint(a);
            if (this.endPoint = b, Wb.isVisible(this.overview._selectDiv) && this.startPoint) {
                var c = b.x > this.startPoint.x ? this.startPoint.x: b.x,
                d = b.x > this.startPoint.x ? this.startPoint.y: b.y;
                b.x > this.startPoint.x && b.y < this.startPoint.y && (d = b.y),
                b.x < this.startPoint.x && b.y > this.startPoint.y && (d = this.startPoint.y);
                var e = this.overview._imageDiv._viewRect;
                c < e.x && (c = e.x),
                c > e.x + e.width && (c = e.x + e.width),
                d < e.y && (d = e.y),
                d > e.y + e.height && (d = e.y + e.height);
                var f = Math.abs(b.x - this.startPoint.x),
                g = Math.abs(b.y - this.startPoint.y);
                c + f > e.x + e.width && (f = e.x + e.width - c),
                d + g > e.y + e.height && (g = e.y + e.height - d),
                Wb.setDiv(this.overview._selectDiv, {
                    x: c,
                    y: d,
                    width: f,
                    height: g
                },
                null, this.overview._selectWidth, this.overview._selectColor)
            } else this.overview.centerNetwork(b, !1)
        },
        clear: function() {
            this.endPoint && (this.endPoint = null, Wb.removeEventListener("mousemove", this.view, this), Wb.removeEventListener("mouseup", this.view, this))
        }
    }),
    Ib.vector.ElementUI = function(a, b) {
        this._network = a,
        this._element = b,
        this._attachments = new Ib.List,
        this._bodyBounds = new Ib.List,
        this._hitTest = !1,
        this._hitTest = !1,
        this._intersectTest = !1,
        this.invalidate(!0)
    },
    Jb.ext("twaver.vector.ElementUI", Object, {
        getElement: function() {
            return this._element
        },
        getNetwork: function() {
            return this._network
        },
        handlePropertyChange: function(a) {},
        handleSelectionChange: function(a) {},
        invalidate: function(a) {
            a === b && (a = !0),
            a && (this._invalidateAttachmentsFlag = !0),
            this._invalidateFlag || (this._hotSpot = null, this._bodyRect = null, this._invalidateFlag = !0, this.invalidateZoom(), this.setAttachmentVisible && this.setAttachmentVisible(!1))
        },
        invalidateZoom: function() {
            this._zoomBodyRect = null,
            this._zoomViewRect = null,
            this._zoomHotSpot = null
        },
        updateStyle: function() {
            this._innerColor = this._network.getInnerColor(this._element),
            this._outerColor = this._network.getOuterColor(this._element),
            this._glowBlur = this._element.getStyle("glow.blur"),
            this._shadowColor = this._network.getShadowColor(this._element),
            this._shadowXOffset = this._element.getStyle("shadow.xoffset"),
            this._shadowYOffset = this._element.getStyle("shadow.yoffset"),
            this._shadowBlur = this._element.getStyle("shadow.blur"),
            this._wholeAlpha = this._element.getStyle("whole.alpha")
        },
        validate: function() {
            var a = this;
            if (0 != this._invalidateFlag) {
                this._bodyBounds.clear(),
                this._invalidateAttachmentsFlag && (this._invalidateAttachmentsFlag = !1, this.checkAttachments()),
                this._invalidateFlag = !1,
                this.updateStyle(),
                this.validateImpl(),
                this._attachments.forEach(function(a) {
                    a.validate()
                });
                var b;
                this._bodyBounds.forEach(function(a) {
                    b = Tb.unionRect(b, a)
                }),
                null == b && (b = Jb.cloneRect(this._element.getLocation()), b.width = 0, b.height = 0),
                this._unionBodyBounds = {
                    x: b.x,
                    y: b.y,
                    width: b.width,
                    height: b.height
                },
                this._attachments.forEach(function(c) {
                    b = c instanceof Ib.vector.EditAttachment ? c.getElementUI() instanceof Ib.vector.LinkUI ? Tb.unionRect(b, c._viewRect) : Tb.unionRect(b, a._network.zoomManager._reverseElementZoomRect(a, c._viewRect)) : c.getElementUI() instanceof Ib.vector.LinkUI ? Tb.unionRect(b, a._network.zoomManager._getAttachmentZoomOutLineRect(c, c._viewRect)) : c.getElementUI() instanceof Ib.vector.GroupUI && c.getElementUI()._shapeRect ? c instanceof Ib.vector.IconsAttachment ? Tb.unionRect(b, c._viewRect) : Tb.unionRect(b, a._network.zoomManager._getAttachmentZoomOutLineRect(c, c._viewRect)) : Tb.unionRect(b, c._viewRect)
                }),
                this._viewRect = b
            }
        },
        validateImpl: function() {},
        setGlow: function(a, b) {
            "glow" === this._element.getStyle("outer.style") && (b.shadowColor = this._outerColor, b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = this._glowBlur)
        },
        clearGlow: function(a) { (0 != a.shadowOffsetX || 0 != a.shadowOffsetY || 0 != a.shadowBlur) && (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0)
        },
        setShadow: function(a, b) {
            var c = this._network.zoomManager,
            d = a.isShadowable() && this._shadowColor && !this._editAttachment;
            if (b.shadowOffsetX === this._shadowXOffset && b.shadowOffsetY === this._shadowYOffset && b.shadowBlur === this._shadowBlur) return b;
            if (d || this._network._showShadowInEdit) {
                var e = c.getGraphicsZoom(),
                f = c.getSizeZoom();
                e *= f,
                e > 1 && (e = 1),
                b.shadowOffsetX = this._shadowXOffset * e,
                b.shadowOffsetY = this._shadowYOffset * e,
                b.shadowBlur = this._shadowBlur * e,
                b.shadowColor = this._shadowColor
            }
            return b
        },
        clearShadow: function(a) { (0 != a.shadowOffsetX || 0 != a.shadowOffsetY || 0 != a.shadowBlur) && (a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0)
        },
        appendShadowBound: function(a, b) {
            var c = a.isShadowable() && this._shadowColor && !this._editAttachment;
            if (c) {
                var d = this._network.zoomManager,
                e = d.getGraphicsZoom(),
                f = d.getSizeZoom();
                e *= f,
                e > 1 && (e = 1),
                this._shadowXOffset > 0 ? b.width += this._shadowXOffset: (b.x += this._shadowXOffset, b.width += -this._shadowXOffset),
                this._shadowYOffset > 0 ? b.height += this._shadowYOffset: (b.y += this._shadowYOffset, b.height += -this._shadowYOffset);
                var g = this._shadowBlur;
                g = Math.ceil(g / e),
                Tb.grow(b, g + 1, g + 1)
            }
            return b
        },
        appendGlowBound: function(a, b) {
            if ("glow" === this._element.getStyle("outer.style")) {
                var c = this._network.zoomManager,
                d = c.getGraphicsZoom(),
                e = c.getSizeZoom();
                d *= e,
                d > 1 && (d = 1);
                var f = this._glowBlur;
                f = Math.ceil(f / d),
                Tb.grow(b, f + 1, f + 1)
            }
        },
        isShadowable: function() {
            return this._shadowColor && this._network.isSelected(this._element) && "shadow" === this._element.getStyle("select.style") ? !0 : !1
        },
        addAttachment: function(a) {
            this._attachments.add(a),
            this.invalidate(!1)
        },
        removeAttachment: function(a) {
            this._attachments.remove(a),
            this.invalidate(!1)
        },
        getAttachments: function() {
            return this._attachments
        },
        checkAttachments: function() {
            this.checkLabelAttachment(),
            this.checkLabel2Attachment(),
            this.checkAlarmAttachment(),
            this.checkIconsAttachment(),
            this.checkEditAttachment()
        },
        checkLabelAttachment: function() {
            var a = this._network.getLabel(this._element);
            null != a && "" !== a ? this._labelAttachment || (this._labelAttachment = new Ib.vector.LabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkLabel2Attachment: function() {
            var a = this._network.getLabel2(this._element);
            null != a && "" !== a ? this._label2Attachment || (this._label2Attachment = new Ib.vector.Label2Attachment(this, Dd.SHOW_LABEL2_IN_ATTACHMENT_DIV), this.addAttachment(this._label2Attachment)) : this._label2Attachment && (this.removeAttachment(this._label2Attachment), this._label2Attachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._network.getAlarmLabel(this._element);
            null != a && "" !== a ? this._alarmAttachment || (this._alarmAttachment = new Ib.vector.AlarmAttachment(this, Dd.SHOW_ALARM_IN_ATTACHMENT_DIV), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        },
        checkIconsAttachment: function() {
            var a = this._network.getIconsNames(this._element);
            a && a.length > 0 ? this._iconsAttachment || (this._iconsAttachment = new Ib.vector.IconsAttachment(this, Dd.SHOW_ICON_IN_ATTACHMENT_DIV), this.addAttachment(this._iconsAttachment)) : this._iconsAttachment && (this.removeAttachment(this._iconsAttachment), this._iconsAttachment = null)
        },
        checkEditAttachment: function() {
            this._network.hasEditInteraction() && this._network.isSelected(this._element) && this._network.isEditable(this._element) && this.isEditable() ? this._editAttachment || (this._editAttachment = new Ib.vector.EditAttachment(this, Dd.SHOW_EDIT_IN_ATTACHMENT_DIV), this.addAttachment(this._editAttachment)) : this._editAttachment && (this.removeAttachment(this._editAttachment), this._editAttachment = null)
        },
        getLabelAttachment: function() {
            return this._labelAttachment
        },
        getAlarmAttachment: function() {
            return this._alarmAttachment
        },
        getIconsAttachment: function() {
            return this._iconsAttachment
        },
        getEditAttachment: function() {
            return this._editAttachment
        },
        isEditable: function() {
            return ! 0
        },
        getInnerColor: function() {
            return this._innerColor
        },
        getOuterColor: function() {
            return this._outerColor
        },
        getShadowColor: function() {
            return this._shadowColor
        },
        getDyeColor: function(a) {
            return this._innerColor ? this._innerColor: this.getStyle(a)
        },
        getStyle: function(a) {
            return this._element.getStyle(a)
        },
        getFont: function(a) {
            var b = this._element.getStyle(a);
            return b ? b: Ib.Defaults.FONT
        },
        paint: function(a) {
            a.save(),
            a.globalAlpha = this._wholeAlpha,
            a.beginPath(),
            this.paintBody(a),
            this.clearShadow(a),
            this.clearGlow(a),
            a.closePath(),
            a.beginPath(),
            this.paintAttachments(a),
            a.closePath(),
            a.restore(),
            this._network._debug && Xb.strokeRect(a, this.getZoomViewRect(), "#820F8D")
        },
        paintBody: function(a) {},
        getZoomBodyRect: function(a) {
            return this._network.zoomManager._getElementZoomRect(this, this.getBodyRect())
        },
        getZoomHotSpot: function() {
            return this._zoomHotSpot || (this._zoomHotSpot = this._network.zoomManager._getZoomHotSpot(this, this._hotSpot)),
            Jb.clone(this._zoomHotSpot)
        },
        getZoomPointers: function(a, b) {
            return this._network.zoomManager._getZoomPointers(a, this, b)
        },
        _getZoomViewRect: function(a, b, c) {
            var d = this._network.zoomManager;
            if (b) {
                var e = Jb.cloneRect(d._getAttachmentZoomRect(b, a));
                return e
            }
            var f = d.getLocationZoom(),
            g = d.getSizeZoom(this),
            h = this._bodyRect ? this._bodyRect: this.getBodyRect();
            a = a || {
                x: h.x,
                y: h.y,
                width: 0,
                height: 0
            };
            var i = h.x + h.width / 2,
            j = h.y + h.height / 2;
            return {
                x: i * f + (a.x - i) * g,
                y: j * f + (a.y - j) * g,
                width: a.width * g,
                height: a.height * g
            }
        },
        getZoomViewRect: function(a) {
            var b = this._network.zoomManager,
            c = b.getLocationZoom();
            if (b.getGraphicsZoom(), 1 == c) return Jb.cloneRect(this._viewRect);
            if (!this._zoomViewRect || a) {
                var d, e = this._getZoomViewRect(Jb.cloneRect(this._unionBodyBounds), !1);
                d = Tb.unionRect(d, e),
                this._attachments.forEach(function(a) {
                    d = a instanceof Ib.vector.EditAttachment ? Tb.unionRect(d, a._viewRect) : Tb.unionRect(d, a.getZoomViewRect())
                }),
                this._zoomViewRect = d
            }
            return Jb.cloneRect(this._zoomViewRect)
        },
        paintAttachments: function(a) {
            a.beginPath();
            for (var b = this._attachments.size(), c = 0; b > c; c++) {
                var d = this._attachments.get(c);
                1 == this._hitTest && 0 == d.isShowOnTop() && this.paintAttachment(a, d),
                1 == this._intersectTest && this.paintAttachment(a, d),
                0 == this._hitTest && 0 == this._intersectTest && (d.isShowOnTop() ? this._network._topAttachmentList.add(d) : this.paintAttachment(a, d))
            }
        },
        paintAttachment: function(a, b) {
            var c = this._network.zoomManager;
            c.isAttachmentVisible(this._element) && (b != this._labelAttachment && b != this._label2Attachment || c.isLabelVisible(this._element)) && (b != this._alarmAttachment || c.isAlarmBalloonVisible(this._element)) && (a.beginPath(), b.paint(a), this.clearShadow(a))
        },
        getViewRect: function() {
            return Jb.cloneRect(this._viewRect)
        },
        getUnionBodyBounds: function() {
            return Jb.cloneRect(this._unionBodyBounds)
        },
        addBodyBounds: function(a) {
            a && this._bodyBounds.add(a)
        },
        getBodyRect: function(a) {
            return a == b && (a = !0),
            this._bodyRect || (this._bodyRect = this.createBodyRect()),
            a ? Jb.cloneRect(this._bodyRect) : this._bodyRect
        },
        getHotSpot: function() {
            return this._hotSpot ? Jb.clone(this._hotSpot) : {
                x: 0,
                y: 0
            }
        },
        setHotSpot: function(a) {
            this._hotSpot = a
        },
        hit: function(a, b) {
            return ! 1
        },
        intersects: function(a) {
            return Tb.contains(a, this.getZoomViewRect()) ? !0 : !1
        },
        hitCanvasRectAtBody: function(a) {
            var b = Nd.getHitCanvas(a.width, a.height),
            c = Nd.getCtx(b);
            if (c.save(), c.translate( - a.x, -a.y), this._element.getImage) {
                var d = Jb.getImageAsset(this._element.getImage());
                if (d && d.getImage() instanceof Gd) return 1
            }
            this.paintBody(c);
            try {
                for (var e = c.getImageData(0, 0, a.width, a.height), f = e.data, g = 0; g < e.width; g++) for (var h = 0; h < e.height; h++) {
                    var i = 4 * (h * e.width + g),
                    j = f[i + 3];
                    if (0 !== j) return c.restore(),
                    1
                }
            } catch(k) {
                if (Nd.disposeHitCanvas(), Tb.contains(this.getUnionBodyBounds(), a)) return 0
            }
            return c.restore(),
            -1
        },
        hitCanvasRectAtAttachments: function(a) {
            var b = Nd.getHitCanvas(a.width, a.height),
            c = Nd.getCtx(b);
            c.save(),
            c.translate( - a.x, -a.y),
            this.paintAttachments(c);
            try {
                for (var d = c.getImageData(0, 0, a.width, a.height), e = d.data, f = 0; f < d.width; f++) for (var g = 0; g < d.height; g++) {
                    var h = 4 * (g * d.width + f),
                    i = e[h + 3];
                    if (0 !== i) return c.restore(),
                    1
                }
            } catch(j) {
                Nd.disposeHitCanvas()
            }
            return c.restore(),
            -1
        },
        hitCanvasRect: function(a) {
            this._intersectTest = !0,
            1 == this._hitTest && (this._intersectTest = !1);
            var b = Tb.intersection(a, this.getZoomViewRect()),
            c = this.hitCanvasRectAtBody(b);
            if (1 == c) return this._intersectTest = !1,
            !0;
            var d = this.hitCanvasRectAtAttachments(b);
            return 1 == d ? (this._intersectTest = !1, !0) : (this._intersectTest = !1, 0 == c)
        },
        hitCanvasPoint: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            if (d && d > 0 && Tb.grow(c, d, d), !Tb.intersects(this.getZoomViewRect(), c)) return ! 1;
            this._hitTest = !0;
            var e = this.hitCanvasRect(c);
            return this._hitTest = !1,
            e
        },
        hitTest: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            if (d && d > 0 && Tb.grow(c, d, d), !Tb.intersects(this.getZoomViewRect(), c)) return null;
            for (var e = Tb.intersection(c, this.getZoomViewRect()), f = this._attachments.size(), g = 0; f > g; g++) {
                var h = this._attachments.get(g);
                if (h.hit(a, b)) return h
            }
            var i = this.hitCanvasRectAtBody(e);
            return 1 == i ? this: 0 == i ? this: null
        },
        dispose: function() {
            this._attachments.forEach(function(a) {
                a.dispose()
            }),
            this._attachments.clear()
        }
    }),
    Ib.vector.NodeUI = function(a, b) {
        Ib.vector.NodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.NodeUI", Ib.vector.ElementUI, {
        invalidate: function(a) {
            this.curInterval && clearInterval(this.curInterval),
            Ib.vector.NodeUI.superClass.invalidate.call(this, a)
        },
        createBodyRect: function() {
            return this._element.getRect()
        },
        validateImpl: function() {
            Ib.vector.NodeUI.superClass.validateImpl.call(this);
            var a = this.getStyle("vector.shape"),
            b = this.getBodyRect();
            this._hotSpot = Tb.getHotSpot(b.x, b.y, b.width, b.height, a),
            this.validateBodyBounds()
        },
        validate: function() {
            0 != this._invalidateFlag && Ib.vector.NodeUI.superClass.validate.call(this)
        },
        validateBodyBounds: function() {
            var a = this.getStyle("body.type");
            "default" === a ? this.addBodyBounds(this.getDefaultBodyRect()) : "vector" === a ? this.addBodyBounds(this.getVectorBody()) : "default.vector" === a ? (this.addBodyBounds(this.getVectorBody()), this.addBodyBounds(this.getDefaultBodyRect())) : "vector.default" === a && (this.addBodyBounds(this.getDefaultBodyRect()), this.addBodyBounds(this.getVectorBody())),
            this._outerColor && "border" === this.getStyle("outer.style") && this.addBodyBounds(this.getOuterBorderRect()),
            !this._editAttachment && "border" === this.getStyle("select.style") && this._network.isSelected(this._element) && this.addBodyBounds(this.getSelectBorderRect())
        },
        getDefaultBodyRect: function() {
            var a = this._element,
            b = this.getBodyRect();
            if (!a.getImage() || "string" == typeof a.getImage() && !Jb.getImageAsset(a.getImage())) return b;
            Tb.addPadding(b, this._element, "image.padding", 1);
            var c = Jb.cloneRect(b);
            return this.appendGlowBound(this, c),
            this.appendShadowBound(this, c),
            b = c
        },
        getVectorBody: function() {
            var a = this.getPathRect("vector");
            return a
        },
        getOuterBorderRect: function() {
            return this._getBorderRect("outer")
        },
        getSelectBorderRect: function() {
            return this._getBorderRect("select")
        },
        _getBorderRect: function(a) {
            var b = this._element,
            c = b.getStyle(a + ".width");
            if (c > 0) {
                var d = this.getBodyRect();
                Tb.addPadding(d, b, a + ".padding", 1);
                var e = Jb.cloneRect(d);
                return Tb.grow(e, 2 * c, 2 * c),
                e
            }
            return null
        },
        getPathRect: function(a, b) {
            var c = this._element,
            d = this.getBodyRect();
            this._network.zoomManager.getSizeZoom(),
            b && Tb.addPadding(d, c, a + ".padding", 1);
            var e = Jb.cloneRect(d),
            f = c.getStyle(a + ".outline.width");
            if (f > 0) if (this._getZoomPoints) {
                for (var g = this._element._points,
                h = g.size(), i = 0, j = 0; h > j; j++) {
                    if (0 == j) var k = g.get(j),
                    l = g.get(h - 1),
                    m = g.get(j + 1);
                    else if (j == h - 1) var k = g.get(j),
                    l = g.get(j - 1),
                    m = g.get(0);
                    else var k = g.get(j),
                    l = g.get(j - 1),
                    m = g.get(j + 1);
                    var n = Tb.getCenterPoint(l, m),
                    o = Tb.getAngle(n, k),
                    p = Math.abs(5 * (f + 1) * Math.sin(o));
                    i = p > i ? p: i,
                    p = Math.abs(5 * (f + 1) * Math.cos(o)),
                    i = p > i ? p: i
                }
                Tb.grow(e, i, i)
            } else Tb.grow(e, f / 2, f / 2);
            return this.appendGlowBound(this, e),
            this.appendShadowBound(this, e),
            e
        },
        getZoomPathRect: function(a, b) {
            var c = this._element,
            d = this.getZoomBodyRect();
            this._network.zoomManager.getSizeZoom(),
            b && Tb.addPadding(d, c, a + ".padding", 1);
            var e = Jb.cloneRect(d),
            f = c.getStyle(a + ".outline.width");
            if (f > 0) if (this._getZoomPoints) {
                for (var g = this._getZoomPoints(), h = g.size(), i = 0, j = 0; h > j; j++) {
                    if (0 == j) var k = g.get(j),
                    l = g.get(h - 1),
                    m = g.get(j + 1);
                    else if (j == h - 1) var k = g.get(j),
                    l = g.get(j - 1),
                    m = g.get(0);
                    else var k = g.get(j),
                    l = g.get(j - 1),
                    m = g.get(j + 1);
                    var n = Tb.getCenterPoint(l, m),
                    o = Tb.getAngle(n, k),
                    p = Math.abs(5 * (f + 1) * Math.sin(o));
                    i = p > i ? p: i,
                    p = Math.abs(5 * (f + 1) * Math.cos(o)),
                    i = p > i ? p: i
                }
                Tb.grow(e, i, i)
            } else Tb.grow(e, f / 2, f / 2);
            return this.appendGlowBound(this, e),
            this.appendShadowBound(this, e),
            e
        },
        paintBody: function(a) {
            if (this._network.hasEditInteraction() && this._network.isEditable(this._element) && this.isEditable() && this._network.isSelected(this._element)) {
                var b, c = this._network.getElementBox(),
                d = c.getDatas();
                for (b = 0; b < d.size(); b++) if (d.get(b) instanceof Ib.Link) {
                    var e = d.get(b).getToNode(),
                    f = d.get(b).getFromNode();
                    c.adjustElementIndex(f),
                    c.adjustElementIndex(e)
                }
            }
            this.curInterval && clearInterval(this.curInterval);
            var g = this.getStyle("body.type");
            "default" === g ? this.drawDefaultBody(a) : "vector" === g ? this.drawVectorBody(a) : "default.vector" === g ? (this.drawVectorBody(a), this.drawDefaultBody(a)) : "vector.default" === g && (this.drawDefaultBody(a), this.drawVectorBody(a)),
            this._outerColor && "border" === this.getStyle("outer.style") && this.drawOuterBorder(a),
            "border" === this.getStyle("select.style") && this._network.isSelected(this._element) && this.drawSelectBorder(a)
        },
        drawOuterBorder: function(a) {
            var b = this._element,
            c = b.getStyle("outer.width");
            if (c > 0) {
                var d = this.getZoomBodyRect();
                Tb.addPadding(d, b, "outer.padding", 1),
                a.lineWidth = c,
                a.lineCap = b.getStyle("outer.cap"),
                a.lineJoin = b.getStyle("outer.join"),
                a.strokeStyle = this._outerColor,
                Xb.drawVector(a, b.getStyle("outer.shape"), null, d),
                a.stroke()
            }
        },
        drawDefaultBody: function(a) {
            var b, c = this._element;
            if (c.getImage() && ("string" != typeof c.getImage() || (b = Jb.getImageAsset(c.getImage())))) {
                var d = this.getZoomBodyRect();
                if (Tb.addPadding(d, this._element, "image.padding", 1), 0 != c.getAngle() && (a.save(), d = c.getOriginalRect(), d = this._network.zoomManager._getElementZoomRect(this, d), Ib.Util.rotateCanvas(a, d, c.getAngle())), this.setGlow(this, a), this.setShadow(this, a), b && b.getImage() instanceof Gd) {
                    var e, f = b.getImage().frames,
                    g = b.getImage().size,
                    h = 0;
                    e = Id(f, g, 0),
                    a.drawImage(e, d.x, d.y, d.width, d.height),
                    this.curInterval = setInterval(function() {
                        h = (h + f.length) % f.length,
                        e = Id(f, g, h),
                        a.drawImage(e, d.x, d.y, d.width, d.height),
                        h++
                    },
                    100)
                } else Nc(a, c.getImage(), this.getInnerColor(), d, c, this._network);
                0 != c.getAngle() && a.restore()
            }
        },
        drawSelectBorder: function(a) {
            this.clearGlow(a);
            var b = this._element,
            c = b.getStyle("select.width");
            if (c > 0) {
                var d = this.getZoomBodyRect();
                Tb.addPadding(d, b, "select.padding", 1);
                var e = Jb.cloneRect(d);
                Tb.grow(e, c / 2, c / 2),
                a.lineWidth = c,
                a.lineCap = b.getStyle("select.cap"),
                a.lineJoin = b.getStyle("select.join"),
                a.strokeStyle = b.getStyle("select.color"),
                Xb.drawVector(a, b.getStyle("select.shape"), null, d),
                a.stroke()
            }
        },
        drawVectorBody: function(a) {
            this.drawPath(a, "vector", !0, this._element.getStyle("vector.outline.pattern"));
            var b = this.getStyle("vector.deep"),
            c = this.getStyle("vector.fill.color");
            if (0 !== b && c && "rectangle" === this.getStyle("vector.shape")) {
                var d = this.getZoomBodyRect(),
                e = this._element.getAngle();
                if (0 != e) {
                    a.save();
                    var f = this._element.getOriginalRect();
                    f = this._network.zoomManager._getElementZoomRect(this, f),
                    Ib.Util.rotateCanvas(a, f, e)
                }
                Xb.draw3DRect(a, c, b, d),
                0 != e && a.restore()
            }
        },
        drawPath: function(a, b, c, d, e, f, g) {
            var h = this._network.zoomManager,
            i = this._element,
            j = null;
            j = "group" == b ? this._shapeRect: this.getZoomBodyRect(),
            c && Tb.addPadding(j, i, b + ".padding", 1);
            var k = i.getStyle(b + ".outline.width");
            this.setGlow(this, a),
            this.setShadow(this, a),
            0 != i.getAngle() && (i instanceof Md || (j = i.getOriginalRect(), j = h._getElementZoomRect(this, j)), a.save(), Ib.Util.rotateCanvas(a, j, i.getAngle()));
            var l, m = i.getStyle(b + ".fill");
            if (m) {
                l = this._innerColor && !vc.hasDefault(this._element) ? this._innerColor: i.getStyle(b + ".fill.color");
                var n = i.getStyle(b + ".gradient");
                n ? Xb.fill(a, l, n, i.getStyle(b + ".gradient.color"), j) : a.fillStyle = l
            }
            var o = i.getStyle(b + ".shape"),
            p = i.getStyle("group.shape.roundrect.radius");
            m && (a.beginPath(), e ? Xb.drawLinePoints(a, e, null, f, g) : "roundrect" === o && "group" === b ? Xb.drawVector(a, o, null, j, p) : Xb.drawVector(a, o, null, j), a.fill()),
            k > 0 && (a.lineWidth = k, a.lineCap = i.getStyle(b + ".cap"), a.lineJoin = i.getStyle(b + ".join"), a.strokeStyle = i.getStyle(b + ".outline.color"), a.beginPath(), e ? Xb.drawLinePoints(a, e, d, f, g) : "roundrect" === o && "group" === b ? Xb.drawVector(a, o, d, j, p) : Xb.drawVector(a, o, d, j), a.stroke()),
            0 != i.getAngle() && a.restore()
        },
        hit: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            if (d && d > 0 && Tb.grow(c, d, d), this._network._transparentSelectionEnable) {
                var e = this.getBodyRect();
                if (Jb.math.intersects(e, c)) return ! 0
            }
            return Tb.intersects(this.getZoomViewRect(), c) ? this.hitCanvasPoint(a, b) : !1
        },
        intersects: function(a) {
            var b = Ib.vector.NodeUI.superClass.intersects.apply(this, arguments);
            if (1 == b) return ! 0;
            if (this._network._transparentSelectionEnable) {
                var c = this.getBodyRect();
                if (Jb.math.intersects(c, a)) return ! 0
            }
            return Tb.intersects(a, this.getZoomViewRect()) ? this.hitCanvasRect(a) : !1
        }
    }),
    Ib.vector.LinkUI = function(a, b) {
        Ib.vector.LinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.LinkUI", Ib.vector.ElementUI, {
        isEditable: function() {
            return ! 0
        },
        invalidate: function(a) {
            this._linkPoints = null,
            this._fromPoint = null,
            this._toPoint = null,
            this._angle = null,
            Ib.vector.LinkUI.superClass.invalidate.call(this, a)
        },
        invalidateZoom: function() {
            this._fromPoint = null,
            this._toPoint = null,
            this._linkPoints = null,
            Ib.vector.LinkUI.superClass.invalidateZoom.call(this)
        },
        validateImpl: function() {
            this.validateBodyBounds(),
            Ib.vector.LinkUI.superClass.validateImpl.call(this)
        },
        validateBodyBounds: function() {
            var a = this.getLinkPoints();
            if (a && !(a.size() < 2)) {
                var b = this._element,
                c = Tb.getLineRect(a),
                d = b.getStyle("link.width"),
                e = d;
                if (this._outerColor) {
                    var f = b.getStyle("outer.width");
                    e += 2 * f
                }
                var g = !this._editAttachment && "border" === b.getStyle("select.style") && this._network.isSelected(this._element);
                if (g) {
                    var h = b.getStyle("select.width");
                    e += 2 * h
                }
                Tb.grow(c, e / 2, e / 2),
                b.getStyle("arrow.from") && (this._network._edgeDetect ? (this._network._debug && (this._arrowFromRect = od.getArrowRect(this, a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), 0, 0, this._network.zoomManager)), c = Tb.unionRect(c, od.getArrowRect(this, a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), 0, 0, this._network.zoomManager))) : (this._network._debug && (this._arrowFromRect = od.getArrowRect(this, a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), b.getStyle("arrow.from.xoffset"), b.getStyle("arrow.from.yoffset"), this._network.zoomManager)), c = Tb.unionRect(c, od.getArrowRect(this, a, !0, b.getStyle("arrow.from.shape"), b.getStyle("arrow.from.width"), b.getStyle("arrow.from.height"), b.getStyle("arrow.from.xoffset"), b.getStyle("arrow.from.yoffset"), this._network.zoomManager)))),
                b.getStyle("arrow.to") && (this._network._edgeDetect ? (this._network._debug && (this._arrowToRect = od.getArrowRect(this, a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), 0, 0, this._network.zoomManager)), c = Tb.unionRect(c, od.getArrowRect(this, a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), 0, 0, this._network.zoomManager))) : (this._network._debug && (this._arrowToRect = od.getArrowRect(this, a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), b.getStyle("arrow.to.xoffset"), b.getStyle("arrow.to.yoffset"), this._network.zoomManager)), c = Tb.unionRect(c, od.getArrowRect(this, a, !1, b.getStyle("arrow.to.shape"), b.getStyle("arrow.to.width"), b.getStyle("arrow.to.height"), b.getStyle("arrow.to.xoffset"), b.getStyle("arrow.to.yoffset"), this._network.zoomManager)))),
                this.appendShadowBound(this, c),
                this.addBodyBounds(c),
                this._growLinkJoinBounds(c, e)
            }
        },
        _growLinkJoinBounds: function(a, b) {},
        createBodyRect: function() {
            var a = this.getHotSpot();
            return a ? {
                x: a.x - 1,
                y: a.y - 1,
                width: 2,
                height: 2
            }: null
        },
        paintBody: function(a) {
            if (this._network.hasEditInteraction() && this._network.isEditable(this._element) && this.isEditable()) {
                if (this._network.isSelected(this._element)) {
                    var b, c, d = this._network.getElementBox(),
                    e = d.getDatas();
                    for (c = 0; c < e.size(); c++) if (e.get(c) instanceof Ib.Link) {
                        var f = e.get(c).getToNode(),
                        g = e.get(c).getFromNode();
                        d.adjustElementIndex(g),
                        d.adjustElementIndex(f)
                    }
                    b = d.getDatas().indexOf(this._element),
                    d.getDatas().removeAt(b),
                    d.getDatas().add(this._element)
                }
            } else if (this._network.isSelected(this._element)) {
                var d = this._network.getElementBox(),
                f = this._element.getToNode(),
                g = this._element.getFromNode();
                d.adjustElementIndex(g),
                d.adjustElementIndex(f)
            }
            var h = this.getLinkPoints();
            if (h && !(h.size() < 2)) {
                var i = this._element,
                j = i.getStyle("link.width"),
                k = j;
                if (this._outerColor && "border" === this.getStyle("outer.style")) {
                    var l = i.getStyle("outer.width");
                    k += 2 * l
                }
                var m = !this._editAttachment && "border" === i.getStyle("select.style") && this._network.isSelected(this._element);
                if (m) {
                    var n = i.getStyle("select.width");
                    k += 2 * n
                }
                this.setGlow(this, a),
                this.setShadow(this, a),
                a.lineCap = i.getStyle("link.cap"),
                a.lineJoin = i.getStyle("link.join");
                var o = i.getStyle("link.pattern");
                m && this.drawLinePoints(a, h, k, i.getStyle("select.color"), o),
                this._outerColor && "border" === this.getStyle("outer.style") && this.drawLinePoints(a, h, j + 2 * l, this._outerColor, o),
                this.drawLinePoints(a, h, j, this._innerColor || i.getStyle("link.color"), o),
                od.drawLinkArrow(this, a, h, this._network.zoomManager)
            }
        },
        drawLinePoints: function(a, b, c, d, e) {
            if (a.lineWidth = c, a.strokeStyle = d, this._element.getStyle("link.flow") === !0 && e && e.length > 1) {
                var f = new uc(a, e[0], e[1]),
                g = this._element.getStyle("link.flow.offset"),
                h = Math.floor(g / (e[0] + e[1]));
                h > 2 && (g -= (e[0] + e[1]) * h),
                this._element.getStyle("link.flow.converse") ? g < e[0] ? f.overflow = e[0] - g: g >= e[0] && g <= e[0] + e[1] ? (f.overflow = e[1] - (g - e[0]), f.overflow && (f.isLine = !1)) : (g -= e[0] + e[1], f.overflow = e[0] - g) : g <= e[1] ? (f.overflow = g, g && (f.isLine = !1)) : g > e[1] && g <= e[0] + e[1] ? f.overflow = g - e[1] : (g -= e[0] + e[1], g && (f.isLine = !1), f.overflow = g),
                this._element._styleMap["link.flow.offset"] = g,
                a.beginPath(),
                Xb._drawLine(b, a),
                a.stroke(),
                a.shadowColor = "transparent",
                a.beginPath();
                var i = this._element.getStyle("link.flow.color");
                i = i ? i: Dd.NETWORK_LINK_FLOW_COLOR,
                a.strokeStyle = i,
                Xb._drawLine(b, f),
                a.stroke(),
                a.shadowColor = this._shadowColor
            } else a.beginPath(),
            Xb.drawLinePoints(a, b, e),
            a.stroke()
        },
        getLinkPoints: function() {
            return this._linkPoints || (this._linkPoints = this.createLinkPoints(), this._lineLength = Tb.calculateLineLength(this._linkPoints)),
            this._linkPoints
        },
        getFromPosition: function(a, b) {
            var c = this.getFromPoint();
            return c ? {
                x: c.x + a,
                y: c.y + b
            }: null
        },
        getToPosition: function(a, b) {
            var c = this.getToPoint();
            return c ? {
                x: c.x + a,
                y: c.y + b
            }: null
        },
        getFromPoint: function() {
            return this._fromPoint || (this._fromPoint = xc.createFromPoint(this, this._network.zoomManager)),
            this._fromPoint
        },
        getToPoint: function() {
            return this._toPoint || (this._toPoint = xc.createToPoint(this, this._network.zoomManager)),
            this._toPoint
        },
        getZoomBodyRect: function() {
            return this.getBodyRect()
        },
        getZoomViewRect: function() {
            return this._viewRect
        },
        createLinkPoints: function() {
            var a = this._network.zoomManager,
            b = this.getStyle("link.type"),
            c = new Ib.List;
            if (xc.isOrthogonalOrFlexionalLink(this._element)) c = xc.orthogonalAndFlexional(this, b, a);
            else if (this._element.isLooped()) {
                var d = this._network.getElementUI(this._element.getFromAgent());
                null != d && (this._hotSpot = xc.fillLoopedPoints(this, d.getZoomBodyRect(), c))
            } else {
                if ("arc" !== b && "triangle" !== b && "parallel" !== b) throw "Can not resolve link type '" + b + "'";
                var e = this.getFromPoint(),
                f = this.getToPoint();
                this._hotSpot = xc.fillBundlePoints(this, b, e, f, c, a)
            }
            if (this._network._linkPathFunction) {
                var g = this._network._linkPathFunction(this, c);
                g && (c = g)
            }
            return c
        },
        checkAttachments: function() {
            Ib.vector.LinkUI.superClass.checkAttachments.call(this),
            this.checkLinkHandlerAttachment()
        },
        checkLinkHandlerAttachment: function() {
            var a = this._network.getLinkHandlerLabel(this._element);
            null != a && "" !== a ? this._linkHandlerAttachment || (this._linkHandlerAttachment = new Ib.vector.LinkHandlerAttachment(this), this.addAttachment(this._linkHandlerAttachment)) : this._linkHandlerAttachment && (this.removeAttachment(this._linkHandlerAttachment), this._linkHandlerAttachment = null)
        },
        getLinkHandlerAttachment: function() {
            return this._linkHandlerAttachment
        },
        getControlPoint: function() {
            return xc.getControlPoint(this._element, this, this._network.zoomManager)
        },
        setControlPoint: function(a) {
            if (a) {
                var b = this.getStyle("link.type");
                if (xc.hasControlPoint(b)) {
                    var c = xc.getLinkSourceBounds(this, this._network.zoomManager),
                    d = xc.getLinkTargetBounds(this, this._network.zoomManager);
                    xc.setParamsByControlPoint(a, c, d, b, this._element)
                }
            }
        },
        getLineLength: function() {
            return this._lineLength
        },
        hit: function(a, b) {
            var c = {
                x: a,
                y: b,
                width: 0,
                height: 0
            },
            d = this._network.getSelectionTolerance();
            return d && d > 0 && Tb.grow(c, d, d),
            Tb.intersects(this._viewRect, c) ? this.hitCanvasPoint(a, b) : !1
        },
        intersects: function(a) {
            var b = Ib.vector.NodeUI.superClass.intersects.apply(this, arguments);
            if (1 == b) return ! 0;
            if (0 == Tb.intersects(a, this._viewRect)) return ! 1;
            var c = this.getLinkPoints(),
            d = c.size();
            if (2 == d) for (var e = 0; d > e; e += 2) {
                var f = c.get(e);
                if (d > e + 1) {
                    var g = c.get(e + 1);
                    if (Nd.intersectsLine(f.x, f.y, g.x, g.y, a.x, a.y, a.width, a.height)) return ! 0
                }
            }
            return this.hitCanvasRect(a)
        },
        getAngle: function() {
            return ! this._angle && this._fromPoint && this._toPoint && (this._angle = Tb.getAngle(this._fromPoint, this._toPoint)),
            this._angle || 0
        },
        getAbsoluteAngle: function() {
            var a = {
                x: 10,
                y: 0
            },
            b = this._fromPoint,
            c = this._toPoint,
            d = {
                x: c.x - b.x,
                y: c.y - b.y
            },
            e = 180 * Math.acos((d.x * a.x + d.y * a.y) / (Math.sqrt(a.x * a.x + a.y * a.y) * Math.sqrt(d.x * d.x + d.y * d.y))) / Math.PI;
            return e = b.y <= c.y ? e: 360 - e,
            e = e % 360 * Math.PI / 180
        },
        appendShadowBound: function(a, b) {
            var c = a.isShadowable() && this._shadowColor && !this._editAttachment;
            if (c) {
                this._shadowXOffset > 0 ? b.width += this._shadowXOffset: (b.x += this._shadowXOffset, b.width += -this._shadowXOffset),
                this._shadowYOffset > 0 ? b.height += this._shadowYOffset: (b.y += this._shadowYOffset, b.height += -this._shadowYOffset);
                var d = this._shadowBlur;
                Tb.grow(b, d + 1, d + 1)
            }
            return b
        }
    }),
    Ib.vector.GroupUI = function(a, b) {
        Ib.vector.GroupUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.GroupUI", Ib.vector.NodeUI, {
        isEditable: function() {
            return ! this._element.isExpanded()
        },
        paintBody: function(a) {
            this._shapeRect ? this.drawExpandedGroup(a) : Ib.vector.GroupUI.superClass.paintBody.apply(this, arguments)
        },
        validateBodyBounds: function() {
            if (this.getBodyRect(), this._shapeRect) {
                var a = this.getPathRect("group", !1),
                b = this.getStyle("group.deep");
                Tb.grow(a, b + 1, b + 1),
                this.addBodyBounds(a)
            } else Ib.vector.GroupUI.superClass.validateBodyBounds.call(this)
        },
        getZoomBodyRect: function() {
            return this._element.isExpanded() ? this.getBodyRect() : Ib.vector.GroupUI.superClass.getZoomBodyRect.call(this)
        },
        getZoomViewRect: function() {
            return this._element.isExpanded() ? this.getViewRect() : Ib.vector.GroupUI.superClass.getZoomViewRect.call(this)
        },
        drawExpandedGroup: function(a) {
            this.drawPath(a, "group", !1, this._element.getStyle("vector.outline.pattern"));
            var b = this.getStyle("group.deep"),
            c = this.getStyle("group.fill.color");
            0 !== b && c && "rectangle" === this.getStyle("group.shape") && Xb.draw3DRect(a, c, b, this._shapeRect)
        },
        getChildrenRects: function() {
            return this._network.getGroupChildrenRects(this._element)
        },
        createBodyRect: function() {
            this._shapeRect = null;
            var a = this._element,
            b = this._network;
            if (a.isExpanded()) {
                a.getChildren().forEach(function(a) {
                    var c = b.getElementUI(a);
                    c && c.validate()
                });
                var c = this.getChildrenRects();
                if (!c.isEmpty()) {
                    var d = a.getStyle("group.shape"),
                    e = Ub[d];
                    if (!e) throw "Can not resolve group shape '" + d + "'";
                    this._shapeRect = e(c)
                }
            }
            return this._shapeRect ? (Tb.addPadding(this._shapeRect, a, "group.padding", 1), this._shapeRect) : Ib.vector.GroupUI.superClass.createBodyRect.call(this)
        },
        appendShadowBound: function(a, b) {
            var c = a.isShadowable() && this._shadowColor && !this._editAttachment;
            if (c) {
                this._shadowXOffset > 0 ? b.width += this._shadowXOffset: (b.x += this._shadowXOffset, b.width += -this._shadowXOffset),
                this._shadowYOffset > 0 ? b.height += this._shadowYOffset: (b.y += this._shadowYOffset, b.height += -this._shadowYOffset);
                var d = this._shadowBlur;
                Tb.grow(b, d + 1, d + 1)
            }
            return b
        }
    }),
    Ib.vector.ShapeNodeUI = function(a, b) {
        Ib.vector.ShapeNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.ShapeNodeUI", Ib.vector.NodeUI, {
        getDefaultBodyRect: function() {
            return this._element._points.size() < 2 ? null: this._reverseZoomPathRect()
        },
        drawDefaultBody: function(a) {
            this._element._points.size() < 2 || (this.drawPath(a, "vector", !0, this._element.getStyle("vector.outline.pattern"), this._getZoomPoints(), this._element._segments, this._element.getStyle("shapenode.closed")), od.drawLinkArrow(this, a, Tb.getPointObject(this._element._points, this._element._segments)))
        },
        invalidateZoom: function() {
            this._zoomPoints = null,
            Ib.vector.LinkUI.superClass.invalidateZoom.call(this)
        },
        _getZoomPoints: function() {
            return this._zoomPoints = this._network.zoomManager._getShapeNodeZoomPoints(this, this._element._points),
            this._zoomPoints
        },
        _reverseZoomPathRect: function() {
            return this._network.zoomManager._reverseElementZoomRect(this, this.getZoomPathRect("vector", !0))
        }
    }),
    Ib.vector.ShapeLinkUI = function(a, b) {
        Ib.vector.ShapeLinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.ShapeLinkUI", Ib.vector.LinkUI, {
        isEditable: function() {
            return ! 0
        },
        createLinkPoints: function() {
            var a = this.getFromPoint(),
            b = this.getToPoint(),
            c = new Ib.List,
            d = this.getStyle("shapelink.type");
            c.add(a),
            null != this._element._points && c.addAll(this._network.zoomManager._getShapeLinkZoomPoints(this._element._points)),
            c.add(b);
            var e, f, g;
            if ("lineto" === d);
            else if ("quadto" === d) {
                for (e = new Ib.List(c.get(0)), f = 1, pointCount = c.size(); f < pointCount; f++) e.add(f < pointCount - 1 ? new Ib.List([c.get(f++), c.get(f)]) : c.get(f));
                c = e
            } else if ("cubicto" === d) {
                for (e = new Ib.List(c.get(0)), f = 1, pointCount = c.size(); f < pointCount; f++) e.add(f < pointCount - 2 ? new Ib.List([c.get(f++), c.get(f++), c.get(f)]) : f < pointCount - 1 ? new Ib.List([c.get(f++), c.get(f)]) : c.get(f));
                c = e
            } else {
                if ("orthogonalto" !== d) throw "Can not resolve shapelink type '" + d + "'";
                for (g = c.get(0), e = new Ib.List(g), f = 1, pointCount = c.size(); f < pointCount; f++) if (f < pointCount - 1) {
                    var h = Jb.clone(c.get(f)),
                    i = h.x,
                    j = h.y,
                    k = i - g.x,
                    l = j - g.y;
                    Math.abs(k) > Math.abs(l) ? (h.x = i, h.y = g.y) : (h.x = g.x, h.y = j),
                    g = h,
                    e.add(g)
                } else e.add(c.get(f));
                c = e
            }
            var m, n, o, h, p, k, l, q = Tb.calculateLineLength(c) / 2,
            r = c.size(),
            s = 0,
            t = 0;
            for (m = 0; r > m; m++) if (h = c.get(m), 0 != m) {
                if (o = h, o instanceof nd && (o = o._as), o instanceof Array ? (p = Tb.calculateCurveLength(n, o, 1), n = o[o.length - 1]) : (l = h.y - n.y, k = h.x - n.x, p = Math.sqrt(k * k + l * l), n = o), t += p, q >= s && t >= q) {
                    var u = q - s,
                    v = c.get(m - 1);
                    v instanceof nd && (v = v._as, v instanceof Array && (v = v[v.length - 1]));
                    var w = c.get(m),
                    x = Tb.getPathInfo(w, v, u, 0, -1).point;
                    this._hotSpot = Jb.clone(x)
                }
                s = t
            } else n = h;
            return c
        },
        _growLinkJoinBounds: function(a, b) {
            Tb.grow(a, 3 * b, 3 * b)
        }
    }),
    Ib.vector.GridUI = function(a, b) {
        Ib.vector.GridUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.GridUI", Ib.vector.NodeUI, {
        drawDefaultBody: function(a) {
            this._element.getImage() ? Ib.vector.GridUI.superClass.drawDefaultBody.apply(this, arguments) : this.drawGridBody(a)
        },
        validateBodyBounds: function() {
            if (this._element.getImage()) Ib.vector.GridUI.superClass.validateBodyBounds.call(this);
            else {
                var a = this.getBodyRect(),
                b = Jb.clone(a),
                c = this._element.getStyle("outer.width");
                Tb.grow(b, c, c),
                this.appendShadowBound(this, b),
                this.addBodyBounds(b)
            }
        },
        _getZoomCellRect: function(a, b) {
            var c = this._element.getCellRect(a, b),
            d = this._element.getRect(),
            e = d.x + d.width / 2,
            f = d.y + d.height / 2,
            g = this.getZoomBodyRect(),
            h = g.width / d.width,
            i = g.x + g.width / 2,
            j = 0 == e ? 1 : i / e;
            return {
                x: e * j + (c.x - e) * h,
                y: f * j + (c.y - f) * h,
                width: c.width * h,
                height: c.height * h
            }
        },
        drawGridBody: function(a) {
            var b = this.getStyle("grid.fill"),
            c = this.getStyle("grid.deep"),
            d = this.getStyle("grid.cell.deep");
            if (b || 0 !== c || 0 !== d) {
                a.beginPath();
                var e = this.getZoomBodyRect(),
                f = this.getDyeColor("grid.fill.color");
                if (this.setGlow(this, a), this.setShadow(this, a), b && (a.fillStyle = f, a.rect(e.x, e.y, e.width, e.height), a.fill()), a.closePath(), this.clearShadow(a), a.beginPath(), 0 != c && Xb.draw3DRect(a, f, c, e.x, e.y, e.width, e.height), a.closePath(), 0 != d) for (var g = this.getStyle("grid.row.count"), h = this.getStyle("grid.column.count"), i = 0; g > i; i++) for (var j = 0; h > j; j++) {
                    var k = this._getZoomCellRect(i, j);
                    null != k && (a.beginPath(), Xb.draw3DRect(a, f, d, k.x, k.y, k.width, k.height), a.closePath())
                }
            }
        }
    }),
    Ib.vector.RotatableNodeUI = function(a, b) {
        Ib.vector.RotatableNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.RotatableNodeUI", Ib.vector.NodeUI, {
        isEditable: function() {
            return ! 1
        },
        getDefaultBodyRect: function() {
            var a = this._element,
            b = Jb.getImageAsset(a.getImage()),
            c = this.getBodyRect();
            return b ? (Tb.addPadding(c, this._element, "image.padding", 1), c) : c
        },
        drawDefaultBody: function(a) {
            var b = this._element,
            c = Jb.getImageAsset(b.getImage());
            if (c) {
                var d = this.getBodyRect();
                if (Tb.addPadding(d, this._element, "image.padding", 1), c.getImage()) {
                    var e = this._element._getOrignalWidth(),
                    f = this._element._getOrignalHeight(),
                    g = this._element._getRotateRect();
                    a.save(),
                    a.translate(d.x - g.x + e / 2, d.y - g.y + f / 2),
                    a.rotate(this._element._angle * Math.PI / 180),
                    a.drawImage(c.getImage(this._innerColor), -e / 2, -f / 2, e, f),
                    a.restore()
                } else if (c.getSrc());
                else if (!c.getFunction()) throw "ImageAsset '" + b.getImage() + " ' is empty"
            }
        }
    }),
    Ib.vector.HTMLNodeUI = function(a, b) {
        Ib.vector.HTMLNodeUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.HTMLNodeUI", Ib.vector.NodeUI, {
        checkAttachments: function() {
            Ib.vector.NodeUI.prototype.checkAttachments.call(this)
        },
        checkLabelAttachment: function() {
            var a = this._element.getStyle("attachment.label.style");
            if (a && "none" === a) return void Ib.vector.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel(this._element);
            null != b && "" !== b ? this._labelAttachment || (this._labelAttachment = new Ib.vector.HTMLLabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkLabel2Attachment: function() {
            var a = this._element.getStyle("attachment.label2.style");
            if (a && "none" === a) return void Ib.vector.HTMLNodeUI.superClass.checkLabel2Attachment.call(this);
            var b = this._network.getLabel2(this._element);
            null != b && "" !== b ? this._label2Attachment || (this._label2Attachment = new Ib.vector.HTMLLabel2Attachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._label2Attachment)) : this._label2Attachment && (this.removeAttachment(this._label2Attachment), this._label2Attachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._element.getStyle("attachment.alarm.style");
            if (a && "none" === a) return void Ib.vector.HTMLNodeUI.superClass.checkAlarmAttachment.call(this);
            var b = this._network.getAlarmLabel(this._element);
            null != b && "" !== b ? this._alarmAttachment || (this._alarmAttachment = new Ib.vector.HTMLAlarmAttachment(this, !1), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        },
        setAttachmentVisible: function(a) {
            a ? (this._labelAttachment && this._labelAttachment.setVisibility("visible"), this._label2Attachment && this._label2Attachment.setVisibility("visible"), this._alarmAttachment && this._alarmAttachment.setVisibility("visible")) : (this._labelAttachment && this._labelAttachment.setVisibility("hidden"), this._label2Attachment && this._label2Attachment.setVisibility("hidden"), this._alarmAttachment && this._alarmAttachment.setVisibility("hidden"))
        }
    }),
    Ib.vector.HTMLLinkUI = function(a, b) {
        Ib.vector.HTMLLinkUI.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.HTMLLinkUI", Ib.vector.LinkUI, {
        checkAttachments: function() {
            Ib.vector.LinkUI.prototype.checkAttachments.call(this)
        },
        checkLabelAttachment: function() {
            var a = this._element.getStyle("attachment.label.style");
            if (a && "none" === a) return void Ib.vector.HTMLLinkUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel(this._element);
            null != b && "" !== b ? this._labelAttachment || (this._labelAttachment = new Ib.vector.HTMLLabelAttachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._labelAttachment)) : this._labelAttachment && (this.removeAttachment(this._labelAttachment), this._labelAttachment = null)
        },
        checkLabel2Attachment: function() {
            var a = this._element.getStyle("attachment.label2.style");
            if (a && "none" === a) return void Ib.vector.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            var b = this._network.getLabel2(this._element);
            null != b && "" !== b ? this._label2Attachment || (this._label2Attachment = new Ib.vector.HTMLLabel2Attachment(this, Dd.SHOW_LABEL_IN_ATTACHMENT_DIV), this.addAttachment(this._label2Attachment)) : this._label2Attachment && (this.removeAttachment(this._label2Attachment), this._label2Attachment = null)
        },
        checkAlarmAttachment: function() {
            var a = this._element.getStyle("attachment.alarm.style");
            if (a && "none" === a) return void Ib.vector.HTMLLinkUI.superClass.checkAlarmAttachment.call(this);
            var b = this._network.getAlarmLabel(this._element);
            null != b && "" !== b ? this._alarmAttachment || (this._alarmAttachment = new Ib.vector.HTMLAlarmAttachment(this, !1), this.addAttachment(this._alarmAttachment)) : this._alarmAttachment && (this.removeAttachment(this._alarmAttachment), this._alarmAttachment = null)
        },
        setAttachmentVisible: function(a) {
            a ? (this._labelAttachment && this._labelAttachment.setVisibility("visible"), this._label2Attachment && this._label2Attachment.setVisibility("visible"), this._alarmAttachment && this._alarmAttachment.setVisibility("visible")) : (this._labelAttachment && this._labelAttachment.setVisibility("hidden"), this._label2Attachment && this._label2Attachment.setVisibility("hidden"), this._alarmAttachment && this._alarmAttachment.setVisibility("hidden"))
        }
    }),
    Ib.vector.Attachment = function(a, b) {
        this._ui = a,
        this._element = this._ui.getElement(),
        this._network = a.getNetwork(),
        this._showOnTop = b,
        b && this._network._hitTestTopAttachmentList.add(this)
    },
    Jb.ext("twaver.vector.Attachment", Object, {
        getElement: function() {
            return this._element
        },
        getElementUI: function() {
            return this._ui
        },
        getNetwork: function() {
            return this._network
        },
        isShowOnTop: function() {
            return this._showOnTop === !0
        },
        setShowOnTop: function(a) {
            this._showOnTop = a
        },
        getStyle: function(a) {
            return this._ui.getStyle(a)
        },
        getFont: function(a) {
            return this._ui.getFont(a)
        },
        getViewRect: function() {
            return Jb.clone(this._viewRect)
        },
        getAlpha: function() {
            return 1
        },
        validate: function() {},
        paint: function(a) {},
        getZoomViewRect: function() {
            var a = this._network.zoomManager._getAttachmentZoomOutLineRect(this, this._viewRect);
            return a
        },
        hit: function(a, b) {
            return Tb.containsPoint(this.getZoomViewRect(), a, b) ? this.hitCanvasRect({
                x: a - 1,
                y: b - 1,
                width: 2,
                height: 2
            }) : !1
        },
        hitCanvasRect: function(a) {
            var b = Nd.getHitCanvas(a.width, a.height),
            c = Nd.getCtx(b);
            c.save(),
            c.translate( - a.x, -a.y),
            this.paint(c);
            try {
                for (var d = c.getImageData(0, 0, a.width, a.height), e = d.data, f = 0; f < d.width; f++) for (var g = 0; g < d.height; g++) {
                    var h = 4 * (g * d.width + f),
                    i = e[h + 3];
                    if (0 !== i) return c.restore(),
                    !0
                }
            } catch(j) {
                Nd.disposeHitCanvas()
            }
            return c.restore(),
            !1
        },
        dispose: function() {
            this._network._hitTestTopAttachmentList.remove(this)
        }
    }),
    Ib.vector.BasicAttachment = function(a, b) {
        Ib.vector.BasicAttachment.superClass.constructor.call(this, a, b),
        this._roundRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this._contentRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    },
    Jb.ext("twaver.vector.BasicAttachment", Ib.vector.Attachment, {
        paint: function(a) {
            Ib.vector.BasicAttachment.superClass.paint.apply(this, arguments);
            var b = this.isFill(),
            c = this.getOutlineWidth(),
            d = this._network.zoomManager._getAttachmentZoomOutLineRect(this, this._roundRect);
            if (this.getElementUI().setGlow(this, a), this.getElementUI().setShadow(this, a), c > 0 || b) {
                if (Xb.drawRoundRect(a, d.x, d.y, d.width, d.height, this.getCornerRadius()), this._network._debug && Xb.strokeRect(a, d, "#C71585"), this._pointers) {
                    var e = this._ui.getZoomPointers(this, this._pointers);
                    a.moveTo(e[0].x, e[0].y),
                    a.lineTo(e[1].x, e[1].y),
                    a.lineTo(e[2].x, e[2].y)
                }
                if (a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b) {
                    var f = this.getFillColor(),
                    g = this.getGradient();
                    g ? Xb.fill(a, f, g, this.getGradientColor(), this._viewRect) : a.fillStyle = f,
                    a.fill()
                }
            }
        },
        validate: function() {
            Ib.vector.BasicAttachment.superClass.validate.call(this),
            this.calculateMeasure();
            var a = this.getOutlineWidth(); (null == a || 0 >= a) && (a = 1),
            this._viewRect = Tb.getRect(this._pointers),
            this._viewRect = Tb.unionRect(this._viewRect, this._roundRect),
            a > 0 && Tb.grow(this._viewRect, 2 * a, 2 * a),
            this._viewRect = this._ui.appendShadowBound(this, this._viewRect);
            var b = this._element instanceof Ib.Link && this._element.getStyle("link.label.rotatable");
            if (b) {
                var c = this._viewRect.x + this._viewRect.width / 2,
                d = this._viewRect.y + this._viewRect.height / 2,
                e = Math.sqrt(this._viewRect.height * this._viewRect.height + this._viewRect.width * this._viewRect.width);
                this._viewRect = {
                    x: c - e,
                    y: d - e,
                    width: 2 * e,
                    height: 2 * e
                }
            }
        },
        calculateMeasure: function() {
            var a = this.getContentWidth(),
            b = this.getContentHeight(),
            c = this.getCornerRadius(),
            d = this.getPointerLength(),
            e = this.getPointerWidth(),
            f = this.getPosition(),
            g = this.getXOffset(),
            h = this.getYOffset(),
            i = this._roundRect;
            i.width = a + c,
            i.height = b;
            var j;
            if (this._ui._element instanceof Ib.Link) {
                var k, l = this._ui.getLinkPoints();
                k = this._ui.getLineLength ? this._ui.getLineLength() : this._ui._element.getLineLength(),
                Math.abs(g) > 0 && Math.abs(g) < 1 ? "from" === f ? g *= k: "to" === f ? g = k * (1 - g) : (g /= 2, g += .5, g *= k) : "from" === f ? g = g: "to" === f ? g = k - g: g += k / 2;
                var m, n = Tb.calculatePointInfoAlongLine(l, !0, g, h),
                o = n.point;
                n.angle,
                m = "from" === f ? this._ui.getFromPoint() : "to" === f ? this._ui.getToPoint() : this._ui._hotSpot,
                g = o.x - m.x,
                h = o.y - m.y
            }
            if (d > 0) {
                var p = this.getDirection();
                j = this._network.getPosition(f, this._ui, null, g, h, !1);
                var q;
                if ("aboveleft" === p) i.y = j.y - d - i.height,
                i.x = j.x - (i.width - c),
                q = Math.max(j.x - e, j.x - (i.width - c) + c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y - d
                },
                {
                    x: q,
                    y: j.y - d
                }];
                else if ("aboveright" === p) i.y = j.y - d - i.height,
                i.x = j.x - c,
                q = Math.min(j.x + e, j.x - c + i.width - c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y - d
                },
                {
                    x: q,
                    y: j.y - d
                }];
                else if ("belowleft" === p) i.y = j.y + d,
                i.x = j.x - (i.width - c),
                q = Math.max(j.x - e, j.x - (i.width - c) + c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y + d
                },
                {
                    x: q,
                    y: j.y + d
                }];
                else if ("belowright" === p) i.y = j.y + d,
                i.x = j.x - c,
                q = Math.min(j.x + e, j.x - c + i.width - c / 2),
                this._pointers = [j, {
                    x: j.x,
                    y: j.y + d
                },
                {
                    x: q,
                    y: j.y + d
                }];
                else if ("leftabove" === p) i.y = j.y + c - i.height,
                i.x = j.x - d - i.width,
                q = Math.max(j.y - e, j.y + c - i.height + c / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y
                },
                {
                    x: j.x - d,
                    y: q
                }];
                else if ("leftbelow" === p) i.y = j.y - c,
                i.x = j.x - d - i.width,
                q = Math.min(j.y + e, j.y - c + i.height - c / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y
                },
                {
                    x: j.x - d,
                    y: q
                }];
                else if ("rightabove" === p) i.y = j.y + c - i.height,
                i.x = j.x + d,
                q = Math.max(j.y - e, j.y + c - i.height + c / 2),
                this._pointers = [j, {
                    x: j.x + d,
                    y: j.y
                },
                {
                    x: j.x + d,
                    y: q
                }];
                else if ("rightbelow" === p) i.y = j.y - c,
                i.x = j.x + d,
                q = Math.min(j.y + e, j.y - c + i.height - c / 2),
                this._pointers = [j, {
                    x: j.x + d,
                    y: j.y
                },
                {
                    x: j.x + d,
                    y: q
                }];
                else if ("above" === p) i.y = j.y - d - i.height,
                i.x = j.x - i.width / 2,
                q = Math.min(a / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - q,
                    y: j.y - d
                },
                {
                    x: j.x + q,
                    y: j.y - d
                }];
                else if ("below" === p) i.y = j.y + d,
                i.x = j.x - i.width / 2,
                q = Math.min(a / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - q,
                    y: j.y + d
                },
                {
                    x: j.x + q,
                    y: j.y + d
                }];
                else if ("left" === p) i.y = j.y - i.height / 2,
                i.x = j.x - d - i.width,
                q = Math.min(b / 2, e / 2),
                this._pointers = [j, {
                    x: j.x - d,
                    y: j.y + q
                },
                {
                    x: j.x - d,
                    y: j.y - q
                }];
                else {
                    if ("right" !== p) throw "Can not resolve '" + p + "' attachment direction";
                    i.y = j.y - i.height / 2,
                    i.x = j.x + d,
                    q = Math.min(b / 2, e / 2),
                    this._pointers = [j, {
                        x: j.x + d,
                        y: j.y + q
                    },
                    {
                        x: j.x + d,
                        y: j.y - q
                    }]
                }
            } else j = this._network.getPosition(f, this._ui, {
                width: i.width,
                height: i.height
            },
            g, h, !1),
            i.x = j.x,
            i.y = j.y,
            this._pointers = null;
            this._contentRect.x = i.x + (i.width - a) / 2,
            this._contentRect.y = i.y + (i.height - b) / 2,
            this._contentRect.width = a,
            this._contentRect.height = b;
            var r = this.getPadding();
            0 != r && Tb.grow(i, r, r),
            r = this.getPaddingLeft(),
            0 != r && (i.x -= r, i.width += r),
            r = this.getPaddingRight(),
            0 != r && (i.width += r),
            r = this.getPaddingTop(),
            0 != r && (i.y -= r, i.height += r),
            r = this.getPaddingBottom(),
            0 != r && (i.height += r),
            i.width < 0 && (i.width = i.width, i.x -= i.width),
            i.height < 0 && (i.height = -i.height, i.y -= i.height)
        },
        getContentWidth: function() {
            return Ib.Defaults.ATTACHMENT_CONTENT_WIDTH
        },
        getContentHeight: function() {
            return Ib.Defaults.ATTACHMENT_CONTENT_HEIGHT
        },
        getCornerRadius: function() {
            return Ib.Defaults.ATTACHMENT_CORNER_RADIUS
        },
        getPointerLength: function() {
            return Ib.Defaults.ATTACHMENT_POINTER_LENGTH
        },
        getPointerWidth: function() {
            return Ib.Defaults.ATTACHMENT_POINTER_WIDTH
        },
        getPosition: function() {
            return Ib.Defaults.ATTACHMENT_POSITION
        },
        getXOffset: function() {
            return Ib.Defaults.ATTACHMENT_XOFFSET
        },
        getYOffset: function() {
            return Ib.Defaults.ATTACHMENT_YOFFSET
        },
        getPadding: function() {
            return Ib.Defaults.ATTACHMENT_PADDING
        },
        getPaddingLeft: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_LEFT
        },
        getPaddingRight: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_RIGHT
        },
        getPaddingTop: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_TOP
        },
        getPaddingBottom: function() {
            return Ib.Defaults.ATTACHMENT_PADDING_BOTTOM
        },
        getDirection: function() {
            return Ib.Defaults.ATTACHMENT_DIRECTION
        },
        isFill: function() {
            return Ib.Defaults.ATTACHMENT_FILL
        },
        getFillColor: function() {
            return Ib.Defaults.ATTACHMENT_FILL_COLOR
        },
        getGradient: function() {
            return Ib.Defaults.ATTACHMENT_GRADIENT
        },
        getGradientColor: function() {
            return Ib.Defaults.ATTACHMENT_GRADIENT_COLOR
        },
        getOutlineWidth: function() {
            return Ib.Defaults.ATTACHMENT_OUTLINE_WIDTH
        },
        getOutlineColor: function() {
            return Ib.Defaults.ATTACHMENT_OUTLINE_COLOR
        },
        getCap: function() {
            return Ib.Defaults.ATTACHMENT_CAP
        },
        getJoin: function() {
            return Ib.Defaults.ATTACHMENT_JOIN
        },
        isShadowable: function() {
            return Ib.Defaults.ATTACHMENT_SHADOWABLE
        },
        getRoundRect: function() {
            return Jb.clone(this._roundRect)
        },
        getContentRect: function() {
            return Jb.clone(this._contentRect)
        }
    }),
    Ib.vector.LabelAttachment = function(a, b) {
        Ib.vector.LabelAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.LabelAttachment", Ib.vector.BasicAttachment, {
        paint: function(a) {
            var b = this._element instanceof Ib.Link && this._element.getStyle("link.label.rotatable");
            if (b) {
                a.save();
                var c = this.getZoomViewRect(),
                d = c.x + c.width / 2,
                e = c.y + c.height / 2;
                a.translate(d, e),
                a.rotate(this._network.getElementUI(this._element).getAngle()),
                a.translate( - d, -e)
            }
            Ib.vector.LabelAttachment.superClass.paint.apply(this, arguments);
            var f = this._network.zoomManager,
            g = f._getAttachmentZoomRect(this, this._contentRect),
            h = this._element.getStyle("label.align");
            if (f._drawText(this, a, this.text, g, this.font, this.getStyle("label.color"), h), b && a.restore(), this._network._debug) {
                var i = f.getAttachmentSizeZoom(this),
                j = g;
                j.width *= i,
                j.height *= i,
                Xb.strokeRect(a, j, "#AAABBB")
            }
        },
        validate: function() {
            this.font = this.getFont("label.font"),
            this.text = this.getLabel(),
            this._textSize = Xb.getTextSize(this.font, this.text),
            Ib.vector.LabelAttachment.superClass.validate.call(this)
        },
        getLabel: function() {
            return this._network.getLabel(this._element)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("label.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("label.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("label.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("label.position")
        },
        getXOffset: function() {
            return this.getStyle("label.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("label.yoffset")
        },
        getPadding: function() {
            return this.getStyle("label.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("label.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("label.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("label.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("label.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("label.direction")
        },
        isFill: function() {
            return this.getStyle("label.fill")
        },
        getFillColor: function() {
            return this.getStyle("label.fill.color")
        },
        getGradient: function() {
            return this.getStyle("label.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("label.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("label.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("label.outline.color")
        },
        getCap: function() {
            return this.getStyle("label.cap")
        },
        getJoin: function() {
            return this.getStyle("label.join")
        },
        getAlpha: function() {
            return this.getStyle("label.alpha")
        },
        isShadowable: function() {
            return this.getStyle("label.shadowable")
        }
    }),
    Ib.vector.Label2Attachment = function(a, b) {
        Ib.vector.Label2Attachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.Label2Attachment", Ib.vector.BasicAttachment, {
        paint: function(a) {
            var b = this._element instanceof Ib.Link && this._element.getStyle("link.label.rotatable");
            if (b) {
                a.save();
                var c = this.getZoomViewRect(),
                d = c.x + c.width / 2,
                e = c.y + c.height / 2;
                a.translate(d, e),
                a.rotate(this._network.getElementUI(this._element).getAngle()),
                a.translate( - d, -e)
            }
            Ib.vector.Label2Attachment.superClass.paint.apply(this, arguments);
            var f = this._network.zoomManager,
            g = f._getAttachmentZoomRect(this, this._contentRect),
            h = this._element.getStyle("label.align");
            if (f._drawText(this, a, this.text, g, this.font, this.getStyle("label2.color"), h), b && a.restore(), this._network._debug) {
                var i = f.getAttachmentSizeZoom(this),
                j = g;
                j.width *= i,
                j.height *= i,
                Xb.strokeRect(a, j, "#AAABBB")
            }
        },
        validate: function() {
            this.font = this.getFont("label2.font"),
            this.text = this.getLabel(),
            this._textSize = Xb.getTextSize(this.font, this.text),
            Ib.vector.LabelAttachment.superClass.validate.call(this)
        },
        getLabel: function() {
            return this._network.getLabel2(this._element)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("label2.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("label2.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("label2.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("label2.position")
        },
        getXOffset: function() {
            return this.getStyle("label2.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("label2.yoffset")
        },
        getPadding: function() {
            return this.getStyle("label2.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("label2.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("label2.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("label2.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("label2.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("label2.direction")
        },
        isFill: function() {
            return this.getStyle("label2.fill")
        },
        getFillColor: function() {
            return this.getStyle("label2.fill.color")
        },
        getGradient: function() {
            return this.getStyle("label2.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("label2.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("label2.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("label2.outline.color")
        },
        getCap: function() {
            return this.getStyle("label2.cap")
        },
        getJoin: function() {
            return this.getStyle("label2.join")
        },
        getAlpha: function() {
            return this.getStyle("label2.alpha")
        },
        isShadowable: function() {
            return this.getStyle("label2.shadowable")
        }
    }),
    Ib.vector.AlarmAttachment = function(a, b) {
        Ib.vector.AlarmAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.AlarmAttachment", Ib.vector.BasicAttachment, {
        paint: function(a) {
            Ib.vector.AlarmAttachment.superClass.paint.apply(this, arguments);
            var b = this._network.zoomManager,
            c = b._getAttachmentZoomRect(this, this._contentRect);
            b._drawText(this, a, this.text, c, this.font, this.getStyle("alarm.color"))
        },
        validate: function() {
            this.font = this.getFont("alarm.font"),
            this.text = this._network.getAlarmLabel(this._element),
            this._textSize = Xb.getTextSize(this.font, this.text),
            this._fillColor = this._network.getAlarmFillColor(this._element),
            Ib.vector.AlarmAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("alarm.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("alarm.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("alarm.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("alarm.position")
        },
        getXOffset: function() {
            return this.getStyle("alarm.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("alarm.yoffset")
        },
        getPadding: function() {
            return this.getStyle("alarm.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("alarm.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("alarm.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("alarm.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("alarm.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("alarm.direction")
        },
        isFill: function() {
            return null != this._fillColor
        },
        getFillColor: function() {
            return this._fillColor
        },
        getGradient: function() {
            return this.getStyle("alarm.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("alarm.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("alarm.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("alarm.outline.color")
        },
        getCap: function() {
            return this.getStyle("alarm.cap")
        },
        getJoin: function() {
            return this.getStyle("alarm.join")
        },
        getAlpha: function() {
            return this.getStyle("alarm.alpha")
        },
        isShadowable: function() {
            return this.getStyle("alarm.shadowable")
        }
    }),
    Ib.vector.LinkHandlerAttachment = function(a, b) {
        Ib.vector.LinkHandlerAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.LinkHandlerAttachment", Ib.vector.BasicAttachment, {
        paint: function(a) {
            var b = this._network.zoomManager;
            Ib.vector.LinkHandlerAttachment.superClass.paint.apply(this, arguments);
            var c = b._getAttachmentZoomRect(this, this._contentRect);
            b._drawText(this, a, this.linkHandlerLabel, c, this.linkHandlerFont, this.getStyle("link.handler.color"))
        },
        validate: function() {
            this.linkHandlerFont = this.getFont("link.handler.font"),
            this.linkHandlerLabel = this._network.getLinkHandlerLabel(this._element),
            this._textSize = Xb.getTextSize(this.linkHandlerFont, this.linkHandlerLabel),
            Ib.vector.LinkHandlerAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("link.handler.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("link.handler.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("link.handler.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("link.handler.position")
        },
        getXOffset: function() {
            return this.getStyle("link.handler.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("link.handler.yoffset")
        },
        getPadding: function() {
            return this.getStyle("link.handler.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("link.handler.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("link.handler.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("link.handler.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("link.handler.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("link.handler.direction")
        },
        isFill: function() {
            return this.getStyle("link.handler.fill")
        },
        getFillColor: function() {
            return this.getStyle("link.handler.fill.color")
        },
        getGradient: function() {
            return this.getStyle("link.handler.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("link.handler.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("link.handler.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("link.handler.outline.color")
        },
        getCap: function() {
            return this.getStyle("link.handler.cap")
        },
        getJoin: function() {
            return this.getStyle("link.handler.join")
        },
        getAlpha: function() {
            return this.getStyle("link.handler.alpha")
        },
        isShadowable: function() {
            return this.getStyle("link.handler.shadowable")
        }
    }),
    Ib.vector.IconsAttachment = function(a, b) {
        Ib.vector.IconsAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.IconsAttachment", Ib.vector.Attachment, {
        isShadowable: function() {
            return Ib.Defaults.ATTACHMENT_SHADOWABLE
        },
        validate: function() {
            if (Ib.vector.IconsAttachment.superClass.validate.call(this), this.iconsNames = this._network.getIconsNames(this._element), this.iconsNames && 0 != this.iconsNames.length) {
                var a = this._makeGroup(this.iconsNames),
                b = this._makeGroup(this._network.getIconsColors(this._element)),
                c = this._network.zoomManager;
                len = a.length,
                this.iconsOrientation = this._makeArray(this._element.getStyle("icons.orientation"), len, "right"),
                this.iconsPosition = this._makeArray(this._element.getStyle("icons.position"), len, "topleft.bottomright"),
                this.iconsXoffset = this._makeArray(this._element.getStyle("icons.xoffset"), len, 0),
                this.iconsYoffset = this._makeArray(this._element.getStyle("icons.yoffset"), len, 0),
                this.iconsXgap = this._makeArray(this._element.getStyle("icons.xgap"), len, 1),
                this.iconsYgap = this._makeArray(this._element.getStyle("icons.ygap"), len, 1),
                this.locations = [],
                this.iconsSizes = [],
                this.iconsOrientations = [];
                var d, e, f;
                for (i = 0; i < len; i++) {
                    var g = a[i],
                    f = this.iconsOrientation[i] || "right",
                    h = this.iconsPosition[i] || "topleft.bottomright",
                    j = this.iconsXgap[i] || 1,
                    k = this.iconsYgap[i] || 1,
                    l = this.iconsXoffset[i] || 0,
                    m = this.iconsYoffset[i] || 0;
                    if (this._ui._element instanceof Ib.Link) {
                        var n, o = this._ui.getLinkPoints();
                        n = this._ui.getLineLength ? this._ui.getLineLength() : this._ui._element.getLineLength(),
                        Math.abs(l) > 0 && Math.abs(l) < 1 ? "from" === h ? l *= n: "to" === h ? l = n * (1 - l) : (l /= 2, l += .5, l *= n) : "from" === h ? l = l: "to" === h ? l = n - l: l += n / 2;
                        var p, q = Tb.calculatePointInfoAlongLine(o, !0, l, m),
                        r = q.point;
                        q.angle,
                        p = "from" === h ? this._ui.getFromPoint() : "to" === h ? this._ui.getToPoint() : this._ui._hotSpot,
                        l = r.x - p.x,
                        m = r.y - p.y
                    }
                    e = null,
                    d = this._getIconsSize(g, f, j, k, c),
                    d && (e = this._network.getPosition(h, this._ui, d, l, m), this._iconLocation = e, "top" === f ? e.y += d.height: "left" === f && (e.x += d.width)),
                    this.locations.push(e),
                    this.iconsSizes.push(d),
                    this.iconsOrientations.push(f)
                }
                var s = null;
                for (i = 0; i < this.locations.length; i++) e = this.locations[i],
                d = this.iconsSizes[i],
                f = this.iconsOrientations[i],
                null != e && (s = null == s ? "top" === f ? {
                    x: e.x,
                    y: e.y - d.height,
                    width: d.width,
                    height: d.height
                }: "left" === f ? {
                    x: e.x - d.width,
                    y: e.y,
                    width: d.width,
                    height: d.height
                }: {
                    x: e.x,
                    y: e.y,
                    width: d.width,
                    height: d.height
                }: "top" === f ? Tb.unionRect(s, {
                    x: e.x,
                    y: e.y - d.height,
                    width: d.width,
                    height: d.height
                }) : "left" === f ? Tb.unionRect(s, {
                    x: e.x - d.width,
                    y: e.y,
                    width: d.width,
                    height: d.height
                }) : Tb.unionRect(s, {
                    x: e.x,
                    y: e.y,
                    width: d.width,
                    height: d.height
                }));
                this._viewRect = c ? s || this.getElementUI().getViewRect() : s || {
                    x: this._element.getLocation().x,
                    y: this._element.getLocation().y,
                    width: 0,
                    height: 0
                },
                this.iconsGroups = a,
                this.colorGroups = b;
                var t = this._element instanceof Ib.Link && this._element.getStyle("link.icons.rotatable");
                for (i = 0; i < len; i++) if (t instanceof Array && t[i] && this._viewRect) {
                    var u = this._viewRect.x + this._viewRect.width / 2,
                    v = this._viewRect.y + this._viewRect.height / 2,
                    w = Math.sqrt(this._viewRect.height * this._viewRect.height + this._viewRect.width * this._viewRect.width);
                    this._viewRect = {
                        x: u - w / 2,
                        y: v - w / 2,
                        width: w,
                        height: w
                    }
                }
            }
        },
        _makeGroup: function(a) {
            if (!Array.isArray(a)) return [[a]];
            var b, c, d, e = [],
            f = !1,
            g = a.length;
            for (b = 0; g > b; b++) c = a[b],
            Array.isArray(c) ? (f = !0, e.push(c)) : (d = [c], e.push(d));
            return f || (e.length = 0, e.push(a)),
            e
        },
        _makeArray: function(a, b, c) {
            if (Array.isArray(a)) return a;
            for (var d = [], e = 0; b > e; e++) d.push(a || c);
            return d
        },
        paint: function(a) {
            if (Ib.vector.IconsAttachment.superClass.paint.apply(this, arguments), this.iconsNames && 0 != this.iconsNames.length && this.locations) {
                var b, c, d, e, f, g, h, i, j, k, l = this._network.zoomManager;
                for (b = 0; b < this.iconsGroups.length; b++) if (c = this.locations[b]) {
                    f = c.x,
                    g = c.y,
                    e = this.iconsGroups[b],
                    h = this.colorGroups[b],
                    i = this.iconsOrientation[b],
                    j = this.iconsXgap[b] || 1,
                    k = this.iconsYgap[b] || 1,
                    d = 0;
                    for (var m in e) {
                        var n = null,
                        o = null;
                        h && h.length > d && (o = h[d++]);
                        var p = Jb.getImageAsset(e[m]);
                        if (null != p) {
                            if (l && this._ui instanceof Ib.vector.GroupUI && this._ui._shapeRect) {
                                var q = l.getAttachmentSizeZoom(this),
                                r = p.getWidth() * q,
                                s = p.getHeight() * q;
                                if ("right" === i) n = {
                                    x: f,
                                    y: g,
                                    width: r,
                                    height: s
                                },
                                f += n.width + j;
                                else if ("left" === i) n = {
                                    x: f - r,
                                    y: g,
                                    width: r,
                                    height: s
                                },
                                f -= n.width + j;
                                else if ("top" === i) n = {
                                    x: f,
                                    y: g - s,
                                    width: r,
                                    height: s
                                },
                                g -= n.height + k;
                                else {
                                    if ("bottom" !== i) throw "Can not resolve '" + i + "' orientation";
                                    n = {
                                        x: f,
                                        y: g,
                                        width: r,
                                        height: s
                                    },
                                    g += n.height + k
                                }
                            } else {
                                if ("right" === i) n = {
                                    x: f,
                                    y: g,
                                    width: p.getWidth(),
                                    height: p.getHeight()
                                },
                                f += n.width + j;
                                else if ("left" === i) n = {
                                    x: f - p.getWidth(),
                                    y: g,
                                    width: p.getWidth(),
                                    height: p.getHeight()
                                },
                                f -= n.width + j;
                                else if ("top" === i) n = {
                                    x: f,
                                    y: g - p.getHeight(),
                                    width: p.getWidth(),
                                    height: p.getHeight()
                                },
                                g -= n.height + k;
                                else {
                                    if ("bottom" !== i) throw "Can not resolve '" + i + "' orientation";
                                    n = {
                                        x: f,
                                        y: g,
                                        width: p.getWidth(),
                                        height: p.getHeight()
                                    },
                                    g += n.height + k
                                }
                                n = l._getAttachmentZoomOutLineRect(this, n)
                            }
                            var t = this._element instanceof Ib.Link && this._element.getStyle("link.icons.rotatable");
                            if (t instanceof Array && t[b]) {
                                a.save();
                                var u = n,
                                f = u.x + u.width / 2,
                                g = u.y + u.height / 2;
                                a.translate(f, g),
                                a.rotate(this._network.getElementUI(this._element).getAbsoluteAngle()),
                                a.translate( - f, -g),
                                Nc(a, p.getImage(o, n.width, n.height), o, n, this._element, this._network),
                                a.restore()
                            } else Nc(a, p.getImage(o, n.width, n.height), o, n, this._element, this._network);
                            if (this._network._debug) {
                                var n = this._viewRect;
                                Xb.strokeRect(a, n, "#FCFC00", 1),
                                Xb.strokeRect(a, n, "#FCFC00", 1)
                            }
                        }
                    }
                }
            }
        },
        _getIconsSize: function(a, b, c, d, e) {
            var f = 0,
            g = 0,
            h = null,
            i = null,
            j = null;
            for (var k in a) if (i = Jb.getImageAsset(a[k])) {
                if ("right" === b) h = {
                    x: f,
                    y: g,
                    width: i.getWidth(),
                    height: i.getHeight()
                },
                f += h.width + c;
                else if ("left" === b) h = {
                    x: f - i.getWidth(),
                    y: g,
                    width: i.getWidth(),
                    height: i.getHeight()
                },
                f -= h.width + c;
                else if ("top" === b) h = {
                    x: f,
                    y: g - i.getHeight(),
                    width: i.getWidth(),
                    height: i.getHeight()
                },
                g -= h.height + d;
                else {
                    if ("bottom" !== b) throw "Can not resolve '" + b + "' orientation";
                    h = {
                        x: f,
                        y: g,
                        width: i.getWidth(),
                        height: i.getHeight()
                    },
                    g += h.height + d
                }
                j = null == j ? Jb.clone(h) : Tb.unionRect(j, h)
            }
            return j ? e && this._ui instanceof Ib.vector.GroupUI && this._ui._shapeRect ? {
                width: Math.abs(j.width) * e.getAttachmentSizeZoom(this),
                height: Math.abs(j.height) * e.getAttachmentSizeZoom(this)
            }: {
                width: Math.abs(j.width),
                height: Math.abs(j.height)
            }: null
        }
    }),
    Ib.vector.EditAttachment = function(a, b) {
        Ib.vector.EditAttachment.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.EditAttachment", Ib.vector.Attachment, {
        paint: function(a) {
            Ib.vector.EditAttachment.superClass.paint.apply(this, arguments),
            this.paintResizingPoints(a),
            this.paintEditPoints(a),
            this.paintRotatePoints(a)
        },
        paintResizingPoints: function(a) {
            var b = this.resizingPoints.size();
            if (! (0 >= b)) {
                var c = 2 * this.resizePointSize,
                d = 2 * this.resizePointSize,
                e = this._network.getResizePointFillColor(),
                f = this._network.getResizePointOutlineWidth(),
                g = this._network.getResizePointOutlineColor(),
                h = this._element.getAngle(),
                i = this._network.zoomManager,
                j = i._getElementZoomRect(this.getElementUI(), this._element.getOriginalRect());
                a.lineWidth = f;
                for (var k = this.resizingPoints,
                l = 0; b > l; l++) {
                    var m = k.get(l),
                    n = {
                        x: m.x - this.resizePointSize,
                        y: m.y - this.resizePointSize,
                        width: 2 * this.resizePointSize,
                        height: 2 * this.resizePointSize
                    },
                    o = this._getRotateRect(n, h, {
                        x: j.x + j.width / 2,
                        y: j.y + j.height / 2
                    });
                    a.save(),
                    Ib.Util.rotateCanvas(a, o, h),
                    Nd.rect(a, o.x, o.y, c, d),
                    a.restore()
                }
                if (a.fillStyle = e, a.strokeStyle = g, a.fill(), a.stroke(), this._network._debug) {
                    var p = this.getViewRect("resize");
                    Xb.strokeRect(a, p, "#CCDDCC");
                    var p = i._getElementZoomRect(this.getElementUI(), this.getElementUI()._viewRect);
                    Xb.strokeRect(a, p, "#FD7766")
                }
            }
        },
        paintEditPoints: function(a) {
            var b = this.editPoints.size();
            if (! (0 >= b)) {
                var c = this._network.getEditPointOutlineColor(),
                d = this._network.getEditPointFillColor(),
                e = this._network.getEditPointOutlineWidth();
                a.beginPath(),
                a.lineWidth = e;
                for (var f = this.editPoints,
                g = 0; b > g; g++) {
                    var h = f.get(g);
                    a.beginPath(),
                    Nd.circle(a, h.x, h.y, this.editPointSize, d, c),
                    a.closePath()
                }
                if (this._network._debug) {
                    var i = this.getViewRect("edit");
                    Xb.strokeRect(a, i, "#AAABBC")
                }
            }
        },
        paintRotatePoints: function(a) {
            var b = this.rotatePoints.size();
            if (! (0 >= b)) {
                var c = this._network.getRotatePointOutlineColor(),
                d = this._network.getRotatePointFillColor(),
                e = this._network.getRotatePointOutlineWidth();
                a.beginPath(),
                a.lineWidth = e;
                for (var f = this.rotatePoints,
                g = 0; b > g; g++) {
                    var h = f.get(g);
                    a.beginPath(),
                    Nd.circle(a, h.x, h.y, this.rotatePointSize, d, c),
                    a.closePath(),
                    a.beginPath()
                }
                if (this._network._debug) {
                    var i = this.getViewRect("rotate");
                    Xb.strokeRect(a, i, "green")
                }
            }
        },
        getViewRect: function(a) {
            if (a) {
                if ("resize" === a) return this._resizeRect;
                if ("rotate" === a) return this._rotateRect;
                if ("edit" === a) return this._editRect
            }
            return this._viewRect || {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }
        },
        validate: function() {
            Ib.vector.EditAttachment.superClass.validate.call(this),
            this.editPointSize = this._network.getEditPointSize(),
            this.resizePointSize = this._network.getResizePointSize(),
            this.rotatePointSize = this._network.getRotatePointSize(),
            this.resizingPoints = new Ib.List,
            this.editPoints = new Ib.List,
            this.rotatePoints = new Ib.List,
            this._element instanceof Ib.Node && this._addResizingPoint(this._element),
            !(this._network.isRotatable(this._element) && this._element instanceof Kd) || this._element instanceof Ib.ShapeNode || this._element instanceof Ib.Grid || this._element instanceof Ib.Group || this._addRotatePoint(this._element),
            this._element instanceof Ib.ShapeNode && (this._addResizingPoint(this._element), this._addShapeNodePoint(this._element)),
            this._ui instanceof Ib.vector.ShapeLinkUI && this._addShapeLinkPoints(this._element),
            this._ui instanceof Ib.vector.LinkUI && this._addLinkControlPoint(this._ui);
            var a = this._network.getResizePointOutlineWidth(),
            b = this.getElementUI().getZoomBodyRect(),
            c = 2 * Math.sqrt(2);
            if (this._resizeOffset = (this.resizePointSize + a + 1) * c, Tb.grow(b, this._resizeOffset, this._resizeOffset), this._resizeRect = b, a = this._network.getEditPointOutlineWidth(), this.editPoints.size() > 0) {
                var d = Tb.getRect(this.editPoints);
                Tb.grow(d, 2 * this.editPointSize + 2 * a),
                b = Tb.unionRect(b, d)
            }
            if (this._editRect = d, a = this._network.getRotatePointOutlineWidth(), this.rotatePoints.size() > 0) {
                var e = this.rotatePoints.get(0),
                f = {
                    x: e.x - this.rotatePointSize - a - 1,
                    y: e.y - this.rotatePointSize - a - 1,
                    width: 2 * this.rotatePointSize + 2 * a + 2,
                    height: 2 * this.rotatePointSize + 2 * a + 2
                };
                b = Tb.unionRect(b, f),
                this._rotateRect = f
            }
            this._viewRect = b
        },
        _addResizingPoint: function(a) {
            var b = this._network.zoomManager._getElementZoomRect(this.getElementUI(), a.getOriginalRect());
            if (b) {
                var c = this._network.getResizePointSize();
                if (! (0 >= c)) {
                    var d = new nd([{
                        x: b.x,
                        y: b.y
                    },
                    {
                        x: b.x + b.width / 2,
                        y: b.y
                    },
                    {
                        x: b.x + b.width,
                        y: b.y
                    },
                    {
                        x: b.x,
                        y: b.y + b.height / 2
                    },
                    {
                        x: b.x + b.width,
                        y: b.y + b.height / 2
                    },
                    {
                        x: b.x,
                        y: b.y + b.height
                    },
                    {
                        x: b.x + b.width / 2,
                        y: b.y + b.height
                    },
                    {
                        x: b.x + b.width,
                        y: b.y + b.height
                    }]),
                    e = this._network.getResizePointOutlineWidth(),
                    f = this._network.getResizePointOutlineColor(),
                    g = this._network.getResizePointFillColor();
                    this._addPoints(a.getRect(), d, e, f, g, !0)
                }
            }
        },
        _addRotatePoint: function(a) {
            var b = this._network.zoomManager._getElementZoomRect(this.getElementUI(), a.getOriginalRect());
            if (b) {
                var c = this._network.getRotatePointSize();
                if (! (0 >= c)) {
                    var d = 2 * c,
                    e = new Ib.List([{
                        x: b.x + b.width / 2,
                        y: b.y - this._network.getRotatePointOffset() - d / 2
                    }]),
                    f = a.getAngle();
                    0 != f && (e = this._rotatePointList(e, f, b));
                    var g = e.get(0),
                    h = {
                        x: g.x - d / 2,
                        y: g.y - d / 2,
                        width: d,
                        height: d
                    },
                    i = this._network.getRotatePointOutlineWidth(),
                    j = this.rotatePointSize + i;
                    Tb.grow(b, j, j),
                    Tb.unionRect(a.getRect(), h),
                    this.rotatePoints = e
                }
            }
        },
        _addShapeNodePoint: function(a) {
            var b = this._network.zoomManager._getShapeNodeZoomPoints(this.getElementUI(), a.getPoints());
            this._addEditPoints(b)
        },
        _addShapeLinkPoints: function(a) {
            var b = this._network.zoomManager._getShapeLinkZoomPoints(a.getPoints());
            this._addEditPoints(b)
        },
        _addLinkControlPoint: function(a) {
            var b, c = new Ib.List,
            d = a._element.getFromAgent();
            b = d ? a._element.getFromAgent() : a._element.getFromNode();
            var e = a._element.getStyle("link.from.xoffset"),
            f = a._element.getStyle("link.from.yoffset"),
            g = b.getCenterLocation(),
            h = {
                x: g.x + e,
                y: g.y + f
            };
            c.add(h);
            var i, j = a._element.getToAgent();
            i = j ? a._element.getToAgent() : a._element.getToNode();
            var k = a._element.getStyle("link.to.xoffset"),
            l = a._element.getStyle("link.to.yoffset"),
            m = i.getCenterLocation(),
            n = {
                x: m.x + k,
                y: m.y + l
            };
            if (c.add(n), xc.isOrthogonalLink(a._element) && a.getControlPoint()) {
                var o = a.getControlPoint();
                o && c.add(o)
            }
            this._addEditPoints(c)
        },
        _addEditPoints: function(a) {
            var b = Tb.getRect(a);
            if (b) {
                var c = this._network.getEditPointSize();
                if (! (0 >= c)) {
                    var d = this._network.getEditPointOutlineWidth();
                    this._addPoints(b, a, d, !1)
                }
            }
        },
        _addPoints: function(a, b, c, d, e, f) {
            var g = f ? this._network.getResizePointSize() : this._network.getEditPointSize();
            if (! (0 > g)) {
                var h = g + c;
                Tb.grow(a, h, h),
                1 == f ? this.resizingPoints = b: this.editPoints = b
            }
        },
        _rotatePoint: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x + c.width / 2, c.y + c.height / 2),
            e = d.transform(a);
            return e
        },
        _rotatePointList: function(a, b, c) {
            var d = this,
            e = new Ib.List;
            return a.forEach(function(a) {
                e.add(d._rotatePoint(a, b, c))
            }),
            e
        },
        _getRotateRect: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x, c.y),
            e = {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            },
            f = d.transform(e),
            g = new Ib.List([{
                x: f.x - a.width / 2,
                y: f.y - a.height / 2
            },
            {
                x: f.x + a.width / 2,
                y: f.y - a.height / 2
            },
            {
                x: f.x + a.width / 2,
                y: f.y + a.height / 2
            },
            {
                x: f.x - a.width / 2,
                y: f.y + a.height / 2
            }]);
            return Tb.getRect(g)
        }
    }),
    Ib.vector.HTMLLabelAttachment = function(a, b) {
        Ib.vector.HTMLLabelAttachment.superClass.constructor.call(this, a, b),
        this._triangleDiv = Ib.Util.createDiv(),
        this._roundDiv = Ib.Util.createDiv(),
        this._contentDiv = Ib.Util.createDiv();
        var c = this._element.getStyle("attachment.htmllabel.hyperlink");
        c ? (Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "auto"), Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "auto")) : (Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "none"), Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "none")),
        Ib.Util.setCSSStyle(this._triangleDiv, "border-style", "solid"),
        Ib.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap"),
        this._network.getView().appendChild(this._roundDiv),
        this._roundDiv.appendChild(this._contentDiv)
    },
    Jb.ext("twaver.vector.HTMLLabelAttachment", Ib.vector.LabelAttachment, {
        validate: function() {
            var a = (this.getFont("label.font"), this.getLabel());
            this._contentDiv.innerHTML = a,
            this._contentDiv.style.visibility = "hidden",
            Ib.vector.HTMLLabelAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._contentDiv.scrollWidth || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "width"))
        },
        getContentHeight: function() {
            return this._contentDiv.scrollHeight || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "height"))
        },
        paint: function(a) {
            var b = this.isFill(),
            c = this.getOutlineWidth(),
            d = this._contentRect;
            if (this.getElementUI().setGlow(this, a), this.getElementUI().setShadow(this, a), c > 0 || b) {
                if (Xb.drawRoundRect(a, d.x, d.y, d.width, d.height, this.getCornerRadius()), this._pointers) {
                    var e = this._ui.getZoomPointers(this, this._pointers);
                    a.moveTo(e[0].x, e[0].y),
                    a.lineTo(e[1].x, e[1].y),
                    a.lineTo(e[2].x, e[2].y)
                }
                if (a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b) {
                    var f = this.getFillColor(),
                    g = this.getGradient();
                    g ? Xb.fill(a, f, g, this.getGradientColor(), this._viewRect) : a.fillStyle = f,
                    a.fill()
                }
            }
            var h = (this.getFont("label.font"), this.getLabel(), this._network.getViewRect().x),
            i = this._network.getViewRect().y,
            j = this._network.getZoom(),
            k = {
                x: this._contentRect.x + this._contentRect.width / 2,
                y: this._contentRect.y + this._contentRect.height / 2
            },
            l = k.x * j - h - this._contentDiv.offsetWidth / 2 * j + "px",
            m = k.y * j - i - this._contentDiv.offsetHeight / 2 * j + "px";
            this._contentDiv.style.left = l,
            this._contentDiv.style.top = m,
            this._contentDiv.style.setProperty("-webkit-transform", "scale(" + j + ")", null),
            this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null),
            this._network._debug && (Xb.strokeRect(a, this._contentRect, "blue"), Xb.strokeRect(a, this._roundRect, "red"), Xb.strokeRect(a, this._viewRect, "green"));
            var n = this._element instanceof Ib.Link && this._element.getStyle("link.label.rotatable");
            if (n) {
                var o = this.getZoomViewRect(),
                p = (o.x + o.width / 2, o.y + o.height / 2, 180 * this._network.getElementUI(this._element).getAbsoluteAngle() / Math.PI);
                this._contentDiv.offsetWidth / 2 * j,
                this._contentDiv.offsetHeight / 2 * j,
                Qb.isFirefox ? Ib.Util.setCSSStyle(this._contentDiv, "-moz-transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")") : Qb.isOpera ? Ib.Util.setCSSStyle(this._contentDiv, "-o-transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")") : Qb.isChrome || Qb.isSafari ? Ib.Util.setCSSStyle(this._contentDiv, "-webkit-transform", "translate(0px, 0px) rotate(" + p + "deg) scale(" + j + ")") : Qb.isIE ? Ib.Util.setCSSStyle(this._contentDiv, "-ms-transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")") : Ib.Util.setCSSStyle(this._contentDiv, "transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")")
            }
        },
        setVisibility: function(a) {
            this._contentDiv.style.visibility = a
        },
        dispose: function() {
            this._network.getView().removeChild(this._roundDiv)
        },
        getView: function() {
            return this._roundDiv
        }
    }),
    Ib.vector.HTMLLabel2Attachment = function(a, b) {
        Ib.vector.HTMLLabel2Attachment.superClass.constructor.call(this, a, b),
        this._triangleDiv = Ib.Util.createDiv(),
        this._roundDiv = Ib.Util.createDiv(),
        this._contentDiv = Ib.Util.createDiv();
        var c = this._element.getStyle("attachment.htmllabel2.hyperlink");
        c ? (Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "auto"), Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "auto")) : (Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "none"), Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "none")),
        Ib.Util.setCSSStyle(this._triangleDiv, "border-style", "solid"),
        Ib.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap"),
        this._network.getView().appendChild(this._roundDiv),
        this._roundDiv.appendChild(this._contentDiv)
    },
    Jb.ext("twaver.vector.HTMLLabel2Attachment", Ib.vector.LabelAttachment, {
        validate: function() {
            var a = (this.getFont("label2.font"), this.getLabel());
            this._contentDiv.innerHTML = a,
            this._contentDiv.style.visibility = "hidden",
            Ib.vector.HTMLLabelAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._contentDiv.scrollWidth || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "width"))
        },
        getContentHeight: function() {
            return this._contentDiv.scrollHeight || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "height"))
        },
        paint: function(a) {
            var b = this.isFill(),
            c = this.getOutlineWidth(),
            d = this._contentRect;
            if (this.getElementUI().setGlow(this, a), this.getElementUI().setShadow(this, a), c > 0 || b) {
                if (Xb.drawRoundRect(a, d.x, d.y, d.width, d.height, this.getCornerRadius()), this._pointers) {
                    var e = this._ui.getZoomPointers(this, this._pointers);
                    a.moveTo(e[0].x, e[0].y),
                    a.lineTo(e[1].x, e[1].y),
                    a.lineTo(e[2].x, e[2].y)
                }
                if (a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b) {
                    var f = this.getFillColor(),
                    g = this.getGradient();
                    g ? Xb.fill(a, f, g, this.getGradientColor(), this._viewRect) : a.fillStyle = f,
                    a.fill()
                }
            }
            var h = (this.getFont("label2.font"), this.getLabel(), this._network.getViewRect().x),
            i = this._network.getViewRect().y,
            j = this._network.getZoom(),
            k = {
                x: this._contentRect.x + this._contentRect.width / 2,
                y: this._contentRect.y + this._contentRect.height / 2
            },
            l = k.x * j - h - this._contentDiv.offsetWidth / 2 * j + "px",
            m = k.y * j - i - this._contentDiv.offsetHeight / 2 * j + "px";
            this._contentDiv.style.left = l,
            this._contentDiv.style.top = m,
            this._contentDiv.style.setProperty("-webkit-transform", "scale(" + j + ")", null),
            this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null),
            this._network._debug && (Xb.strokeRect(a, this._contentRect, "blue"), Xb.strokeRect(a, this._roundRect, "red"), Xb.strokeRect(a, this._viewRect, "green"));
            var n = this._element instanceof Ib.Link && this._element.getStyle("link.label2.rotatable");
            if (n) {
                var o = this.getZoomViewRect(),
                p = (o.x + o.width / 2, o.y + o.height / 2, 180 * this._network.getElementUI(this._element).getAbsoluteAngle() / Math.PI);
                this._contentDiv.offsetWidth / 2 * j,
                this._contentDiv.offsetHeight / 2 * j,
                Qb.isFirefox ? Ib.Util.setCSSStyle(this._contentDiv, "-moz-transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")") : Qb.isOpera ? Ib.Util.setCSSStyle(this._contentDiv, "-o-transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")") : Qb.isChrome || Qb.isSafari ? Ib.Util.setCSSStyle(this._contentDiv, "-webkit-transform", "translate(0px, 0px) rotate(" + p + "deg) scale(" + j + ")") : Qb.isIE ? Ib.Util.setCSSStyle(this._contentDiv, "-ms-transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")") : Ib.Util.setCSSStyle(this._contentDiv, "transform", "translate(0px,0px) rotate(" + p + "deg) scale(" + j + ")")
            }
        },
        setVisibility: function(a) {
            this._contentDiv.style.visibility = a
        },
        dispose: function() {
            this._network.getView().removeChild(this._roundDiv)
        },
        getView: function() {
            return this._roundDiv
        },
        getLabel: function() {
            return this._network.getLabel2(this._element)
        },
        getContentWidth: function() {
            return this._textSize ? this._textSize.width: 0
        },
        getContentHeight: function() {
            return this._textSize ? this._textSize.height: 0
        },
        getCornerRadius: function() {
            return this.getStyle("label2.corner.radius")
        },
        getPointerLength: function() {
            return this.getStyle("label2.pointer.length")
        },
        getPointerWidth: function() {
            return this.getStyle("label2.pointer.width")
        },
        getPosition: function() {
            return this.getStyle("label2.position")
        },
        getXOffset: function() {
            return this.getStyle("label2.xoffset")
        },
        getYOffset: function() {
            return this.getStyle("label2.yoffset")
        },
        getPadding: function() {
            return this.getStyle("label2.padding")
        },
        getPaddingLeft: function() {
            return this.getStyle("label2.padding.left")
        },
        getPaddingRight: function() {
            return this.getStyle("label2.padding.right")
        },
        getPaddingTop: function() {
            return this.getStyle("label2.padding.top")
        },
        getPaddingBottom: function() {
            return this.getStyle("label2.padding.bottom")
        },
        getDirection: function() {
            return this.getStyle("label2.direction")
        },
        isFill: function() {
            return this.getStyle("label2.fill")
        },
        getFillColor: function() {
            return this.getStyle("label2.fill.color")
        },
        getGradient: function() {
            return this.getStyle("label2.gradient")
        },
        getGradientColor: function() {
            return this.getStyle("label2.gradient.color")
        },
        getOutlineWidth: function() {
            return this.getStyle("label2.outline.width")
        },
        getOutlineColor: function() {
            return this.getStyle("label2.outline.color")
        },
        getCap: function() {
            return this.getStyle("label2.cap")
        },
        getJoin: function() {
            return this.getStyle("label2.join")
        },
        getAlpha: function() {
            return this.getStyle("label2.alpha")
        },
        isShadowable: function() {
            return this.getStyle("label2.shadowable")
        }
    }),
    Ib.vector.HTMLAlarmAttachment = function(a, b) {
        Ib.vector.HTMLAlarmAttachment.superClass.constructor.call(this, a, b),
        this._triangleDiv = Ib.Util.createDiv(),
        this._roundDiv = Ib.Util.createDiv(),
        this._contentDiv = Ib.Util.createDiv(),
        Ib.Util.setCSSStyle(this._triangleDiv, "border-style", "solid"),
        Ib.Util.setCSSStyle(this._triangleDiv, "pointer-events", "none"),
        Ib.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap"),
        Ib.Util.setCSSStyle(this._contentDiv, "pointer-events", "none"),
        this._network.getView().appendChild(this._roundDiv),
        this._roundDiv.appendChild(this._contentDiv)
    },
    Jb.ext("twaver.vector.HTMLAlarmAttachment", Ib.vector.AlarmAttachment, {
        validate: function() {
            var a = (this.getFont("alarm.font"), this._network.getAlarmLabel(this._element));
            this._contentDiv.innerHTML = a,
            this._contentDiv.style.visibility = "hidden",
            Ib.vector.HTMLAlarmAttachment.superClass.validate.call(this)
        },
        getContentWidth: function() {
            return this._contentDiv.scrollWidth || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "width"))
        },
        getContentHeight: function() {
            return this._contentDiv.scrollHeight || parseInt(Ib.Util.getCSSStyle(this._contentDiv.firstChild, "height"))
        },
        paint: function(a) {
            var b = this.isFill(),
            c = this.getOutlineWidth(),
            d = this._contentRect;
            if (this.getElementUI().setShadow(this, a), c > 0 || b) {
                if (Xb.drawRoundRect(a, d.x, d.y, d.width, d.height, this.getCornerRadius()), this._pointers) {
                    var e = this._ui.getZoomPointers(this, this._pointers);
                    a.moveTo(e[0].x, e[0].y),
                    a.lineTo(e[1].x, e[1].y),
                    a.lineTo(e[2].x, e[2].y)
                }
                if (a.closePath(), c > 0 && (a.lineWidth = c, a.strokeStyle = this.getOutlineColor(), a.lineCap = this.getCap(), a.lineJoin = this.getJoin(), a.stroke()), b) {
                    var f = this.getFillColor(),
                    g = this.getGradient();
                    g ? Xb.fill(a, f, g, this.getGradientColor(), this._viewRect) : a.fillStyle = f,
                    a.fill()
                }
            }
            var h = (this.getFont("alarm.font"), this._network.getAlarmLabel(this._element), this._network.getViewRect().x),
            i = this._network.getViewRect().y,
            j = this._network.getZoom(),
            k = {
                x: this._contentRect.x + this._contentRect.width / 2,
                y: this._contentRect.y + this._contentRect.height / 2
            },
            l = k.x * j - h - this._contentDiv.offsetWidth / 2 * j + "px",
            m = k.y * j - i - this._contentDiv.offsetHeight / 2 * j + "px";
            this._contentDiv.style.left = l,
            this._contentDiv.style.top = m,
            this._contentDiv.style.setProperty("-webkit-transform", "scale(" + j + ")", null),
            this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null),
            this._network._debug && Xb.strokeRect(a, this._contentRect, "#DDDDDD"),
            Ib.vector.AlarmAttachment.superClass.paint.apply(this, arguments)
        },
        setVisibility: function(a) {
            this._contentDiv.style.visibility = a
        },
        dispose: function() {
            this._network.getView().removeChild(this._roundDiv)
        },
        getView: function() {
            return this._roundDiv
        }
    }),
    Ib.vector.BaseZoomManager = function(a) {
        this.network = a,
        this.visibilityThresholds = a.visibilityThresholds
    },
    Jb.ext("twaver.vector.BaseZoomManager", Object, {
        getZoom: function() {
            return this.network.getZoom()
        },
        getGraphicsZoom: function() {
            return 1
        },
        getSizeZoom: function(a) {
            return 1
        },
        getAttachmentSizeZoom: function(a) {
            var b = a.getElementUI();
            return this.getSizeZoom(b)
        },
        getLocationZoom: function() {
            return 1
        },
        _getZoomVisibilityThresholds: function() {
            return this.network.getZoomVisibilityThresholds()
        },
        _convertPointFromView: function(a) {
            var b = a.x * this.getGraphicsZoom() - this.network.getViewRect().x,
            c = a.y * this.getGraphicsZoom() - this.network.getViewRect().y;
            return {
                x: b,
                y: c
            }
        },
        _getElementViewRect: function(a, b) {
            var c = this.getLocationZoom(),
            d = this.getSizeZoom(a);
            if (1 == c && 1 == d) return b;
            var e = this._getZoomPoint(a),
            f = e.x,
            g = e.y;
            return null == b && console.log("View rect is null"),
            {
                x: f * c + (b.x - f) * d,
                y: g * c + (b.y - g) * d,
                width: b.width * d,
                height: b.height * d
            }
        },
        _invalidateZoom: function() {
            this.network.invalidateElementUIs()
        },
        _getGroupChildrenRects: function(a) {
            var b = new nd;
            return a.getChildren().forEach(function(a) {
                if (a instanceof Kd) {
                    var c = this.network.getElementUI(a);
                    if (c) {
                        var d = c.getZoomViewRect(this);
                        d && b.add(d)
                    }
                }
            },
            this),
            b
        },
        _zoomGraphicsBegin: function(a) {
            var b = this.network,
            c = this.getGraphicsZoom();
            a.scale(c, c),
            a.translate(Math.floor( - b.viewRect.x / c), Math.floor( - b.viewRect.y / c))
        },
        _getEditZoomPoints: function(a, b) {
            var c = this.getLocationZoom(),
            d = this.getSizeZoom(a);
            if (1 == c && 1 == d || a instanceof Ib.vector.LinkUI && !(a instanceof Ib.vector.ShapeLinkUI)) return b;
            var e;
            e = a instanceof Ib.vector.ShapeLinkUI ? Tb.getCenterPoint(Tb.getRect(b)) : this._getZoomPoint(a);
            var f = e.x,
            g = e.y;
            if (b.forEach) {
                var h, i = new nd;
                return b.forEach(function(a) {
                    a instanceof nd ? (h = new nd, a.forEach(function(a) {
                        h.add({
                            x: f * c + (a.x - f) * d,
                            y: g * c + (a.y - g) * d
                        })
                    }), i.add(h)) : i.add({
                        x: f * c + (a.x - f) * d,
                        y: g * c + (a.y - g) * d
                    })
                }),
                i
            }
            return b.x ? {
                x: f * c + (b.x - f) * d,
                y: g * c + (b.y - g) * d
            }: void 0
        },
        _getShapeNodeZoomPoints: function(a, b, c) {
            var d = this.getLocationZoom(),
            e = this.getSizeZoom(a);
            if (1 == d && 1 == e) return b;
            c && (d = 1 / d, e = 1 / e);
            var f, g = Tb.getRect(b),
            h = g.x + g.width / 2,
            i = g.y + g.height / 2,
            j = new nd;
            return b.forEach(function(a) {
                a instanceof nd ? (f = new nd, a.forEach(function(a) {
                    f.add({
                        x: h * d + (a.x - h) * e,
                        y: i * d + (a.y - i) * e
                    })
                }), j.add(f)) : j.add({
                    x: h * d + (a.x - h) * e,
                    y: i * d + (a.y - i) * e
                })
            }),
            j
        },
        _getShapeLinkZoomPoints: function(a, b) {
            var c = this.getLocationZoom(),
            d = c;
            if (1 == c && 1 == d) return a;
            b && (c = 1 / c, d = 1 / d);
            var e, f = Tb.getRect(a),
            g = f.x + f.width / 2,
            h = f.y + f.height / 2,
            i = new nd;
            return a.forEach(function(a) {
                a instanceof nd ? (e = new nd, a.forEach(function(a) {
                    e.add({
                        x: g * c + (a.x - g) * d,
                        y: h * c + (a.y - h) * d
                    })
                }), i.add(e)) : i.add({
                    x: g * c + (a.x - g) * d,
                    y: h * c + (a.y - h) * d
                })
            }),
            i
        },
        _getLogicalPoint: function(a, b) {
            var c, d = b ? this.getZoom() : this.getGraphicsZoom(),
            e = this.network;
            if (Qb.isTouchable && a.changedTouches && a.changedTouches.length > 0) {
                var f = e._view.getBoundingClientRect(),
                g = a.changedTouches[0],
                h = Qb.isAndroid ? 0 : zc.scrollLeft(),
                i = Qb.isAndroid ? 0 : zc.scrollTop();
                return c = {
                    x: (g.clientX + e.viewRect.x - f.left - h) / d,
                    y: (g.clientY + e.viewRect.y - f.top - i) / d
                }
            }
            return c = Qb.isFirefox ? {
                x: (a.layerX + e.viewRect.x) / d,
                y: (a.layerY + e.viewRect.y) / d
            }: {
                x: (a.offsetX + e.viewRect.x) / d,
                y: (a.offsetY + e.viewRect.y) / d
            }
        },
        _getVisibleRect: function(a) {
            return a
        },
        _getElementZoomRect: function(a, b) {
            var c = this.getLocationZoom(),
            d = this.getSizeZoom(a);
            if (1 == c && 1 == d) return Jb.cloneRect(b);
            var e = null != a ? this._getZoomPoint(a) : {
                x: b.x + b.width / 2,
                y: b.y + b.height / 2
            },
            f = e.x,
            g = e.y;
            return {
                x: f * c + (b.x - f) * d,
                y: g * c + (b.y - g) * d,
                width: b.width * d,
                height: b.height * d
            }
        },
        _reverseElementZoomRect: function(a, b) {
            var c = this.getLocationZoom(),
            d = this.getSizeZoom(a);
            if (1 == c && 1 == d) return Jb.cloneRect(b);
            var e = null != a ? this._getZoomPoint(a) : {
                x: b.x + b.width / 2,
                y: b.y + b.height / 2
            },
            f = e.x,
            g = e.y;
            return {
                x: f + (b.x - f * c) / d,
                y: g + (b.y - g * c) / d,
                width: b.width / d,
                height: b.height / d
            }
        },
        _getZoomContentRect: function(a, c, d, e, f, g) {
            var h = this.getSizeZoom(a.getElementUI()),
            i = this.getAttachmentSizeZoom(a),
            j = a.getElementUI();
            return g == b ? j instanceof Ib.vector.GroupUI && j._shapeRect ? {
                x: e.x * f + 1 * (c.x - e.x) + (d.x - c.x) * i,
                y: e.y * f + 1 * (c.y - e.y) + (d.y - c.y) * i,
                width: d.width,
                height: d.height
            }: {
                x: e.x * f + (c.x - e.x) * h + (d.x - c.x) * i,
                y: e.y * f + (c.y - e.y) * h + (d.y - c.y) * i,
                width: d.width,
                height: d.height
            }: {
                x: e.x * f + (c.x - e.x) * h + (d.x - c.x) * i,
                y: e.y * f + (c.y - e.y) * h + (d.y - c.y) * i + g * (a.textHeight - 4) * i,
                width: d.width,
                height: a.textHeight
            }
        },
        _getAttachmentZoomRect: function(a, c, d) {
            var e = this.getLocationZoom(),
            f = a.getElementUI(),
            g = this.getSizeZoom(a.getElementUI()),
            h = this.getAttachmentSizeZoom(a),
            i = a._pointers;
            if (1 == e && 1 == h && 1 == g) return d == b ? c: {
                x: c.x,
                y: c.y + d * (a.textHeight - 4),
                width: c.width,
                height: a.textHeight
            };
            var f = a.getElementUI(),
            j = this._getZoomPoint(f, a),
            k = (j.x, j.y, a.getPosition ? a.getPosition() : "center"),
            l = i ? i[0] : Qd.get(k, c);
            return d == b ? f instanceof Ib.vector.LinkUI || f instanceof Ib.vector.GroupUI && f._shapeRect ? this._getZoomContentRect(a, l, c, j, 1) : this._getZoomContentRect(a, l, c, j, e) : this._getZoomContentRect(a, l, c, j, e, d)
        },
        _getZoomPoint: function(a, b) {
            var c, d, e = a._element;
            if (e instanceof Ib.Follower && e.getHost() && e.getHost() instanceof Ib.Grid) return c = e.getHost(),
            d = c.getRect(),
            {
                x: d.x + d.width / 2,
                y: d.y + d.height / 2
            };
            if (d = a.getBodyRect(), a instanceof Ib.vector.LinkUI && b && b.getPosition) {
                if (b.getXOffset(), b.getYOffset(), "from" === b.getPosition()) return a._fromPoint;
                if ("to" === b.getPosition()) return a._toPoint
            }
            return {
                x: d.x + d.width / 2,
                y: d.y + d.height / 2
            }
        },
        _getZoomPointers: function(a, b, c) {
            if (c) {
                var d = this._getZoomPoint(b),
                e = this.getLocationZoom(),
                f = this.getSizeZoom(b),
                g = this.getAttachmentSizeZoom(a),
                h = c[0];
                return b instanceof Ib.vector.LinkUI ? [{
                    x: d.x + (h.x - d.x) * f,
                    y: d.y + (h.y - d.y) * f
                },
                {
                    x: d.x + (h.x - d.x) * f + (c[1].x - h.x) * g,
                    y: d.y + (h.y - d.y) * f + (c[1].y - h.y) * g
                },
                {
                    x: d.x + (h.x - d.x) * f + (c[2].x - h.x) * g,
                    y: d.y + (h.y - d.y) * f + (c[2].y - h.y) * g
                }] : b instanceof Ib.vector.GroupUI && b._shapeRect ? [{
                    x: d.x + 1 * (h.x - d.x),
                    y: d.y + 1 * (h.y - d.y)
                },
                {
                    x: d.x + 1 * (h.x - d.x) + (c[1].x - h.x) * g,
                    y: d.y + 1 * (h.y - d.y) + (c[1].y - h.y) * g
                },
                {
                    x: d.x + 1 * (h.x - d.x) + (c[2].x - h.x) * g,
                    y: d.y + 1 * (h.y - d.y) + (c[2].y - h.y) * g
                }] : [{
                    x: d.x * e + (h.x - d.x) * f,
                    y: d.y * e + (h.y - d.y) * f
                },
                {
                    x: d.x * e + (h.x - d.x) * f + (c[1].x - h.x) * g,
                    y: d.y * e + (h.y - d.y) * f + (c[1].y - h.y) * g
                },
                {
                    x: d.x * e + (h.x - d.x) * f + (c[2].x - h.x) * g,
                    y: d.y * e + (h.y - d.y) * f + (c[2].y - h.y) * g
                }]
            }
        },
        _getZoomHotSpot: function(a, b) {
            if (b) {
                var c = this._getZoomPoint(a),
                d = this.getLocationZoom(),
                e = this.getSizeZoom(a);
                return {
                    x: c.x * d + (b.x - c.x) * e,
                    y: c.y * d + (b.y - c.y) * e
                }
            }
            return null
        },
        limitZoom: function(a) {
            return a
        },
        _isVisible: function(a) {
            var b, c = this._getZoomVisibilityThresholds(),
            d = c[a];
            if (null != d) {
                var e = c.zoomName;
                if (b = "sizeZoom" == e ? this.getSizeZoom() : "locationZoom" == e ? this.getLocationZoom() : "graphicsZoom" == e ? this.getGraphicsZoom() : this.getZoom(), d > b) return ! 1
            }
            return ! 0
        },
        isElementVisible: function(a) {
            var b = this.getZoom(),
            c = this._isVisible("element", b);
            return c && a instanceof Ib.Link ? this.isLinkVisible(a) : c
        },
        isLinkVisible: function(a) {
            var b = this.getZoom();
            return this._isVisible("link", b)
        },
        isLabelVisible: function(a) {
            var b = this.getZoom();
            return this._isVisible("label", b)
        },
        isAttachmentVisible: function(a) {
            var b = this.getZoom();
            return this._isVisible("attachment", b)
        },
        isAlarmBalloonVisible: function(a) {
            var b = this.getZoom();
            return this._isVisible("alarmBallon", b)
        },
        _getAttachmentOutLineWidth: function(a) {
            return a.getOutlineWidth()
        },
        _getAttachmentZoomOutLineRect: function(a, b) {
            var c = this.getLocationZoom(),
            d = this.getAttachmentSizeZoom(a);
            if (1 == c && 1 == d) return b;
            var e = this._getAttachmentZoomRect(a, b, null),
            f = a.getElement();
            return this.isAttachmentVisible(f) ? (a instanceof Ib.vector.LabelAttachment || a instanceof Ib.vector.Label2Attachment) && !this.isLabelVisible(f) ? {
                x: e.x,
                y: e.x,
                width: 0,
                height: 0
            }: a instanceof Ib.vector.AlarmAttachment && !this.isAlarmBalloonVisible(f) ? {
                x: e.x,
                y: e.x,
                width: 0,
                height: 0
            }: {
                x: e.x,
                y: e.y,
                width: e.width * d,
                height: e.height * d
            }: {
                x: e.x,
                y: e.x,
                width: 0,
                height: 0
            }
        },
        _drawText: function(a, b, c, d, e, f, g) {
            var h = this.getLocationZoom(),
            i = this.getAttachmentSizeZoom(a);
            1 != h && 1 != i ? (b.translate(d.x, d.y), b.scale(i, i), Xb.drawText(b, c, {
                x: 0,
                y: 0,
                width: d.width,
                height: d.height
            },
            e, f, g), b.scale(1 / i, 1 / i), b.translate( - d.x, -d.y)) : Xb.drawText(b, c, d, e, f, g)
        },
        _getOffset: function(a, b) {
            var c = this.getLocationZoom();
            return {
                x: (a.x - b.x) / c,
                y: (a.y - b.y) / c
            }
        }
    });
    var Qd = {
        "topleft.topleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y + a.height
            }
        },
        "topleft.topright": function(a) {
            return {
                x: a.x,
                y: a.y + a.height
            }
        },
        "top.top": function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height
            }
        },
        "topright.topleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y + a.height
            }
        },
        "topright.topright": function(a) {
            return {
                x: a.x,
                y: a.y + a.height
            }
        },
        topleft: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        top: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        topright: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        "topleft.bottomleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y
            }
        },
        "topleft.bottomright": function(a) {
            return {
                x: a.x,
                y: a.y
            }
        },
        "top.bottom": function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y
            }
        },
        "topright.bottomleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y
            }
        },
        "topright.bottomright": function(a) {
            return {
                x: a.x,
                y: a.y
            }
        },
        "left.left": function(a) {
            return {
                x: a.x + a.width,
                y: a.y + a.height / 2
            }
        },
        left: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        "left.right": function(a) {
            return {
                x: a.x,
                y: a.y + a.height / 2
            }
        },
        center: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        "right.left": function(a) {
            return {
                x: a.x + a.width,
                y: a.y + a.height / 2
            }
        },
        right: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        "right.right": function(a) {
            return {
                x: a.x,
                y: a.y + a.height / 2
            }
        },
        "bottomleft.topleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y + a.height
            }
        },
        "bottomleft.topright": function(a) {
            return {
                x: a.x,
                y: a.y + a.height
            }
        },
        "bottom.top": function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height
            }
        },
        "bottomright.topleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y + a.height
            }
        },
        "bottomright.topright": function(a) {
            return {
                x: a.x,
                y: a.y + a.height
            }
        },
        bottomleft: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        bottom: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        bottomright: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        "bottomleft.bottomleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y
            }
        },
        "bottomleft.bottomright": function(a) {
            return {
                x: a.x,
                y: a.y
            }
        },
        "bottom.bottom": function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y
            }
        },
        "bottomright.bottomleft": function(a) {
            return {
                x: a.x + a.width,
                y: a.y
            }
        },
        "bottomright.bottomright": function(a) {
            return {
                x: a.x,
                y: a.y
            }
        },
        from: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        to: function(a) {
            return {
                x: a.x + a.width / 2,
                y: a.y + a.height / 2
            }
        },
        get: function(a, b) {
            if (!b) throw "rect can not be null";
            var c = Qd[a];
            if (c) return c(b);
            throw "Can not resolve '" + a + "' position"
        }
    };
    Ib.vector.PhysicalZoomManager = function(a) {
        Ib.vector.PhysicalZoomManager.superClass.constructor.apply(this, arguments)
    },
    Jb.ext("twaver.vector.PhysicalZoomManager", Ib.vector.BaseZoomManager, {
        getGraphicsZoom: function() {
            return this.getZoom()
        },
        _invalidateZoom: function() {}
    }),
    Ib.vector.LogicalZoomManager = function(a, b) {
        Ib.vector.LogicalZoomManager.superClass.constructor.apply(this, arguments),
        this.sizeChange = b
    },
    Jb.ext("twaver.vector.LogicalZoomManager", Ib.vector.BaseZoomManager, {
        getLocationZoom: function() {
            return this.getZoom()
        },
        getSizeZoom: function(a) {
            return this.sizeChange ? this.getZoom() : 1
        }
    }),
    Ib.vector.MixedZoomManager = function(a, b) {
        Ib.vector.MixedZoomManager.superClass.constructor.call(this, a, b)
    },
    Jb.ext("twaver.vector.MixedZoomManager", Ib.vector.LogicalZoomManager, {}),
    function() {
        function a(a) {
            d[a] = function() {
                return this.getZoom() > 1 ? b[a].apply(this, arguments) : c[a].apply(this, arguments)
            }
        }
        var b = Ib.vector.LogicalZoomManager.prototype,
        c = Ib.vector.PhysicalZoomManager.prototype,
        d = Ib.vector.MixedZoomManager.prototype;
        for (var e in c)"function" == typeof c[e] && "constructor" != e && (b.hasOwnProperty(e) || c.hasOwnProperty(e)) && a(e);
        d._invalidateZoom = function() {
            this.network.invalidateElementUIs()
        }
    } (),
    Ib.vector.interaction.BaseInteraction = function(a) {
        this.network = a
    },
    Jb.ext("twaver.vector.interaction.BaseInteraction", Object, {
        setUp: function() {},
        tearDown: function() {},
        repaint: function() {
            this.network.repaintTopCanvas()
        },
        getOffset: function(a, b) {
            return this.network.getOffset(a, b)
        },
        convertPointFromView: function(a) {
            return this.network.convertPointFromView(a)
        },
        convertFromUIToMarkerRect: function(a, b, c, d) {
            var e = this.network.zoomManager,
            f = e.getLocationZoom(),
            g = e.getGraphicsZoom(),
            h = e.getSizeZoom(this.network.getElementUI(d));
            return {
                x: a.x * f * g - this.network.getViewRect().x + b * f * g,
                y: a.y * f * g - this.network.getViewRect().y + c * f * g,
                width: a.width * h * g,
                height: a.height * h * g
            }
        },
        getMarkerPoint: function(a) {
            var b;
            if (Qb.isTouchable && a.changedTouches && a.changedTouches.length > 0) {
                var c = a.changedTouches[0];
                return b = {
                    x: c.clientX,
                    y: c.clientY
                }
            }
            return b = Qb.isFirefox ? {
                x: a.layerX,
                y: a.layerY
            }: {
                x: a.offsetX,
                y: a.offsetY
            }
        },
        paint: function(a) {},
        addListener: function() {
            for (var a = 0; a < arguments.length; a++) {
                var b = arguments[a];
                Wb.addEventListener(b, "handle_" + b, this.network.getView(), this)
            }
        },
        removeListener: function() {
            for (var a = 0; a < arguments.length; a++) Wb.removeEventListener(arguments[a], this.network.getView(), this)
        },
        _handle_mousedown: function(a) {
            0 === a.button && (this._startLogical = this.network.getLogicalPoint2(a), this._startClient = Wb.getClientPoint(a), this._startLogical && Wb.handle_mousedown(this, a))
        },
        _handle_mousemove: function(a) {
            this._endLogical = {
                x: this._startLogical.x + (a.clientX - this._startClient.x) / this.network.getGraphicsZoom(),
                y: this._startLogical.y + (a.clientY - this._startClient.y) / this.network.getGraphicsZoom()
            }
        },
        _handle_mouseup: function(a) {
            delete this._startClient,
            delete this._startLogical,
            delete this._endLogical
        }
    }),
    Ib.vector.interaction.DefaultInteraction = function(a, b) {
        Ib.vector.interaction.DefaultInteraction.superClass.constructor.call(this, a),
        this.lazyMode = b
    },
    Jb.ext("twaver.vector.interaction.DefaultInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseover", "mouseout", "keydown"),
            Qb.isFirefox ? Wb.addEventListener("DOMMouseScroll", "handleMouseWheel", this.network.getView(), this) : Wb.addEventListener("mousewheel", "handleMouseWheel", this.network.getView(), this),
            Wb.addEventListener("mouseup", "handle_mouseup", a, this),
            Wb.addEventListener("dblclick", "handleDoubleClicked", this.network.getView(), this),
            this._oldCursor = this.network.getView().style.cursor,
            this.network.addPropertyChangeListener(this.handleViewRectChange, this),
            this.validateScrollBar(),
            this.network.addMarker(this),
            this.network.getView().oncontextmenu = function(a) {
                a.preventDefault()
            },
            this._createZoomDiv()
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseover", "mouseout", "keydown"),
            Qb.isFirefox ? Wb.removeEventListener("DOMMouseScroll", this.network.getView(), this) : Wb.removeEventListener("mousewheel", this.network.getView(), this),
            Wb.removeEventListener("mouseup", a, this),
            Wb.removeEventListener("dblclick", this.network.getView(), this),
            this.network.removePropertyChangeListener(this.handleViewRectChange, this),
            this.end(),
            this.network.removeMarker(this),
            this._zoomDiv = null
        },
        _createZoomDiv: function() {
            if (null == this._zoomDiv) {
                this._zoomDiv = Ob.createElement("div"),
                this._zoomLabel = Ob.createElement("span"),
                this._zoomLabel.style.display = "block",
                this._zoomLabel.style.textAlign = "center";
                var b = Ob.createElement("button");
                b.innerHTML = "Reset to default",
                this._zoomDiv.appendChild(this._zoomLabel),
                this._zoomDiv.appendChild(b);
                var c = Dd,
                d = this._zoomDiv.style;
                d.position = "absolute",
                d.color = c.TOOLTIP_COLOR,
                d.background = c.TOOLTIP_BACKGROUND,
                d.fontSize = c.TOOLTIP_FONT_SIZE,
                d.padding = c.TOOLTIP_PADDING,
                d.border = c.TOOLTIP_BORDER,
                d.borderRadius = c.TOOLTIP_BORDER_RADIUS,
                d.boxShadow = c.TOOLTIP_BOX_SHADOW,
                d.zIndex = c.TOOLTIP_ZINDEX,
                d.setProperty && d.setProperty("-webkit-box-shadow", c.TOOLTIP_BOX_SHADOW, null);
                var e = this;
                b.onclick = function(a) {
                    e.network.setZoom(1),
                    e._setZoomDivVisible(!1)
                };
                var f = this._zoomDiv,
                g = function() {
                    return f.style.opacity = parseFloat(f.style.opacity) - .05,
                    parseFloat(f.style.opacity) <= .05 ? (e._setZoomDivVisible(!1), void(f._clearTimeout = null)) : void(f._clearTimeout = setTimeout(f._clearFunc, 100))
                };
                f._clearFunc = g,
                f.onmouseover = function(b) {
                    b || (b = a.event);
                    for (var c = b.relatedTarget ? b.relatedTarget: b.fromElement; c && c != f;) c = c.parentNode;
                    c != f && (f._clearTimeout && (clearTimeout(f._clearTimeout), f._clearTimeout = null), f.style.opacity = 1)
                },
                f.onmouseout = function(b) {
                    b || (b = a.event);
                    for (var c = b.relatedTarget ? b.relatedTarget: b.toElement; c && c != f;) c = c.parentNode;
                    c != f && (f._clearTimeout = setTimeout(f._clearFunc, 10))
                }
            }
        },
        _isZoomDivVisible: function() {
            return null != this._zoomDiv && null != this._zoomDiv.parentNode
        },
        _getZoomDiv: function() {
            return this._zoomDiv || this._createZoomDiv(),
            this._zoomDiv
        },
        _setZoomDivVisible: function(a, b, c) {
            var d = this._getZoomDiv();
            a ? (this._zoomLabel.innerHTML = c, d.style.opacity = 1, this._isZoomDivVisible() || this.network.getView().appendChild(d), d.style.left = Dd.TOOLTIP_XOFFSET + "px", d.style.top = Dd.TOOLTIP_YOFFSET + "px", d._clearTimeout && (clearTimeout(d._clearTimeout), d._clearTimeout = null), d._clearTimeout = setTimeout(d._clearFunc, 250)) : d.parentNode && d.parentNode.removeChild(d)
        },
        handleViewRectChange: function(a) { ("viewRect" == a.property || "canvasSizeChange" == a.property) && this.validateScrollBar()
        },
        getScrollBarWidth: function() {
            return this.network.getScrollBarWidth()
        },
        getScrollBarColor: function() {
            return "#cccccc"
        },
        validateScrollBar: function() {
            if (this.hThumbRect = null, this.vThumbRect = null, 0 == this.network.isScrollBarVisible()) return void this.repaint();
            var a = this.network.getViewRect().height,
            b = this.network.getViewRect().width,
            c = this.network.getViewRect().x,
            d = this.network.getViewRect().y,
            e = this.network.getCanvasSize(),
            f = this.network._unionBounds,
            g = f.x,
            h = f.y,
            i = f.width,
            j = f.height,
            k = e.width,
            l = e.height,
            m = b,
            n = a,
            o = !1,
            p = !1; (c > g || k > b + c) && (p = !0),
            (d > h || l > d + a) && (o = !0);
            var q, r, s, t = 0,
            u = 0,
            v = 0,
            w = 0,
            x = m,
            y = n,
            z = this.getScrollBarWidth();
            p && (o && (x -= z), w = z, u = n - z, c > g && c + b > k ? (q = c - g, q = q * x / (q + m), t = q, v = x - q) : g > c && k > c + b ? (q = k - (c + b), q = x * q / (q + m), t = 0, v = x - q) : (r = c - g, s = k - (c + b), r = x * r / i, s = x * s / i, t = r, v = m - r - s), this.hThumbRect = {
                x: t,
                y: u,
                width: v,
                height: w
            }),
            t = 0,
            u = 0,
            v = 0,
            w = 0,
            x = m,
            y = n,
            o && (p && (y -= z), v = z, t = m - z, d > h && d + a > l ? (q = d - h, q = y * q / (q + n), u = q, w = y - q) : h > d && l > d + a ? (q = l - (d + a), q = y * q / (q + n), u = 0, w = y - q) : (r = d - h, s = l - (d + a), r = y * r / j, s = y * s / j, u = r, w = y - r - s), this.vThumbRect = {
                x: t,
                y: u,
                width: v,
                height: w
            }),
            this.network.setHScrollBarVisible(null != this.hThumbRect),
            this.network.setVScrollBarVisible(null != this.vThumbRect),
            this.repaint()
        },
        scrollXOffset: function(a) {
            var b = this.network.getViewRect().height,
            c = this.network.getViewRect().width,
            d = this.network.getViewRect().x,
            e = this.network.getViewRect().y,
            f = 30;
            a && (f = -30),
            this.network.setViewRect(d + f, e, c, b)
        },
        scrollYOffset: function(a) {
            var b = this.network.getViewRect().height,
            c = this.network.getViewRect().width,
            d = this.network.getViewRect().x,
            e = this.network.getViewRect().y,
            f = 30;
            a && (f = -30),
            this.network.setViewRect(d, e + f, c, b)
        },
        handle_mouseover: function(a) {
            1 != this.scrollBarVisible && (this.scrollBarVisible = !0, this.repaint())
        },
        handle_mouseout: function(a) {
            0 != this.scrollBarVisible && (this.scrollBarVisible = !1, this.repaint(), this.end(a))
        },
        handle_keydown: function(a) {
            this.currentKeyEvent = a,
            this.addListener("keyup"),
            Cc.handleKeyDown(this.network, a)
        },
        handle_keyup: function(a) {
            this.currentKeyEvent = null,
            this.removeListener("keyup")
        },
        start: function(b) {
            this.end(b, !0),
            this.lastPoint = this.network.getLogicalPoint2(b),
            this.startPoint = this.network.getLogicalPoint2(b),
            this.lastPanPoint = this.getMarkerPoint(b),
            this.lazyMode && (this.pressPoint = this.lastPoint),
            Wb.addEventListener("mousemove", "handle_mousemove", a, this)
        },
        end: function(b, c) {
            if (this.vBarDownPoint = null, this.hBarDownPoint = null, c || (this.network.getView().style.cursor = this._oldCursor), this.isMoving) {
                if (this.lazyMode) {
                    if (null != this.dragPoint && null != this.pressPoint) {
                        var d = this,
                        e = function() {
                            d.network.fireInteractionEvent({
                                kind: "lazyMoveEnd",
                                event: b
                            }),
                            d.network.setMovingElement(!1)
                        },
                        f = this.getOffset(this.dragPoint, this.pressPoint),
                        g = f.x,
                        h = f.y;
                        this.network.moveSelectedElements(g, h, this.network.isLazyMoveAnimate(), e)
                    }
                } else this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                    kind: "liveMoveEnd",
                    event: b
                }));
                if (this.isParenting()) {
                    null == this.parent && (this.parent = this.network.getCurrentSubNetwork());
                    var d = this;
                    this.network.getMovableSelectedElements().forEach(function(a) {
                        a.setParent(d.parent)
                    },
                    this.network)
                }
                this.parentProcess(b, !0),
                this.isParenting() && this.repaint(),
                this.network.invalidateCanvasSize(),
                this.lastPoint = null,
                this.dragPoint = null,
                this.pressPoint = null,
                this.repaint()
            }
            if (this.isSelecting && this.startPoint) {
                if (this.endPoint && this.startPoint.x !== this.endPoint.x && this.startPoint.y !== this.endPoint.y) {
                    var i = Tb.getRect([this.startPoint, this.endPoint]),
                    j = this.network.getElementsAtRect(i, this.getIntersectMode(), this.network.getRectSelectFilter());
                    if (j && j.size() > 0) {
                        var k = this.network.getSelectionModel(),
                        l = k.toSelection();
                        j.forEach(function(a) {
                            k.contains(a) ? l.remove(a) : l.add(a)
                        },
                        this),
                        k.setSelection(l)
                    }
                    this.network.fireInteractionEvent({
                        kind: "selectEnd",
                        event: b
                    })
                }
                this.network.setSelectingElement(!1),
                this.startPoint = null,
                this.endPoint = null,
                this.repaint()
            }
            this.isMouseDown = !1,
            Wb.removeEventListener("mousemove", a, this)
        },
        _isDragToSelect: function(a) {
            return ! this.network._dragToPan
        },
        handle_mousedown: function(a) {
            var b = this.network;
            if (a.target == b.getView() || a.target == b._topCanvas || a.target == b._rootCanvas) {
                if (this.isMoving = !1, this.isSelecting = !1, this.hBarDownPoint = null, this.vBarDownPoint = null, this._setZoomDivVisible(!1), !this.network.isValidEvent(a)) {
                    var c = this.getMarkerPoint(a);
                    return this.start(a),
                    null != this.vThumbRect && Tb.containsPoint(this.vThumbRect, c.x, c.y) && (this.vBarDownPoint = {
                        x: a.screenX,
                        y: a.screenY
                    },
                    this.vBarDownOffset = this.vBarDownPoint.y - this.vThumbRect.y),
                    void(null != this.hThumbRect && Tb.containsPoint(this.hThumbRect, c.x, c.y) && (this.hBarDownPoint = {
                        x: a.screenX,
                        y: a.screenY
                    },
                    this.hBarDownOffset = this.hBarDownPoint.x - this.hThumbRect.x))
                }
                this.network.isFocusOnClick() && Ib.Util.setFocus(this.network.getView());
                var d = this.network.getElementAt(a);
                if (this.network.isSelectingElement() || this.network.isEditingElement() || null == d || (this.network.isMovable(d) ? this.isMoving = !0 : this.network.getView().style.cursor = "pointer", this.start(a)), !this.network.isSelectingElement() && !this.network.isEditingElement()) {
                    var e = this.network.getSelectionModel();
                    null == d ? (Jb.isCtrlDown(a) ? this.isSelecting = !0 : this._isDragToSelect(a) ? (this.isSelecting = !0, e.clearSelection()) : this.network.isRectSelectEnabled() && (e.clearSelection(), this.network.getView().style.cursor = "pointer"), this.start(a)) : Jb.isCtrlDown(a) ? e.contains(d) ? e.removeSelection(d) : e.appendSelection(d) : e.contains(d) || e.setSelection(d)
                }
                this.handleClicked(a, d),
                this.isMouseDown = !0
            }
        },
        handle_mousemove: function(a) {
            this._setZoomDivVisible(!1);
            var b = this.network.getLogicalPoint2(a);
            if (b) {
                var c = {
                    x: a.screenX,
                    y: a.screenY
                },
                d = this.network.getCanvasSize(),
                e = this.network.getViewRect().height,
                f = this.network.getViewRect().width,
                g = this.getScrollBarWidth();
                if (null != this.hBarDownPoint) {
                    var h = c.x - this.hBarDownPoint.x;
                    return this.hBarDownPoint = c,
                    void this.network.setViewOffSet(h * d.width / (f - g), 0)
                }
                if (null != this.vBarDownPoint) {
                    var i = c.y - this.vBarDownPoint.y;
                    return this.vBarDownPoint = c,
                    void this.network.setViewOffSet(0, i * d.height / (e - g))
                }
                if (this.network.isSelectingElement() || this.network.isEditingElement() || !this.isMoving || !this.isMouseDown || Jb.isCtrlDown(a)) if (this.isSelecting && (Jb.isCtrlDown(a) || this._isDragToSelect())) this.network.setSelectingElement(!0),
                this.network.fireInteractionEvent(null == this.endPoint ? {
                    kind: "selectStart",
                    event: a
                }: {
                    kind: "selectBetween",
                    event: a
                }),
                this.endPoint = b,
                this.repaint();
                else if (this.isMoving || this.isSelecting || !this.isMouseDown) this.end(a);
                else {
                    if (!this.lastPanPoint || !this.network._dragToPan) return;
                    var b = this.getMarkerPoint(a);
                    if (!b) return;
                    var j = b.x - this.lastPanPoint.x,
                    k = b.y - this.lastPanPoint.y;
                    this.network.panByOffset( - j, -k),
                    this.lastPanPoint = b
                } else {
                    var l = this.getOffset(b, this.lastPoint);
                    if (this.xoffset = l.x, this.yoffset = l.y, Math.abs(this.xoffset) < 1 && Math.abs(this.yoffset) < 1) return;
                    this.lazyMode ? null == this.dragPoint ? (this.network.fireInteractionEvent({
                        kind: "lazyMoveStart",
                        event: a
                    }), this.network.setMovingElement(!0)) : this.network.fireInteractionEvent({
                        kind: "lazyMoveBetween",
                        event: a
                    }) : (this.lastPoint = b, this.network.isMovingElement() ? this.network.fireInteractionEvent({
                        kind: "liveMoveBetween",
                        event: a
                    }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                        kind: "liveMoveStart",
                        event: a
                    })), this.network.moveSelectedElements(this.xoffset, this.yoffset)),
                    this.parentProcess(a, !1),
                    this.lazyMode && (this.dragPoint = b),
                    (this.lazyMode || this.isParenting()) && this.repaint()
                }
            }
        },
        handleMouseWheel: function(a) {
            if (Ob.activeElement === this.network.getView()) {
                if (!this.network._wheelToZoom) return void this._handleMouseWheelScroll(a);
                Wb.preventDefault(a);
                var b = {
                    x: a.offsetX || a.layerX,
                    y: a.offsetY || a.layerY
                },
                c = this.network.getZoom();
                a.wheelDelta && a.wheelDelta > 0 || a.detail && a.detail < 0 ? this.network.setZoom(1.1 * c, b) : this.network.setZoom(c / 1.1, b),
                this._setZoomDivVisible(this.network.isZoomDivVisible(), a, "Zoom : " + parseFloat(this.network.getZoom().toFixed(4)))
            }
        },
        _handleMouseWheelScroll: function(a) {
            Wb.preventDefault(a);
            var b = !1,
            c = this._getVisibleScrollBar();
            null != c && (b = a.wheelDelta ? a.wheelDelta > 0 : a.detail < 0, "v" == c ? this.scrollYOffset(b) : this.scrollXOffset(b))
        },
        handle_mouseup: function(a) {
            this.end(a)
        },
        isParenting: function() {
            return this.pressPoint && null != this.currentKeyEvent && 80 === this.currentKeyEvent.keyCode
        },
        parentProcess: function(a, b) {
            var c = null;
            this.parent = null;
            var d = this;
            if (!b && this.isParenting()) {
                var e = {},
                f = this.network.getLogicalPoint2(a);
                e.x = f.x - 1,
                e.y = f.y - 1,
                e.width = 2,
                e.height = 2;
                var g = this.network.getElementsAtRect(e, !0);
                if (g && g.size() > 0) for (var h = g.size(), i = 0; h > i; i++) {
                    var j = g.get(i);
                    if (!d.network.getElementBox().getSelectionModel().contains(j)) {
                        d.parent = j;
                        break
                    }
                }
            } else this.parent = null;
            null != this.parent && (c = this.network.getElementUI(this.parent).getViewRect()),
            this.parentRect = null == c || b ? null: c
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this.startPoint.x > this.endPoint.x && this.startPoint.y > this.endPoint.y
        },
        _getVisibleScrollBar: function() {
            return 0 == this.network.isScrollBarVisible() ? null: null != this.vThumbRect ? "v": null != this.hThumbRect ? "h": null
        },
        paintScroll: function(a) {
            if (0 != this.network.isScrollBarVisible() && (0 != this.scrollBarVisible || null != this.hBarDownPoint || null != this.vBarDownPoint)) {
                var b = this.getScrollBarWidth(),
                c = this.network.getViewRect().height,
                d = this.network.getViewRect().width;
                a.save();
                var e, f = this.getScrollBarColor();
                null != this.hThumbRect && (e = a.createLinearGradient(this.hThumbRect.x, this.hThumbRect.y, this.hThumbRect.x, this.hThumbRect.y + this.hThumbRect.height), e.addColorStop(0, f), e.addColorStop(1, "#666666"), this.paintRoundRect(a, this.getScrollBarColor(), .5, 0, c - b, d - b, b, b / 2), this.paintRoundRect(a, e, .9, this.hThumbRect.x, this.hThumbRect.y + 1, this.hThumbRect.width, this.hThumbRect.height - 2, b / 2)),
                null != this.vThumbRect && (e = a.createLinearGradient(this.vThumbRect.x, this.vThumbRect.y, this.vThumbRect.x + this.vThumbRect.width, this.vThumbRect.y), e.addColorStop(0, f), e.addColorStop(1, "#666666"), this.paintRoundRect(a, this.getScrollBarColor(), .5, d - b, 0, b, c - b, b / 2), this.paintRoundRect(a, e, .9, this.vThumbRect.x + 1, this.vThumbRect.y, this.vThumbRect.width - 2, this.vThumbRect.height, b / 2)),
                a.restore()
            }
        },
        paintRoundRect: function(a, b, c, d, e, f, g, h) {
            a.beginPath(),
            a.globalAlpha = c,
            a.fillStyle = b,
            Xb.drawRoundRect(a, d, e, f, g, h),
            a.fill()
        },
        paint: function(a) {
            if (this.paintScroll(a), this.network.isSelectingElement()) {
                if (null == this.startPoint || null == this.endPoint) return;
                var b = this.convertPointFromView(this.startPoint),
                c = this.convertPointFromView(this.endPoint),
                d = b.x,
                e = b.y,
                f = c.x,
                g = c.y,
                h = Tb.getRect([{
                    x: d,
                    y: e
                },
                {
                    x: f,
                    y: g
                }]);
                if (null != h) {
                    a.beginPath();
                    var i = this.network.getSelectOutlineWidth(),
                    j = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
                    a.strokeStyle = this.network.getSelectOutlineColor(),
                    a.lineWidth = i,
                    Nd.rect(a, h.x, h.y, h.width, h.height, j, this.network.getSelectOutlineColor()),
                    a.closePath()
                }
            } else {
                if (this.lazyMode) {
                    if (null == this.pressPoint || null == this.dragPoint) return;
                    a.beginPath();
                    var k = this.getOffset(this.dragPoint, this.pressPoint),
                    l = k.x,
                    m = k.y,
                    n = this.network.getMovableSelectedElements(),
                    o = n.size(),
                    p = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null,
                    i = this.network.getLazyMoveOutlineWidth(),
                    q = this.network.getLazyMoveOutlineColor();
                    a.strokeStyle = q,
                    a.lineWidth = i,
                    a.fillStyle = p;
                    for (var r = 0; o > r; r++) {
                        var s = n.get(r),
                        t = this.network.getElementUI(s);
                        if (t) {
                            var u = this.convertFromUIToMarkerRect(t.getViewRect(), l, m);
                            Nd.rect(a, u.x, u.y, u.width, u.height)
                        }
                    }
                    a.fill(),
                    a.stroke()
                }
                if (this.parentRect) {
                    a.beginPath();
                    var p = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null,
                    i = this.network.getLazyMoveOutlineWidth(),
                    q = this.network.getLazyMoveOutlineColor();
                    a.strokeStyle = q,
                    a.lineWidth = i,
                    a.fillStyle = p;
                    var u = this.parentRect;
                    Nd.rect(a, u.x, u.y, u.width, u.height),
                    a.fill(),
                    a.stroke()
                }
            }
        },
        handleClicked: function(a, b) {
            Cc.handleClicked(this.network, a, b)
        },
        handleDoubleClicked: function(a) {
            var b = this.network.getElementAt(a);
            Cc.handleDoubleClicked(this.network, a, b)
        }
    }),
    Ib.vector.interaction.CreateElementInteraction = function(a, b) {
        b || (b = Ib.Node),
        this.elementFunction = Ib.Util.isTypeOf(b, Ib.Node) ?
        function(a) {
            var c = new b;
            return c instanceof Ib.Node && c.setCenterLocation(a),
            c
        }: b,
        Ib.vector.interaction.CreateElementInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.vector.interaction.CreateElementInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown")
        },
        tearDown: function() {
            this.removeListener("mousedown")
        },
        handle_mousedown: function(a) {
            var b = this.network.getLogicalPoint2(a);
            if (b) {
                var c = this.elementFunction(b);
                c && this.network.addElementByInteraction(c)
            }
        }
    }),
    Ib.vector.interaction.EditInteraction = function(a, b) {
        this.lazyMode = b,
        this.pointIndex = -1,
        this.editPointSize = a.getEditPointSize(),
        this.resizePointSize = a.getResizePointSize(),
        this.rotatePointSize = a.getRotatePointSize(),
        this.linkPointsType = null,
        Ib.vector.interaction.EditInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.vector.interaction.EditInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mouseup", "mousemove"),
            this.oldCursor = this.network.getView().style.cursor,
            this.network.setHasEditInteraction(!0),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mouseup", "mousemove"),
            this.network.getView().style.cursor = this.oldCursor,
            this.network.setHasEditInteraction(!1),
            this.clear(),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            if (1 == this.lazyMode && null != this.resizingRect) {
                a.lineWidth = this.network.getResizeLineWidth();
                var b = this.convertFromUIToMarkerRect(this.resizingRect, 0, 0, this.node);
                a.save(),
                Ib.Util.rotateCanvas(a, b, this.node.getAngle()),
                a.beginPath(),
                Nd.rect(a, b.x, b.y, b.width, b.height, null, this.network.getResizeLineColor()),
                a.restore()
            }
            this.isStartRotate && this.showRotateScale(a)
        },
        clear: function() {
            this.network.setEditingElement(!1),
            this.network.setRotatingElement(!1),
            this.isStart = !1,
            this.isStartRotate = !1,
            this.node = null,
            this.shapeNode = null,
            this.shapeLink = null,
            this.linkUI = null,
            this.resizingRect = null,
            this.resizeDirection = null,
            this.pointIndex = -1,
            this._removeCursor(),
            this.oldCursor = null,
            this.network.repaintTopCanvas()
        },
        _removeCursor: function() {
            this.cursorID && (this.network.getView().style.cursor = this.oldCursor || "default", this.cursorID = null),
            this.resizeDirection = null,
            this.isCrossCursor = !1
        },
        _setCrossCursor: function() {
            this.isCrossCursor || (this._removeCursor(), this._setCursor("crosshair"), this.isCrossCursor = !0)
        },
        _setCursor: function(a) {
            this.cursorID = a,
            this.network.getView().style.cursor !== this.cursorID && (this.network.getView().style.cursor = this.cursorID)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) if (!Jb.isAltDown(a) || this.network.isEditingElement()) ! this.network.isEditingElement() || this.isStart || this.isStartRotate || (this.node && this.resizeDirection ? (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: this.lazyMode ? "lazyResizeStart": "liveResizeStart",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            })) : this.shapeNode && this.pointIndex >= 0 ? Jb.isAltDown(a) ? (this.shapeNode.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                kind: "removePoint",
                event: a,
                element: this.shapeNode
            })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.shapeNode,
                pointIndex: this.pointIndex
            })) : this.shapeLink && this.pointIndex >= 0 ? Jb.isAltDown(a) ? (this.shapeLink.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                kind: "removePoint",
                event: a,
                element: this.shapeLink
            })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.shapeLink,
                pointIndex: this.pointIndex
            })) : this.linkUI ? (this.isStart = !0, this.network.fireInteractionEvent({
                kind: "liveMovePointStart",
                event: a,
                element: this.linkUI._element
            })) : this.node && (this.isStartRotate = !0, this._handle_mousedown(a)));
            else {
                var b = this.network.getElementAt(a),
                c = this.network.getLogicalPoint2(a);
                if (b instanceof Ib.ShapeNode) {
                    var d = this.getPointIndex(this.network.getShapeNodeZoomPoints(b), c, !0);
                    d > 0 && (this._handle_mousedown(a), this.pointIndex = d, this.shapeNode = b, b.addPoint(c, d), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: b,
                        pointIndex: d
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: b,
                        pointIndex: d
                    }))
                }
                if (b instanceof Ib.ShapeLink) {
                    var e = new Ib.List(b.getPoints()),
                    f = this.network.getElementUI(b);
                    e.add(f.getFromPoint(), 0),
                    e.add(f.getToPoint());
                    var d = this.getPointIndex(e, c) - 1;
                    d > 0 && (this._handle_mousedown(a), this.pointIndex = d, this.shapeLink = b, b.addPoint(c, d), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: b,
                        pointIndex: d
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: b,
                        pointIndex: d
                    }))
                }
            }
        },
        handle_mouseup: function(a) {
            if (this.isStart) {
                var b = this.network.getLogicalPoint2(a);
                if (this.resizingRect) if (this.lazyMode) if (this.network.isResizeAnimate()) {
                    var c = this,
                    d = new Ib.animate.AnimateBounds(this.node, this.resizingRect,
                    function() {
                        c.network.fireInteractionEvent({
                            kind: "lazyResizeEnd",
                            event: a,
                            element: c.node,
                            resizeDirection: c.resizeDirection
                        }),
                        c.clear()
                    });
                    Ib.animate.AnimateManager.start(d)
                } else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "lazyResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "liveResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else this.shapeNode && this.pointIndex >= 0 && b ? (this._resetShapeNodePoints(b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.shapeNode,
                    pointIndex: this.pointIndex
                })) : this.shapeLink && this.pointIndex >= 0 && b ? (this._resetShapeLinkPoints(b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.shapeLink,
                    pointIndex: this.pointIndex
                })) : this.linkUI && b && ("from" === this.linkPointsType ? this._setFromPoint(b) : "to" === this.linkPointsType ? this._setToPoint(b) : "control" === this.linkPointsType && xc.isOrthogonalLink(this.linkUI._element) && this.linkUI.getControlPoint() && (this._setLinkControlPoint(b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.linkUI._element
                })))
            }
            this._handle_mouseup(a),
            this.lazyMode || this.clear()
        },
        handle_mousemove: function(a) {
            if (this.network.isValidEvent(a)) {
                if (this.isStartRotate && this.node) return this._handleRotateElement(a, this.node),
                void(this.network.isShowRotateScale() && this.repaint());
                if (this.isStart) {
                    if (this.shapeNode && this.pointIndex >= 0) return void this._handleMovingShapeNodePoint(a);
                    if (this.shapeLink && this.pointIndex >= 0) return void this._handleMovingShapeLinkPoint(a);
                    if (this.node && this.resizeDirection) return void this._handleResizing(a);
                    if (this.linkUI && this.linkPointsType) {
                        if ("from" === this.linkPointsType) return void this._handleMovingFromPoint(a);
                        if ("to" === this.linkPointsType) return void this._handleMovingToPoint(a);
                        if ("control" === this.linkPointsType && xc.isOrthogonalLink(this.linkUI._element) && this.linkUI.getControlPoint()) return void this._handleMovingLinkControlPoint(a)
                    }
                }
                if (this.network.isSelectingElement() || this.network.isMovingElement() || 0 === this.network.getSelectionModel().size()) return void this.clear();
                var b = this.network.getElementAt(a),
                c = this.network.getElementUI(b);
                if (!c || !c.getEditAttachment()) return void this.clear();
                var d = this.network.getLogicalPoint2(a);
                if (b instanceof Ib.Node) {
                    if (this.node = b, this._isEditingShapeNode(d) || this._isResizingNode(d)) return void this.network.setEditingElement(!0);
                    if (this._isRotatingElement(d)) return this.network.setRotatingElement(!0),
                    void this.network.setEditingElement(!0)
                } else if (b instanceof Ib.ShapeLink) {
                    if (this.shapeLink = b, this._isEditingShapeLink(d)) return void this.network.setEditingElement(!0)
                } else if (c instanceof Ib.vector.LinkUI) {
                    this.linkUI = c;
                    var e, f = this.linkUI._element.getFromAgent();
                    e = f ? this.linkUI._element.getFromAgent() : this.linkUI._element.getFromNode();
                    var g, h = this.linkUI._element.getStyle("link.from.xoffset"),
                    i = this.linkUI._element.getStyle("link.from.yoffset"),
                    j = e.getCenterLocation(),
                    k = {
                        x: j.x + h,
                        y: j.y + i
                    },
                    l = this.linkUI._element.getToAgent();
                    g = l ? this.linkUI._element.getToAgent() : this.linkUI._element.getToNode();
                    var m = this.linkUI._element.getStyle("link.to.xoffset"),
                    n = this.linkUI._element.getStyle("link.to.yoffset"),
                    o = g.getCenterLocation(),
                    p = {
                        x: o.x + m,
                        y: o.y + n
                    };
                    if (k && this._contains(d, k, this.editPointSize)) return this.linkPointsType = "from",
                    this._setCrossCursor(),
                    void this.network.setEditingElement(!0);
                    if (p && this._contains(d, p, this.editPointSize)) return this.linkPointsType = "to",
                    this._setCrossCursor(),
                    void this.network.setEditingElement(!0);
                    if (xc.isOrthogonalLink(c._element)) {
                        this.linkUI = c;
                        var q = this.linkUI.getControlPoint();
                        if (q && this._contains(d, q, this.editPointSize)) return this.linkPointsType = "control",
                        this._setCrossCursor(),
                        void this.network.setEditingElement(!0)
                    }
                    return void(this.linkPointsType = null)
                }
                this.clear()
            }
        },
        _isRotatingElement: function(a) {
            var b = this.network.getRotatePointSize();
            if (0 >= b) return ! 1;
            var c = this.network.zoomManager,
            d = this.network.getElementUI(this.node),
            e = c.getSizeZoom(d),
            f = c._getElementZoomRect(d, this.node.getOriginalRect()),
            g = this.node.getAngle();
            return this._isRotating(a, "crosshair", f, g, e)
        },
        _isRotating: function(a, b, c, d, e) {
            var f = this.network.getRotatePointSize(),
            g = {
                x: c.x + c.width / 2,
                y: c.y - this.network.getRotatePointOffset() - f
            },
            h = this._rotatePoint(g, d, c),
            i = {
                x: h.x - f,
                y: h.y - f,
                width: 2 * f,
                height: 2 * f
            };
            return Tb.containsPoint(i, a) ? (this._removeCursor(), this._setCursor(b), !0) : !1
        },
        _handleRotateElement: function(a, b) {
            this._handle_mousemove(a);
            var c = this._calculateAngle(this.network.getLogicalPoint2(a), b);
            b.setAngle(c)
        },
        _calculateAngle: function(a, b) {
            var c = this.network.getZoomBodyRect(b),
            d = Tb.getCenterPoint(c);
            return Math.round(180 * Math.atan2(d.x - a.x, a.y - d.y) / Math.PI + 180)
        },
        _resetShapeNodePoints: function(a) {
            var b = this.network.getShapeNodeZoomPoints(this.shapeNode);
            b.set(this.pointIndex, a);
            var c = this.network.getElementUI(this.shapeNode),
            d = this.network.zoomManager._getShapeNodeZoomPoints(c, b, !0);
            this.shapeNode.setPoints(d)
        },
        _handleMovingShapeNodePoint: function(a) {
            var b = this.network.getLogicalPoint2(a);
            this._resetShapeNodePoints(b),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.shapeNode,
                pointIndex: this.pointIndex
            })
        },
        _resetShapeLinkPoints: function(a) {
            var b = this.network.zoomManager._getShapeLinkZoomPoints(this.shapeLink._points);
            b.set(this.pointIndex, a);
            var c = this.network.zoomManager._getShapeLinkZoomPoints(b, !0);
            this.shapeLink.setPoints(c)
        },
        _handleMovingShapeLinkPoint: function(a) {
            var b = this.network.getLogicalPoint2(a);
            this._resetShapeLinkPoints(b),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.shapeLink,
                pointIndex: this.pointIndex
            })
        },
        _setLinkControlPoint: function(a) {
            var b = this.linkUI.getControlPoint(),
            c = this.linkUI.getControlPoint(),
            d = (this.network.zoomManager, {
                x: a.x - c.x,
                y: a.y - c.y
            });
            b.x += d.x,
            b.y += d.y,
            this.linkUI.setControlPoint(b)
        },
        _handleMovingLinkControlPoint: function(a) {
            var b = this.network.getLogicalPoint2(a);
            this._setLinkControlPoint(b),
            this.network.fireInteractionEvent({
                kind: "liveMovePointBetween",
                e: a,
                element: this.linkUI._element
            })
        },
        _setFromPoint: function(a) {
            var b, c = this.linkUI._element.getFromAgent();
            b = c ? this.linkUI._element.getFromAgent().getCenterLocation() : this.linkUI._element.getFromNode().getCenterLocation();
            var d = {
                x: a.x - b.x,
                y: a.y - b.y
            };
            this.linkUI._element.setStyle("link.from.xoffset", d.x),
            this.linkUI._element.setStyle("link.from.yoffset", d.y)
        },
        _handleMovingFromPoint: function(a) {
            var b = this.network.getLogicalPoint2(a);
            this._setFromPoint(b)
        },
        _setToPoint: function(a) {
            var b, c = this.linkUI._element.getToAgent();
            b = c ? this.linkUI._element.getToAgent().getCenterLocation() : this.linkUI._element.getToNode().getCenterLocation();
            var d = {
                x: a.x - b.x,
                y: a.y - b.y
            };
            this.linkUI._element.setStyle("link.to.xoffset", d.x),
            this.linkUI._element.setStyle("link.to.yoffset", d.y)
        },
        _handleMovingToPoint: function(a) {
            var b = this.network.getLogicalPoint2(a);
            this._setToPoint(b)
        },
        convertFromUIToMarkerRect: function(a, b, c, d) {
            var e = this.network.zoomManager,
            f = e.getLocationZoom(),
            g = e.getGraphicsZoom(),
            h = this.network.getElementUI(d),
            i = e.getSizeZoom(h),
            j = a.x + a.width / 2,
            k = a.y + a.height / 2,
            l = j - a.x,
            m = k - a.y;
            return {
                x: j * f * g - this.network.getViewRect().x + b * f * g - l * i * g,
                y: k * f * g - this.network.getViewRect().y + c * f * g - m * i * g,
                width: a.width * i * g,
                height: a.height * i * g
            }
        },
        _getReverseZoomPoint: function(a, b, c) {
            var d = this.network.zoomManager,
            e = d.getLocationZoom(),
            f = d.getSizeZoom(this.network.getElementUI(a));
            return b.x *= e,
            b.y *= e,
            {
                x: b.x / e + (c.x - b.x) / f,
                y: b.y / e + (c.y - b.y) / f
            }
        },
        _getReverseZoomRect: function(a, b) {
            var c = this.network.zoomManager,
            d = c.getLocationZoom(),
            e = c.getSizeZoom(f);
            if (d == e) return a;
            var f = this.network.getElementUI(b),
            g = f.getBodyRect(),
            h = g.x + g.width / 2,
            i = g.y + g.height / 2,
            j = {
                x: h * d + (a.x - h) * e,
                y: i * d + (a.y - i) * e,
                width: a.width * e,
                height: a.height * e
            };
            return h = j.x + j.width / 2,
            i = j.y + j.height / 2,
            {
                x: h / d + (j.x - h) * e,
                y: i / d + (j.y - i) * e,
                width: a.width,
                height: a.height
            }
        },
        _handleResizing: function(a) {
            this._handle_mousemove(a);
            var b = this.node.getAngle(),
            c = this.node.getLocation(),
            d = this.node.getWidth() / 2,
            e = this.node.getHeight() / 2,
            f = {
                x: c.x + d,
                y: c.y + e
            },
            g = {
                x: -d,
                y: -e
            },
            h = {
                x: -d,
                y: e
            },
            i = {
                x: d,
                y: e
            },
            j = {
                x: d,
                y: -e
            },
            k = {
                x: 0,
                y: -e
            },
            l = {
                x: d,
                y: 0
            },
            m = {
                x: 0,
                y: e
            },
            n = {
                x: -d,
                y: 0
            },
            o = this._getReverseZoomPoint(this.node, Jb.clone(f), this._endLogical);
            if ("northwest" === this.resizeDirection && (this._transformPoint(i, f, b), g.x = o.x, g.y = o.y, f.x = (g.x + i.x) / 2, f.y = (g.y + i.y) / 2, this._reversPoint(g, f, b), this._reversPoint(i, f, b), this.resizingRect = {
                x: g.x,
                y: g.y,
                width: i.x - g.x,
                height: i.y - g.y
            }), "north" === this.resizeDirection) {
                var p = {
                    x: o.x,
                    y: o.y
                };
                this._reversPoint(p, f, b),
                k.y = p.y - f.y,
                this._transformPoint(k, f, b),
                this._transformPoint(m, f, b),
                f.x = (k.x + m.x) / 2,
                f.y = (k.y + m.y) / 2,
                this._reversPoint(k, f, b),
                this._reversPoint(m, f, b),
                this.resizingRect = {
                    x: f.x - this.node.getWidth() / 2,
                    y: f.y - (m.y - k.y) / 2,
                    width: this.node.getWidth(),
                    height: m.y - k.y
                }
            }
            if ("northeast" === this.resizeDirection && (this._transformPoint(h, f, b), j.x = o.x, j.y = o.y, f.x = (h.x + j.x) / 2, f.y = (h.y + j.y) / 2, this._reversPoint(h, f, b), this._reversPoint(j, f, b), this.resizingRect = {
                x: h.x,
                y: j.y,
                width: j.x - h.x,
                height: h.y - j.y
            }), "west" === this.resizeDirection) {
                var p = {
                    x: o.x,
                    y: o.y
                };
                this._reversPoint(p, f, b),
                n.x = p.x - f.x,
                this._transformPoint(l, f, b),
                this._transformPoint(n, f, b),
                f.x = (l.x + n.x) / 2,
                f.y = (l.y + n.y) / 2,
                this._reversPoint(l, f, b),
                this._reversPoint(n, f, b),
                this.resizingRect = {
                    x: f.x - (l.x - n.x) / 2,
                    y: f.y - this.node.getHeight() / 2,
                    width: l.x - n.x,
                    height: this.node.getHeight()
                }
            }
            if ("east" === this.resizeDirection) {
                var p = {
                    x: o.x,
                    y: o.y
                };
                this._reversPoint(p, f, b),
                l.x = p.x - f.x,
                this._transformPoint(l, f, b),
                this._transformPoint(n, f, b),
                f.x = (l.x + n.x) / 2,
                f.y = (l.y + n.y) / 2,
                this._reversPoint(l, f, b),
                this._reversPoint(n, f, b),
                this.resizingRect = {
                    x: f.x - (l.x - n.x) / 2,
                    y: f.y - this.node.getHeight() / 2,
                    width: l.x - n.x,
                    height: this.node.getHeight()
                }
            }
            if ("southwest" === this.resizeDirection && (this._transformPoint(j, f, b), h.x = o.x, h.y = o.y, f.x = (h.x + j.x) / 2, f.y = (h.y + j.y) / 2, this._reversPoint(h, f, b), this._reversPoint(j, f, b), this.resizingRect = {
                x: h.x,
                y: j.y,
                width: j.x - h.x,
                height: h.y - j.y
            }), "south" === this.resizeDirection) {
                var p = {
                    x: o.x,
                    y: o.y
                };
                this._reversPoint(p, f, b),
                m.y = p.y - f.y,
                this._transformPoint(k, f, b),
                this._transformPoint(m, f, b),
                f.x = (k.x + m.x) / 2,
                f.y = (k.y + m.y) / 2,
                this._reversPoint(k, f, b),
                this._reversPoint(m, f, b),
                this.resizingRect = {
                    x: f.x - this.node.getWidth() / 2,
                    y: f.y - (m.y - k.y) / 2,
                    width: this.node.getWidth(),
                    height: m.y - k.y
                }
            }
            "southeast" === this.resizeDirection && (this._transformPoint(g, f, b), i.x = o.x, i.y = o.y, f.x = (g.x + i.x) / 2, f.y = (g.y + i.y) / 2, this._reversPoint(g, f, b), this._reversPoint(i, f, b), this.resizingRect = {
                x: g.x,
                y: g.y,
                width: i.x - g.x,
                height: i.y - g.y
            }),
            this.resizingRect = this._getReverseZoomRect(this.resizingRect, this.node),
            this.lazyMode ? (this.repaint(), this.network.fireInteractionEvent({
                kind: "lazyResizeBetween",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            })) : (this.node.setLocation(this.resizingRect.x, this.resizingRect.y), this.node.setSize(this.resizingRect.width, this.resizingRect.height), this.network.fireInteractionEvent({
                kind: "liveResizeBetween",
                event: a,
                element: this.node,
                resizeDirection: this.resizeDirection
            }))
        },
        _isEditingShapeNode: function(a) {
            if (this.node instanceof Ib.ShapeNode) {
                this.shapeNode = this.node;
                for (var b = this.network.getShapeNodeZoomPoints(this.node), c = 0, d = b.size(); d > c; c++) {
                    var e = b.get(c);
                    if (this._contains(a, e, this.editPointSize)) return this._setCrossCursor(),
                    this.pointIndex = c,
                    !0
                }
            }
            return this.pointIndex = -1,
            !1
        },
        _isEditingShapeLink: function(a) {
            for (var b = this.network.zoomManager._getShapeLinkZoomPoints(this.shapeLink.getPoints()), c = 0, d = b.size(); d > c; c++) {
                var e = b.get(c);
                if (this._contains(a, e, this.editPointSize)) return this._setCrossCursor(),
                this.pointIndex = c,
                !0
            }
            return this.pointIndex = -1,
            !1
        },
        _isResizingNode: function(a) {
            var b = this.network.getResizePointSize();
            if (0 >= b) return ! 1;
            var c = this.network.zoomManager,
            d = this.network.getElementUI(this.node),
            e = c._getElementZoomRect(d, this.node.getOriginalRect()),
            f = this.node.getAngle(),
            g = {
                x: e.x,
                y: e.y
            },
            h = this._rotatePoint(g, f, e);
            return this._isResizing(a, h.x, h.y, "northwest", "nwse-resize") ? !0 : (g = {
                x: e.x + e.width / 2,
                y: e.y
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "north", "ns-resize") ? !0 : (g = {
                x: e.x + e.width,
                y: e.y
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "northeast", "nesw-resize") ? !0 : (g = {
                x: e.x,
                y: e.y + e.height / 2
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "west", "ew-resize") ? !0 : (g = {
                x: e.x + e.width,
                y: e.y + e.height / 2
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "east", "ew-resize") ? !0 : (g = {
                x: e.x,
                y: e.y + e.height
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "southwest", "nesw-resize") ? !0 : (g = {
                x: e.x + e.width / 2,
                y: e.y + e.height
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "south", "ns-resize") ? !0 : (g = {
                x: e.x + e.width,
                y: e.y + e.height
            },
            h = this._rotatePoint(g, f, e), this._isResizing(a, h.x, h.y, "southeast", "nwse-resize") ? !0 : !1)))))))
        },
        _rotatePoint: function(a, b, c) {
            var d = Tb.createMatrix(b * Math.PI / 180, c.x + c.width / 2, c.y + c.height / 2),
            e = d.transform(a);
            return e
        },
        _isResizing: function(a, b, c, d, e) {
            return this._contains(a, {
                x: b,
                y: c
            },
            this.resizePointSize) ? (this.resizeDirection !== d && (this._removeCursor(), e = this._changeCursorWithAngle(d, this.node.getAngle()), this._setCursor(e), this.resizeDirection = d), !0) : !1
        },
        _getRect: function(a, b, c, d) {
            var e = c > a ? a: c,
            f = d > b ? b: d,
            g = Math.abs(a - c),
            h = Math.abs(b - d);
            return {
                x: e,
                y: f,
                width: g,
                height: h
            }
        },
        _contains: function(a, b, c) {
            var d = {
                x: b.x - c,
                y: b.y - c,
                width: 2 * c,
                height: 2 * c
            };
            return Tb.containsPoint(d, a)
        },
        getPointIndex: function(a, b, c) {
            if (a.size() < 2) return 0;
            for (var d, e = a.get(0), f = 1; f < a.size(); f++) {
                if (d = a.get(f), this.isPointOnLine(b, e, d, 6)) return f;
                e = d
            }
            return e = a.get(0),
            c && this.isPointOnLine(b, e, d, 6) ? a.size() : 0
        },
        showRotateScale: function(a) {
            var b, c, d, e, f, g = (new Ib.List, this.network.getRotateScaleWidth()),
            h = this.network.getRotateScaleHeight(),
            i = this.network.getRotatePointSize(),
            j = this.node.getAngle(),
            k = this.network.zoomManager,
            l = this.network.getElementUI(this.node),
            m = k._getElementZoomRect(l, this.node.getOriginalRect()),
            n = {
                x: m.x + m.width / 2,
                y: m.y - this.network.getRotatePointOffset() - i
            },
            o = this._rotatePoint(n, j, m),
            p = "13px Arial",
            q = j + "°",
            r = this.network.getViewRect();
            1 === k.getLocationZoom() && (a.translate( - r.x, -r.y), a.scale(this.network.getZoom(), this.network.getZoom())),
            this.node.getAngle() >= 0 && this.node.getAngle() <= 180 ? (c = {
                x: o.x + i,
                y: o.y
            },
            d = {
                x: c.x + g,
                y: c.y
            },
            e = {
                x: d.x,
                y: d.y - h
            },
            f = {
                x: c.x,
                y: e.y
            }) : this.node.getAngle() > 180 && this.node.getAngle() <= 360 && (c = {
                x: o.x - i,
                y: o.y
            },
            d = {
                x: c.x - g,
                y: c.y
            },
            e = {
                x: d.x,
                y: d.y - h
            },
            f = {
                x: c.x,
                y: e.y
            });
            var s = new Ib.List([c, d, e, f]),
            b = Jb.math.getRect(s);
            1 !== k.getLocationZoom() && (b.x -= r.x, b.y -= r.y),
            a.fillStyle = this.network.getRotateScaleFillColor(),
            a.fillRect(b.x, b.y, b.width, b.height),
            a.fillStyle = this.network.getRotateScaleFontColor(),
            a.textBaseline = "middle",
            a.textAlign = "center",
            a.font = p,
            a.fillText(q, b.x + b.width / 2, b.y + b.height / 2),
            1 === k.getLocationZoom() && (a.scale(1 / this.network.getZoom(), 1 / this.network.getZoom()), a.translate(r.x, r.y))
        },
        isPointOnLine: function(a, b, c, d) {
            0 > d && (d = 0);
            var e = this.getDistanceFromPointToLine(a, b, c);
            return d >= e && a.x >= Math.min(b.x, c.x) - d && a.x <= Math.max(b.x, c.x) + d && a.y >= Math.min(b.y, c.y) - d && a.y <= Math.max(b.y, c.y) + d
        },
        getDistanceFromPointToLine: function(a, b, c) {
            if (b.x === c.x) return Math.abs(a.x - b.x);
            var d = (c.y - b.y) / (c.x - b.x),
            e = (c.x * b.y - b.x * c.y) / (c.x - b.x);
            return Math.abs(d * a.x - a.y + e) / Math.sqrt(d * d + 1)
        },
        _transformPoint: function(a, b, c) {
            var d = Math.cos(c * Math.PI / 180),
            e = Math.sin(c * Math.PI / 180),
            f = a.x,
            g = a.y,
            h = f * d - g * e,
            i = f * e + g * d;
            a.x = h + b.x,
            a.y = i + b.y
        },
        _reversPoint: function(a, b, c) {
            c *= -1;
            var d = Math.cos(c * Math.PI / 180),
            e = Math.sin(c * Math.PI / 180),
            f = a.x - b.x,
            g = a.y - b.y,
            h = f * d - g * e,
            i = f * e + g * d;
            a.x = h + b.x,
            a.y = i + b.y
        },
        _changeCursorWithAngle: function(a, b) {
            var c, d = ["auto", "nwse-resize", "ns-resize", "nesw-resize", "ew-resize", "nwse-resize", "ns-resize", "nesw-resize", "ew-resize"];
            switch (a) {
            case "northwest":
                c = 1;
                break;
            case "north":
                c = 2;
                break;
            case "northeast":
                c = 3;
                break;
            case "east":
                c = 4;
                break;
            case "southeast":
                c = 5;
                break;
            case "south":
                c = 6;
                break;
            case "southwest":
                c = 7;
                break;
            case "west":
                c = 8;
                break;
            default:
                c = 0
            }
            return (b >= 360 || -360 >= b) && (b %= 360),
            b > 22.5 && 67.5 >= b && (c += 1),
            -22.5 > b && b >= -67.5 && (c -= 1),
            b > 67.5 && 112.5 >= b && (c += 2),
            -67.5 > b && b >= -112.5 && (c -= 2),
            b > 112.5 && 157.5 >= b && (c += 3),
            -112.5 > b && b >= -157.5 && (c -= 3),
            b > 157.5 && 202.5 >= b && (c += 4),
            -157.5 > b && b >= -202.5 && (c -= 4),
            b > 202.5 && 247.5 >= b && (c += 5),
            -202.5 > b && b >= -247.5 && (c -= 5),
            b > 247.5 && 292.5 >= b && (c += 6),
            -247.5 > b && b >= -292.5 && (c -= 6),
            b > 292.5 && 337.5 >= b && (c += 7),
            -292.5 > b && b >= -337.5 && (c -= 7),
            c > 8 && (c -= 8),
            0 >= c && (c += 8),
            d[c]
        }
    }),
    Ib.vector.interaction.CreateLinkInteraction = function(a, b) {
        b || (b = Ib.Link),
        this.linkFunction = Ib.Util.isTypeOf(b, Ib.Link) ?
        function(a, c) {
            var d = new b;
            return d instanceof Ib.Link && (d.setFromNode(a), d.setToNode(c)),
            d
        }: b,
        Ib.vector.interaction.CreateLinkInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.vector.interaction.CreateLinkInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.clear(),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            a.beginPath();
            var b, c;
            a.lineWidth = this.network.getEditLineWidth();
            var d = this.network.getEditLineColor();
            this.currentNode && this.currentNode !== this.fromNode && (b = this.network.getElementUI(this.currentNode).getZoomViewRect(!0), c = this.convertFromUIToMarkerRect(b, 0, 0), Nd.rect(a, c.x, c.y, c.width, c.height, null, d)),
            this.fromNode && (b = this.network.getElementUI(this.fromNode).getZoomViewRect(!0), c = this.convertFromUIToMarkerRect(b, 0, 0), Nd.rect(a, c.x, c.y, c.width, c.height, null, d)),
            this.currentPoint && this.paintLine(a),
            a.closePath()
        },
        convertFromUIToMarkerRect: function(a, b, c) {
            var d = this.network.zoomManager,
            e = d.getGraphicsZoom();
            return {
                x: a.x * e - this.network.getViewRect().x + b * e,
                y: a.y * e - this.network.getViewRect().y + c * e,
                width: a.width * e,
                height: a.height * e
            }
        },
        getZoomNodeRectOrPoint: function(a, b) {
            var c = this.network.getElementUI(a).getZoomBodyRect();
            return b ? {
                x: c.x + c.width / 2,
                y: c.y + c.height / 2
            }: c
        },
        paintLine: function(a) {
            var b = this.network.getEditLineColor(),
            c = this.network.getElementUI(this.fromNode).getZoomBodyRect(),
            d = this.convertPointFromView({
                x: c.x + c.width / 2,
                y: c.y + c.height / 2
            }),
            e = d.x,
            f = d.y,
            g = this.currentPoint.x,
            h = this.currentPoint.y;
            a.strokeStyle = b,
            a.beginPath(),
            a.moveTo(e, f),
            a.lineTo(g, h),
            a.stroke()
        },
        clear: function() {
            this.currentPoint = null,
            this.currentNode = null,
            this.fromNode = null,
            this.toNode = null
        },
        createLink: function() {
            return this.linkFunction(this.fromNode, this.toNode)
        },
        handle_mousedown: function(a) {
            if (this.network.isValidEvent(a)) if (this.fromNode) {
                if (this.toNode = this.currentNode, this.toNode) {
                    var b = this.createLink();
                    b && this.network.addElementByInteraction(b)
                }
                this.clear()
            } else this.fromNode = this.currentNode,
            this.currentNode = null,
            this.currentPoint = null,
            this.repaint()
        },
        handle_mousemove: function(a) {
            var b = this.getMarkerPoint(a);
            if (b) {
                if (this.network.isMovingElement() || this.network.isEditingElement()) return void this.clear();
                var c = null;
                this.fromNode ? (this.currentNode = this.getToNode(a, this.fromNode), this.currentPoint = b, this.repaint()) : (c = this.getFromNode(a), this.currentNode !== c && (this.currentNode = c, this.repaint()))
            }
        },
        getFromNode: function(a) {
            return this.getNode(a)
        },
        getToNode: function(a, b) {
            return this.getNode(a, b)
        },
        getNode: function(a, b) {
            var c = this.network.getElementAt(a);
            return c instanceof Kd && this.network.isLinkable(c, b) ? c: null
        }
    }),
    Ib.vector.interaction.CreateShapeLinkInteraction = function(a, b) {
        Ib.vector.interaction.CreateShapeLinkInteraction.superClass.constructor.call(this, a),
        b || (b = Ib.ShapeLink),
        this.linkFunction = Ib.Util.isTypeOf(b, Ib.ShapeLink) ?
        function(a, c, d) {
            var e = new b;
            if (e instanceof Ib.ShapeLink && (e.setFromNode(a), e.setToNode(c), d)) {
                var f = this.network.zoomManager;
                e.setPoints(f._getShapeLinkZoomPoints(d, !0))
            }
            return e
        }: b
    },
    Jb.ext("twaver.vector.interaction.CreateShapeLinkInteraction", Ib.vector.interaction.CreateLinkInteraction, {
        clear: function() {
            this.points = null,
            Ib.vector.interaction.CreateShapeLinkInteraction.superClass.clear.call(this)
        },
        createLink: function() {
            return this.linkFunction(this.fromNode, this.toNode, this.points)
        },
        handle_mousedown: function(a) {
            if (0 === a.button) {
                var b = this.network.getLogicalPoint2(a);
                if (b) {
                    if (this.fromNode) if (this.toNode = this.currentNode, this.toNode) {
                        var c = this.createLink();
                        c && this.network.addElementByInteraction(c),
                        this.clear()
                    } else {
                        if (this.points || (this.points = new Ib.List), this.points.size() > 0) {
                            var d = this.points.get(this.points.size() - 1);
                            if (d.x === b.x && d.y === b.y) return
                        }
                        this.points.add(b)
                    } else this.fromNode = this.currentNode,
                    this.points = null,
                    this.currentNode = null,
                    this.currentPoint = null;
                    this.repaint()
                }
            }
        },
        paintLine: function(a) {
            if (this.currentPoint) {
                var b, c = new Ib.List;
                if (b = this.convertPointFromView(this.getZoomNodeRectOrPoint(this.fromNode, !0)), c.add(b, 0), this.points && this.points.size() > 0) for (var d = this.points.size(), e = 0; d > e; e++) b = this.convertPointFromView(this.points.get(e)),
                c.add(b);
                b = this.currentPoint,
                c.add(b),
                a.lineWidth = this.network.getEditLineWidth(),
                a.strokeStyle = this.network.getEditLineColor(),
                a.beginPath(),
                Xb.drawLinePoints(a, c),
                a.stroke()
            }
        }
    }),
    Ib.vector.interaction.CreateShapeNodeInteraction = function(a, b) {
        b || (b = Ib.ShapeNode),
        this.shapeNodeFunction = Ib.Util.isTypeOf(b, Ib.ShapeNode) ?
        function(a) {
            var c = new b;
            if (c instanceof Ib.ShapeNode) {
                var d = this.network.zoomManager,
                e = this.network.createElementUI(c);
                if (a) {
                    var f = d._getShapeNodeZoomPoints(e, a, !0);
                    e.invalidateZoom(),
                    c.setPoints(f)
                }
            }
            return c
        }: b,
        Ib.vector.interaction.CreateShapeNodeInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.vector.interaction.CreateShapeNodeInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousedown", "mousemove"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove"),
            this.clear(),
            this.network.removeMarker(this),
            this.network.setEditingElement(!1)
        },
        clear: function() {
            this.points = null,
            this.currentPoint = null
        },
        paint: function(a) {
            if (this.points && this.points.size() > 0 && this.currentPoint) {
                for (var b, c = new Ib.List,
                d = this.points.size(), e = 0; d > e; e++) b = this.convertPointFromView(this.points.get(e)),
                c.add(b);
                b = this.convertPointFromView(this.currentPoint),
                c.add(b),
                a.lineWidth = this.network.getEditLineWidth(),
                a.strokeStyle = this.network.getEditLineColor(),
                a.beginPath(),
                Xb.drawLinePoints(a, c),
                a.stroke()
            }
        },
        handle_mousedown: function(a) {
            if (0 === a.button) {
                var b = this.network.getLogicalPoint2(a);
                if (b) {
                    if (2 === a.detail) {
                        if (this.points) {
                            var c = this.shapeNodeFunction(this.points);
                            this.network.addElementByInteraction(c),
                            this.clear();
                            var d = this;
                            setTimeout(function() {
                                d.network.setEditingElement(!1)
                            },
                            0)
                        }
                    } else {
                        if (this.network.isEditingElement() || this.network.setEditingElement(!0), this.points || (this.points = new Ib.List), this.points.size() > 0) {
                            var e = this.points.get(this.points.size() - 1);
                            if (e.x === b.x && e.y === b.y) return
                        }
                        this.points.add(b)
                    }
                    this.repaint()
                }
            }
        },
        handle_mousemove: function(a) {
            this.points && (this.currentPoint = this.network.getLogicalPoint2(a), this.repaint())
        }
    }),
    Ib.vector.interaction.MagnifyInteraction = function(a, b, c, d, e) {
        Ib.vector.interaction.MagnifyInteraction.superClass.constructor.call(this, a),
        this.scale = b || 2,
        this.xRadius = c || 100,
        this.yRadius = d || 100,
        this.shape = e || "circle",
        this.borderColor = "black",
        this.borderWidth = 1,
        this.backgroundColor = "white",
        this.markCanvas = Wb.createCanvas()
    },
    Jb.ext("twaver.vector.interaction.MagnifyInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            this.addListener("mousemove"),
            this.addListener("mousewheel"),
            this.network.addMarker(this)
        },
        tearDown: function() {
            this.removeListener("mousemove"),
            this.removeListener("mousewheel"),
            this.network.removeMarker(this)
        },
        paint: function(a) {
            if (this.point) {
                var b = this.network.zoomManager,
                c = b.getLocationZoom(),
                d = b.getGraphicsZoom(),
                e = (b.getSizeZoom(), this.network.getZoom(), this.xRadius / this.scale / d),
                f = this.yRadius / this.scale / d;
                if ("mousewheel" === this.mouseFlag) {
                    var g = {
                        x: this.zoomPoint.x - e,
                        y: this.zoomPoint.y - f,
                        width: 2 * e,
                        height: 2 * f
                    };
                    this.network.toCanvasByRegion(g, this.scale * d, this.markCanvas, "white");
                    var h = {
                        x: this.zoomPoint.x - this.xRadius - this.network.viewRect.x,
                        y: this.zoomPoint.y - this.yRadius - this.network.viewRect.y,
                        width: this.markCanvas.width,
                        height: this.markCanvas.height
                    }
                } else {
                    var g = {
                        x: this.point.x * c - e,
                        y: this.point.y * c - f,
                        width: 2 * e,
                        height: 2 * f
                    };
                    this.network.toCanvasByRegion(g, this.scale * d, this.markCanvas, "white");
                    var h = {
                        x: this.point.x * c * d - this.xRadius - this.network.viewRect.x,
                        y: this.point.y * c * d - this.yRadius - this.network.viewRect.y,
                        width: this.markCanvas.width,
                        height: this.markCanvas.height
                    }
                }
                a.save(),
                a.beginPath(),
                Xb.drawVector(a, this.shape, null, h.x, h.y, 2 * g.width * d, 2 * g.height * d),
                a.clip(),
                a.fillStyle = this.backgroundColor,
                a.beginPath(),
                a.rect(h.x, h.y, h.width, h.height),
                a.fill(),
                a.drawImage(this.markCanvas, h.x, h.y),
                a.restore(),
                a.beginPath(),
                a.lineWidth = this.borderWidth,
                Xb.drawVector(a, this.shape, null, h.x + this.borderWidth / 2, h.y + this.borderWidth / 2, 2 * g.width * d - this.borderWidth, 2 * g.height * d - this.borderWidth),
                a.strokeStyle = this.borderColor,
                a.stroke(),
                this.mouseFlag = null
            }
        },
        handle_mousemove: function(a) {
            this.point = this.network.getLogicalPoint(a),
            this.point && (this.mouseFlag = "mousemove", this.repaint())
        },
        handle_mousewheel: function(a) {
            var b = this.network.zoomManager,
            c = b.getLocationZoom();
            1 !== c && (this.zoomPoint = this.network.getLogicalPoint2(a)),
            this.zoomPoint && (this.mouseFlag = "mousewheel", this.repaint())
        },
        getScale: function() {
            return this.scale
        },
        setScale: function(a) {
            this.scale = a,
            this.network.repaintTopCanvas()
        },
        getShape: function() {
            return this.shape
        },
        setShape: function(a) {
            this.shape = a,
            this.network.repaintTopCanvas()
        },
        getXRadius: function() {
            return this.xRadius
        },
        setXRadius: function(a) {
            this.xRadius = a,
            this.network.repaintTopCanvas()
        },
        getYRadius: function() {
            return this.yRadius
        },
        setYRadius: function(a) {
            this.yRadius = a,
            this.network.repaintTopCanvas()
        },
        getBorderColor: function() {
            return this.borderColor
        },
        setBorderColor: function(a) {
            this.borderColor = a,
            this.network.repaintTopCanvas()
        },
        getBorderWidth: function() {
            return this.borderWidth
        },
        setBorderWidth: function(a) {
            this.borderWidth = a,
            this.network.repaintTopCanvas()
        },
        getBackgroundColor: function() {
            return this.backgroundColor
        },
        setBackgroundColor: function(a) {
            this.backgroundColor = a,
            this.network.repaintTopCanvas()
        }
    }),
    Ib.vector.interaction.TouchInteraction = function(a) {
        Ib.vector.interaction.TouchInteraction.superClass.constructor.call(this, a)
    },
    Jb.ext("twaver.vector.interaction.TouchInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            var a = this.network.getView();
            Wb.addEventListener("touchstart", "handleTouchstart", a, this),
            Wb.addEventListener("touchmove", "handleTouchmove", a, this),
            Wb.addEventListener("touchend", "handleTouchend", a, this),
            Wb.addEventListener("touchcancel", "handleTouchend", a, this)
        },
        tearDown: function() {
            var a = this.network.getView();
            Wb.removeEventListener("touchstart", a, this),
            Wb.removeEventListener("touchmove", a, this),
            Wb.removeEventListener("touchend", a, this),
            Wb.removeEventListener("touchcancel", a, this)
        },
        handleTouchstart: function(a) {
            if (Wb.preventDefault(a), 1 == a.touches.length) {
                var b = this.network.getLogicalPoint2(a),
                c = this._element = this.network.getElementAt(b);
                this._startTouchTime = new Date,
                this._currentTouchPoint = b,
                this._startTouchClient = this._currentTouchClient = this.getMarkerPoint(a),
                c ? this.network.getSelectionModel().contains(c) || this.network.getSelectionModel().setSelection(c) : this.network.getSelectionModel().clearSelection(),
                Cc.handleClicked(this.network, a, c),
                this._endTouchTime && this._startTouchTime.getTime() - this._endTouchTime.getTime() <= 500 && Tb.getDistance(this._endTouchClient, this._startTouchClient) <= 20 ? (delete this._endTouchTime, delete this._endTouchClient, Cc.handleDoubleClicked(this.network, a, c)) : (this._endTouchTime = this._startTouchTime, this._endTouchClient = this._startTouchClient)
            } else this._distance = zc.getDistance(a),
            this._zoom = this.network.getZoom()
        },
        handleTouchmove: function(a) {
            if (Wb.preventDefault(a), a.touches.length > 1) {
                var b = zc.getDistance(a);
                if (Math.abs(b - this._distance) < 20) return;
                var c = b / this._distance;
                this.network.setZoom(this._zoom * c, !1)
            } else if (null == this._zoom) {
                var d = this.getMarkerPoint(a);
                if (Tb.getDistance(this._startTouchClient, d) < 20) return;
                if (this._element) {
                    var e = this.network.getLogicalPoint2(a),
                    f = e.x - this._currentTouchPoint.x,
                    g = e.y - this._currentTouchPoint.y;
                    this._currentTouchPoint = e,
                    this.network.moveSelectedElements(f, g),
                    this.network.isMovingElement() ? this.network.fireInteractionEvent({
                        kind: "liveMoveBetween",
                        event: a
                    }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                        kind: "liveMoveStart",
                        event: a
                    }))
                } else {
                    var f = this._currentTouchClient.x - d.x,
                    g = this._currentTouchClient.y - d.y;
                    this.network.panByOffset(f, g),
                    this._currentTouchClient = d
                }
            }
        },
        handleTouchend: function(a) {
            Wb.preventDefault(a),
            this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            })),
            0 === a.touches.length && (this._distance = null, this._zoom = null, this._element = null, this._startTouchTime = null, this._currentTouchPoint = null, this._startTouchClient = this._currentTouchClient = null)
        }
    }),
    Ib.vector.interaction.MSTouchInteraction = function(a) {
        Ib.vector.interaction.MSTouchInteraction.superClass.constructor.call(this, a),
        this._pointerMap = {},
        this._pointerIdArray = []
    },
    Jb.ext("twaver.vector.interaction.MSTouchInteraction", Ib.vector.interaction.BaseInteraction, {
        setUp: function() {
            var a = this.network.getView();
            Wb.addEventListener("MSPointerDown", "handleTouchstart", a, this),
            Wb.addEventListener("MSPointerMove", "handleTouchmove", a, this),
            Wb.addEventListener("MSPointerUp", "handleTouchend", a, this),
            Wb.addEventListener("MSPointerCancel", "handleTouchend", a, this),
            this.network.addMarker(this)
        },
        tearDown: function() {
            var a = this.network.getView();
            Wb.removeEventListener("MSPointerDown", a, this),
            Wb.removeEventListener("MSPointerMove", a, this),
            Wb.removeEventListener("MSPointerUp", a, this),
            Wb.removeEventListener("MSPointerCancel", a, this),
            this.network.removeMarker(this)
        },
        handleTouchstart: function(a) {
            if (this.network.isFocusOnClick() && Ib.Util.setFocus(this.network._view), !this.network.isSelectingElement() || a.pointerType != a.MSPOINTER_TYPE_MOUSE) {
                var b = this.network.getLogicalPoint2(a),
                c = new Date;
                if (a.isPrimary && this._pointerIdArray.length > 0 && this.handle_mouseup(a), this._pointerMap[a.pointerId] || (this._pointerIdArray.push(a.pointerId), this._pointerMap[a.pointerId] = a), 1 == this._pointerIdArray.length) {
                    var d = this.network.getElementAt(b);
                    this._startTouchElement = d,
                    this._startClientPoint = {
                        x: a.clientX,
                        y: a.clientY
                    };
                    var e = this.network.getSelectionModel();
                    d ? Jb.isCtrlDown(a) ? e.contains(d) ? e.removeSelection(d) : e.appendSelection(d) : e.contains(d) || e.setSelection(d) : Jb.isCtrlDown(a) || e.clearSelection(),
                    Cc.handleClicked(this.network, a, d),
                    this._startTouchTime && this._startTouchPoint && c.getTime() - this._startTouchTime.getTime() <= 500 && Tb.getDistance(this._startTouchPoint, b) <= 20 ? (Cc.handleDoubleClicked(this.network, a, d), this._doubleClick = !0) : (Wb.handle_mousedown(this, a), this._startTouchPoint = b, this._startTouchTime = c)
                } else 2 == this._pointerIdArray.length && (this._distance = this._getDistance(), this._zoom = this.network.getZoom())
            }
        },
        handleTouchmove: function(a) {
            if (null != this._startTouchPoint && 0 != this._pointerIdArray.length && this._pointerMap[a.pointerId] && !(Tb.getDistance({
                x: this._pointerMap[a.pointerId].pageX,
                y: this._pointerMap[a.pointerId].pageY
            },
            {
                x: a.pageX,
                y: a.pageY
            }) <= 10) && (this._pointerMap[a.pointerId] = a, 2 == this._pointerIdArray.length)) {
                var b = this._getDistance() / this._distance;
                this.network.setZoom(this._zoom * b, !1)
            }
        },
        handleTouchend: function(a) {
            if (this.network.isMovingElement() && (this.network.setMovingElement(!1), this.network.fireInteractionEvent({
                kind: "liveMoveEnd",
                event: a
            })), this.network.isSelectingElement()) {
                var b = Tb.getRect([this._startTouchPoint, this._moveTouchPoint]),
                c = this.network.getElementsAtRect(b, this.getIntersectMode(), this.network.getRectSelectFilter());
                if (c && c.size() > 0) {
                    var d = this.network.getSelectionModel(),
                    e = d.toSelection();
                    c.forEach(function(a) {
                        d.contains(a) ? e.remove(a) : e.add(a)
                    },
                    this),
                    d.setSelection(e)
                }
                this.network.fireInteractionEvent({
                    kind: "selectEnd",
                    event: a
                }),
                this._moveTouchPoint = null,
                this.network.setSelectingElement(!1),
                this.repaint()
            }
            this._doubleClick && (delete this._doubleClick, delete this._startTouchPoint, delete this._startTouchTime);
            for (var f = -1,
            g = 0; g < this._pointerIdArray.length; g++) if (this._pointerIdArray[g] == a.pointerId) {
                f = g;
                break
            }
            f >= 0 && this._pointerIdArray.splice(f, 1),
            delete this._pointerMap[a.pointerId],
            this._moveTouchPoint = null
        },
        _getDistance: function() {
            return Tb.getDistance({
                x: this._pointerMap[this._pointerIdArray[0]].pageX,
                y: this._pointerMap[this._pointerIdArray[0]].pageY
            },
            {
                x: this._pointerMap[this._pointerIdArray[1]].pageX,
                y: this._pointerMap[this._pointerIdArray[1]].pageY
            })
        },
        getIntersectMode: function() {
            return "intersect" === this.network.getSelectMode() ? !0 : "contain" === this.network.getSelectMode() ? !1 : this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y;
        },
        handle_mousemove: function(a) {
            var b = {
                x: a.clientX,
                y: a.clientY
            };
            if (! (Tb.getDistance(this._startClientPoint, b) < 3) && this._startTouchPoint && 1 == this._pointerIdArray.length) if (this._moveTouchPoint = {
                x: this._startTouchPoint.x + (b.x - this._startClientPoint.x) / this.network.getZoom(),
                y: this._startTouchPoint.y + (b.y - this._startClientPoint.y) / this.network.getZoom()
            },
            null == this._startTouchElement && this.network.isRectSelectEnabled()) {
                var c = this.network.getLogicalPoint2(a);
                if (!c) return;
                this.network.setSelectingElement(!0),
                this.network.fireInteractionEvent(this._moveTouchPoint ? {
                    kind: "selectBetween",
                    event: a
                }: {
                    kind: "selectStart",
                    event: a
                }),
                this.repaint()
            } else {
                var d = this.network.getElementAt(this._moveTouchPoint);
                if (null != this._startTouchElement || this.network.isRectSelectEnabled()) {
                    if (this.network.isMovingElement() || null != this._startTouchElement && d == this._startTouchElement && this.network.getMovableSelectedElements().contains(d)) {
                        var e = this._moveTouchPoint.x - this._startTouchPoint.x,
                        f = this._moveTouchPoint.y - this._startTouchPoint.y;
                        this.network.moveSelectedElements(e, f),
                        this.network.isMovingElement() ? this.network.fireInteractionEvent({
                            kind: "liveMoveBetween",
                            event: a
                        }) : (this.network.setMovingElement(!0), this.network.fireInteractionEvent({
                            kind: "liveMoveStart",
                            event: a
                        }))
                    }
                } else {
                    var e = this._startClientPoint.x - b.x,
                    f = this._startClientPoint.y - b.y;
                    this.network.panByOffset(e, f)
                }
                this._startClientPoint = b
            }
        },
        handle_mouseup: function(a) {
            this.handleTouchend(a),
            this._pointerIdArray = [],
            this._pointerMap = {}
        },
        paint: function(a) {
            if (this._startTouchPoint && this._moveTouchPoint && !this._startTouchElement && this.network.isRectSelectEnabled()) {
                var b = this.convertPointFromView(this._startTouchPoint),
                c = this.convertPointFromView(this._moveTouchPoint),
                d = b.x,
                e = b.y,
                f = c.x,
                g = c.y,
                h = Tb.getRect([{
                    x: d,
                    y: e
                },
                {
                    x: f,
                    y: g
                }]);
                if (null != h) {
                    a.beginPath();
                    var i = this.network.getSelectOutlineWidth(),
                    j = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
                    a.strokeStyle = this.network.getSelectOutlineColor(),
                    a.lineWidth = i,
                    Nd.rect(a, h.x, h.y, h.width, h.height, j, this.network.getSelectOutlineColor()),
                    a.closePath()
                }
            }
        }
    }),
    Ib.XmlSerializer = function(a, b, c) {
        this.dataBox = a,
        this.settings = b ? b: new Ib.SerializationSettings,
        this.filterFunction = c,
        this.ref = 0,
        this.refMap = {},
        this.idMap = {},
        this.xmlString = ""
    },
    Jb.ext("twaver.XmlSerializer", Object, {
        serialize: function() {
            return this.xmlString = "<twaver version='" + Ib.Util.getVersion() + "' platform='html5'>\n",
            this.serializeBody(),
            this.xmlString += "</twaver>\n",
            this.xmlString
        },
        serializeBody: function() {
            this.ref = 0,
            this.dataBox.getRoots().forEach(this.initRefs, this),
            this.settings.isDataBoxSerializable && (this.xmlString += "<dataBox class='" + this.dataBox.getClassName() + "'>\n", this.dataBox.serializeXml(this, this.dataBox.newInstance()), this.xmlString += "</dataBox>\n"),
            this.dataBox.getRoots().forEach(this.serializeData, this)
        },
        initRefs: function(a) {
            this.refMap[a.getId()] = this.ref++,
            a.getChildren().forEach(this.initRefs, this)
        },
        isSerializable: function(a) {
            return this.dataBox.contains(a) ? this.filterFunction && !this.filterFunction(a) ? !1 : !0 : !1
        },
        serializeData: function(a) {
            if (this.isSerializable(a)) {
                var b = a.newInstance(),
                c = this.refMap[a.getId()];
                this.xmlString += "<data class='" + a.getClassName() + "' ref='" + c + "'",
                null != this.settings.getPropertyType("id") && (this.xmlString += " id='" + a.getId() + "'"),
                this.xmlString += ">\n",
                a.serializeXml(this, b),
                this.xmlString += "</data>\n"
            }
            a.getChildren().forEach(this.serializeData, this)
        },
        serializePropertyXml: function(a, b, c) {
            var d = this.settings.getPropertyType(b);
            if (d) {
                var e = Jb.getValue(a, b, d),
                f = Jb.getValue(c, b, d);
                e !== f && this.serializeValue("p", b, e, f, d)
            }
        },
        serializeStyleXml: function(a, b, c) {
            var d = this.settings.getStyleType(b);
            if (d) {
                var e = a.getStyle(b),
                f = c.getStyle(b);
                e != f && this.serializeValue("s", b, e, f, d)
            }
        },
        serializeClientXml: function(a, b, c) {
            var d = this.settings.getClientType(b);
            if (null != d) {
                var e = a.getClient(b),
                f = c.getClient(b);
                e != f && this.serializeValue("c", b, e, f, d)
            }
        },
        serializeValue: function(a, b, c, d, e) {
            if (null == c) this.xmlString += "	<" + a + " n='" + b + "' none=''/>\n";
            else if ("cdata" === e) this.xmlString += "	<" + a + " n='" + b + "'><![CDATA[" + c + "]]></" + a + ">\n";
            else if ("data" === e) {
                var f = this.refMap[c.getId()];
                null != f && (this.xmlString += "	<" + a + " n='" + b + "' ref='" + f + "'/>\n")
            } else "point" === e ? d && c.x === d.x && c.y === d.y || (this.xmlString += "	<" + a + " n='" + b + "' x='" + c.x + "' y='" + c.y + "'/>\n") : "list.point" === e ? (this.xmlString += "	<" + a + " n='" + b + "'>\n", c.forEach(function(a) {
                this.xmlString += "		<p x='" + a.x + "' y='" + a.y + "'/>\n"
            },
            this), this.xmlString += "	</" + a + ">\n") : "list.string" === e || "list.number" === e ? (this.xmlString += "	<" + a + " n='" + b + "'>\n", c.forEach(function(a) {
                this.xmlString += "		<s>" + a + "</s>\n"
            },
            this), this.xmlString += "	</" + a + ">\n") : this.xmlString += "rectangle" === e ? "	<" + a + " n='" + b + "' x='" + c.x + "' y='" + c.y + "' w='" + c.width + "' h='" + c.height + "'/>\n": "	<" + a + " n='" + b + "'>" + c + "</" + a + ">\n"
        },
        deserialize: function(a, b) {
            Jb.isDeserializing = !0,
            this.xmlString = a;
            var c = Jb.xml(a).documentElement;
            this.refMap = {},
            this.idMap = {};
            var d, e, f, g = new nd,
            h = new nd,
            i = c.getElementsByTagName("data"),
            j = i.length;
            for (f = 0; j > f; f++) {
                e = i[f];
                var k = e.getAttribute("class"),
                l = this.settings.getPropertyType("id");
                if (l && e.hasAttribute("id")) {
                    var m = null;
                    if ("string" === l) m = e.getAttribute("id");
                    else if ("int" === l) m = parseInt(e.getAttribute("id"));
                    else {
                        if ("number" !== l) throw "Unsupported id type '" + l + "'";
                        m = parseFloat(e.getAttribute("id"))
                    }
                    if ("remove" === e.getAttribute("action")) {
                        this.dataBox.removeById(m);
                        continue
                    }
                    d = this.dataBox.getDataById(m),
                    d || (d = Jb.newInstance(k, m))
                } else d = Jb.newInstance(k);
                if (e.hasAttribute("ref")) {
                    var n = e.getAttribute("ref");
                    this.refMap[n] = d
                }
                g.add(d),
                h.add(e),
                this.idMap[d.getId()] = d
            }
            for (this.dataBox.forEach(function(a) {
                this.idMap[a.getId()] = a
            },
            this), j = g.size(), f = 0; j > f; f++) d = g.get(f),
            e = h.get(f),
            d.deserializeXml(this, e);
            for (f = 0; j > f; f++) d = g.get(f),
            this.dataBox.containsById(d.getId()) || (b && !d.getParent() && d.setParent(b), this.dataBox.add(d));
            this.settings.isDataBoxSerializable && 1 === c.getElementsByTagName("dataBox").length && this.dataBox.deserializeXml(this, c.getElementsByTagName("dataBox")[0]),
            Jb.isDeserializing = !1
        },
        deserializePropertyXml: function(a, b, c) {
            var d = this.settings.getPropertyType(c);
            d && Jb.setValue(a, c, this.deserializeValue(b, d))
        },
        deserializeStyleXml: function(a, b, c) {
            var d = this.settings.getStyleType(c);
            d && a.setStyle(c, this.deserializeValue(b, d))
        },
        deserializeClientXml: function(a, b, c) {
            var d = this.settings.getClientType(c);
            d && a.setClient(c, this.deserializeValue(b, d))
        },
        deserializeValue: function(a, b) {
            if (a.hasAttribute("@none")) return null;
            if ("string" === b) return a.textContent;
            if ("number" === b) return parseFloat(a.textContent);
            if ("boolean" === b) return "true" === a.textContent;
            if ("int" === b) return parseInt(a.textContent);
            if ("point" === b) return {
                x: parseFloat(a.getAttribute("x")),
                y: parseFloat(a.getAttribute("y"))
            };
            if ("data" === b) {
                var c = a.getAttribute("ref"),
                d = this.refMap[c];
                return d ? d: this.idMap[c]
            }
            var e, f, g, h;
            if ("list.point" === b) {
                var i = new nd,
                j = a.getElementsByTagName("p");
                for (e = j.length, h = 0; e > h; h++) {
                    var k = j[h];
                    i.add({
                        x: parseFloat(k.getAttribute("x")),
                        y: parseFloat(k.getAttribute("y"))
                    })
                }
                return i
            }
            if ("list.string" === b) {
                var l = new nd;
                for (g = a.getElementsByTagName("s"), e = g.length, h = 0; e > h; h++) l.add(g[h].textContent);
                return l
            }
            if ("list.number" === b) {
                for (f = new nd, g = a.getElementsByTagName("s"), e = g.length, h = 0; e > h; h++) f.add(parseFloat(g[h].textContent));
                return f
            }
            if ("array.string" === b) return a.textContent.split(",");
            if ("array.number" === b) {
                for (f = a.textContent.split(","), e = f.length, h = 0; e > h; h++) f[h] = parseFloat(f[h]);
                return f
            }
            return "rectangle" === b ? {
                x: parseFloat(a.getAttribute("x")),
                y: parseFloat(a.getAttribute("y")),
                width: parseFloat(a.getAttribute("w")),
                height: parseFloat(a.getAttribute("h"))
            }: a.textContent
        }
    }),
    Jb.addMethod(Ib.Data, {
        serializeXml: function(a, b) {
            if (a.settings.isClientSerializable && this._clientMap) for (var c in this._clientMap) this.serializeClientXml(a, c, b);
            this.serializePropertyXml(a, "name", b),
            this.serializePropertyXml(a, "icon", b),
            this.serializePropertyXml(a, "toolTip", b),
            this.serializePropertyXml(a, "parent", b)
        },
        serializePropertyXml: function(a, b, c) {
            a.serializePropertyXml(this, b, c)
        },
        serializeClientXml: function(a, b, c) {
            a.serializeClientXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            var c, d, e, f, g = b.getElementsByTagName("p"),
            h = g.length;
            for (c = 0; h > c; c++) d = g[c],
            d.hasAttribute("n") && this.deserializePropertyXml(a, d, d.getAttribute("n"));
            if (a.settings.isClientSerializable) for (e = b.getElementsByTagName("c"), h = e.length, c = 0; h > c; c++) f = e[c],
            f.hasAttribute("n") && this.deserializeClientXml(a, f, f.getAttribute("n"))
        },
        deserializePropertyXml: function(a, b, c) {
            a.deserializePropertyXml(this, b, c)
        },
        deserializeClientXml: function(a, b, c) {
            a.deserializeClientXml(this, b, c)
        }
    }),
    Jb.addMethod(Ib.Element, {
        serializeXml: function(a, b) {
            if (a.settings.isStyleSerializable && this._styleMap) for (var c in this._styleMap) this.serializeStyleXml(a, c, b);
            Ib.Element.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "layerId", b),
            this._alarmState.getHighestNativeAlarmSeverity() && "alarmstate" === a.settings.getPropertyType("alarmState") && (a.xmlString += "	<p n='alarmState'>\n", Ib.AlarmSeverity.forEach(function(b) {
                var c = this.getNewAlarmCount(b);
                c > 0 && (a.xmlString += "		<n n='" + b.name + "' c='" + c + "'/>\n")
            },
            this._alarmState), Ib.AlarmSeverity.forEach(function(b) {
                var c = this.getAcknowledgedAlarmCount(b);
                c > 0 && (a.xmlString += "		<a n='" + b.name + "' c='" + c + "'/>\n")
            },
            this._alarmState), a.xmlString += "	</p>\n")
        },
        serializeStyleXml: function(a, b, c) {
            a.serializeStyleXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            if (Ib.Element.superClass.deserializeXml.call(this, a, b), a.settings.isStyleSerializable) {
                var c, d, e = b.getElementsByTagName("s"),
                f = e.length;
                for (c = 0; f > c; c++) d = e[c],
                d.hasAttribute("n") && this.deserializeStyleXml(a, d, d.getAttribute("n"))
            }
        },
        deserializeStyleXml: function(a, b, c) {
            a.deserializeStyleXml(this, b, c)
        },
        deserializePropertyXml: function(a, b, c) {
            if ("alarmState" === c) {
                if ("alarmstate" === a.settings.getPropertyType("alarmState")) {
                    var d, e, f, g = b.getElementsByTagName("n");
                    for (e = 0; e < g.length; e++) f = g[e],
                    d = Ib.AlarmSeverity.getByName(f.getAttribute("n")),
                    this._alarmState.setNewAlarmCount(d, parseInt(f.getAttribute("c")));
                    for (g = b.getElementsByTagName("a"), e = 0; e < g.length; e++) f = g[e],
                    d = Ib.AlarmSeverity.getByName(f.getAttribute("n")),
                    this._alarmState.setAcknowledgedAlarmCount(d, parseInt(f.getAttribute("c")))
                }
            } else Ib.Element.superClass.deserializePropertyXml.call(this, a, b, c)
        }
    }),
    Jb.addMethod(Kd, {
        serializeXml: function(a, b) {
            Kd.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "image", b),
            this.serializePropertyXml(a, "location", b),
            Jb.num(this._width) && this._width >= 0 && this.serializePropertyXml(a, "width", b),
            Jb.num(this._height) && this._height >= 0 && this.serializePropertyXml(a, "height", b)
        }
    }),
    Jb.addMethod(Ib.Link, {
        serializeXml: function(a, b) {
            Ib.Link.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "fromNode", b),
            this.serializePropertyXml(a, "toNode", b)
        }
    }),
    Jb.addMethod(Ib.Follower, {
        serializeXml: function(a, b) {
            Ib.Follower.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "host", b)
        }
    }),
    Jb.addMethod(Md, {
        serializeXml: function(a, b) {
            Md.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "expanded", b)
        }
    }),
    Jb.addMethod(Ib.ShapeNode, {
        serializeXml: function(a, b) {
            Ib.ShapeNode.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "points", b),
            this.serializePropertyXml(a, "segments", b)
        }
    }),
    Jb.addMethod(Ib.ShapeLink, {
        serializeXml: function(a, b) {
            Ib.ShapeLink.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "points", b)
        }
    }),
    Jb.addMethod(Ib.RotatableNode, {
        serializeXml: function(a, b) {
            Ib.RotatableNode.superClass.serializeXml.call(this, a, b),
            this.serializePropertyXml(a, "angle", b)
        }
    }),
    Jb.addMethod(Ib.DataBox, {
        serializeXml: function(a, b) {
            if (a.settings.isClientSerializable && this._clientMap) for (var c in this._clientMap) this.serializeClientXml(a, c, b);
            this.serializePropertyXml(a, "name", b),
            this.serializePropertyXml(a, "icon", b),
            this.serializePropertyXml(a, "toolTip", b)
        },
        serializePropertyXml: function(a, b, c) {
            a.serializePropertyXml(this, b, c)
        },
        serializeClientXml: function(a, b, c) {
            a.serializeClientXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            var c, d, e, f, g = b.getElementsByTagName("p"),
            h = g.length;
            for (c = 0; h > c; c++) d = g[c],
            d.hasAttribute("n") && this.deserializePropertyXml(a, d, d.getAttribute("n"));
            if (a.settings.isClientSerializable) for (e = b.getElementsByTagName("c"), h = e.length, c = 0; h > c; c++) f = e[c],
            f.hasAttribute("n") && this.deserializeClientXml(a, f, f.getAttribute("n"))
        },
        deserializePropertyXml: function(a, b, c) {
            a.deserializePropertyXml(this, b, c)
        },
        deserializeClientXml: function(a, b, c) {
            a.deserializeClientXml(this, b, c)
        }
    }),
    Jb.addMethod(Ib.ElementBox, {
        serializeXml: function(a, b) {
            if (a.settings.isLayerBoxSerializable && (a.xmlString += "	<layerBox>\n", this._layerBox.forEachByDepthFirst(function(b) {
                a.xmlString += this._layerBox.getDefaultLayer() === b ? "		<layer ": "		<layer id='" + b.getId() + "' ",
                b.getName() && (a.xmlString += "name='" + b.getName() + "' "),
                a.xmlString += "visible='" + b.isVisible() + "' editable='" + b.isEditable() + "' movable='" + b.isMovable() + "'/>\n"
            },
            null, this), a.xmlString += "	</layerBox>\n"), a.settings.isStyleSerializable && this._styleMap) for (var c in this._styleMap) this.serializeStyleXml(a, c, b);
            Ib.ElementBox.superClass.serializeXml.call(this, a, b)
        },
        serializeStyleXml: function(a, b, c) {
            a.serializeStyleXml(this, b, c)
        },
        deserializeStyleXml: function(a, b, c) {
            a.deserializeStyleXml(this, b, c)
        },
        deserializeXml: function(a, b) {
            if (Ib.ElementBox.superClass.deserializeXml.call(this, a, b), a.settings.isLayerBoxSerializable && 1 == b.getElementsByTagName("layerBox").length) for (var c = b.getElementsByTagName("layerBox")[0].getElementsByTagName("layer"), d = 0; d < c.length; d++) {
                var e, f = c[d];
                if (f.hasAttribute("id")) {
                    var g = a.settings.getPropertyType("layerId");
                    if ("string" === g) e = new Ib.Layer(f.getAttribute("id"));
                    else if ("int" === g) e = new Ib.Layer(parseInt(f.getAttribute("id")));
                    else {
                        if ("number" !== g) throw "Unsupported layer id type '" + g + "'";
                        e = new Ib.Layer(parseFloat(f.getAttribute("id")))
                    }
                    this._layerBox.getDataById(e.getId()) ? e = this._layerBox.getDataById(e.getId()) : this._layerBox.add(e)
                } else e = this._layerBox.getDefaultLayer();
                f.hasAttribute("name") && e.setName(f.getAttribute("name")),
                f.hasAttribute("visible") && e.setVisible("true" === f.getAttribute("visible")),
                f.hasAttribute("editable") && e.setEditable("true" === f.getAttribute("editable")),
                f.hasAttribute("movable") && e.setMovable("true" === f.getAttribute("movable"))
            }
            if (a.settings.isStyleSerializable) for (var h = b.getElementsByTagName("s"), i = h.length, d = 0; i > d; d++) {
                var j = h[d];
                j.hasAttribute("n") && this.deserializeStyleXml(a, j, j.getAttribute("n"))
            }
        }
    }),
    Ib.JsonSerializer = function(a, b, c) {
        this.dataBox = a,
        this.settings = b ? b: new Ib.SerializationSettings,
        this.filterFunction = c,
        this.ref = 0,
        this.refMap = {},
        this.idMap = {},
        this.jsonObject = {}
    },
    Jb.ext("twaver.JsonSerializer", Object, {
        serialize: function() {
            return this.jsonObject = {
                version: Ib.Util.getVersion(),
                platform: "html5"
            },
            this.settings.isImageSerializable && (this.jsonObject.images = {}),
            this.serializeBody(),
            JSON.stringify(this.jsonObject)
        },
        serializeBody: function() {
            if (this.ref = 0, this.dataBox.getRoots().forEach(this.initRefs, this), this.settings.isDataBoxSerializable) {
                var a = {
                    "class": this.dataBox.getClassName(),
                    p: {},
                    s: {},
                    c: {}
                };
                this.jsonObject.dataBox = a,
                this.dataBox.serializeJson(this, this.dataBox.newInstance(), a),
                Jb.isEmptyObject(a.p) && delete a.p,
                Jb.isEmptyObject(a.s) && delete a.s,
                Jb.isEmptyObject(a.c) && delete a.c
            }
            this.jsonObject.datas = [],
            this.dataBox.getRoots().forEach(this.serializeData, this)
        },
        initRefs: function(a) {
            this.refMap[a.getId()] = this.ref++,
            a.getChildren().forEach(this.initRefs, this)
        },
        isSerializable: function(a) {
            return this.dataBox.contains(a) ? this.filterFunction && !this.filterFunction(a) ? !1 : !0 : !1
        },
        serializeData: function(a) {
            if (this.isSerializable(a)) {
                var b = a.newInstance(),
                c = this.refMap[a.getId()],
                d = {
                    "class": a.getClassName(),
                    ref: c,
                    p: {},
                    s: {},
                    c: {}
                };
                if (this.settings.getPropertyType("id") && (this.jsonObject.id = a.getId()), this.jsonObject.datas.push(d), a.serializeJson(this, b, d), Jb.isEmptyObject(d.p) && delete d.p, Jb.isEmptyObject(d.s) && delete d.s, Jb.isEmptyObject(d.c) && delete d.c, this.settings.isImageSerializable && a.getImage) {
                    var e = a.getImage();
                    if ("string" == typeof e && !Pd[e] && !this.jsonObject.images[e]) {
                        var f = Jb.getImageAsset(e),
                        g = f && f.getImage();
                        g && !cd(g) && (this.jsonObject.images[e] = g)
                    }
                }
            }
            a.getChildren().forEach(this.serializeData, this)
        },
        serializePropertyJson: function(a, b, c, d) {
            var e = this.settings.getPropertyType(b);
            if (e) {
                var f = Jb.getValue(a, b, e),
                g = Jb.getValue(c, b, e);
                f !== g && this.serializeValue(b, f, g, e, d.p)
            }
        },
        serializeStyleJson: function(a, b, c, d) {
            var e = this.settings.getStyleType(b);
            if (e) {
                var f = a.getStyle(b),
                g = c.getStyle(b);
                f != g && this.serializeValue(b, f, g, e, d.s)
            }
        },
        serializeClientJson: function(a, b, c, d) {
            var e = this.settings.getClientType(b);
            if (null != e) {
                var f = a.getClient(b),
                g = c.getClient(b);
                f != g && this.serializeValue(b, f, g, e, d.c)
            }
        },
        serializeValue: function(a, b, c, d, e) {
            if (null == b) e[a] = null;
            else if (b instanceof nd) e[a] = b._as;
            else if ("data" === d) {
                var f = this.refMap[b.getId()];
                null != f && (e[a] = f)
            } else e[a] = b
        },
        deserialize: function(a, b) {
            Jb.isDeserializing = !0,
            this.jsonObject = JSON.parse(a);
            var c = this.jsonObject.images;
            this.settings.isImageSerializable && c && Object.keys(c).forEach(function(a) {
                Jb.registerImage(a, c[a])
            }),
            this.refMap = {},
            this.idMap = {};
            for (var d, e = new nd,
            f = new nd,
            g = this.jsonObject.datas.length,
            h = 0; g > h; h++) {
                var i = this.jsonObject.datas[h],
                j = i["class"],
                k = this.settings.getPropertyType("id");
                if (k && null != i.id) {
                    if ("remove" === i.action) {
                        this.dataBox.removeById(i.id);
                        continue
                    }
                    d = this.dataBox.getDataById(i.id),
                    d || (d = Jb.newInstance(j, i.id))
                } else d = Jb.newInstance(j);
                null != i.ref && (this.refMap[i.ref] = d),
                e.add(d),
                f.add(i),
                this.idMap[d.getId()] = d
            }
            for (this.dataBox.forEach(function(a) {
                this.idMap[a.getId()] = a
            },
            this), g = e.size(), h = 0; g > h; h++) d = e.get(h),
            d.deserializeJson(this, f.get(h));
            for (h = 0; g > h; h++) d = e.get(h),
            this.dataBox.containsById(d.getId()) || (b && !d.getParent() && d.setParent(b), this.dataBox.add(d));
            this.settings.isDataBoxSerializable && this.jsonObject.dataBox && this.dataBox.deserializeJson(this, this.jsonObject.dataBox),
            Jb.isDeserializing = !1
        },
        deserializePropertyJson: function(a, b, c) {
            var d = this.settings.getPropertyType(c);
            d && Jb.setValue(a, c, this.deserializeValue(b, d))
        },
        deserializeStyleJson: function(a, b, c) {
            var d = this.settings.getStyleType(c);
            d && a.setStyle(c, this.deserializeValue(b, d))
        },
        deserializeClientJson: function(a, b, c) {
            var d = this.settings.getClientType(c);
            d && a.setClient(c, this.deserializeValue(b, d))
        },
        deserializeValue: function(a, b) {
            if ("data" === b) {
                var c = this.refMap[a];
                return c ? c: this.idMap[a]
            }
            return "array.number" === b ? a: a instanceof Array ? new nd(a) : a
        }
    }),
    Jb.addMethod(Ib.Data, {
        serializeJson: function(a, b, c) {
            if (a.settings.isClientSerializable && this._clientMap) for (var d in this._clientMap) this.serializeClientJson(a, d, b, c);
            this.serializePropertyJson(a, "name", b, c),
            this.serializePropertyJson(a, "icon", b, c),
            this.serializePropertyJson(a, "toolTip", b, c),
            this.serializePropertyJson(a, "parent", b, c)
        },
        serializePropertyJson: function(a, b, c, d) {
            a.serializePropertyJson(this, b, c, d)
        },
        serializeClientJson: function(a, b, c, d) {
            a.serializeClientJson(this, b, c, d)
        },
        deserializeJson: function(a, b) {
            var c;
            for (c in b.p) this.deserializePropertyJson(a, b.p[c], c);
            if (a.settings.isClientSerializable) for (c in b.c) this.deserializeClientJson(a, b.c[c], c)
        },
        deserializePropertyJson: function(a, b, c) {
            a.deserializePropertyJson(this, b, c)
        },
        deserializeClientJson: function(a, b, c) {
            a.deserializeClientJson(this, b, c)
        }
    }),
    Jb.addMethod(Ib.Element, {
        serializeJson: function(a, b, c) {
            if (a.settings.isStyleSerializable && this._styleMap) for (var d in this._styleMap) this.serializeStyleJson(a, d, b, c);
            if (Ib.Element.superClass.serializeJson.call(this, a, b, c), this.serializePropertyJson(a, "layerId", b, c), this._alarmState.getHighestNativeAlarmSeverity() && "alarmstate" === a.settings.getPropertyType("alarmState")) {
                var e = {
                    n: {},
                    a: {}
                };
                c.p.alarmState = e,
                Ib.AlarmSeverity.forEach(function(a) {
                    var b = this.getNewAlarmCount(a);
                    b > 0 && (e.n[a.name] = b)
                },
                this._alarmState),
                Ib.AlarmSeverity.forEach(function(a) {
                    var b = this.getAcknowledgedAlarmCount(a);
                    b > 0 && (e.a[a.name] = b)
                },
                this._alarmState),
                Jb.isEmptyObject(e.n) && delete e.n,
                Jb.isEmptyObject(e.a) && delete e.a,
                Jb.isEmptyObject(e) && delete c.p.alarmState
            }
        },
        serializeStyleJson: function(a, b, c, d) {
            a.serializeStyleJson(this, b, c, d)
        },
        deserializeJson: function(a, b) {
            if (Ib.Element.superClass.deserializeJson.call(this, a, b), a.settings.isStyleSerializable) for (var c in b.s) this.deserializeStyleJson(a, b.s[c], c)
        },
        deserializeStyleJson: function(a, b, c) {
            a.deserializeStyleJson(this, b, c)
        },
        deserializePropertyJson: function(a, b, c) {
            if ("alarmState" === c) {
                if ("alarmstate" === a.settings.getPropertyType("alarmState")) {
                    var d;
                    for (d in b.n) this._alarmState.setNewAlarmCount(Ib.AlarmSeverity.getByName(d), b.n[d]);
                    for (d in b.a) this._alarmState.setAcknowledgedAlarmCount(Ib.AlarmSeverity.getByName(d), b.a[d])
                }
            } else Ib.Element.superClass.deserializePropertyJson.call(this, a, b, c)
        }
    }),
    Jb.addMethod(Kd, {
        serializeJson: function(a, b, c) {
            Kd.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "image", b, c),
            this.serializePropertyJson(a, "location", b, c),
            Jb.num(this._width) && this._width >= 0 && this.serializePropertyJson(a, "width", b, c),
            Jb.num(this._height) && this._height >= 0 && this.serializePropertyJson(a, "height", b, c)
        }
    }),
    Jb.addMethod(Ib.Link, {
        serializeJson: function(a, b, c) {
            Ib.Link.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "fromNode", b, c),
            this.serializePropertyJson(a, "toNode", b, c)
        }
    }),
    Jb.addMethod(Ib.Follower, {
        serializeJson: function(a, b, c) {
            Ib.Follower.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "host", b, c)
        }
    }),
    Jb.addMethod(Md, {
        serializeJson: function(a, b, c) {
            Md.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "expanded", b, c)
        }
    }),
    Jb.addMethod(Ib.ShapeNode, {
        serializeJson: function(a, b, c) {
            Ib.ShapeNode.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "points", b, c),
            this.serializePropertyJson(a, "segments", b, c)
        }
    }),
    Jb.addMethod(Ib.ShapeLink, {
        serializeJson: function(a, b, c) {
            Ib.ShapeLink.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "points", b, c)
        }
    }),
    Jb.addMethod(Ib.RotatableNode, {
        serializeJson: function(a, b, c) {
            Ib.RotatableNode.superClass.serializeJson.call(this, a, b, c),
            this.serializePropertyJson(a, "angle", b, c)
        }
    }),
    Jb.addMethod(Ib.DataBox, {
        serializeJson: function(a, b, c) {
            if (a.settings.isClientSerializable && this._clientMap) for (var d in this._clientMap) this.serializeClientJson(a, d, b, c);
            this.serializePropertyJson(a, "name", b, c),
            this.serializePropertyJson(a, "icon", b, c),
            this.serializePropertyJson(a, "toolTip", b, c)
        },
        serializePropertyJson: function(a, b, c, d) {
            a.serializePropertyJson(this, b, c, d)
        },
        serializeClientJson: function(a, b, c, d) {
            a.serializeClientJson(this, b, c, d)
        },
        deserializeJson: function(a, b) {
            var c;
            for (c in b.p) this.deserializePropertyJson(a, b.p[c], c);
            if (a.settings.isClientSerializable) for (c in b.c) this.deserializeClientJson(a, b.c[c], c)
        },
        deserializePropertyJson: function(a, b, c) {
            a.deserializePropertyJson(this, b, c)
        },
        deserializeClientJson: function(a, b, c) {
            a.deserializeClientJson(this, b, c)
        }
    }),
    Jb.addMethod(Ib.ElementBox, {
        serializeJson: function(a, b, c) {
            if (a.settings.isLayerBoxSerializable && (c.layers = [], this._layerBox.forEachByDepthFirst(function(a) {
                var b = {};
                c.layers.push(b),
                this._layerBox.getDefaultLayer() !== a && (b.id = a.getId()),
                a.getName() && (b.name = a.getName()),
                b.visible = a.isVisible(),
                b.editable = a.isEditable(),
                b.movable = a.isMovable()
            },
            null, this)), a.settings.isStyleSerializable && this._styleMap) for (var d in this._styleMap) this.serializeStyleJson(a, d, b, c);
            Ib.ElementBox.superClass.serializeJson.call(this, a, b, c)
        },
        serializeStyleJson: function(a, b, c, d) {
            a.serializeStyleJson(this, b, c, d)
        },
        deserializeStyleJson: function(a, b, c) {
            a.deserializeStyleJson(this, b, c)
        },
        deserializeJson: function(a, b) {
            if (Ib.ElementBox.superClass.deserializeJson.call(this, a, b), a.settings.isLayerBoxSerializable && b.layers && b.layers) for (var c = b.layers.length,
            d = 0; c > d; d++) {
                var e, f = b.layers[d];
                null != f.id ? (e = new Ib.Layer(f.id), this._layerBox.getDataById(e.getId()) ? e = this._layerBox.getDataById(e.getId()) : this._layerBox.add(e)) : e = this._layerBox.getDefaultLayer(),
                f.name && e.setName(f.name),
                null != f.visible && e.setVisible(f.visible),
                null != f.editable && e.setEditable(f.editable),
                null != f.movable && e.setMovable(f.movable)
            }
            if (a.settings.isStyleSerializable) for (var g in b.s) this.deserializeStyleJson(a, b.s[g], g)
        }
    }),
    Ib.layout.SpringLayouter = function(a) {
        this._network = a,
        this._damper = 1,
        this._maxMotion = 0,
        this._motionRatio = 0,
        this._isAdjusting = !1,
        this._timer = null,
        this._snodeMap = {},
        this._snodes = new nd,
        this._slinks = new nd,
        this._network.getElementBox().addDataBoxChangeListener(this._handleDataBoxChange, this),
        this._network.getElementBox().addDataPropertyChangeListener(this._handleDataPropertyChange, this),
        this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this)
    },
    Jb.ext("twaver.layout.SpringLayouter", Object, {
        _nodeRepulsionFactor: .6,
        _linkRepulsionFactor: .6,
        _limitBounds: null,
        _interval: 50,
        _stepCount: 10,
        _motionLimit: .01,
        start: function() {
            if (!this._timer) {
                var b = this,
                c = function() {
                    b.relax.call(b)
                };
                this._timer = a.setInterval(c, this._interval),
                this._damper = 1
            }
        },
        stop: function() {
            this._timer && (a.clearInterval(this._timer), this._timer = null)
        },
        relax: function() {
            if (! (this._damper < .1 && this._maxMotion < this._motionLimit)) {
                this._rebuild();
                for (var a = this._snodes.size(), b = 0; b < this._stepCount; b++) {
                    this._slinks.forEach(this._relaxLink, this);
                    for (var c = 0; a > c; c++) for (var d = 0; a > d; d++) {
                        var e = this._snodes.get(c),
                        f = this._snodes.get(d);
                        e != f && this._relaxNodePair(e, f)
                    }
                    this._moveNodes()
                }
                this._isAdjusting = !0;
                for (var b = 0; a > b; b++) {
                    var g = this._snodes.get(b);
                    g.fix || g.element.setLocation(g.x, g.y)
                }
                this._isAdjusting = !1
            }
        },
        isRunning: function() {
            return !! this._timer
        },
        getNetwork: function() {
            return this._network
        },
        isVisible: function(a) {
            return this._network.isVisible(a)
        },
        isMovable: function(a) {
            return this._network.isMovable(a) ? this._network.getSelectionModel().contains(a) ? !1 : a instanceof Md ? !1 : !0 : !1
        },
        getNodeRepulsionFactor: function() {
            return this._nodeRepulsionFactor
        },
        setNodeRepulsionFactor: function(a) {.02 > a && (a = .02),
            this._nodeRepulsionFactor = a,
            this._damper = 1
        },
        getLinkRepulsionFactor: function() {
            return this._linkRepulsionFactor
        },
        setLinkRepulsionFactor: function(a) {.02 > a && (a = .02),
            this._linkRepulsionFactor = a,
            this._damper = 1
        },
        getStepCount: function() {
            return this._stepCount
        },
        setStepCount: function(a) {
            this._stepCount = a,
            this._damper = 1
        },
        getInterval: function() {
            return this._interval
        },
        setInterval: function(b) {
            if (this._interval !== b && (this._interval = b, this._timer)) {
                a.clearInterval(this._timer);
                var c = this,
                d = function() {
                    c.relax.call(c)
                };
                this._timer = a.setInterval(d, this._interval)
            }
        },
        getLimitBounds: function() {
            return this._limitBounds
        },
        setLimitBounds: function(a) {
            this._limitBounds = a,
            this._damper = 1
        },
        _handleDataPropertyChange: function(a) {
            this._isAdjusting || (this._damper = 1)
        },
        _handleDataBoxChange: function(a) {
            this._damper = 0 === this._network.getElementBox().size() ? 0 : 1
        },
        _handleNetworkPropertyChange: function(a) {
            if ("elementBox" === a.property) {
                var b = a.oldValue;
                null != b && (b.removeDataBoxChangeListener(this._handleDataBoxChange, this), b.removeDataPropertyChangeListener(this._handleDataPropertyChange, this)),
                this._network.getElementBox().addDataBoxChangeListener(this._handleDataBoxChange, this),
                this._network.getElementBox().addDataPropertyChangeListener(this._handleDataPropertyChange, this)
            }
        },
        _relaxLink: function(a) {
            var b = a.toNode.x - a.fromNode.x,
            c = a.toNode.y - a.fromNode.y,
            d = Math.sqrt(b * b + c * c),
            e = .25 * b,
            f = .25 * c;
            e /= 100 * a.length;
            var g = a.length,
            h = 100 * g,
            i = f;
            f /= h,
            i /= 100 * a.length,
            a.toNode.dx = a.toNode.dx - e * d,
            a.toNode.dy = a.toNode.dy - f * d,
            a.fromNode.dx = a.fromNode.dx + e * d,
            a.fromNode.dy = a.fromNode.dy + f * d
        },
        _relaxNodePair: function(a, b) {
            var c = 0,
            d = 0,
            e = a.x - b.x,
            f = a.y - b.y,
            g = e * e + f * f;
            0 === g ? (c = Ib.Util.random(), d = Ib.Util.random()) : 36e4 > g && (c = e / g, d = f / g);
            var h = a.repulsion * b.repulsion / 100,
            i = .25 * h;
            a.dx += c * i,
            a.dy += d * i,
            b.dx -= c * i,
            b.dy -= d * i
        },
        _moveNodes: function() {
            for (var a = this._maxMotion,
            b = 0,
            c = 0,
            d = this._snodes.size(); d > c; c++) {
                var e = this._snodes.get(c),
                f = e.dx,
                g = e.dy;
                f *= this._damper,
                g *= this._damper,
                e.dx = f / 2,
                e.dy = g / 2;
                var h = Math.sqrt(f * f + g * g);
                if (!e.fix) if (e.x = e.x + Math.max( - 30, Math.min(30, f)), e.y = e.y + Math.max( - 30, Math.min(30, g)), this._limitBounds) {
                    e.x < this._limitBounds.x && (e.x = this._limitBounds.x, this._adjustLocation(1, 0)),
                    e.y < this._limitBounds.y && (e.y = this._limitBounds.y, this._adjustLocation(0, 1));
                    var i, j = this._network.getElementUI(e.element);
                    i = j ? j._viewRect: e.element.getRect(),
                    i && (e.x + i.width > this._limitBounds.x + this._limitBounds.width && (e.x = this._limitBounds.x + this._limitBounds.width - i.width, this._adjustLocation( - 1, 0)), e.y + i.height > this._limitBounds.y + this._limitBounds.height && (e.y = this._limitBounds.y + this._limitBounds.height - i.height, this._adjustLocation(0, -1)))
                } else e.x < 1 && this._adjustLocation(1, 0),
                e.y < 1 && this._adjustLocation(0, 1);
                b = Math.max(h, b)
            }
            this._maxMotion = b,
            this._motionRatio = this._maxMotion > 0 ? a / this._maxMotion - 1 : 0,
            this._damp()
        },
        _damp: function() {
            this._motionRatio <= .001 && ((this._maxMotion < .2 || this._maxMotion > 1 && this._damper < .9) && this._damper > .01 ? this._damper -= .01 : this._maxMotion < .4 && this._damper > .003 ? this._damper -= .003 : this._damper > 1e-4 && (this._damper -= 1e-4)),
            this._maxMotion < this._motionLimit && (this._damper = 0)
        },
        _rebuild: function() {
            this._snodeMap = {},
            this._snodes.clear(),
            this._slinks.clear(),
            this._network.getElementBox().forEach(function(a) {
                this.isVisible(a) && (a instanceof Ib.Link ? this._addLink(a) : a instanceof Kd && this._addNode(a))
            },
            this)
        },
        _addNode: function(a) {
            var b = this._snodeMap[a.getId()];
            return b ? b: (b = {},
            b.element = a, b.repulsion = this._getRepulsion(a), b.x = a.getX(), b.y = a.getY(), b.dx = 0, b.dy = 0, b.fix = !this.isMovable(a), this._snodeMap[a.getId()] = b, this._snodes.add(b), b)
        },
        _addLink: function(a) {
            var b = {};
            b.fromNode = this._addNode(a.getFromNode()),
            b.toNode = this._addNode(a.getToNode()),
            b.element = a;
            var c, d, e = this._network.getElementUI(a.getToNode()),
            f = this._network.getElementUI(a.getFromNode());
            e && e._viewRect && f && f._viewRect ? (c = e._viewRect.width + f._viewRect.width, d = e._viewRect.height + f._viewRect.height) : (c = a.getToNode().getWidth() + a.getFromNode().getWidth(), d = a.getToNode().getHeight() + a.getFromNode().getHeight()),
            b.length = Math.floor(Math.sqrt(c * c + d * d) * this._linkRepulsionFactor),
            b.length <= 0 && (b.length = 100),
            this._slinks.add(b)
        },
        _getRepulsion: function(a) {
            var b, c = this._network.getElementUI(a);
            if (c && c._viewRect) {
                var d = c._viewRect;
                b = Math.floor(Math.sqrt(d.width * d.width + d.height * d.height) * this._nodeRepulsionFactor)
            } else b = 100;
            return 0 >= b && (b = 100),
            b
        },
        _adjustLocation: function(a, b) {
            for (var c = 0,
            d = this._snodes.size(); d > c; c++) {
                var e, f = this._snodes.get(c),
                g = this._network.getElementUI(f.element);
                if (e = g ? g._viewRect: f.element.getRect(), !e) return;
                a > 0 ? (!this._limitBounds || f.x + e.width + a < this._limitBounds.x + this._limitBounds.width) && (f.x += a) : (!this._limitBounds || f.x + a > this._limitBounds.x) && (f.x += a),
                b > 0 ? (!this._limitBounds || f.y + e.height + b < this._limitBounds.y + this._limitBounds.height) && (f.y += b) : (!this._limitBounds || f.y + b > this._limitBounds.y) && (f.y += b)
            }
        }
    }),
    Ib.layout.CloudLayouter = function(a) {
        Ib.layout.CloudLayouter.superClass.constructor.apply(this, arguments),
        this._network = a,
        this._centerX = 0,
        this._centerY = 0,
        this._radius = 1,
        this._rect = null,
        this._localPoint = null,
        this._lastWidth = -1e3,
        this._lastHeight = -1e3,
        this._nodes = new nd,
        this._sa = 0,
        this._ca = 0,
        this._sb = 0,
        this._cb = 0,
        this._sc = 0,
        this._cc = 0,
        this._lasta = 0,
        this._lastb = 0,
        this._active = !1,
        this._horizontalElliptical = 1,
        this._verticalElliptical = 1,
        this._timer = null,
        this._centering = !1,
        this._centeringNode = null,
        this._freeze = !1,
        this._network.setInteractions("twaver.network.Network" === this._network.getClassName() ? [new Ib.network.interaction.SelectInteraction(this._network)] : [new Ib.canvas.interaction.SelectInteraction(this._network)])
    },
    Jb.ext("twaver.layout.CloudLayouter", Ib.PropertyChangeDispatcher, {
        __accessor: ["updateNodeFunction", "mouseMoveFunction", "mouseOverFunction", "percentPadding", "ceaseRate", "ceaseLimit"],
        __bool: ["elliptical", "active", "updateLayoutRectOnResized", "reloadOnDataBoxChanged"],
        _moveSpeed: 2,
        _ceaseRate: .9,
        _ceaseLimit: .01,
        _percentPadding: .2,
        _elliptical: !0,
        _interval: 50,
        _reloadOnDataBoxChanged: !0,
        _updateLayoutRectOnResized: !0,
        getNetwork: function() {
            return this._network
        },
        isLayoutable: function(a) {
            return this._network.isVisible(a) && this._network.isMovable(a)
        },
        start: function(b) {
            if (0 === arguments.length && (b = !0), !this._timer) {
                this._installListeners(),
                b && this.updateLayoutRect(!0);
                var c = this,
                d = function() {
                    c._update.call(c)
                };
                this._timer = a.setInterval(d, this._interval),
                this._update()
            }
        },
        stop: function() {
            this._timer && (a.clearInterval(this._timer), this._timer = null)
        },
        isRunning: function() {
            return !! this._timer
        },
        getInterval: function() {
            return this._interval
        },
        setInterval: function(b) {
            if (this._interval !== b) {
                var c = this._interval;
                if (this._interval = b, this._timer) {
                    a.clearInterval(this._timer);
                    var d = this,
                    e = function() {
                        d._update.call(d)
                    };
                    this._timer = a.setInterval(e, this._interval)
                }
                this.firePropertyChange("interval", c, b)
            }
        },
        getMoveSpeed: function() {
            return this._moveSpeed
        },
        setMoveSpeed: function(a) {
            var b = this._moveSpeed;
            this._moveSpeed = a,
            this.firePropertyChange("moveSpeed", b, a)
        },
        getLayoutRect: function() {
            var a = this._network.getView().offsetWidth / this._network.getZoom(),
            b = this._network.getView().offsetHeight / this._network.getZoom(),
            c = a * this._percentPadding,
            d = b * this._percentPadding;
            return {
                x: c,
                y: d,
                width: a - 2 * c,
                height: b - 2 * d
            }
        },
        getCount: function() {
            return this._nodes.size()
        },
        updateLayoutRect: function(a) {
            var b = this._radius;
            if (this._rect = this.getLayoutRect(), this._rect.width <= 2 && (this._rect.width = 2), this._rect.height <= 2 && (this._rect.height = 2), this._radius = Math.min(this._rect.width / 2, this._rect.height / 2), this.isElliptical() ? (this._horizontalElliptical = this._rect.width / 2 / this._radius, this._verticalElliptical = this._rect.height / 2 / this._radius) : (this._horizontalElliptical = 1, this._verticalElliptical = 1), this._centerX = this._rect.x + this._rect.width / 2, this._centerY = this._rect.y + this._rect.height / 2, a) this.reload();
            else {
                this._lasta = 1,
                this._lastb = 1;
                for (var c = this._nodes.size(), d = 0; c > d; d++) {
                    var e = this._nodes.get(d);
                    e.cx *= this._radius / b,
                    e.cy *= this._radius / b,
                    e.cz *= this._radius / b
                }
                this._freeze ? this._updateNodes(0, 0, 0) : this._update()
            }
            this._lastWidth = this._network.getView().offsetWidth,
            this._lastHeight = this._network.getView().offsetHeight
        },
        reload: function() {
            this._freeze = !1,
            this._centeringNode = null,
            this._localPoint = null,
            this._centering = !1,
            this._nodes = new nd,
            this._box.forEach(function(a) {
                if (a && this.isLayoutable(a)) {
                    var b = {};
                    b.node = a,
                    this._nodes.add(b)
                }
            },
            this),
            this._sineCosine(0, 0, 0),
            this._active = !1,
            this._lasta = 1,
            this._lastb = 1;
            for (var a = 0,
            b = 0,
            c = this._nodes.size(), d = 0; c > d; d++) {
                a = Math.acos( - 1 + (2 * (d + 1) - 1) / c),
                b = Math.sqrt(c * Math.PI) * a;
                var e = this._nodes.get(d);
                e.cx = this._radius * Math.cos(b) * Math.sin(a),
                e.cy = this._radius * Math.sin(b) * Math.sin(a),
                e.cz = this._radius * Math.cos(a)
            }
        },
        _sineCosine: function(a, b, c) {
            var d = Math.PI / 180;
            this._sa = Math.sin(a * d),
            this._ca = Math.cos(a * d),
            this._sb = Math.sin(b * d),
            this._cb = Math.cos(b * d),
            this._sc = Math.sin(c * d),
            this._cc = Math.cos(c * d)
        },
        handleSelectionChange: function(a) {
            this.centerNode(this._network.getSelectionModel().getLastData())
        },
        handleDataBoxChange: function(a) { (this._reloadOnDataBoxChanged || "clear" === a.kind) && this.reload()
        },
        handleMouseMove: function(a) {
            this._centering || this._updateLogicalPoint(a),
            this._active = this._mouseMoveFunction ? this._mouseMoveFunction(a) : !0
        },
        handleMouseOver: function(a) {
            this._centering || this._updateLogicalPoint(a),
            this._active = this._mouseOverFunction ? this._mouseOverFunction(a) : !0
        },
        _updateLogicalPoint: function(a) {
            this._localPoint = this._network.getLogicalPoint(a)
        },
        handleRollOut: function(a) {
            this._active = !1
        },
        handleResize: function(a) {
            if ("validateEnd" === a.kind) {
                if (!this._updateLayoutRectOnResized) return;
                if (Math.abs(this._network.getView().offsetWidth - this._lastWidth) <= 2 && Math.abs(this._network.getView().offsetHeight - this._lastHeight) <= 2) return;
                this.updateLayoutRect()
            }
        },
        handleNetworkPropertyChange: function(a) {
            "elementBox" === a.property && (this._box.removeDataBoxChangeListener(this.handleDataBoxChange, this), this._box = this._network.getElementBox(), this._box.addDataBoxChangeListener(this.handleDataBoxChange, this), this.reload()),
            "zoom" === a.property && (this._localPoint = null, this.updateLayoutRect())
        },
        _adjustIndex: function() {
            this._nodes.sort(this._sortFunction);
            for (var a = this._nodes.size(), b = 0; a > b; b++) {
                var c = this._nodes.get(b).node,
                d = this._box.getDatas().indexOf(c);
                this._box.getDatas().removeAt(d),
                this._box.getDatas().add(c, b),
                this._box.fireIndexChange(c, d, b),
                this.updateNode(c, b, a, this._nodes.get(b).alpha)
            }
        },
        _sortFunction: function(a, b) {
            return b.cz > a.cz ? 1 : b.cz < a.cz ? -1 : 0
        },
        updateNode: function(a, b, c, d) {
            this._updateNodeFunction && this._updateNodeFunction(a, b, c, d)
        },
        _update: function() {
            if (!this._freeze) {
                var a, b;
                if (this._centering && this._centeringNode) {
                    var c = this.isAtCenter(this._centeringNode.node, this._centeringNode.perspective, this._centeringNode.cx, this._centeringNode.cy, this._centeringNode.cz);
                    if (c) return this._freeze = !0,
                    this._centering = !1,
                    void(this._centeringNode = null)
                }
                if (!this._freeze && (this._active || this._centering) && this._localPoint ? this.isElliptical() ? (a = (this._centerY - this._localPoint.y) / (this._rect.height / 2) * this._moveSpeed, b = (this._localPoint.x - this._centerX) / (this._rect.width / 2) * this._moveSpeed) : (a = (this._centerY - this._localPoint.y) / this._radius * this._moveSpeed, b = (this._localPoint.x - this._centerX) / this._radius * this._moveSpeed) : (a = this._lasta * this._ceaseRate, b = this._lastb * this._ceaseRate), this._lasta = a, this._lastb = b, Math.abs(a) > this._ceaseLimit || Math.abs(b) > this._ceaseLimit) {
                    var d = 0;
                    this._sineCosine(a, b, d);
                    for (var e = 0,
                    f = this._nodes.size(); f > e; e++) {
                        var g = this._nodes.get(e),
                        h = g.cx,
                        i = g.cy * this._ca + g.cz * -this._sa,
                        j = g.cy * this._sa + g.cz * this._ca,
                        k = h * this._cb + j * this._sb,
                        l = i,
                        m = h * -this._sb + j * this._cb,
                        n = k * this._cc + l * -this._sc,
                        o = k * this._sc + l * this._cc,
                        p = m;
                        g.cx = n,
                        g.cy = o,
                        g.cz = p;
                        var q = 2 * this._radius;
                        q /= q + p,
                        g.perspective = q,
                        g.alpha = (this._radius - p) / (2 * this._radius);
                        var r = this._horizontalElliptical * n * q - 2 * this._horizontalElliptical + this._centerX,
                        s = o * q * this._verticalElliptical + this._centerY;
                        g.node.setCenterLocation(r, s)
                    }
                    this._adjustIndex()
                }
            }
        },
        centerNode: function(a) {
            if (a && this.isLayoutable(a)) {
                if (this._centeringNode && a === this._centeringNode.node && this._freeze) return;
                for (var b = 0,
                c = this._nodes.size(); c > b; b++) {
                    var d = this._nodes.get(b);
                    if (d && a === d.node) {
                        this._centering = !0,
                        this._freeze = !1,
                        this._active = !0,
                        this._centeringNode = d,
                        this._localPoint = this.createControlPoint(this._centeringNode.node);
                        break
                    }
                }
            } else this._centering = !1,
            this._freeze = !1,
            this._active = !1,
            this._localPoint = null
        },
        createControlPoint: function(a) {
            var b = a.getCenterLocation(),
            c = this.getLayoutRect(),
            d = c.x + c.width / 2,
            e = c.y + c.height / 2,
            f = Math.atan2(b.y - e, b.x - d),
            g = c.width + c.height;
            return {
                x: d + g * Math.cos(f),
                y: e + g * Math.sin(f)
            }
        },
        isAtCenter: function(a, b, c, d, e) {
            if (this._moveSpeed <= 0) return ! 0;
            var f = 16 / this._moveSpeed;
            return f > 20 ? f = 20 : 2 > f && (f = 2),
            -e / Math.sqrt(c * c + d * d) > f
        },
        _updateNodes: function(a, b, c) {
            this._sineCosine(a, b, c);
            for (var d = 0,
            e = this._nodes.size(); e > d; d++) {
                var f = this._nodes.get(d),
                g = f.cx,
                h = f.cy * this._ca + f.cz * -this._sa,
                i = f.cy * this._sa + f.cz * this._ca,
                j = g * this._cb + i * this._sb,
                k = h,
                l = g * -this._sb + i * this._cb,
                m = j * this._cc + k * -this._sc,
                n = j * this._sc + k * this._cc,
                o = l;
                f.cx = m,
                f.cy = n,
                f.cz = o;
                var p = 2 * this._radius;
                p /= p + o,
                f.perspective = p;
                var q = this._horizontalElliptical * m * p - 2 * this._horizontalElliptical + this._centerX,
                r = n * p * this._verticalElliptical + this._centerY;
                f.node.setCenterLocation(q, r)
            }
            this._adjustIndex()
        },
        _installListeners: function() {
            this._box = this._network.getElementBox(),
            this._box.addDataBoxChangeListener(this.handleDataBoxChange, this),
            this._network.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this),
            this._network.addViewListener(this.handleResize, this),
            Wb.addEventListener("mouseout", "handleRollOut", this._network.getView(), this),
            Wb.addEventListener("mousemove", "handleMouseMove", this._network.getView(), this),
            Wb.addEventListener("mouseover", "handleMouseOver", this._network.getView(), this),
            this._network.addPropertyChangeListener(this.handleNetworkPropertyChange, this)
        },
        _uninstallListeners: function() {
            this._box.removeDataBoxChangeListener(this.handleDataBoxChange, this),
            this._network.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this),
            this._network.removeViewListener(this.handleResize, this),
            Wb.removeEventListener("mouseout", this._network.getView(), this),
            Wb.removeEventListener("mousemove", this._network.getView(), this),
            Wb.removeEventListener("mouseover", this._network.getView(), this),
            this._network.removePropertyChangeListener(this.handleNetworkPropertyChange, this)
        }
    }),
    Ib.layout.AutoLayouter = function(a) {
        this._box = a
    },
    Jb.ext("twaver.layout.AutoLayouter", Object, {
        _expandGroup: !1,
        _repulsion: 1,
        _type: null,
        _animate: !0,
        _explicitXOffset: Number.NaN,
        _explicitYOffset: Number.NaN,
        _xOffset: 0,
        _yOffset: 0,
        isExpandGroup: function() {
            return this._expandGroup
        },
        setExpandGroup: function(a) {
            this._expandGroup = a
        },
        getRepulsion: function() {
            return this._repulsion
        },
        setRepulsion: function(a) {
            this._repulsion = a
        },
        getType: function() {
            return this._type
        },
        isAnimate: function() {
            return this._animate
        },
        setAnimate: function(a) {
            this._animate = a
        },
        getElementBox: function() {
            return this._box
        },
        getExplicitXOffset: function() {
            return this._explicitXOffset
        },
        setExplicitXOffset: function(a) {
            this._explicitXOffset = a
        },
        getExplicitYOffset: function() {
            return this._explicitYOffset
        },
        setExplicitYOffset: function(a) {
            this._explicitYOffset = a
        },
        getDimension: function(a) {
            if (a instanceof Md && a.getChildrenSize() > 0) {
                for (var b = null,
                c = 0,
                d = a.getChildrenSize(); d > c; c++) {
                    var e = a.getChildAt(c);
                    e instanceof Kd && (b = b ? Tb.unionRect(b, e.getRect()) : e.getRect())
                }
                return b ? {
                    width: b.width,
                    height: b.height
                }: null
            }
            return {
                width: a.getWidth(),
                height: a.getHeight()
            }
        },
        isVisible: function(a) {
            return ! 0
        },
        isMovable: function(a) {
            return ! 0
        },
        getGroupLayoutType: function(a) {
            return this._type
        },
        getElements: function() {
            var a, b = this._box,
            c = b.getSelectionModel().size() > 1;
            c ? a = b.getSelectionModel().getSelection() : (a = new nd, b.forEachByBreadthFirst(a.add, null, a)),
            this._xOffset = -1,
            this._yOffset = -1;
            for (var d = new nd,
            e = 0,
            f = a.size(); f > e; e++) {
                var g = a.get(e);
                this.isVisible(g) && (g instanceof Ib.Link ? d.add(g) : this.isMovable(g) && g instanceof Kd && (d.add(g), c && ((this._xOffset < 0 || g.getX() < this._xOffset) && (this._xOffset = g.getX()), (this._yOffset < 0 || g.getY() < this._yOffset) && (this._yOffset = g.getY()))))
            }
            return c || (this._xOffset = isNaN(this._explicitXOffset) ? 50 / this._repulsion: this._explicitXOffset, this._yOffset = isNaN(this._explicitYOffset) ? 50 / this._repulsion: this._explicitYOffset),
            d
        },
        getLayoutResult: function(a) {
            var b = {};
            return this.doLayoutImpl(a, null, b),
            b
        },
        doLayout: function(a, b) {
            return this.doLayoutImpl(a, b)
        },
        doLayoutImpl: function(a, b, c) {
            var d = this,
            e = b;
            b = function() {
                d._box._layoutMovingElements = !1,
                e && e()
            },
            this._type = a;
            var f = null;
            if ("round" === a ? f = new cf: "symmetry" === a ? f = new rf: "hierarchic" === a ? f = new Bf: ("topbottom" === a || "bottomtop" === a || "rightleft" === a || "leftright" === a) && (f = new Qe), null == f) return ! 1;
            d._box._layoutMovingElements = !0;
            var g = {},
            h = this.getElements(),
            i = new sf(this, h, !0, null);
            h = i.process();
            var j = new mf(this, h, a, !0, null);
            try {
                f.i2(j)
            } catch(k) {
                return i.resetGroup(),
                null != b && b(),
                !1
            }
            var l, m;
            for (l in j._a) {
                m = j._a[l];
                var n = j.g4(m);
                g[l] = {
                    x: n.x + this._xOffset,
                    y: n.y + this._yOffset
                }
            }
            var o;
            if ("rightleft" === a || "leftright" === a || "bottomtop" === a) {
                var p = sf.createMatrix(a),
                q = Number.MAX_VALUE,
                r = Number.MAX_VALUE;
                for (l in g) {
                    m = j._a[l],
                    o = g[l];
                    var s = p.transform(o);
                    o.x = s.x,
                    o.y = s.y;
                    var t;
                    "rightleft" === a || "leftright" === a ? (t = s.x - j.g9(m) / 2 / this._repulsion, q > t && (q = t), t = s.y - j.gj(m) / 2 / this._repulsion, r > t && (r = t)) : (t = s.x - j.gj(m) / 2 / this._repulsion, q > t && (q = t), t = s.y - j.g9(m) / 2 / this._repulsion, r > t && (r = t))
                }
                for (l in g) m = j._a[l],
                o = g[l],
                o.x = o.x - q + this._xOffset,
                o.y = o.y - r + this._yOffset
            }
            if (null == c && this._animate) {
                var u = new nd,
                v = new nd;
                for (l in g) u.add(j._a[l].node),
                v.add(g[l]);
                Ib.animate.AnimateManager.endAnimate(),
                Ib.animate.AnimateManager.start(new Ib.animate.AnimateCenterLocation(u, v,
                function() {
                    i.resetGroup(),
                    null != b && Jb.callLater(b)
                }))
            } else {
                for (l in g) m = j._a[l],
                o = g[l],
                null == c ? m.node.setCenterLocation(o.x, o.y) : c[m.node.getId()] = o;
                i.resetGroup(),
                null != b && Jb.callLater(b)
            }
            return ! 0
        }
    });
    var Rd = function(a, b) {
        this.x = a,
        this.y = b
    };
    Jb.ext(Rd, Object, {
        equals: function(a) {
            return this === a ? !0 : a instanceof Rd ? a.x == this.x && a.y == this.y: !1
        }
    });
    var Sd = function(a, b) {
        this.width = a,
        this.height = b
    };
    Jb.ext(Sd, Object, {});
    var Td = function(a, b) {
        this.x = a,
        this.y = b
    };
    Jb.ext(Td, Object, {});
    var Ud = function() {
        2 === arguments.length ? (Ud.superClass.constructor.call(this, arguments[1].width, arguments[1].height), this.x = arguments[0].x, this.y = arguments[0].y) : (Ud.superClass.constructor.call(this, arguments[2], arguments[3]), this.x = arguments[0], this.y = arguments[1])
    };
    Jb.ext(Ud, Sd, {});
    var Vd = function(a, b) {
        if (Vd.a2(a.x, b.x)) this._a = 1,
        this._b = 0,
        this._c = -a.x;
        else {
            this._b = -1;
            var c = (b.y - a.y) / (b.x - a.x),
            d = a.y - a.x * c;
            this._a = c,
            this._c = d
        }
    };
    Jb.ext(Vd, Object, {
        a3: function() {
            return this._a
        },
        a4: function() {
            return this._b
        },
        a5: function() {
            return this._c
        }
    }),
    Vd.a6 = function(a, b) {
        if (Vd.a1(a.a3()) && Vd.a1(b.a3())) return null;
        if (Vd.a1(a.a4()) && Vd.a1(b.a4())) return null;
        if (Vd.a1(b.a4())) {
            var c = a;
            a = b,
            b = c
        }
        var d, e, f = a.a3(),
        g = a.a4(),
        h = -a.a5();
        Vd.a1(a.a3()) ? (d = b.a4(), e = -b.a5()) : (d = b.a4() - b.a3() / a.a3() * a.a4(), e = -b.a5() - b.a3() / a.a3() * -a.a5());
        var i = e / d,
        j = (h - i * g) / f;
        return new Rd(j, i)
    },
    Vd.a1 = function(a) {
        return Vd.a2(a, 0)
    },
    Vd.a2 = function(a, b) {
        return Math.abs(a - b) < 1e-5
    };
    var Wd = function(a) {
        if (this._a = new pe, a) for (var b = 0; b < a.size(); b++) this._a.aa(a.get(b))
    };
    Jb.ext(Wd, Object, {
        c: function() {
            return this._a.ah()
        },
        d: function() {
            return this._a.ah()
        },
        a: function() {
            for (var a = new nd,
            b = this.c(); b.i1(); b.i2()) a.add(b.i6(), 0);
            return new Wd(a)
        },
        b: function() {
            return this._a.ay()
        }
    });
    var Xd = function(a, b) {
        this.x = a,
        this.y = b
    };
    Jb.ext(Xd, Object, {
        a: function(a, b) {
            this.x = a,
            this.y = b
        }
    });
    var Yd = function(a, b) {
        this.x = a || 0,
        this.y = b || 0
    };
    Jb.ext(Yd, Object, {
        b: function() {
            return new Yd(this.x, this.y)
        },
        a: function(a) {
            this.z = a
        },
        c: function() {
            return this.x
        },
        d: function() {
            return this.y
        },
        f: function(a, b) {
            this.x = a,
            this.y = b
        }
    });
    var Zd = function(a) {
        this._c = new pe,
        a ? (this.ac(a.a8().b()), this.ad(a.a9().b())) : (this.ac(new Yd), this.ad(new Yd))
    };
    Jb.ext(Zd, Object, {
        a6: function() {
            return this.a5(this)
        },
        ac: function(a) {
            a.a(this),
            this._a = a
        },
        ad: function(a) {
            a.a(this),
            this._b = a
        },
        a8: function() {
            return this._a
        },
        a9: function() {
            return this._b
        },
        a1: function(a, b) {
            return this.a4(a, b, this.aa())
        },
        a2: function() {
            return this._c.ay()
        },
        a7: function(a) {
            return this._c.ak(a)
        },
        aa: function() {
            return 0 === this._c.ay() ? null: this._c.as()
        },
        a3: function() {
            this._c.af()
        },
        i2: function(a) {
            var b = this.a7(a);
            return null != b ? new Rd(b.x, b.y) : null
        },
        i1: function() {
            return this.a2()
        },
        i6: function() {
            var a = this.a8();
            return new Rd(a.c(), a.d())
        },
        i7: function() {
            var a = this.a9();
            return new Rd(a.c(), a.d())
        },
        i8: function(a) {
            this.a8().f(a.x, a.y)
        },
        i9: function(a) {
            this.a9().f(a.x, a.y)
        },
        i3: function(a, b, c) {
            var d = this.a7(a);
            null != d && d.a(b, c)
        },
        i4: function(a, b) {
            this.a1(a, b)
        },
        i5: function() {
            this.a3()
        }
    });
    var $d = function(a) {
        $d.superClass.constructor.call(this, a)
    };
    Jb.ext($d, Zd, {
        a5: function(a) {
            return new $d(a)
        },
        a4: function(a, b, c) {
            var d = new Xd(a, b);
            return this.ab(d, c),
            d
        },
        ab: function(a, b) {
            this._c.an(a, this._c.al(b))
        }
    });
    var _d = function() {
        if (2 === arguments.length) {
            var a = arguments[0],
            b = arguments[1];
            this._s = !1,
            this._w = 30,
            this._h = 30,
            this._x = a - this._w / 2,
            this._y = b - this._h / 2
        } else {
            var c = arguments[0];
            this._s = c._s,
            this._w = c._w,
            this._h = c._h,
            this._x = c._x,
            this._y = c._y
        }
    };
    Jb.ext(_d, Object, {
        m3: function() {
            return this.m2(this)
        },
        m4: function() {
            return this._x + this._w / 2
        },
        m5: function() {
            return this._y + this._h / 2
        },
        m6: function(a, b) {
            this._x = a - this._w / 2,
            this._y = b - this._h / 2
        },
        i1: function() {
            return this._x
        },
        i2: function() {
            return this._y
        },
        i5: function(a, b) {
            this._x = a,
            this._y = b
        },
        i3: function() {
            return this._w
        },
        i4: function() {
            return this._h
        },
        i6: function(a, b) {
            var c = (this._w - a) / 2,
            d = (this._h - b) / 2;
            this._x += c,
            this._y += d,
            this._w = a,
            this._h = b
        },
        m1: function(a) {
            var b, c, d, e;
            a.width <= 0 ? (b = this._x, c = this._x + this._w, d = this._y, e = this._y + this._h) : (b = Math.min(this._x, a.x), c = Math.max(this._x + this._w, a.x + a.width), d = Math.min(this._y, a.y), e = Math.max(this._y + this._h, a.y + a.height)),
            a.x = b,
            a.y = d,
            a.width = c - b,
            a.height = e - d
        }
    });
    var ae = function(a) {
        a ? ae.superClass.constructor.call(this, a) : ae.superClass.constructor.call(this, 0, 0)
    };
    Jb.ext(ae, _d, {
        m2: function(a) {
            return new ae(a)
        }
    });
    var be = {};
    be.a2 = function(a) {
        var b = Me.a2(Gf.a(a.xa()));
        return be.a4(a, b, be.a3(a, b))
    },
    be.a3 = function(a, b) {
        for (var c = a.x9(); c.i1(); c.i2()) b.i7(c.i9(), -1);
        for (var d = 0,
        e = new ve(a.xa()), f = a.x9(); f.i1(); f.i2()) {
            var g = f.i9(); - 1 === b.i2(g) && be.a(g, e, b, d++)
        }
        return d
    },
    be.a6 = function(a) {
        for (var b = new qe,
        c = be.a2(a), d = 0; d < c.length - 1; d++) {
            var e = a.xo(c[d].x2(), c[d + 1].x3());
            b.aa(e)
        }
        return b
    },
    be.a4 = function(a, b, c) {
        for (var d = [], e = 0; c > e; e++) d[e] = new Ie;
        for (var f = a.x9(); f.i1(); f.i2()) d[b.i2(f.i9())].ae(f.i9());
        return d
    },
    be.a = function(a, b, c, d) {
        for (b.c(a), c.i7(a, d); ! b.a();) {
            a = b.b();
            for (var e = a.ag(); null != e; e = e.a8()) {
                var f = e.a3(); - 1 === c.i2(f) && (c.i7(f, d), b.c(f))
            }
            for (var g = a.ae(); null != g; g = g.a7()) {
                var h = g.a2(); - 1 === c.i2(h) && (c.i7(h, d), b.c(h))
            }
        }
    },
    be.a1 = function(a, b, c) {
        var d = new ke(b, c);
        return d.a8(a),
        d._i
    },
    be.a5 = function(a, b, c) {
        for (var d = [], e = 0; c > e; e++) d[e] = new qe;
        for (var f = a.xf(); f.i1(); f.i2()) d[b.i2(f.i8())].aa(f.i8());
        return d
    },
    be.a7 = function(a) {
        var b = new qe,
        c = Me.a3(Gf.b(a.xa())),
        d = Me.a4(Gf.a(a.xh())),
        e = be.a1(a, d, c),
        f = be.a5(a, d, e);
        if (f.length > 1) {
            for (var g = new Ie,
            h = 0; h < f.length; h++) {
                var i = f[h],
                j = null;
                if (1 === i.ay()) {
                    var k = i.c2();
                    1 === k.a2().ad() ? j = k.a2() : 1 === k.a3().ad() && (j = k.a3())
                } else {
                    for (var l = i.c1(); l.i1(); l.i2()) {
                        var m = l.i8();
                        if (c.i4(m.a2())) if (null == j) j = m.a2();
                        else if (j !== m.a2()) {
                            j = null;
                            break
                        }
                        if (c.i4(m.a3())) if (null != j) {
                            if (j !== m.a3()) {
                                j = null;
                                break
                            }
                        } else j = m.a3()
                    }
                    if (null != j) {
                        var n = i.c2();
                        j = n.a2() !== j ? n.a2() : n.a3()
                    }
                }
                null != j && g.aa(j)
            }
            for (var o, p = g.x4(); ! g.ar(); p = o) o = g.x4(),
            b.ac(a.xo(p, o))
        }
        return b
    };
    var ce = function() {
        this._c = 0,
        this._d = 0,
        this._e = 0,
        this._b = !0,
        this._f = !1
    };
    Jb.ext(ce, Object, {
        a6: function(a) {
            this._f = a
        },
        a7: function(a) {
            this._b = a
        },
        a8: function(a) {
            0 !== a.x0() && this.a9(a, a.x9().i9())
        },
        a9: function(a, b) {
            if (this._xx = a.xk(), this._c = a.xl(), this._d = 0, this._e = 0, this.a0(b), this._b) for (var c = a.x9(); c.i1(); c.i2()) {
                var d = c.i9();
                null == this._xx.i1(d) && (this.a1(d), this.a0(d))
            }
            a.xi(this._xx),
            a.xj(this._c)
        },
        a0: function(a) {
            var b = ++this._d;
            this._xx.z1(a, ce._B),
            this.a5(a, b);
            for (var c = this._f ? a.ap() : a.af(); c.i1(); c.i2()) {
                var d = c.i8();
                if (!this._c.i4(d)) {
                    this._c.i7(d, !0);
                    var e = d.a1(a);
                    null == this._xx.i1(e) ? (this.a3(d, e, !0), this.a0(e), this.a2(d, e)) : this.a3(d, e, !1)
                }
            }
            this.a4(a, b, ++this._e),
            this._xx.z1(a, ce._C)
        },
        a5: function(a, b) {},
        a4: function(a, b, c) {},
        a3: function(a, b, c) {},
        a2: function(a, b) {},
        a1: function(a) {}
    }),
    ce._B = {},
    ce._C = {};
    var de = function(a) {
        this._a = a
    };
    Jb.ext(de, ce, {
        a5: function(a, b) {
            var c = this._a._ah.i2(a);
            this._a._ad[c].ae(a)
        }
    });
    var ee = function(a) {
        this._a = a
    };
    Jb.ext(ee, ce, {
        a2: function(a, b) {
            var c = a.a1(b),
            d = this._a[c.al()],
            e = this._a[b.al()];
            e._a + 1 > d._a ? (d._c = d._a, d._b = d._d, d._a = e._a + 1, d._d = a) : e._a + 1 > d._c && (d._c = e._a + 1, d._b = a)
        }
    });
    var fe = function(a) {
        this._a = a
    };
    Jb.ext(fe, ce, {
        a3: function(a, b, c) {
            c && a.a2() === b && this._a.ac(a)
        }
    });
    var ge = function() {
        this._a = 0,
        this._c = 0
    };
    Jb.ext(ge, Object, {});
    var he = function() {
        this._a = 0
    };
    Jb.ext(he, Object, {
        a1: function(a, b) {
            this._a = 0;
            for (var c = b.length - 1; c >= 0; c--) b[c] = -1;
            for (var d = a.x9(); d.i1(); d.i2()) {
                var e = d.i9();
                if (0 === e.ak()) {
                    this.a2(e, e.al(), b);
                    break
                }
            }
            for (var f = a.x9(); f.i1(); f.i2()) {
                var g = f.i9(),
                h = g.al(); - 1 === b[h] && this.a2(g, h, b)
            }
        },
        a2: function(a, b, c) {
            c[b] = -2;
            for (var d = a.ag(); null != d;) {
                var e = d.a3(),
                f = e.al();
                switch (c[f]) {
                case - 1 : this.a2(e, f, c);
                case - 2 : default:
                    d = d.a8()
                }
            }
            c[b] = this._a++
        }
    });
    var ie = {};
    ie.a1 = function(a) {
        var b = new je;
        return b.a8(a),
        b._n
    },
    ie.a2 = function(a) {
        var b = a.x9(),
        c = null,
        d = 0;
        for (b.i4(); b.i1(); b.i2()) 0 === b.i9().ak() && (c = b.i9(), d++);
        if (1 === d) return c;
        for (d = 0, b.i4(); b.i1(); b.i2()) 0 === b.i9().ao() && (c = b.i9(), d++);
        return 1 === d ? c: ie.a8(a)
    },
    ie.a8 = function(a) {
        var b = Gf.a(a.x0()),
        c = Me.a2(b);
        return ie.a6(a, c)
    },
    ie.a6 = function(a, b) {
        var c = a.xd(),
        d = Gf.d(1),
        e = Gf.a(a.x0(), -1),
        f = ie.a4(a, c);
        ie.a7(c, b, d, e, -1);
        for (var g = f.c1(); g.i1(); g.i2()) a.x3(g.i8());
        return d[0]
    },
    ie.a7 = function(a, b, c, d, e) {
        for (var f = 0,
        g = a.ag(); null != g; g = g.a8()) {
            var h = g.a3(),
            i = ie.a7(h, b, c, d, e);
            i > e && (e = i),
            f += d[h.al()]
        }
        for (var j = f * (a._g.xa() - 1 - f), k = a.ag(); null != k; k = k.a8()) for (var l = k.a3(), m = k.a8(); null != m; m = m.a8()) {
            var n = m.a3();
            j += d[l.al()] * d[n.al()]
        }
        return b.i7(a, j),
        d[a.al()] = f + 1,
        j > e && (e = j, c[0] = a),
        e
    },
    ie.a4 = function(a, b) {
        var c = new qe,
        d = new fe(c);
        d.a6(!1),
        d.a9(a, b);
        for (var e = c.c1(); e.i1(); e.i2()) a.x3(e.i8());
        return c
    },
    ie.a3 = function(a) {
        return ie.a4(a, ie.a2(a))
    };
    var je = function() {
        this._n = !0,
        this.a6(!1)
    };
    Jb.ext(je, ce, {
        a3: function(a, b, c) {
            c || (this._n = !1)
        },
        a1: function(a) {
            this._n = !1
        }
    });
    var ke = function(a, b) {
        this._i = 0,
        this._m = b,
        this._j = a,
        this._l = !1
    };
    Jb.ext(ke, ce, {
        a8: function(a) {
            this._h = Gf.a(a.x0()),
            this._k = Gf.a(a.x0()),
            this._g = new ve(a.xh()),
            ke.superClass.a8.call(this, a)
        },
        a5: function(a, b) {
            this._k[a.al()] = this._h[a.al()] = b
        },
        a3: function(a, b, c) {
            if (this._g.c(a), !c) {
                var d = a.a1(b);
                this._h[d.al()] = Math.min(this._h[d.al()], this._k[b.al()])
            }
        },
        a1: function(a) {
            this._l = !1
        },
        a2: function(a, b) {
            var c = a.a1(b);
            if (this._h[b.al()] >= this._k[c.al()]) {
                for (; this._g.d() !== a; this._j.i5(this._g.b(), this._i));
                this._j.i5(this._g.b(), this._i),
                this._i++,
                this._g.a() ? this._l ? this._m.i5(c, !0) : this._l = !0 : this._m.i5(c, !0)
            }
            this._h[c.al()] = Math.min(this._h[c.al()], this._h[b.al()])
        }
    });
    var le = function(a, b) {
        this._h = !1,
        this._i = a,
        this._g = b
    };
    Jb.ext(le, Object, {
        z1: function(a, b) {
            a._c[this._i] = b
        },
        i1: function(a) {
            return a._c[this._i]
        },
        i5: function(a, b) {
            a._c[this._i] = b
        },
        i4: function(a) {
            return a._c[this._i]
        },
        i7: function(a, b) {
            a._c[this._i] = b
        },
        i2: function(a) {
            var b = a._c[this._i];
            return null == b ? 0 : b
        },
        i6: function(a, b) {
            a._c[this._i] = b
        },
        i3: function(a) {
            var b = a._c[this._i];
            return null == b ? 0 : b
        },
        c: function() {
            return this._h
        },
        d: function() {
            this._h = !0
        }
    });
    var me = function(a, b) {
        this._c = !1,
        this._d = a,
        this._b = b
    };
    Jb.ext(me, Object, {
        i8: function(a, b) {
            a._c[this._d] = b
        },
        i1: function(a) {
            return a._c[this._d]
        },
        i7: function(a, b) {
            a._c[this._d] = b
        },
        i4: function(a) {
            var b = a._c[this._d];
            return null == b ? !1 : b
        },
        i5: function(a, b) {
            a._c[this._d] = b
        },
        i2: function(a) {
            var b = a._c[this._d];
            return null == b ? 0 : b
        },
        i6: function(a, b) {
            a._c[this._d] = b
        },
        i3: function(a) {
            var b = a._c[this._d];
            return null == b ? 0 : b
        },
        a: function() {
            return this._c
        },
        b: function() {
            this._c = !0
        }
    });
    var ne = function(a) {
        this._bb = a,
        this.i4()
    };
    Jb.ext(ne, Object, {
        i1: function() {
            return null != this._aa
        },
        i2: function() {
            this._aa = this._aa._a
        },
        i3: function() {
            this._aa = this._aa._b
        },
        i4: function() {
            this._aa = this._bb._b
        },
        i5: function() {
            this._aa = this._bb._c
        },
        i7: function() {
            return this._bb.ay()
        },
        i6: function() {
            return this._aa._c
        }
    });
    var oe = function(a) {
        oe.superClass.constructor.call(this, a)
    };
    Jb.ext(oe, ne, {
        i8: function() {
            return this.i6()
        }
    });
    var pe = function(a) {
        if (this._id = Jb.id(), this._a = 0, a) for (a.i4(); a.i1(); a.i2()) this.ae(a.i6())
    };
    Jb.ext(pe, Object, {
        ac: function(a) {
            var b = this.ag(a);
            return null == this._b ? this._b = this._c = b: (this._b._b = b, b._a = this._b, this._b = b),
            this._a++,
            b
        },
        ae: function(a) {
            var b = this.ag(a);
            return null == this._c ? this._b = this._c = b: (this._c._a = b, b._b = this._c, this._c = b),
            this._a++,
            b
        },
        z1: function(a) {
            a._b = null,
            a._a = null,
            null == this._c ? this._b = this._c = a: (this._c._a = a, a._b = this._c, this._c = a),
            this._a++
        },
        ad: function(a) {
            a._b = null,
            a._a = null,
            null == this._b ? this._b = this._c = a: (this._b._b = a, a._a = this._b, this._b = a),
            this._a++
        },
        aa: function(a) {
            return this.ae(a),
            !0
        },
        ab: function(a) {
            for (; a.i1(); a.i2()) this.ae(a.i6())
        },
        ao: function(a, b) {
            if (b === this._b) return this.ac(a);
            if (null == b) return this.ae(a);
            var c = this.ag(a);
            return this.aq(c, b),
            c
        },
        aq: function(a, b) {
            if (null == b) this.ad(a);
            else if (b === this._b) this.ad(a);
            else {
                if (null == this._c) a._b = null,
                a._a = null,
                this._b = this._c = a;
                else {
                    var c = b._b;
                    b._b = a,
                    a._a = b,
                    c._a = a,
                    a._b = c
                }
                this._a++
            }
        },
        ap: function(a, b) {
            if (null == b) this.z1(a);
            else if (b === this._c) this.z1(a);
            else {
                if (null == this._b) a._b = null,
                a._a = null,
                this._b = this._c = a;
                else {
                    var c = b._a;
                    b._a = a,
                    a._a = c,
                    c._b = a,
                    a._b = b
                }
                this._a++
            }
        },
        an: function(a, b) {
            if (b === this._c) return this.ae(a);
            if (null == b) return this.ac(a);
            var c = this.ag(a);
            return this.ap(c, b),
            c
        },
        ay: function() {
            return this._a
        },
        ar: function() {
            return 0 === this._a
        },
        af: function() {
            this._b = this._c = null,
            this._a = 0
        },
        am: function() {
            return this._b._c
        },
        at: function() {
            var a = this.am();
            return this.aw(this._b),
            a
        },
        as: function() {
            return this._c._c
        },
        au: function() {
            return this.aw(this._c)
        },
        ak: function(a) {
            for (var b = 0,
            c = this._b; null != c;) {
                if (a === b) return c._c;
                c = c._a,
                b++
            }
            return null
        },
        aj: function(a) {
            return null == a._a ? this._b: a._a
        },
        ai: function(a) {
            return null == a._b ? this._c: a._b
        },
        aw: function(a) {
            return a !== this._b ? a._b._a = a._a: this._b = a._a,
            a !== this._c ? a._a._b = a._b: this._c = a._b,
            this._a--,
            a._c
        },
        av: function(a) {
            return this.aw(a._aa)
        },
        ah: function() {
            return new ne(this)
        },
        al: function(a) {
            for (var b = this._b; null != b;) {
                if (null == b._c && null == a) return b;
                if (b._c === a) return b;
                b = b._a
            }
            return null
        },
        a0: function() {
            for (var a = Gf.d(this._a), b = 0, c = this._b; null != c;) a[b] = c._c,
            c = c._a,
            b++;
            return a
        },
        ax: function() {
            for (var a = this._b; null != a; a = a._b) {
                var b = a._a;
                a._a = a._b,
                a._b = b
            }
            var c = this._b;
            this._b = this._c,
            this._c = c
        },
        a1: function(a) {
            var b = this.a0();
            b.sort(a);
            for (var c = 0,
            d = this._b; null != d;) d._c = b[c],
            d = d._a,
            c++
        },
        a2: function() {
            var a = this.a0();
            a.sort(Gf.c);
            for (var b = 0,
            c = this._b; null != c;) c._c = a[b],
            c = c._a,
            b++
        },
        az: function(a) {
            null == this._b ? (this._b = a._b, this._c = a._c) : null != a._b && (this._c._a = a._b, a._b._b = this._c, this._c = a._c),
            this._a += a._a,
            a._b = a._c = null,
            a._a = 0
        },
        ag: function(a) {
            return new te(a)
        }
    });
    var qe = function(a) {
        qe.superClass.constructor.call(this, a)
    };
    Jb.ext(qe, pe, {
        c1: function() {
            return new oe(this)
        },
        c2: function() {
            return this.am()
        },
        c3: function() {
            return this.at()
        }
    });
    var re = function() {
        this._c = 0
    };
    Jb.ext(re, Object, {
        a: function(a) {
            this._c++,
            a._b = this._b,
            a._a = null,
            null != this._b ? (this._b._a = a, this._b = a) : this._b = this._a = a
        },
        b: function(a, b) {
            if (null == b) return void this.a(a);
            var c = b._b;
            null != c ? c._a = a: this._a = a,
            a._b = c,
            a._a = b,
            b._b = a,
            this._c++
        },
        c: function(a) {
            var b = a._a,
            c = a._b;
            this._c--,
            null != b ? b._b = c: this._b = c,
            null != c ? c._a = b: this._a = b
        }
    });
    var se = function(a, b) {
        this._p = a,
        this._j = b,
        this._o = a._o[b]
    };
    Jb.ext(se, Object, {
        i1: function() {
            return null != this._o
        },
        i2: function() {
            this._o = this._o._k[this._j]
        },
        i3: function() {
            this._o = this._o._f[this._j]
        },
        i4: function() {
            this._o = this._p._o[this._j]
        },
        i5: function() {
            this._o = this._p._q[this._j]
        },
        i7: function() {
            return this._p._n[this._j]
        },
        i6: function() {
            return this._o
        },
        i8: function() {
            return this._o
        }
    });
    var te = function(a) {
        this._c = a
    };
    Jb.ext(te, Object, {
        a: function() {
            return this._a
        },
        b: function() {
            return this._b
        },
        c: function(a) {
            this._c = a
        },
        d: function() {
            return this._c
        }
    });
    var ue = function(a, b, c, d) {
        this._r = a,
        this._s = b,
        this._q = c,
        this._p = d
    };
    Jb.ext(ue, Object, {
        i1: function(a) {
            return this._p[a.a5()]
        },
        i3: function(a) {
            return this._r[a.a5()]
        },
        i2: function(a) {
            return this._s[a.a5()]
        },
        i4: function(a) {
            return this._q[a.a5()]
        },
        i8: function(a, b) {
            this._p[a.a5()] = b
        },
        i6: function(a, b) {
            this._r[a.a5()] = b
        },
        i5: function(a, b) {
            this._s[a.a5()] = b
        },
        i7: function(a, b) {
            this._q[a.a5()] = b
        }
    });
    var ve = function(a) {
        this._a = Gf.d(a),
        this._b = -1
    };
    Jb.ext(ve, Object, {
        d: function() {
            return this._a[this._b]
        },
        b: function() {
            return this._a[this._b--]
        },
        c: function(a) {
            this._a[++this._b] = a
        },
        a: function() {
            return this._b < 0
        }
    });
    var we = function() {};
    Jb.ext(we, Object, {
        a0: function(a) {
            this._c = Gf.d(a)
        }
    });
    var xe = function(a, b, c, d, e, f, g) {
        this._g = 0,
        a.xt(this, b, c, d, e, f, g)
    };
    Jb.ext(xe, we, {
        a5: function() {
            return this._h._u && this._h.b1(),
            this._g
        },
        a2: function() {
            return this._d
        },
        a3: function() {
            return this._e
        },
        a1: function(a) {
            return this._d !== a ? this._d: this._e
        },
        a4: function() {
            for (var a = 0; 1 >= a; a++) this._k[a] = null,
            this._f[a] = null
        },
        a8: function() {
            return this._k[0]
        },
        a7: function() {
            return this._k[1]
        },
        a6: function(a, b, c, d) {
            this.a0(d),
            this._h = a,
            this._k = Gf.d(2),
            this._f = Gf.d(2),
            this._d = b,
            this._e = c
        }
    });
    var ye = function(a) {
        this._j = 0,
        this._h = a,
        this.i4()
    };
    Jb.ext(ye, Object, {
        i2: function() {
            this._k = this._k._k[this._j],
            null == this._k && 0 === this._j && (this._k = this._h._o[1], this._j = 1)
        },
        i3: function() {
            this._k = this._k._f[this._j],
            null == this._k && 1 === this._j && (this._k = this._h._q[0], this._j = 0)
        },
        i4: function() {
            this._k = this._h._o[0],
            null == this._k ? (this._k = this._h._o[1], this._j = 1) : this._j = 0
        },
        i5: function() {
            this._k = this._h._q[1],
            null == this._k ? (this._k = this._h._q[0], this._j = 0) : this._j = 1
        },
        i1: function() {
            return null != this._k
        },
        i6: function() {
            return this._k
        },
        i8: function() {
            return this._k
        },
        i7: function() {
            return this._h.ad()
        }
    });
    var ze = function() {
        this._a = ef._A,
        this._b = ef._A,
        this._c = new nd
    };
    Jb.ext(ze, Object, {
        i1: function() {
            return this._c.size()
        },
        i2: function(a) {
            return this._c.get(a)
        },
        i3: function(a, b, c) {
            this._c.set(a, new Rd(b, c))
        },
        i4: function(a, b) {
            this._c.add(new Rd(a, b))
        },
        i5: function() {
            this._c.clear()
        },
        i6: function() {
            return this._a
        },
        i7: function() {
            return this._b
        },
        i8: function(a) {
            this._a = a
        },
        i9: function(a) {
            this._b = a
        }
    });
    var Ae = function() {
        this._x = 0,
        this._y = 0,
        this._w = 0,
        this._h = 0
    };
    Jb.ext(Ae, Object, {
        i5: function(a, b) {
            this._x = a,
            this._y = b
        },
        i6: function(a, b) {
            this._w = a,
            this._h = b
        },
        i4: function() {
            return this._h
        },
        i3: function() {
            return this._w
        },
        i1: function() {
            return this._x
        },
        i2: function() {
            return this._y
        }
    });
    var Be = function(a, b, c, d) {
        this._m = a,
        this._n = b,
        this._l = c,
        this._k = d
    };
    Jb.ext(Be, Object, {
        i1: function(a) {
            return this._k[a.al()]
        },
        i3: function(a) {
            return this._m[a.al()]
        },
        i2: function(a) {
            return this._n[a.al()]
        },
        i4: function(a) {
            return this._l[a.al()]
        },
        z1: function(a, b) {
            this._k[a.al()] = b
        },
        i6: function(a, b) {
            this._m[a.al()] = b
        },
        i7: function(a, b) {
            this._n[a.al()] = b
        },
        i5: function(a, b) {
            this._l[a.al()] = b
        }
    });
    var Ce = function(a, b) {
        this._b = a,
        this._r = b,
        this._a = [];
        for (var c = this._b - 1; c >= 0; c--) this._a.push(c);
        this._c = new nd
    };
    Jb.ext(Ce, Object, {
        a1: function(a) {
            var b;
            if (0 === this._a.length) {
                this.a2(a, this._b, this._b + this._r);
                for (var c = this._b + this._r - 1; c > this._b; c--) this._a.push(c);
                b = this._b,
                this._b += this._r
            } else b = this._a.pop();
            return b
        },
        b: function(a) {
            var b = this.a1(a),
            c = new le(b, this);
            return this._c.add(c),
            this.a4(a, b),
            c
        },
        c: function(a) {
            var b = this.a1(a),
            c = new me(b, this);
            return this._c.add(c),
            this.a4(a, b),
            c
        },
        a2: function(a, b, c) {
            for (var d = a._a; null != d; d = d._a) {
                var e = Gf.d(c);
                Gf.f(d._c, e, b),
                d._c = e
            }
        },
        a3: function(a, b, c) {
            var d = Gf.d(c);
            Gf.f(a._c, d, b),
            a._c = d
        },
        a4: function(a, b) {
            for (var c = a._a; null != c; c = c._a) c._c[b] = null
        },
        a5: function(a, b) {
            if (a instanceof le) {
                var c = a;
                if (c.c()) throw "Error";
                c.d();
                var d = a._i;
                this._a.indexOf(d) < 0 && (this.a4(b, d), this._a.push(d), this._c.remove(a))
            }
        },
        a6: function(a, b) {
            if (a instanceof me) {
                var c = a;
                if (c.a()) throw "Error";
                c.b();
                var d = c._d;
                this._a.indexOf(d) < 0 && (this.a4(b, d), this._a.push(d), this._c.remove(a))
            }
        }
    });
    var De = function(a) {
        this._id = Jb.id(),
        this._p = 0,
        a.xs(this)
    };
    Jb.ext(De, we, {
        ad: function() {
            return this._n[0] + this._n[1]
        },
        ak: function() {
            return this._n[1]
        },
        ao: function() {
            return this._n[0]
        },
        al: function() {
            return this._g._y && this._g.c(),
            this._p
        },
        ag: function() {
            return this._o[0]
        },
        ae: function() {
            return this._o[1]
        },
        af: function() {
            return new ye(this)
        },
        am: function() {
            return new se(this, 1)
        },
        ap: function() {
            return new se(this, 0)
        },
        an: function() {
            return new Fe(this)
        },
        aq: function() {
            return new Ee(this, 1)
        },
        aw: function() {
            return new Ee(this, 0)
        },
        ah: function(a) {
            for (var b = this._o[0]; null != b; b = b._k[0]) if (b.a3() === a) return b;
            return null
        },
        ai: function(a) {
            for (var b = this._o[1]; null != b; b = b._k[1]) if (b.a2() === a) return b;
            return null
        },
        aj: function(a) {
            var b = this.ah(a);
            return null == b && (b = this.ai(a)),
            b
        },
        au: function(a) {
            this.at(a, 1, Gf.d(this.ak()))
        },
        av: function(a) {
            this.at(a, 0, Gf.d(this.ao()))
        },
        as: function(a, b) {
            this.a0(b),
            this._g = a,
            this._o = Gf.d(2),
            this._q = Gf.d(2),
            this._n = Gf.a(2)
        },
        ab: function(a, b, c, d, e) {
            if (null == b) return void this.aa(a, c, d);
            var f;
            if (f = b._d === b._e ? d: this !== b._d ? 1 : 0, 0 === e) {
                var g = b._k[f];
                a._f[d] = b,
                a._k[d] = g,
                b._k[f] = a,
                null == g ? this._q[c] = a: g._d === g._e ? g._f[d] = a: g._f[this !== g._d ? 1 : 0] = a
            } else {
                var h = b._f[f];
                a._k[d] = b,
                a._f[d] = h,
                b._f[f] = a,
                null == h ? this._o[c] = a: h._d === h._e ? h._k[d] = a: h._k[this !== h._d ? 1 : 0] = a
            }
            this._n[c]++
        },
        aa: function(a, b, c) {
            var d = this._q[b];
            a._k[c] = null,
            null == d ? (this._o[b] = a, a._f[c] = null) : (a._f[c] = d, d._d === d._e ? d._k[c] = a: d._k[this !== d._d ? 1 : 0] = a),
            this._q[b] = a,
            this._n[b]++
        },
        ar: function(a, b, c) {
            var d, e;
            d = a._k[c],
            e = a._f[c],
            null == d ? this._q[b] = e: d._f[d._d !== this ? 1 : 0] = e,
            null == e ? this._o[b] = d: e._k[e._d !== this ? 1 : 0] = d,
            this._n[b]--
        },
        ac: function() {
            for (var a = 0; 1 >= a; a++) this._o[a] = null,
            this._q[a] = null,
            this._n[a] = 0
        },
        at: function(a, b, c) {
            if (! (this._n[b] < 2)) {
                var d, e = this._n[b],
                f = 0;
                for (d = this._o[b]; null != d; d = d._k[b]) c[f] = d,
                f++;
                Gf.s(c, e, a);
                var g = this._o[b] = c[0];
                g._f[b] = null;
                for (var h = 1; e > h;) d = c[h],
                d._f[b] = g,
                g._k[b] = d,
                h++,
                g = d;
                this._q[b] = d,
                d._k[b] = null
            }
        }
    });
    var Ee = function(a, b) {
        Ee.superClass.constructor.call(this, a, b),
        this._h = 1 !== b ? 1 : 0
    };
    Jb.ext(Ee, se, {
        i6: function() {
            return this.i9()
        },
        i9: function() {
            return 0 !== this._h ? this._o._e: this._o._d
        }
    });
    var Fe = function(a) {
        Fe.superClass.constructor.call(this, a)
    };
    Jb.ext(Fe, ye, {
        i6: function() {
            return this._k.a1(this._h)
        },
        i9: function() {
            return this._k.a1(this._h)
        }
    });
    var Ge = function(a) {
        Ge.superClass.constructor.call(this, a)
    };
    Jb.ext(Ge, ne, {
        i9: function() {
            return this.i6()
        }
    });
    var He = function(a) {
        this._o = a,
        this._c = a._a
    };
    Jb.ext(He, Object, {
        i1: function() {
            return null != this._c
        },
        i2: function() {
            this._c = this._c._a
        },
        i3: function() {
            this._c = this._c._b
        },
        i5: function() {
            this._c = this._o._b
        },
        i4: function() {
            this._c = this._o._a
        },
        i7: function() {
            return this._o._c
        },
        i6: function() {
            return this._c
        },
        i9: function() {
            return this._c
        },
        i8: function() {
            return this._c
        }
    });
    var Ie = function(a) {
        if (a && a.length) {
            Ie.superClass.constructor.call(this);
            for (var b = 0; b < a.length; b++) this.ae(a[b])
        } else Ie.superClass.constructor.call(this, a)
    };
    Jb.ext(Ie, pe, {
        x1: function() {
            return new Ge(this)
        },
        x2: function() {
            return this.am()
        },
        x3: function() {
            return this.as()
        },
        x4: function() {
            return this.at()
        }
    });
    var Je = function(a) {
        this._d = a,
        Je.superClass.constructor.call(this)
    };
    Jb.ext(Je, Ie, {});
    var Ke = function(a) {
        this._a = a,
        this._b = new qe,
        this._c = new Ie
    };
    Jb.ext(Ke, Object, {
        a: function() {
            for (var a = this._a.x9(); a.i1(); a.i2()) this.e(a.i9())
        },
        b: function() {
            this.c(),
            this.d()
        },
        c: function() {
            for (; ! this._c.ar();) {
                var a = this._c.x4();
                this._a.xq(a) || this.g(a)
            }
        },
        d: function() {
            for (; ! this._b.ar();) {
                var a = this._b.c3();
                this._a.xp(a) || this.f(a)
            }
        },
        e: function(a) {
            for (var b = a.af(); b.i1(); b.i2()) this._b.ac(b.i8()),
            this._a.h1(b.i8());
            this._c.ac(a),
            this._a.h2(a)
        },
        f: function(a) {
            this._a.u1(a)
        },
        g: function(a) {
            this._a.h3(a)
        }
    }),
    Ke.h = function(a, b) {
        for (b.i4(); b.i1(); b.i2()) {
            var c = b.i8();
            a.xq(c.a2()) || a.h3(c.a2()),
            a.xq(c.a3()) || a.h3(c.a3()),
            a.xp(c) || a.u1(c)
        }
    },
    Ke.i = function(a, b) {
        for (b.i4(); b.i1(); b.i2()) {
            var c = b.i8();
            a.xp(c) && a.h1(c),
            0 === c.a2().ad() && a.h2(c.a2()),
            0 === c.a3().ad() && a.h2(c.a3())
        }
    };
    var Le = function() {
        this._g = arguments[0],
        this._f = this._g.xk(),
        this._h = this._g.xk(),
        this._d = new pe,
        this._e = 0,
        1 !== arguments.length && this.a(arguments[1], arguments[2], arguments[3], arguments[4])
    };
    Jb.ext(Le, Object, {
        a: function(a, b, c, d) {
            for (var e = Gf.d(c - b + 1), f = b; c >= f; f++) e[f] = new Je(f);
            for (var g = this._g.x9(); g.i1(); g.i2()) {
                var h = g.i9(); (null == d || d.i4(h)) && (this._f.z1(h, e[a.i2(h) - b].ac(h)), this._e++)
            }
            for (var i = 0; i < e.length; i++) for (var j = e[i], k = this._d.ae(j), l = j.x1(); l.i1(); l.i2()) this._h.z1(l.i9(), k)
        },
        c: function() {
            this._g.xi(this._h),
            this._g.xi(this._f)
        },
        e: function() {
            return 0 === this._e
        },
        g: function() {
            for (; this._d.am().ar(); this._d.at());
            this._e--;
            var a = this._d.am().x4();
            return this._h.z1(a, null),
            this._f.z1(a, null),
            a
        },
        f: function() {
            for (; this._d.as().ar(); this._d.au());
            this._e--;
            var a = this._d.as().x4();
            return this._h.z1(a, null),
            this._f.z1(a, null),
            a
        },
        d: function(a) {
            var b = this._f.i1(a),
            c = this._h.i1(a),
            d = c.d(),
            e = null,
            f = c.a();
            null != f ? (e = f.d(), this._h.z1(a, f)) : (e = new Je(d._d + 1), this._h.z1(a, this._d.ae(e))),
            d.aw(b),
            this._f.z1(a, e.ac(a))
        },
        b: function(a) {
            var b = this._f.i1(a),
            c = this._h.i1(a),
            d = c.d(),
            e = null,
            f = c.b();
            null != f ? (e = f.d(), this._h.z1(a, f)) : (e = new Je(d._d - 1), this._h.z1(a, this._d.ac(e))),
            d.aw(b),
            this._f.z1(a, e.ac(a))
        }
    });
    var Me = {};
    Me.a1 = function(a) {
        return new Be(a, null, null, null)
    },
    Me.a2 = function(a) {
        return new Be(null, a, null, null)
    },
    Me.a3 = function(a) {
        return new Be(null, null, a, null)
    },
    Me.a4 = function(a) {
        return new ue(null, a, null, null)
    },
    Me.a5 = function(a) {
        return new ue(null, null, a, null)
    },
    Me.a6 = function(a) {
        return new ue(null, null, null, a)
    };
    var Ne = function() {
        if (2 === arguments.length) {
            this._a = new pe,
            this._b = new pe,
            this._c = 0;
            var a = arguments[0],
            b = arguments[1],
            c = new Oe(a._j2.gj(b) / 2, 0);
            this._a.ac(c),
            c = new Oe(a._j2.gj(b) / 2, 0),
            this._b.ac(c)
        } else this._a = arguments[1],
        this._b = arguments[2],
        this._c = arguments[3]
    };
    Jb.ext(Ne, Object, {});
    var Oe = function(a, b) {
        this._b = a,
        this._a = b
    };
    Jb.ext(Oe, Object, {});
    var Pe = function() {
        this._cx = !0,
        this._cs = new _e,
        this._ct = new Ze,
        this._cw = new $e
    };
    Jb.ext(Pe, Object, {
        i5: function(a) {
            this._cx = a
        },
        k: function() {
            var a = new af(this);
            return this._cx && (this._cs.w1(a), a = this._cs),
            this._cw.w1(a),
            a = this._cw,
            this._ct.w1(a),
            a = this._ct
        },
        i2: function(a) {
            this.k().i2(a)
        },
        i1: function(a) {
            return this.k().i1(a)
        }
    });
    var Qe = function() {
        Qe.superClass.constructor.call(this),
        this._jv = 20,
        this._jw = 40,
        this._jx = function(a, b) {
            var c = a.a3(),
            d = b.a3(),
            e = c._g;
            return Math.floor(100 * (e.g5(c) - e.g5(d)))
        }
    };
    Jb.ext(Qe, Pe, {
        i4: function(a) {
            return ie.a1(a)
        },
        i3: function(a) {
            if (!this.i4(a)) throw "Error";
            var b = ie.a3(a);
            if (this._j2 = a, this._j3 = new Re(a), nf.c(a), this._jy = a.xk(), !a.xb()) {
                this.bu();
                var c = this._j3.c1();
                this.f(c),
                this.b(this._j3),
                this.c(this._j3)
            }
            for (var d; ! b.ar(); a.x3(d)) d = b.c3(),
            nf.b(a.g2(d))
        },
        bu: function() {
            if (null != this._jx) for (var a = this._j2.x9(); a.i1(); a.i2()) a.i9().av(this._jx)
        },
        c: function(a) {
            for (var b = this.a2(a), c = Gf.a(b.length), d = 0; d < b.length; d++) {
                for (var e = b[d], f = 0, g = e.ah(); g.i1(); g.i2()) {
                    var h = g.i6();
                    f = Math.max(f, this._j2.g9(h))
                }
                c[d] = f
            }
            for (var i = -this._jw,
            j = 0; j < b.length; j++) {
                i += this._jw + c[j];
                for (var k = b[j], l = k.ah(); l.i1(); l.i2()) {
                    var m = l.i6();
                    this._j2.s2(m, this._j2.g5(m), i - c[j] / 2)
                }
            }
        },
        a2: function(a) {
            for (var b = Gf.d(a.b()), c = 0, d = a.b(); d > c; c++) b[c] = new pe;
            return a.c1(),
            this.a1(a.c1(), 0, b),
            b
        },
        a1: function(a, b, c) {
            c[b].ae(a);
            for (var d = a.aw(); d.i1(); d.i2()) this.a1(d.i9(), b + 1, c)
        },
        b: function(a) {
            var b = a.c1();
            this._j2.s2(b, 0, this._j2.g6(b)),
            this.g(b)
        },
        g: function(a) {
            for (var b = a.aw(); b.i1(); b.i2()) {
                var c = b.i9(),
                d = this._jy.i1(c);
                this._j2.s2(c, this._j2.g5(a) + d._c, this._j2.g6(c)),
                this.g(c)
            }
        },
        f: function(a) {
            if (this._j3.c2(a)) return void this._jy.z1(a, new Ne(this, a));
            var b = a.aw(),
            c = b.i9();
            b.i2(),
            this.f(c);
            var d = this._jy.i1(c),
            e = new Ne(this, d._a, d._b, 0);
            if (!b.i1()) return e._a.ac(new Oe(this._j2.gj(a) / 2, 0)),
            e._b.ac(new Oe(this._j2.gj(a) / 2, 0)),
            void this._jy.z1(a, e);
            for (; b.i1();) {
                c = b.i9(),
                b.i2(),
                this.f(c),
                d = this._jy.i1(c);
                for (var f = e._b.ah(), g = d._a.ah(), h = 2147483647, i = 0, j = 0; f.i1() && g.i1();) {
                    var k = f.i6();
                    f.i2();
                    var l = g.i6();
                    g.i2(),
                    j += k._a,
                    i += l._a,
                    h = Math.min(h, i - j - k._b - l._b)
                }
                d._c = this._jv - h,
                i += d._c;
                var m = d._b.am();
                if (m._a = d._c, f.i1() && !g.i1()) for (var n = j - this.a3(d._b); f.i1(); n = 0) {
                    var o = f.i6();
                    f.i2(),
                    d._b.ae(new Oe(o._b, o._a + n))
                } else if (!f.i1() && g.i1()) {
                    var p = this.a3(e._a);
                    for (p = i - p; g.i1(); p = 0) {
                        var q = g.i6();
                        g.i2(),
                        e._a.ae(new Oe(q._b, q._a + p))
                    }
                }
                e._b = d._b
            }
            this._jy.z1(a, e);
            for (var r = -d._c / 2,
            s = a.aw(); s.i1();) {
                var t = s.i9();
                s.i2();
                var u = this._jy.i1(t);
                u._c += r;
                var v = u._b.am();
                v._a += r,
                v = u._a.am(),
                v._a += r
            }
            e._a.ac(new Oe(this._j2.gj(a) / 2, 0)),
            e._b.ac(new Oe(this._j2.gj(a) / 2, 0))
        },
        a3: function(a) {
            for (var b = 0,
            c = a.ah(); c.i1(); c.i2()) {
                var d = c.i6();
                b += d._a
            }
            return b
        }
    });
    var Re = function(a) {
        this._b = a,
        this.a()
    };
    Jb.ext(Re, Object, {
        c1: function() {
            return null == this._a && this.a(),
            this._a
        },
        b: function() {
            return null == this._a ? -1 : this.d(this._a)
        },
        d: function(a) {
            for (var b = 0,
            c = a.aw(); c.i1(); c.i2()) b = Math.max(b, this.d(c.i9()));
            return b + 1
        },
        c2: function(a) {
            return 0 === a.ao()
        },
        a: function() {
            for (var a = this._b.x9(); a.i1(); a.i2()) if (0 === a.i9().ak()) return void(this._a = a.i9())
        }
    });
    var Se = function(a) {
        this._d = 0,
        this._e = 0,
        this._f = 0,
        this._a = 0,
        this._b = 0,
        this._g = a,
        this._c = new pe
    };
    Jb.ext(Se, Object, {
        a: function() {
            return this._d + this._e + this._f
        }
    });
    var Te = function() {
        Te.superClass.constructor.call(this),
        this._kl = 340,
        this._km = 360,
        this._kk = 40,
        this._ko = .5
    };
    Jb.ext(Te, Pe, {
        ic: function() {
            return this._km
        },
        ia: function() {
            return this._kl
        },
        i9: function() {
            return this._ko
        },
        i3: function(a) {
            if (!ie.a1(a)) throw "Error";
            this._a = a;
            var b = this.i8(),
            c = ie.a4(a, b);
            nf.c(a),
            this._kn = Gf.d(a.x0());
            for (var d = a.x9(); d.i1(); d.i2()) {
                var e = d.i9();
                e !== b ? this.aa(e, new Se(this._kk + this.q(e.aq().i9()))) : this.aa(e, new Se(this._kk))
            }
            this.s(b),
            a.s2(b, 0, 0),
            this.t(b);
            for (var f; ! c.ar(); a.x3(f)) f = c.c3()
        },
        i4: function(a) {
            return ie.a1(a)
        },
        i0: function(a) {
            return this._kn[a.al()]
        },
        i8: function() {
            return ie.a2(this._a)
        },
        i7: function(a) {
            for (var b, c = this.ib(a); b = this.i6(a), !(c >= b);) for (var d = a.aw(); d.i1(); d.i2()) {
                var e = d.i9();
                this.i0(e)._g *= 1 + this._ko
            }
            var f = (c - b) / (2 * a.ao());
            b = 0;
            for (var g = a.aw(); g.i1(); g.i2()) {
                var h = this.i0(g.i9());
                h._d += f,
                h._e += f,
                b += h._d + h._e
            }
            this.id(a)
        },
        id: function(a) {
            for (var b = Gf.d(a.ao()), c = 0, d = a.ap(); d.i1();) b[c] = d.i8(),
            d.i2(),
            c++;
            var e = this;
            b.sort(function(a, b) {
                var c = a.a3(),
                d = b.a3(),
                f = e.i0(c).a() - e.i0(d).a();
                return f > 0 ? 1 : f >= 0 ? 0 : -1
            });
            for (var f = 0; f < b.length; f++) this._a.h1(b[f]);
            for (var g = 0; g < b.length; g += 2) this._a.u1(b[g]);
            for (c = b.length - 1, c % 2 === 0 && c--; c > 0; c -= 2) this._a.u1(b[c])
        },
        ib: function(a) {
            return 0 === a.ak() ? this._km: 2 === a.ao() ? Math.min(180, this._kl) : this._kl
        },
        i6: function(a) {
            for (var b = 0,
            c = a.ap(); c.i1(); c.i2()) {
                for (var d, e = c.i8(), f = e.a3(), g = this.i0(f), h = -g._g, i = g._b, j = g._c, k = 0, l = k + 1, m = j._b, n = m.d(); l > k; l = (d.y - i) / (d.x - h)) d = n,
                m = j.ai(m),
                n = m.d(),
                k = (n.y - d.y) / (n.x - d.x);
                for (g._d = 180 * -Math.atan(l) / Math.PI, k = 0, l = k - 1, m = j._b, n = m.d(); m.a().d().x === n.x; n = m.d()) m = m.a();
                for (var o; k > l; l = (o.y - i) / (o.x - h)) o = n,
                m = j.aj(m),
                n = m.d(),
                k = (n.y - o.y) / (n.x - o.x);
                g._e = 180 * Math.atan(l) / Math.PI,
                b += g._d + g._e
            }
            return b
        },
        aa: function(a, b) {
            this._kn[a.al()] = b
        },
        p: function(a) {
            var b = this.i0(a),
            c = new pe,
            d = 2 * this.q(a);
            c.aa(new Rd(0, 0)),
            c.aa(new Rd(0, d)),
            c.aa(new Rd(d, d)),
            c.aa(new Rd(d, 0)),
            b._c = c,
            b._a = d / 2,
            b._b = d / 2
        },
        r: function(a) {
            if (0 === a.ao()) this.p(a);
            else {
                var b = this.i0(a),
                c = this.q(a),
                d = new pe;
                d.aa(new Rd( - c, -c)),
                d.aa(new Rd( - c, c)),
                d.aa(new Rd(c, -c)),
                d.aa(new Rd(c, c));
                for (var e = a.aw(); e.i1(); e.i2()) {
                    var f = this.i0(e.i9());
                    d.az(f._c)
                }
                for (var g = ef.h(d), h = Number.MAX_VALUE, i = Number.MAX_VALUE, j = Number.MIN_VALUE, k = Number.MIN_VALUE, l = g.ah(); l.i1(); l.i2()) {
                    var m = l.i6();
                    m.x < h && (h = m.x),
                    m.x > j && (j = m.x),
                    m.y < i && (i = m.y),
                    m.y > k && (k = m.y)
                }
                for (var n = new pe,
                o = g.ah(); o.i1(); o.i2()) {
                    var p = o.i6();
                    n.aa(new Rd(p.x - h, p.y - i))
                }
                b._c = n,
                b._a = -h,
                b._b = -i
            }
        },
        s: function(a) {
            if (0 === a.ao()) this.r(a);
            else {
                for (var b = a.aw(); b.i1(); b.i2()) this.s(b.i9());
                this.i7(a);
                for (var c = 0,
                d = a.aw(); d.i1(); d.i2()) {
                    var e = d.i9(),
                    f = this.i0(e),
                    g = 180 - (360 - this.ib(a)) / 2 - c - (f._e + f._f);
                    c += f.a(),
                    g = g / 180 * Math.PI;
                    for (var h = Math.sin(g), i = Math.cos(g), j = f._c._b; null != j; j = j.a()) {
                        var k = j.d(),
                        l = k.x + f._g,
                        m = k.y - f._b,
                        n = new Rd(l * i - h * m, l * h + i * m);
                        j.c(n)
                    }
                    var o = f._a + f._g;
                    f._a = o * i,
                    f._b = o * h
                }
                this.r(a)
            }
        },
        t: function(a) {
            var b = this._a.g4(a),
            c = 0;
            if (a.ak() > 0) {
                var d = a.aq().i9(),
                e = this._a.g4(d);
                c = Math.PI + Math.atan2(e.y - b.y, e.x - b.x)
            }
            for (var f = a.aw(); f.i1(); f.i2()) {
                var g = f.i9(),
                h = this.i0(g);
                if (0 !== c) {
                    var i = Math.cos(c),
                    j = Math.sin(c),
                    k = h._a * i - j * h._b,
                    l = h._a * j + i * h._b;
                    h._a = k,
                    h._b = l
                }
                this._a.s2(g, b.x + h._a, b.y + h._b),
                this.t(g)
            }
        },
        q: function(a) {
            return 1.41 * (Math.max(this._a.gj(a), this._a.g9(a)) / 2)
        }
    });
    var Ue = function() {};
    Jb.ext(Ue, Object, {
        i2: function(a) {
            return a.ad()
        },
        i1: function(a) {
            throw "Error"
        },
        i3: function(a) {
            throw "Error"
        },
        i4: function(a) {
            throw "Error"
        }
    });
    var Ve = function(a) {
        this._a = a
    };
    Jb.ext(Ve, Object, {
        i2: function(a) {
            for (var b = 0,
            c = a.an(); c.i1(); c.i2()) null != this._a.i1(c.i9()) && b++;
            return b
        },
        i4: function(a) {
            return null == this._a.i1(a)
        },
        i1: function(a) {
            throw "Error"
        },
        i3: function(a) {
            throw "Error"
        }
    });
    var We = function() {
        We.superClass.constructor.call(this),
        this._kq = !1,
        this._kp = 90
    };
    Jb.ext(We, Te, {
        a: function(a, b) {
            this._kr = b,
            this._ks = a,
            this._kq = !0
        },
        i7: function(a) {
            if (!this.u(a)) return void We.superClass.i7.call(this, a);
            for (var b = this.i9(), c = this.ib(a), d = (360 - c) / 2 + c, e = new qe(a.ap());;) {
                var f = this.i6(a);
                f = (360 - c) / 2;
                for (var g = null,
                h = null,
                i = e._b; null != i; i = i.a()) {
                    var j = i.d(),
                    k = j.a3(),
                    l = this.i0(k),
                    m = this._ks.i3(j),
                    n = m - (f + l._e);
                    if (n >= 0 && m + l._d >= d && (n = f + l.a() <= d ? d - f - l.a() : 2 * (d - (m + l._d))), l._f = 0, n >= 0) l._f = n,
                    g = i,
                    h = l;
                    else {
                        for ( - n > l._d + l._e ? n = (l._d + l._e) / 2 : n /= -2, f -= n, d >= f && f + l.a() > d && (f += n, n = f + l.a() - d, f -= n); null != g && n > h._f; h = this.i0(g.d().a3())) if (n -= h._f, h._f = 0, g = g.b(), null == g) {
                            h = null;
                            break
                        }
                        null != g ? h._f -= n: f += n
                    }
                    f += l.a()
                }
                if (d >= f) {
                    for (var o = 0,
                    p = (360 - c) / 2, q = a.ap(); q.i1(); q.i2()) {
                        var r = q.i8(),
                        s = r.a3(),
                        t = this._ks.i3(r),
                        u = this.i0(s),
                        v = p + u._f + u._e;
                        o < Math.abs(v - t) && (o = Math.abs(v - t)),
                        p += u.a()
                    }
                    if (o <= this._kp) break
                }
                for (var w = a.aw(); w.i1(); w.i2()) {
                    var x = w.i9();
                    this.i0(x)._g *= 1 + b
                }
            }
        },
        ib: function(a) {
            return this.u(a) ? 0 === a.ak() ? this.ic() : this.ia() : We.superClass.ib.call(this, a)
        },
        u: function(a) {
            return this._kq && 0 !== a.ao() ? null != this._ks.i1(a.ag()) : !1
        }
    });
    var Xe = function(a) {
        this._a = a
    };
    Jb.ext(Xe, Object, {
        i1: function(a) {
            return this._a.i1(a)
        },
        i2: function(a) {
            throw "Error"
        },
        i3: function(a) {
            throw "Error"
        },
        i4: function(a) {
            throw "Error"
        }
    });
    var Ye = function() {};
    Jb.ext(Ye, Object, {
        w1: function(a) {
            this._bb = a
        },
        w2: function() {
            return this._bb
        },
        w4: function(a) {
            null != this._bb && this._bb.i2(a)
        },
        w3: function(a) {
            return null != this._bb ? this._bb.i1(a) : !0
        }
    });
    var Ze = function() {
        this._cg = 45,
        this._ce = 400,
        this._ch = 400,
        this._cf = 0
    };
    Jb.ext(Ze, Ye, {
        i1: function(a) {
            if (null != this.w2()) {
                for (var b = !0,
                c = a.xk(), d = be.a3(a, c), e = Gf.d(d), f = Gf.d(d), g = 0; d > g; g++) e[g] = new Ie,
                f[g] = new qe;
                for (var h = a.xf(); h.i1(); h.i2()) {
                    var i = h.i8();
                    f[c.i2(i.a2())].aa(i),
                    a.h1(i)
                }
                for (var j = a.x9(); j.i1(); j.i2()) {
                    var k = j.i9();
                    e[c.i2(k)].aa(k),
                    a.h2(j.i9())
                }
                for (var l = 0; d > l; l++) {
                    for (var m = e[l].x1(); m.i1(); m.i2()) a.h3(m.i9());
                    for (var n = f[l].c1(); n.i1(); n.i2()) a.u1(n.i8());
                    b = this.w3(a);
                    for (var o = f[l].c1(); o.i1(); o.i2()) a.h1(o.i8());
                    for (var p = e[l].x1(); p.i1(); p.i2()) a.h2(p.i9());
                    if (!b) break
                }
                for (var q = 0; d > q; q++) for (var r = e[q].x1(); r.i1(); r.i2()) a.h3(r.i9());
                for (var s = 0; d > s; s++) for (var t = f[s].c1(); t.i1(); t.i2()) a.u1(t.i8());
                return a.xi(c),
                b
            }
            return ! 0
        },
        i2: function(a) {
            if (!a.xb()) {
                for (var b = a.xk(), c = be.a3(a, b), d = Gf.d(c), e = Gf.d(c), f = Gf.d(c), g = Gf.d(c), h = 0; c > h; h++) d[h] = new Ie,
                e[h] = new qe;
                for (var i = a.xf(); i.i1(); i.i2()) {
                    var j = i.i8();
                    e[b.i2(j.a2())].aa(j),
                    a.h1(j)
                }
                for (var k = a.x9(); k.i1(); k.i2()) {
                    var l = k.i9();
                    d[b.i2(l)].aa(l),
                    a.h2(k.i9())
                }
                for (var m = 0; c > m; m++) {
                    for (var n = d[m].x1(); n.i1(); n.i2()) a.h3(n.i9());
                    for (var o = e[m].c1(); o.i1(); o.i2()) a.u1(o.i8());
                    this.w4(a);
                    var p = a.g3();
                    f[m] = new Ud(p.x, p.y, p.width, p.height);
                    var q = {};
                    if (g[m] = q, this._cf > 0) {
                        var r = this._cg + Math.ceil((p.width + 1) / this._cf) * this._cf,
                        s = this._cg + Math.ceil((p.height + 1) / this._cf) * this._cf;
                        q.x = p.x,
                        q.y = p.y,
                        q.width = r,
                        q.height = s
                    } else q.x = p.x,
                    q.y = p.y,
                    q.width = p.width + this._cg,
                    q.height = p.height + this._cg;
                    for (var t = e[m].c1(); t.i1(); t.i2()) a.h1(t.i8());
                    for (var u = d[m].x1(); u.i1(); u.i2()) a.h2(u.i9())
                }
                for (var v = 0; c > v; v++) for (var w = d[v].x1(); w.i1(); w.i2()) a.h3(w.i9());
                for (var x = 0; c > x; x++) for (var y = e[x].c1(); y.i1(); y.i2()) a.u1(y.i8());
                if (nf.a(g, null, this._ce / this._ch), this._cf <= 0) for (var z = 0; z < g.length; z++) this.w5(a, d[z], e[z], new Rd(g[z].x, g[z].y), f[z]);
                else for (var A = 0; A < g.length; A++) {
                    var B = Math.floor((g[A].x - f[A].x) / this._cf) * this._cf,
                    C = Math.floor((g[A].y - f[A].y) / this._cf) * this._cf,
                    D = f[A].x + B,
                    E = f[A].y + C;
                    this.w5(a, d[A], e[A], new Rd(D, E), f[A])
                }
                a.xi(b)
            }
        },
        w5: function(a, b, c, d, e) {
            for (var f = -e.x + d.x,
            g = -e.y + d.y,
            h = b.x1(); h.i1(); h.i2()) {
                var i = a.ga(h.i9());
                a.s4(h.i9(), new Rd(i.x + f, i.y + g))
            }
            for (var j = c.c1(); j.i1(); j.i2()) {
                for (var k = j.i8(), l = new nd, m = a.gp(k).c(); m.i1(); m.i2()) {
                    var n = m.i6();
                    l.add(new Rd(n.x + f, n.y + g))
                }
                a.s5(k, new Wd(l))
            }
        }
    });
    var $e = function() {};
    Jb.ext($e, Ye, {
        i1: function(a) {
            return this.w3(a)
        },
        i2: function(a) {
            this.w7(a),
            null != this.w2() && this.w4(a),
            this.w6(a)
        },
        w7: function(a) {
            this.e(a),
            this.k(a),
            this.i(a)
        },
        e: function(a) {
            for (var b = a.x9(); b.i1(); b.i2()) {
                var c = a.g4(b.i9());
                a.s1(b.i9(), c)
            }
        },
        w6: function(a) {
            this.l(a),
            this.j(a),
            this.f(a)
        },
        l: function(a) {
            for (var b = a.x9(); b.i1(); b.i2()) {
                var c = a.g4(b.i9());
                a.s1(b.i9(), c)
            }
        },
        j: function(a) {
            for (var b = a.xf(); b.i1(); b.i2()) {
                var c = a.g7(b.i8()),
                d = c.i6();
                c.i8(d),
                d = c.i7(),
                c.i9(d);
                for (var e = 0; e < c.i1(); e++) {
                    var f = c.i2(e);
                    c.i3(e, f.x, f.y)
                }
            }
        },
        k: function(a) {
            for (var b = a.xf(); b.i1(); b.i2()) {
                var c = a.g7(b.i8()),
                d = c.i6();
                c.i8(d),
                d = c.i7(),
                c.i9(d);
                for (var e = 0; e < c.i1(); e++) {
                    var f = c.i2(e);
                    c.i3(e, f.x, f.y)
                }
            }
        },
        f: function(a) {
            null != this._ca && (a.x1("A", this._ca), this._ca = null, this._b6 = null),
            null != this._b8 && (a.x1("B", this._b8), this._b8 = null, this._b9 = null)
        },
        i: function(a) {
            this._ca = a.xc("A"),
            null != this._ca && (this._b6 = new Xe(this._ca), a.x1("A", this._b6)),
            this._b8 = a.xc("B"),
            null != this._b8 && (this._b9 = new Xe(this._b8), a.x1("B", this._b9))
        }
    });
    var _e = function() {
        this._a = new qe,
        this._c = 10
    };
    Jb.ext(_e, Ye, {
        i2: function(a) {
            this._b = a.xl(),
            this.w9(a),
            this.w4(a),
            this.c(a),
            this.w8(a, this._b),
            a.xj(this._b)
        },
        i1: function(a) {
            if (null == this.w2()) return ! 0;
            this._b = a.xl(),
            this.w9(a);
            var b = this.w3(a);
            return this.c(a),
            a.xj(this._b),
            b
        },
        w8: function(a, b) {
            for (var c = a.xf(); c.i1(); c.i2()) {
                var d = c.i8();
                if (null != b.i1(d)) {
                    var e = b.i1(d);
                    nf.g(a, d, e, this._c)
                }
            }
        },
        w9: function(a) {
            for (var b = a.xk(), c = a.x9(); c.i1(); c.i2()) {
                for (var d = c.i9(), e = d.af(); e.i1(); e.i2()) {
                    var f = e.i8(),
                    g = f.a1(d),
                    h = b.i1(g);
                    if (h !== f) if (null == h) b.z1(g, f);
                    else {
                        null == this._b.i1(h) && this._b.i8(h, new qe);
                        var i = this._b.i1(h);
                        i.aa(f),
                        this._a.ac(f),
                        a.h1(f)
                    }
                }
                for (var j = d.af(); j.i1(); j.i2()) {
                    var k = j.i8(),
                    l = k.a1(d);
                    b.z1(l, null)
                }
            }
            a.xi(b)
        },
        c: function(a) {
            for (; ! this._a.ar(); a.u1(this._a.c3()));
        }
    });
    var af = function(a) {
        this._a = a
    };
    Jb.ext(af, Object, {
        i2: function(a) {
            this._a.i3(a)
        },
        i1: function(a) {
            return this._a.i4(a)
        }
    });
    var bf = function() {
        bf.superClass.constructor.call(this),
        this._jo = 30,
        this._jp = new ff,
        this._jt = 5
    };
    Jb.ext(bf, Pe, {
        i4: function(a) {
            return ! 0
        },
        i3: function(a) {
            this._ju = a,
            nf.c(a);
            for (var b = this._jp.i1(a), c = 0, d = a.x9(); d.i1(); d.i2()) c = Math.max(c, this.e(d.i9()));
            c < this._jt && (c = this._jt),
            this.a(b, c)
        },
        a: function(a, b) {
            var c = a.i7(),
            d = 2 * Math.PI / c,
            e = 0,
            f = Gf.a(c);
            a.i4();
            for (var g = 0; c > g;) f[g] = this.e(a.i9()) + this._jo,
            e += f[g],
            g++,
            a.i2();
            var h = e / c,
            i = e / (2 * Math.PI);
            b > i && (i = b),
            a.i4();
            for (var j = 0,
            k = 0; c > k;) {
                var l = d / h * f[k];
                j += l / 2;
                var m = Math.cos(j) * i,
                n = Math.sin(j) * i;
                j += l / 2,
                this._ju.s2(a.i9(), m, n),
                k++,
                a.i2()
            }
            return i
        },
        e: function(a) {
            var b = this._ju.gj(a),
            c = this._ju.g9(a);
            return c >= b ? c: b
        }
    });
    var cf = function() {
        cf.superClass.constructor.call(this),
        this._jm = new bf,
        this._jk = new We
    };
    Jb.ext(cf, Pe, {
        i4: function(a) {
            return ! 0
        },
        i3: function(a) {
            if (! (a.x0() < 2)) {
                this._jn = a,
                nf.c(this._jn),
                nf.e(this._jn);
                var b = new lf(this._jn);
                b.a1(),
                b.h();
                var c = new Ke(this._jn);
                c.a();
                for (var d = b.x9(); d.i1(); d.i2()) {
                    var e = d.i9(),
                    f = b.c2(e);
                    if (f.ay() > 1) {
                        var g = b.d1(e);
                        Ke.h(this._jn, g.c1()),
                        this._jm.i3(this._jn);
                        var h = this._jn.g3();
                        b.s7(e, h.width, h.height)
                    } else if (1 === f.ay()) {
                        var i = f.x2();
                        b.s8(e, this._jn.gm(i)),
                        this._jn.s2(i, 0, 0)
                    } else b.s7(e, 1, 1);
                    Ke.i(this._jn, this._jn.xf())
                }
                c.b();
                var j = this.a7(b);
                ie.a4(b, j);
                var k = b.xk(),
                l = b.xl();
                this.a2(b, l, k),
                this.a1(b, l),
                this.a3(b, j, l),
                this._jk.a(l, k),
                this._jk.i3(b),
                this.a5(b, j, k);
                for (var m = b.x9(); m.i1(); m.i2()) for (var n = m.i9(), o = b.g4(n), p = b.c2(n).x1(); p.i1(); p.i2()) {
                    var q = p.i9();
                    this._jn.s2(q, o.x + this._jn.g5(q), o.y + this._jn.g6(q))
                }
            }
        },
        a7: function(a) {
            for (var b = -1,
            c = null,
            d = a.x9(); d.i1(); d.i2()) {
                var e = d.i9();
                a.c2(e).ay() > b && (c = e, b = a.c2(e).ay())
            }
            return c
        },
        a1: function(a, b) {
            for (var c = function(a, c) {
                var d = b.i3(a) - b.i3(c);
                return d > 0 ? 1 : d >= 0 ? 0 : -1
            },
            d = a.x9(); d.i1(); d.i2()) d.i9().av(c)
        },
        a2: function(a, b, c) {
            for (var d = Gf.a(this._jn.x0()), e = a.x9(); e.i1(); e.i2()) for (var f = e.i9(), g = a.c2(f), h = g.x1(); h.i1(); h.i2()) {
                var i = h.i9();
                d[i.al()] = f.al()
            }
            var j = ie.a2(a);
            this.a4(a, j, d, b, c)
        },
        a3: function(a, b, c) {
            if (a.c2(b).ay() > 1) {
                for (var d = 0,
                e = 0,
                f = 0,
                g = b.ap(); g.i1(); g.i2()) {
                    var h = g.i8(),
                    i = c.i3(h);
                    i - d > e && (e = i - d, f = (d + i) / 2),
                    d = i
                }
                360 - d > e && (f = (360 + d) / 2),
                this.a6(a, b, f);
                for (var j = b.ap(); j.i1(); j.i2()) {
                    var k = j.i8(),
                    l = c.i3(k);
                    for (l -= f; 0 > l; l += 360);
                    c.i6(k, l)
                }
                b.av(function(a, b) {
                    var d = c.i3(a) - c.i3(b);
                    return d > 0 ? 1 : d >= 0 ? 0 : -1
                })
            }
        },
        a4: function(a, b, c, d, e) {
            for (var f = b.al(), g = e.i3(b), h = b.ap(); h.i1(); h.i2()) {
                for (var i = h.i8(), j = a.b(i), k = 0, l = 0, m = 0, n = 0, o = j.c1(); o.i1(); o.i2()) {
                    var p = o.i8(),
                    q = null,
                    r = null;
                    c[p.a2().al()] === f ? (q = p.a2(), r = p.a3()) : (q = p.a3(), r = p.a2()),
                    m -= this._jn.g5(q),
                    n += this._jn.g6(q),
                    k -= this._jn.g5(r),
                    l += this._jn.g6(r)
                }
                if (0 !== m || 0 !== n) {
                    var s;
                    for (s = 180 * Math.atan2(n, m) / Math.PI - g; 0 > s; s += 360);
                    d.i6(i, s)
                }
                if (0 !== k && 0 !== l) {
                    var t = 180 * Math.atan2(l, k) / Math.PI;
                    0 > t && (t += 360),
                    e.i6(i.a3(), t)
                }
                this.a4(a, i.a3(), c, d, e)
            }
        },
        a5: function(a, b, c) {
            for (var d = a.g4(b), e = b.ap(); e.i1(); e.i2()) {
                var f = e.i8(),
                g = f.a3(),
                h = a.g4(g),
                i = h.x - d.x,
                j = h.y - d.y,
                k = 180 * Math.atan2(j, i) / Math.PI;
                if (null != c.i1(g)) {
                    var l = c.i3(g);
                    k += l
                }
                this.a6(a, g, k),
                this.a5(a, g, c)
            }
        },
        a6: function(a, b, c) {
            c = c / 180 * Math.PI;
            var d = a.c2(b);
            if (! (d.ay() <= 1)) for (var e = d.x1(); e.i1(); e.i2()) {
                var f = e.i9(),
                g = this._jn.g5(f),
                h = this._jn.g6(f),
                i = Math.cos(c),
                j = Math.sin(c),
                k = g * i - j * h,
                l = g * j + i * h;
                this._jn.s2(f, k, l)
            }
        }
    });
    var df = function() {
        this._a = (new Date).getTime()
    };
    Jb.ext(df, Object, {
        b: function() {
            return (new Date).getTime() - this._a
        }
    });
    var ef = {};
    ef._A = new Rd(0, 0),
    ef.b = function(a, b, c) {
        return ef.c(a.x, a.y, b.x, b.y, c.x, c.y)
    },
    ef.c = function(a, b, c, d, e, f) {
        c -= a,
        d -= b,
        e -= a,
        f -= b;
        var g = e * d - f * c;
        return Math.abs(g) < 1e-5 ? 0 : g >= 0 ? 0 >= g ? 0 : -1 : 1
    },
    ef.d = function(a, b, c) {
        return ef.b(a, b, c) > 0
    },
    ef.f = function(a, b, c) {
        return ef.b(a, b, c) < 0
    },
    ef.g = function(a, b, c) {
        return 0 === ef.b(a, b, c)
    },
    ef.h = function(a) {
        return ef.i(a)
    },
    ef.i = function(a) {
        var b = new pe(a.ah()),
        c = new pe;
        if (b.a2(), b.ar()) return c;
        var d = b.at();
        for (c.ae(d); ! b.ar() && d.equals(b.am()); b.at());
        if (b.ar()) return c;
        d = b.at();
        for (var e = c.ae(d), f = b.ah(); f.i1(); f.i2()) {
            var g = f.i6();
            if (!g.equals(d)) if (d = g, 2 === c.ay() && ef.g(c.am(), c.as(), g)) e.c(g);
            else {
                var h;
                for (h = e; ! ef.f(c.ai(h).d(), h.d(), g); h = c.ai(h));
                var i;
                for (i = e; ! ef.d(c.aj(i).d(), i.d(), g); i = c.aj(i));
                for (; i !== c.aj(h); c.aw(c.aj(h)));
                e = c.an(g, h)
            }
        }
        return c
    },
    ef.j = function() {
        return ef.k(Number.MAX_VALUE)
    },
    ef.k = function(a) {
        return Math.floor(Ib.Util.random() * a)
    },
    ef.l = function(a, b) {
        return Ib.Util.random() * (b - a) + a
    };
    var ff = function() {};
    Jb.ext(ff, Object, {
        i1: function(a) {
            this._b = a;
            var b = new qe;
            b = be.a6(a),
            b.az(be.a7(a));
            for (var c = this.a1(); ! b.ar(); a.x5(b.c3()));
            return c.x1()
        },
        a1: function() {
            if (this._b.x0() < 3) return new Ie(this._b.x9());
            for (var a = this._b.xk(), b = this._b.xk(), c = this._b.xl(), d = new Le(this._b, new Ue, 0, this.a3(this._b)), e = this._b.x0(), f = new qe, g = new qe, h = new Ke(this._b); e > 3; e--) {
                for (var i = d.g(), j = i.an(); j.i1(); j.i2()) a.z1(j.i9(), e),
                b.i5(j.i9(), !1);
                for (var k = i.an(); k.i1(); k.i2()) for (var l = k.i9(), m = l.ap(); m.i1(); m.i2()) {
                    var n = m.i8();
                    a.i2(n.a3()) === e && (g.aa(n), b.i5(n.a2(), !0), b.i5(n.a3(), !0))
                }
                if (g.ay() < i.ad() - 1) {
                    for (var o = null,
                    p = i.an(); p.i1(); p.i2()) {
                        var q = p.i9();
                        if (a.i2(q) === e && !b.i4(q)) if (null == o) o = q;
                        else {
                            var r = this._b.xo(o, q);
                            c.i7(r, !0),
                            g.aa(r),
                            o = null
                        }
                    }
                    if (null != o) for (var s = i.an(); s.i1(); s.i2()) {
                        var t = s.i9();
                        if (t !== o && null == t.aj(o)) {
                            var u = this._b.xo(o, t);
                            c.i7(u, !0),
                            g.aa(u);
                            break
                        }
                    }
                    if (g.ay() < i.ad() - 1) {
                        for (var v = 2147483647,
                        w = null,
                        x = i.an(); x.i1(); x.i2()) {
                            var y = x.i9();
                            y.ad() < v && (w = y, v = y.ad())
                        }
                        for (var z = i.an(); z.i1(); z.i2()) {
                            var A = z.i9();
                            if (null == w.aj(A) && w !== A) {
                                var B = this._b.xo(w, A);
                                if (c.i7(B, !0), g.aa(B), g.ay() >= i.ad() - 1) break
                            }
                        }
                    }
                }
                for (var C = i.an(); C.i1(); C.i2()) d.b(C.i9());
                for (var D = g.c1(); D.i1(); D.i2()) {
                    var E = D.i8();
                    c.i4(E) && (d.d(E.a2()), d.d(E.a3()))
                }
                f.az(g),
                h.e(i)
            }
            h.b(),
            d.c();
            for (var F = f.c1(); F.i1(); F.i2()) {
                var G = F.i8();
                null != G._h && (c.i4(G) ? this._b.x5(G) : this._b.h1(G))
            }
            var H = this.a4(this._b),
            I = new Ie,
            J = H.ak(0),
            K = H.ak(1),
            L = null;
            L = J.a2() === K.a2() || J.a2() === K.a3() ? J.a3() : J.a2(),
            I.aa(L);
            for (var M = H.c1(); M.i1(); M.i2()) {
                var N = M.i8();
                L = N.a1(L),
                I.aa(L)
            }
            for (var O = f.c1(); O.i1(); O.i2()) {
                var P = O.i8();
                c.i4(P) || null != P._h || this._b.u1(P)
            }
            return this._b.xi(b),
            this._b.xj(c),
            this._b.xi(a),
            this.a2(I),
            I
        },
        a2: function(a) {
            if (a.ay() < this._b.x0()) {
                for (var b = this._b.xk(), c = a._b; null != c; c = c.a()) {
                    var d = c.d();
                    b.z1(d, c)
                }
                var e;
                for (e = new Le(this._b, new Ve(b), 0, a.ay(), new Ve(b)); ! e.e();) {
                    for (var f = e.f(), g = f.an(); g.i1(); g.i2()) {
                        var h = g.i9();
                        if (null != b.i1(h)) {
                            var i = b.i1(h),
                            j = a.ai(i).d(),
                            k = null;
                            k = null != f.aj(j) ? a.ao(f, i) : a.an(f, i),
                            b.z1(f, k);
                            break
                        }
                    }
                    for (var l = f.an(); l.i1(); l.i2()) {
                        var m = l.i9();
                        null == b.i1(m) && e.d(m)
                    }
                }
                this._b.xi(b),
                e.c()
            }
        },
        a3: function(a) {
            for (var b = 0,
            c = a.x9(); c.i1(); c.i2()) b = Math.max(b, c.i9().ad());
            return b
        },
        a4: function(a) {
            for (var b = [], c = 0, d = a.x0(); d > c; c++) b[c] = new ge;
            var e = new ee(b);
            e.a6(!1),
            e.a8(a);
            for (var f = -1,
            g = null,
            h = a.x9(); h.i1(); h.i2()) {
                var i = h.i9(),
                j = b[i.al()];
                j._a + j._c > f && (f = j._a + j._c, g = i)
            }
            for (var k = new qe,
            l = g,
            m = b[l.al()]._d; null != m; m = b[l.al()]._d) k.ac(m),
            l = m.a1(l);
            l = g;
            for (var n = b[l.al()]._b; null != n; n = b[l.al()]._d) k.ae(n),
            l = n.a1(l);
            return k
        }
    });
    var gf = function() {
        this._v = new re,
        this._x = new re,
        this._z = new Ce(3, 5),
        this._w = new Ce(3, 5),
        this._y = !1,
        this._u = !1,
        this._t = {}
    };
    Jb.ext(gf, Object, {
        xm: function() {
            var a = new De(this);
            return a
        },
        xo: function(a, b) {
            return this.xn(a, null, b, null, 0, 0)
        },
        xn: function(a, b, c, d, e, f) {
            return new xe(this, a, b, c, d, e, f)
        },
        x4: function(a) {
            this.b3(a)
        },
        b3: function(a) {
            for (var b; null != (b = a._o[0]);) this.x5(b);
            for (; null != (b = a._o[1]);) this.x5(b);
            this._v.c(a),
            a._g = null,
            this._y = !0
        },
        x5: function(a) {
            this.a11(a)
        },
        a11: function(a) {
            if (a._h !== this) throw "Error";
            var b = a.a2(),
            c = a.a3();
            this.a12(a, b, c),
            this._x.c(a),
            a._h = null,
            this._u = !0
        },
        x7: function(a) {
            a._p = this._v._c,
            a._g = this,
            a.ac(),
            a._c.length < this._z._b && this._z.a3(a, a._c.length, this._z._b),
            this._v.a(a),
            this._y = !0
        },
        x8: function(a) {
            if (null != a._h) throw "Error";
            a._c.length < this._w._b && this._w.a3(a, a._c.length, this._w._b),
            null == a._a || a._a._h !== this ? this._x.a(a) : this._x.b(a, a._a),
            a._h = this,
            a.a4(),
            this.b2(a, a.a2(), null, a.a3(), null, 0, 0),
            this._u = !0
        },
        xr: function(a, b, c) {
            var d = a.a2(),
            e = a.a3();
            null == a._h ? (a._d = b, a._e = c) : (d !== b && (d.ar(a, 0, 0), a._d = b, b.ab(a, null, 0, 0, 0)), e !== c && (e.ar(a, 1, 1), a._e = c, c.ab(a, null, 1, 1, 0)))
        },
        x3: function(a) {
            this.xr(a, a.a3(), a.a2())
        },
        h1: function(a) {
            this.a11(a)
        },
        u1: function(a) {
            this.x8(a)
        },
        h2: function(a) {
            this.x4(a)
        },
        h3: function(a) {
            this.x7(a)
        },
        xa: function() {
            return this._v._c
        },
        x0: function() {
            return this._v._c
        },
        xh: function() {
            return this._x._c
        },
        xg: function() {
            return this._x._c
        },
        xb: function() {
            return 0 === this._v._c
        },
        xq: function(a) {
            return a._g === this
        },
        xp: function(a) {
            return a._h === this
        },
        xd: function() {
            return this._v._a
        },
        x9: function() {
            return new He(this._v)
        },
        xf: function() {
            return new He(this._x)
        },
        x2: function(a, b) {
            var c = Gf.d(this.xh());
            if (null != a && null != b) for (var d = this.x9(); d.i1(); d.i2()) d.i9().at(a, 1, c),
            d.i9().at(b, 0, c);
            else if (null == b && null != a) for (var e = this.x9(); e.i1(); e.i2()) e.i9().at(a, 1, c);
            else if (null != b && null == a) for (var f = this.x9(); f.i1(); f.i2()) f.i9().at(b, 0, c)
        },
        xk: function() {
            return this._z.b(this._v)
        },
        xl: function() {
            return this._w.c(this._x)
        },
        xi: function(a) {
            this._z.a5(a, this._v)
        },
        xj: function(a) {
            this._w.a6(a, this._x)
        },
        xc: function(a) {
            return this._t[a]
        },
        x1: function(a, b) {
            this._t[a] = b
        },
        x6: function(a) {
            delete this._t[a]
        },
        b2: function(a, b, c, d, e, f, g) {
            b.ab(a, c, 0, 0, f),
            d.ab(a, e, 1, 1, g)
        },
        a12: function(a, b, c) {
            b.ar(a, 0, 0),
            c.ar(a, 1, 1)
        },
        c: function() {
            for (var a = 0,
            b = this.x9(); b.i1(); b.i2()) b.i9()._p = a++;
            this._y = !1
        },
        b1: function() {
            for (var a = 0,
            b = this.xf(); b.i1(); b.i2()) b.i8()._g = a++;
            this._u = !1
        },
        xs: function(a) {
            a.as(this, this._z._b),
            a._p = this._v._c,
            this._v.a(a)
        },
        xt: function(a, b, c, d, e, f, g) {
            a.a6(this, b, d, this._w._b),
            a._g = this._x._c,
            this._x.a(a),
            this.b2(a, a.a2(), c, a.a3(), e, f, g)
        }
    });
    var hf = function() {
        hf.superClass.constructor.call(this)
    };
    Jb.ext(hf, gf, {
        gb: function(a) {
            return this.g1(a)
        },
        g7: function(a) {
            return this.g2(a)
        },
        g5: function(a) {
            var b = this.g1(a);
            return b.i1() + b.i3() / 2
        },
        g6: function(a) {
            var b = this.g1(a);
            return b.i2() + b.i4() / 2
        },
        g4: function(a) {
            return new Rd(this.g5(a), this.g6(a))
        },
        gi: function(a) {
            return this.g1(a).i1()
        },
        gh: function(a) {
            return this.g1(a).i2()
        },
        ga: function(a) {
            var b = this.g1(a);
            return new Rd(b.i1(), b.i2())
        },
        gj: function(a) {
            return this.g1(a).i3()
        },
        g9: function(a) {
            return this.g1(a).i4()
        },
        gm: function(a) {
            return new Sd(this.gj(a), this.g9(a))
        },
        s1: function(a, b) {
            this.s2(a, b.x, b.y)
        },
        s2: function(a, b, c) {
            var d = this.g1(a);
            d.i5(b - d.i3() / 2, c - d.i4() / 2)
        },
        s7: function(a, b, c) {
            this.g1(a).i6(b, c)
        },
        s8: function(a, b) {
            this.s7(a, b.width, b.height)
        },
        s3: function(a, b, c) {
            this.g1(a).i5(b, c)
        },
        s4: function(a, b) {
            this.s3(a, b.x, b.y)
        },
        gp: function(a) {
            for (var b = this.g2(a), c = new nd, d = 0; d < b.i1(); d++) c.add(b.i2(d));
            return new Wd(c)
        },
        gf: function(a) {
            for (var b = this.g2(a), c = new pe, d = 0; d < b.i1(); d++) c.aa(b.i2(d));
            return c
        },
        gc: function(a) {
            var b = new nd;
            b.add(this.gs(a));
            for (var c = this.gp(a).d(); c.i1(); c.i2()) b.add(c.i6());
            return b.add(this.gl(a)),
            new Wd(b)
        },
        gd: function(a) {
            var b = new pe;
            b.aa(this.gs(a));
            for (var c = this.gp(a).d(); c.i1(); c.i2()) b.aa(c.i6());
            return b.aa(this.gl(a)),
            b
        },
        m1: function(a, b) {
            var c = this.g2(a);
            c.i5();
            var d = b.ah(),
            e = d.i6();
            this.gx(a, e);
            var f = b.as();
            for (d.i2(); d.i6() !== f; d.i2()) {
                var g = d.i6();
                c.i4(g.x, g.y)
            }
            this.gy(a, f)
        },
        s5: function(a, b) {
            var c = this.g2(a);
            c.i5();
            for (var d = b.d(); d.i1(); d.i2()) {
                var e = d.i6();
                c.i4(e.x, e.y)
            }
        },
        s6: function(a, b) {
            var c = this.g2(a);
            c.i5();
            for (var d = b.ah(); d.i1(); d.i2()) {
                var e = d.i6();
                c.i4(e.x, e.y)
            }
        },
        m2: function(a, b, c) {
            this.gx(a, b),
            this.gy(a, c)
        },
        gn: function(a) {
            return this.g2(a).i6()
        },
        gk: function(a) {
            return this.g2(a).i7()
        },
        gt: function(a, b) {
            this.g2(a).i8(b)
        },
        gz: function(a, b) {
            this.g2(a).i9(b)
        },
        gs: function(a) {
            var b = this.g2(a).i6();
            if (null == b) return this.g4(a.a2());
            var c = new Rd(this.g5(a.a2()) + b.x, this.g6(a.a2()) + b.y);
            return c
        },
        gl: function(a) {
            var b = this.g2(a).i7();
            if (null == b) return this.g4(a.a3());
            var c = new Rd(this.g5(a.a3()) + b.x, this.g6(a.a3()) + b.y);
            return c
        },
        gx: function(a, b) {
            var c = new Rd(b.x - this.g5(a.a2()), b.y - this.g6(a.a2()));
            this.g2(a).i8(c)
        },
        gy: function(a, b) {
            var c = new Rd(b.x - this.g5(a.a3()), b.y - this.g6(a.a3()));
            this.g2(a).i9(c)
        },
        g8: function() {
            for (var a = new qe,
            b = this.xf(); b.i1(); b.i2()) a.aa(b.i8());
            return a
        },
        g3: function() {
            for (var a, b, c = a = Number.MAX_VALUE,
            d = b = Number.MIN_VALUE,
            e = this.x9(); e.i1(); e.i2()) {
                var f = this.ga(e.i9()),
                g = this.gm(e.i9());
                c = Math.min(f.x, c),
                a = Math.min(f.y, a),
                d = Math.max(f.x + g.width, d),
                b = Math.max(f.y + g.height, b)
            }
            for (var h = this.xf(); h.i1(); h.i2()) for (var i = this.gp(h.i8()).c(); i.i1(); i.i2()) {
                var j = i.i6();
                c = Math.min(j.x, c),
                a = Math.min(j.y, a),
                d = Math.max(j.x, d),
                b = Math.max(j.y, b)
            }
            return {
                x: Math.floor(c),
                y: Math.floor(a),
                width: Math.floor(d - c),
                height: Math.floor(b - a)
            }
        }
    });
    var jf = function() {
        jf.superClass.constructor.call(this),
        this.a(new ae, new $d)
    };
    Jb.ext(jf, hf, {
        a: function(a, b) {
            this._a3 = a,
            this._a4 = b
        },
        xo: function(a, b) {
            return this.l2(a, b, this._a4.a6())
        },
        l2: function(a, b, c) {
            return this.l1(a, null, b, null, 0, 0, c)
        },
        xn: function(a, b, c, d, e, f) {
            return this.l1(a, b, c, d, e, f, this._a4.a6())
        },
        l1: function(a, b, c, d, e, f, g) {
            var h = new xe(this, a, b, c, d, e, f);
            return h._l = g,
            h
        },
        xm: function() {
            var a = new De(this);
            return a._r = this._a3.m3(),
            a
        },
        g3: function() {
            for (var a = {
                x: 0,
                y: 0,
                width: -1,
                height: -1
            },
            b = this.x9(); b.i1(); b.i2()) b.i9()._r.m1(a);
            return a
        },
        g1: function(a) {
            return a._r
        },
        g2: function(a) {
            return a._l
        },
        g5: function(a) {
            return a._r.m4()
        },
        g6: function(a) {
            return a._r.m5()
        },
        gi: function(a) {
            return a._r.i1()
        },
        gh: function(a) {
            return a._r.i2()
        },
        gj: function(a) {
            return a._r.i3()
        },
        g9: function(a) {
            return a._r.i4()
        },
        s2: function(a, b, c) {
            a._r.m6(b, c)
        },
        s7: function(a, b, c) {
            a._r.i6(b, c)
        },
        s3: function(a, b, c) {
            a._r.i5(b, c)
        }
    });
    var kf = function() {
        kf.superClass.constructor.call(this),
        this._ap = this.xk(),
        this._as = this.xl()
    };
    Jb.ext(kf, hf, {
        g1: function(a) {
            var b = this._ap.i1(a);
            return null == b && (b = new Ae, this._ap.z1(a, b)),
            b
        },
        g2: function(a) {
            var b = this._as.i1(a);
            return null == b && (b = new ze, this._as.i8(a, b)),
            b
        }
    });
    var lf = function(a) {
        lf.superClass.constructor.call(this),
        this._ay = a,
        this._a0 = this.xk(),
        this._au = this.xl()
    };
    Jb.ext(lf, kf, {
        c2: function(a) {
            var b = this._a0.i1(a);
            return b
        },
        a2: function(a, b) {
            this._a0.z1(a, b)
        },
        h: function() {
            null == this._az && (this._az = this.xk());
            for (var a = Gf.a(this._ay.x0() + 1), b = 1, c = this.x9(); c.i1();) {
                for (var d = this.c2(c.i9()), e = d.x1(); e.i1(); e.i2()) {
                    var f = e.i9();
                    a[f.al()] = b
                }
                for (var g = new qe,
                h = d.x1(); h.i1(); h.i2()) for (var i = h.i9(), j = a[i.al()], k = i.ap(); k.i1(); k.i2()) {
                    var l = k.i8(),
                    m = l.a3(),
                    n = a[m.al()];
                    n === j && g.ac(l)
                }
                this._az.z1(c.i9(), g),
                c.i2(),
                b++
            }
        },
        d1: function(a) {
            return this._az.i1(a)
        },
        b: function(a) {
            return this._au.i1(a)
        },
        a3: function(a, b) {
            this._au.i8(a, b)
        },
        a1: function() {
            var a = this._ay.xk(),
            b = Me.a4(Gf.a(this._ay.xh())),
            c = be.a1(this._ay, b, a),
            d = be.a5(this._ay, b, c);
            this.d2(a, d),
            this._ay.xi(a)
        },
        c1: function(a) {
            for (var b = null,
            c = -1,
            d = 0,
            e = a.length; e > d; d++) {
                var f = a[d];
                f.ay() > c && (b = f, c = f.ay())
            }
            return b
        },
        d2: function(a, b) {
            for (var c = this._ay.xl(), d = this._ay.xk(), e = b.length, f = 0; e > f; f++) for (var g = b[f], h = g.c1(); h.i1(); h.i2()) c.i8(h.i8(), g);
            var i = this.c1(b);
            this.a4(i, a, c, new nd, d);
            var j = {};
            e = b.length;
            for (var k = 0; e > k; k++) {
                var l = b[k];
                if (l.ay() > 1) {
                    var m = this.xm();
                    j[l._id] = m
                }
            }
            for (var n = this._ay.x9(); n.i1(); n.i2()) {
                var o = n.i9();
                if (a.i4(o) && null == d.i1(o)) {
                    var p = this.xm();
                    j[o._id] = p;
                    var q = new Ie;
                    q.aa(o),
                    this.a2(p, q)
                }
            }
            var r = Gf.d(2);
            e = b.length;
            for (var s = 0; e > s; s++) {
                var t = b[s];
                if (1 === t.ay()) {
                    var u = t.c2();
                    r[0] = u.a2(),
                    r[1] = u.a3();
                    for (var v = 0; 2 > v; v++) {
                        var w = r[v];
                        if (1 === w.ad()) {
                            var x = this.xm();
                            j[w._id] = x;
                            var y = new Ie;
                            y.aa(w),
                            this.a2(x, y)
                        }
                    }
                }
            }
            for (var z = this._ay.x9(); z.i1(); z.i2()) {
                var A = z.i9();
                if (null != d.i1(A)) for (var B = d.i1(A), C = j[B._id], D = A.af(); D.i1(); D.i2()) {
                    var E = D.i8();
                    if (c.i1(E) !== B) {
                        var F = j[c.i1(E)._id];
                        if (null == F) {
                            var G = E.a1(A),
                            H = d.i1(G);
                            F = null != H ? j[H._id] : j[G._id]
                        }
                        var I = C.aj(F),
                        J = null;
                        null == I ? (I = this.xo(C, F), J = new qe) : J = this.b(I),
                        J.aa(E),
                        this.a3(I, J)
                    }
                } else if (a.i4(A)) for (var K = j[A._id], L = A.af(); L.i1(); L.i2()) {
                    var M = L.i8(),
                    N = M.a1(A),
                    O = j[N._id];
                    if (null != O) {
                        var P = K.aj(O);
                        if (null == P) {
                            var Q = this.xo(K, O),
                            R = new qe;
                            R.aa(M),
                            this.a3(Q, R)
                        }
                    }
                }
            }
            if (2 === this._ay.x0() && 1 === this._ay.xg()) {
                var S = this._ay.xf().i8(),
                T = j[S.a2()._id],
                U = j[S.a3()._id];
                if (null != U && null != T && null == U.aj(T)) {
                    var V = this.xo(T, U),
                    W = new qe;
                    W.aa(S),
                    this.a3(V, W)
                }
            }
            var X = Gf.a(this._ay.x0()),
            Y = 1;
            e = b.length;
            for (var Z = 0; e > Z; Z++) {
                var $ = b[Z],
                _ = j[$._id];
                if (null != _) {
                    var aa = this.c2(_);
                    null == aa && (aa = new Ie, this.a2(_, aa));
                    for (var ba = $.c1(); ba.i1(); ba.i2()) {
                        var ca = ba.i8(),
                        da = ca.a2();
                        X[da.al()] === Y || a.i4(da) && d.i1(da) !== $ || (X[da.al()] = Y, aa.aa(da)),
                        da = ca.a3(),
                        X[da.al()] === Y || a.i4(da) && d.i1(da) !== $ || (X[da.al()] = Y, aa.aa(da))
                    }
                }
            }
            this._ay.xj(c),
            this._ay.xi(d)
        },
        a4: function(a, b, c, d, e) {
            if (!d.contains(a)) {
                d.add(a);
                for (var f = [], g = a.c1(); g.i1(); g.i2()) {
                    var h = g.i8();
                    f[0] = h.a2(),
                    f[1] = h.a3();
                    for (var i = 0; 2 > i; i++) {
                        var j = f[i];
                        if (b.i4(j) && null == e.i1(j)) {
                            a.ay() > 1 && e.z1(j, a);
                            for (var k = j.af(); k.i1(); k.i2()) {
                                var l = c.i1(k.i8());
                                this.a4(l, b, c, d, e)
                            }
                        }
                    }
                }
            }
        }
    });
    var mf = function(a, b, c, d, e) {
        this._a = {},
        mf.superClass.constructor.call(this);
        var f, g, h = new nd;
        for (f = 0, g = b.size(); g > f; f++) {
            var i = b.get(f);
            if (i instanceof Ib.Link) h.add(i);
            else {
                var j = d && null == e && i instanceof Md;
                j && i.setExpanded(!0);
                var k = a.getDimension(i);
                if (j && i.setExpanded(!1), null == k) continue;
                var l = this.xm(),
                m = a._repulsion;
                "rightleft" === c || "leftright" === c ? this.s7(l, k.height * m, k.width * m) : this.s7(l, k.width * m, k.height * m),
                l.node = i,
                this._a[i.getId()] = l
            }
        }
        for (f = 0, g = h.size(); g > f; f++) {
            var n = h.get(f),
            o = n.getFromAgent(),
            p = n.getToAgent(),
            q = this._a[o.getId()],
            r = this._a[p.getId()];
            null != q && null != r && q !== r && this.xo(q, r)
        }
    };
    Jb.ext(mf, jf, {});
    var nf = {};
    nf._D = new Wd,
    nf._E = new Rd(0, 0),
    nf.b = function(a) {
        if (a.i1() > 0) {
            for (var b = new nd,
            c = a.i1() - 1; c >= 0; c--) b.add(a.i2(c));
            a.i5();
            for (var d = 0,
            e = b.size(); e > d; d++) {
                var f = b.get(d);
                a.i4(f.x, f.y)
            }
        }
        var g = a.i6();
        a.i8(a.i7()),
        a.i9(g)
    },
    nf.c = function(a) {
        nf.d(a, !0)
    },
    nf.d = function(a, b) {
        if (b) for (var c = a.xf(); c.i1(); c.i2()) {
            var d = c.i8();
            a.gt(d, nf._E),
            a.gz(d, nf._E),
            a.s5(d, nf._D)
        } else for (var e = a.xf(); e.i1(); e.i2()) a.s5(e.i8(), nf._D)
    },
    nf.e = function(a) {
        for (var b = new Rd(0, 0), c = a.xf(); c.i1(); c.i2()) {
            var d = c.i8();
            a.gt(d, b),
            a.gz(d, b)
        }
    },
    nf.f = function(a, b, c, d) {
        for (var e = a.gc(b).b(), f = Gf.d(e), g = 0, h = a.gc(b).c(); h.i1(); h.i2()) {
            var i = h.i6(); (0 >= g || !i.equals(f[g - 1])) && (f[g] = new Rd(i.x, i.y), g++)
        }
        if (e = g, !(2 > e)) {
            var j = new nd,
            k = new Td(f[1].x - f[0].x, f[1].y - f[0].y),
            l = nf.i(k);
            l.x *= d,
            l.y *= d;
            for (var m = nf.h(f[0], l), n = nf.h(f[1], l), o = new Vd(m, n), p = 1; e - 1 > p; p++) {
                var q = o,
                r = nf.i(new Td(f[p + 1].x - f[p].x, f[p + 1].y - f[p].y));
                r.x *= d,
                r.y *= d;
                var s = nf.h(f[p], r),
                t = nf.h(f[p + 1], r);
                o = new Vd(s, t);
                var u = Vd.a6(q, o);
                null != u && j.add(new Rd(u.x, u.y))
            }
            var v = new Td(f[e - 1].x - f[e - 2].x, f[e - 1].y - f[e - 2].y);
            v = nf.i(v),
            v.x *= d,
            v.y *= d;
            var w = nf.h(f[e - 1], v),
            x = new Wd(j);
            b.a2() === c.a2() ? (a.s5(c, x), a.m2(c, m, w)) : (a.s5(c, x.a()), a.m2(c, w, m))
        }
    },
    nf.g = function(a, b, c, d) {
        for (var e = d,
        f = c.c1(); f.i1(); f.i2()) {
            var g = f.i8();
            nf.f(a, b, g, e),
            0 > e && (e -= d),
            e = -e
        }
    },
    nf.a = function(a, b, c) {
        return nf.j(a, b, c, 1)
    },
    nf.l = function(a, b, c) {
        if (null == a || a.length < 1) return null != b && (b.x = 0, b.y = 0, b.width = 0, b.height = 0),
        {
            width: 0,
            height: 0
        };
        for (var d = 0,
        e = 0,
        f = 0; f < a.length; f++) {
            var g = a[f];
            d = Math.max(d, g.width),
            e = Math.max(e, g.height)
        }
        var h, i, j = d * e * a.length,
        k = Math.sqrt(j / c),
        l = j / k,
        m = Math.floor(l / d),
        n = Math.ceil(l / d),
        o = Math.ceil(a.length / m),
        p = Math.ceil(a.length / n);
        n * p > m * o ? (h = m, i = o) : (h = n, i = p);
        var q, r = 0,
        s = 0,
        t = 0,
        u = 0;
        if (d > e) for (var v = 0; v < a.length; v++) q = a[v],
        q.x = s * d,
        q.y = r * e,
        t = Math.max(t, q.x + q.width),
        u = Math.max(u, q.y + q.height),
        ++s >= h && (r++, s = 0);
        else for (var w = 0; w < a.length; w++) q = a[w],
        q.x = s * d,
        q.y = r * e,
        t = Math.max(t, q.x + q.width),
        u = Math.max(u, q.y + q.height),
        ++r >= i && (s++, r = 0);
        return null != b && (b.x = 0, b.y = 0, b.width = t, b.height = u),
        {
            width: i,
            height: h
        }
    },
    nf.j = function(a, b, c, d) {
        if (null == a || a.length < 1) return null != b && (b.x = 0, b.y = 0, b.width = 0, b.height = 0),
        0;
        for (var e, f, g = e = a[0].width, h = f = a[0].height, i = a.length, j = 1; i > j; j++) {
            var k = a[j].width;
            g = Math.min(g, k),
            e = Math.max(e, k);
            var l = a[j].height;
            h = Math.min(h, l),
            f = Math.max(f, l)
        }
        if (h / f > .95 && g / e > .95) return nf.l(a, b, c).width;
        for (var m = new pe,
        n = 0,
        o = 0; i > o; o++) {
            var p = a[o];
            m.aa(a[o]),
            n = Math.floor(n + p.width * p.height)
        }
        m.a1(function(a, b) {
            var c = Math.floor(b.height) - Math.floor(a.height);
            return 0 === c ? Math.floor(b.width) - Math.floor(a.width) : c
        });
        var q = 0,
        r = 0,
        s = Math.floor(c * Math.sqrt(n / c)),
        t = s,
        u = 0,
        v = new pe;
        do {
            var w = new pe;
            v.aa(w);
            for (var x, y, z = x = y = 0,
            A = m.ah(); A.i1(); A.i2()) {
                var B = A.i6();
                z + B.width > t && w.ay() > 0 ? (y = Math.max(y, z), w = new pe, w.aa(B), v.aa(w), z = Math.floor(B.width)) : (w.aa(B), z = Math.floor(z + B.width)),
                1 === w.ay() && (x = Math.floor(x + w.am().height))
            }
            y = Math.max(y, z), c * x > y && u !== y && (v.af(), t = Math.floor(1.1 * t), u = y)
        } while ( v . ar ());
        for (var C = 0,
        D = v.ah(); D.i1(); D.i2()) {
            for (var E = 0,
            F = D.i6(), G = F.ah(); G.i1(); G.i2()) {
                var H = G.i6();
                H.x = E,
                H.y = C,
                E += H.width
            }
            q = Math.max(q, E),
            C += nf.k(F),
            r = Math.max(r, C)
        }
        return null != b && (b.x = 0, b.y = 0, b.width = q, b.height = r),
        v.ay()
    },
    nf.k = function(a) {
        for (var b = 0,
        c = a.ah(); c.i1(); c.i2()) b = Math.max(c.i6().height, b);
        return b
    },
    nf.h = function(a, b) {
        return new Rd(a.x + b.x, a.y + b.y)
    },
    nf.i = function(a) {
        var b = Math.sqrt(a.x * a.x + a.y * a.y);
        return new Td( - a.y / b, a.x / b)
    };
    var of = function(a) {
        this._a = a,
        this._b = !1
    };
    Jb.ext(of, Object, {
        a: function() {
            return this._b
        },
        b: function() {
            return this._a
        },
        c: function() {
            return 1 === this._a
        },
        d: function() {
            return 2 === this._a
        },
        e: function() {
            return 4 === this._a
        },
        f: function() {
            return 8 === this._a
        },
        g: function() {
            return 0 === this._a
        }
    }),
    of.h = function(a, b) {
        var c = a.xc("A");
        return null == c ? null: c.i1(b)
    },
    of.i = function(a, b) {
        var c = a.xc("B");
        return null == c ? null: c.i1(b)
    },
    of.j = function(a) {
        switch (a) {
        case 1:
            return of.k;
        case 2:
            return of.l
        }
        return null
    },
    of.k = new of(1),
    of.l = new of(2);
    var pf = function(a, b, c, d, e) {
        this._o = 0,
        this._l = 0,
        this._i = 0,
        this._d = 0,
        this._f = 0,
        this._b = a,
        this._a = 1e-4,
        this._r = b,
        this._p = 1,
        this._e = (e.gj(a) + e.g9(a)) / 4;
        var f = .45 * c * Math.sqrt(d);
        this._k = ef.l( - f, f),
        this._h = ef.l( - f, f),
        this._g = ef.l( - f, f)
    };
    Jb.ext(pf, Object, {});
    var qf = function() {
        this._a = 0,
        this._c = 0,
        this._b = 0
    };
    Jb.ext(qf, Object, {});
    var rf = function() {
        rf.superClass.constructor.call(this),
        this._dj = 0,
        this._dh = 0,
        this._dq = 0,
        this._dp = 0,
        this._dt = 0,
        this._de = 0,
        this._d3 = 0,
        this._dr = 0,
        this._ed = 0,
        this._dw = .65,
        this._ea = 1,
        this._dl = 80,
        this._dx = 3,
        this._d8 = !0,
        this._eb = 3e5,
        this._ee = 2,
        this._di = 2,
        this._df = 1e3
    };
    Jb.ext(rf, Pe, {
        i4: function(a) {
            return ! 0
        },
        i3: function(a) {
            if (null != a && (this._d5 = a, this.s(a))) {
                var b = new qf,
                c = 0,
                d = Math.floor(this._dx * this._dz.length * this._dz.length + 20 * this._dz.length);
                d = Math.max(d, 1e4);
                var e = this._ea * this._ea * this._dz.length,
                f = this._df;
                try {
                    for (; this._dj > e && d > c; c++) {
                        var g = this.b(2147483647 & c);
                        0 === f--&&(this._dy.b() > this._eb && (c = d), f = this._df),
                        this.h(g, b),
                        this.d(g, b),
                        this.i(g, b),
                        this._d8 ? (this.g(g, b), this.j(g, b)) : (this.f(g, b), this.c(g, b));
                        var h = Math.sqrt(b._a * b._a + b._c * b._c + b._b * b._b);
                        this.ac(g, b, h),
                        this.aa(g, b, h)
                    }
                } catch(i) {} finally {
                    this.r()
                }
            }
        },
        s: function(a) {
            if (null == a || a.xa() < 1) return ! 1;
            this._d5 = a,
            this._dp = 1,
            this._dy = new df,
            this._dt = a.x0(),
            this._d2 = Gf.d(this._dt),
            this._df = 1 + 1e5 / this._dt,
            this._ed = 1 / (2 * this._di),
            this._de = this._ed * this._ee / (.05 * this._dl),
            this._d3 = Math.pow(this._dl, -1) * this._ed,
            this._dr = Math.pow(this._dl, 3) * this._ed,
            this._dj = 0,
            this._du = new qf,
            this._dq = Math.max(20 * this._dl, 10);
            var b = Math.max(.1, Math.min(this._dw * this._dl, this._dq)),
            c = this._dt;
            nf.c(a),
            this._dz = Gf.d(c);
            for (var d = a.x9(); d.i1(); d.i2()) {
                var e = d.i9(),
                f = new pf(e, b, this._dl, this._dt, a);
                this._dz[--c] = f,
                this._dj += f._r,
                this._dh += f._r * f._r,
                this._du._a += f._k,
                this._du._c += f._h,
                this._du._b += f._g,
                this._d2[e.al()] = f
            }
            return this._d8 = !1,
            this._dz.length > 0
        },
        b: function(a) {
            var b = this._dz.length,
            c = b - a % b - 1,
            d = ef.k(c + 1),
            e = this._dz[d];
            return this._dz[d] = this._dz[c],
            this._dz[c] = e,
            e
        },
        f: function(a, b) {
            for (var c, d, e = c = d = 0,
            f = a._b.ae(); null != f; f = f.a7()) {
                var g, h = this._d2[f.a2().al()],
                i = h._k - a._k,
                j = h._h - a._h,
                k = h._g - a._g,
                l = i * i + j * j + k * k,
                m = Math.sqrt(l),
                n = m - (h._e + a._e);
                0 >= n || (g = n * n * this._d3 / m, e += i * g, c += j * g, d += k * g)
            }
            for (var o = a._b.ag(); null != o; o = o.a8()) {
                var p, q = this._d2[o.a3().al()],
                r = q._k - a._k,
                s = q._h - a._h,
                t = q._g - a._g,
                u = r * r + s * s + t * t,
                v = Math.sqrt(u),
                w = v - (q._e + a._e);
                0 >= w || (p = w * w * this._d3 / v, e += r * p, c += s * p, d += t * p)
            }
            b._a += e,
            b._c += c,
            b._b += d
        },
        g: function(a, b) {
            var c, d, e = c = d = 0;
            this._dp++,
            a._f = this._dp;
            for (var f = a._b.ae(); null != f; f = f.a7()) {
                var g = this._d2[f.a2().al()];
                g._f = this._dp;
                var h = g._k - a._k,
                i = g._h - a._h,
                j = g._g - a._g,
                k = h * h + i * i + j * j,
                l = Math.sqrt(k);
                if (0 !== l) {
                    var m = Math.max(1e-6, l - (a._e + g._e)),
                    n = -this._ef[f.a5()] / (m * m);
                    n += m * m * this._d1[f.a5()],
                    n /= l,
                    e += h * n,
                    c += i * n,
                    d += j * n
                }
            }
            for (var o = a._b.ag(); null != o; o = o.a8()) {
                var p = this._d2[o.a3().al()];
                p._f = this._dp;
                var q = p._k - a._k,
                r = p._h - a._h,
                s = p._g - a._g,
                t = q * q + r * r + s * s,
                u = Math.sqrt(t);
                if (0 !== u) {
                    var v = Math.max(1e-6, u - (a._e + p._e)),
                    w = -this._ef[o.a5()] / (v * v);
                    w += v * v * this._d1[o.a5()],
                    w /= u,
                    e += q * w,
                    c += r * w,
                    d += s * w
                }
            }
            b._a += e,
            b._c += c,
            b._b += d
        },
        j: function(a, b) {
            for (var c, d, e = c = d = 0,
            f = this._dt - 1; f >= 0; f--) {
                var g = this._d2[f];
                if (g._f !== a._f) {
                    var h = a._k - g._k,
                    i = a._h - g._h,
                    j = a._g - g._g,
                    k = h * h + i * i + j * j;
                    if (0 !== k) {
                        var l = Math.sqrt(k),
                        m = Math.max(1e-6, l - (a._e + g._e)),
                        n = this._dr / (m * m * l);
                        e += h * n,
                        c += i * n,
                        d += j * n
                    }
                }
            }
            b._a += e,
            b._c += c,
            b._b += d
        },
        c: function(a, b) {
            for (var c, d, e = c = d = 0,
            f = this._dt - 1; f >= 0; f--) {
                var g = this._d2[f],
                h = a._k - g._k,
                i = a._h - g._h,
                j = a._g - g._g,
                k = h * h + i * i + j * j;
                if (0 !== k) {
                    var l, m = Math.sqrt(k),
                    n = m - (a._e + g._e);
                    l = 0 >= n ? this._dr / (1e-8 * m) : this._dr / (n * n * m),
                    e += h * l,
                    c += i * l,
                    d += j * l
                }
            }
            b._a += e,
            b._c += c,
            b._b += d
        },
        i: function(a, b) {
            var c = this._du._b / this._dt - a._g;
            b._b += c * this._dl * this._dt / this._dh
        },
        d: function(a, b) {
            if (0 !== this._de) {
                var c = this._du._a / this._dt - a._k,
                d = this._du._c / this._dt - a._h,
                e = this._du._b / this._dt - a._g;
                b._a += c * this._de,
                b._c += d * this._de,
                b._b += e * this._de
            }
        },
        h: function(a, b) {
            var c = .05 * (a._r + 2);
            c > 0 && (b._a = ef.l( - c, c), b._c = ef.l( - c, c), b._b = ef.l( - c, c))
        },
        ac: function(a, b, c) {
            if (0 !== c && 0 !== a._a) {
                var d = b._a * a._o + b._c * a._l + b._b * a._i,
                e = d / (c * a._a);
                this._dh -= a._r * a._r,
                this._dj -= a._r,
                a._r += a._p * e > 0 ? .45 * e: .15 * e,
                a._r > this._dq ? a._r = this._dq: a._r < .1 && (a._r = .1),
                this._dj += a._r,
                this._dh += a._r * a._r,
                a._p = e
            }
        },
        aa: function(a, b, c) {
            if (c > 0) {
                var d = a._r / c,
                e = b._a * d,
                f = b._c * d,
                g = b._b * d;
                a._k += e,
                a._h += f,
                a._g += g,
                this._du._a += e,
                this._du._c += f,
                this._du._b += g,
                a._a = c,
                a._o = b._a,
                a._l = b._c,
                a._i = b._b
            }
        },
        r: function() {
            for (var a = this._d2.length - 1; a >= 0; a--) {
                var b = this._d2[a];
                this._d5.s2(b._b, b._k, b._h)
            }
        }
    });
    var sf = function(a, b, c, d) {
        this._e = a,
        this._f = b,
        this._a = c,
        this._b = d,
        this._c = {}
    };
    Jb.ext(sf, Object, {
        resetGroup: function() {
            if (this._a && null == this._b) for (var a in this._c) {
                var b = this._c[a];
                b.group.setExpanded(this._e.isExpandGroup() ? !0 : b.b)
            }
        },
        process: function() {
            for (var a = new nd,
            b = 0,
            c = this._f.size(); c > b; b++) {
                var d = this._f.get(b);
                if (d instanceof Ib.Link) d.isLooped() || a.add(d);
                else {
                    if (null == this._b && d.getParent() instanceof Md) continue; (null == this._b || null != this._b && this._b !== d) && a.add(d),
                    null == this._b && d instanceof Md && this.layoutGroup(d)
                }
            }
            return a
        },
        layoutGroup: function(a) {
            if (this._a && null == this._c[a.getId()] && null == this._b) {
                this._c[a.getId()] = {
                    group: a,
                    b: a.isExpanded()
                };
                var b = this._e.getGroupLayoutType(a);
                if (b) {
                    a.setExpanded(!0);
                    for (var c, d = new nd,
                    e = a.getChildren(), f = 0, g = e.size(); g > f; f++) if (c = e.get(f), c instanceof Md && (this.layoutGroup(c), c.setExpanded(!1)), c instanceof Ib.Link || d.contains(c) || d.add(c), c instanceof Kd) {
                        var h = c.getLinks();
                        if (null != h) for (var i = 0,
                        j = h.size(); j > i; i++) {
                            var k = h.get(i);
                            d.contains(k) || d.add(k)
                        }
                    }
                    var l = new mf(this._e, d, b, this._a, this._b);
                    try {
                        var m = null;
                        if ("round" === b ? m = new cf: "symmetry" === b ? m = new rf: "hierarchic" === b ? m = new Bf: ("topbottom" === b || "bottomtop" === b || "rightleft" === b || "leftright" === b) && (m = new Qe), null != m) {
                            m.i2(l);
                            var n = sf.createMatrix(b),
                            o = {},
                            p = {};
                            for (var q in l._a) {
                                var r = l._a[q],
                                s = r.node,
                                t = l.g4(r);
                                if (o[q] = s.getCenterLocation(), null != n) {
                                    var u = n.transform(t);
                                    s.setCenterLocation(u.x, u.y)
                                } else s.setCenterLocation(t.x, t.y);
                                p[q] = s.getCenterLocation()
                            }
                        }
                    } catch(v) {}
                    for (e = a.getChildren(), f = 0, g = e.size(); g > f; f++) c = e.get(f),
                    c instanceof Md && c.setExpanded(!0)
                }
            }
        }
    }),
    sf.createMatrix = function(a) {
        return "rightleft" === a ? Tb.createMatrix(Math.PI / 2, 0, 0) : "leftright" === a ? Tb.createMatrix( - Math.PI / 2, 0, 0) : "bottomtop" === a ? Tb.createMatrix(Math.PI, 0, 0) : null
    };
    var tf = function() {};
    Jb.ext(tf, Object, {
        i1: function(a, b, c) {
            var d = this.a1(a, b);
            return this.a2(a, b, c),
            d
        },
        a1: function(a, b) {
            var c = tf.i4(a);
            c.ax();
            for (var d = 0,
            e = c.x1(); e.i1(); e.i2()) b.i7(e.i9(), -1);
            for (var f = c.x1(); f.i1(); f.i2()) {
                for (var g = f.i9(), h = -1, i = g.aq(); i.i1(); i.i2()) h = Math.max(h, b.i2(i.i9()));
                b.i7(g, h + 1),
                d = Math.max(d, h + 1)
            }
            return d + 1
        },
        a2: function(a, b, c) {
            c.az(tf.i3(a, b))
        }
    }),
    tf.i3 = function(a, b) {
        for (var c = new qe,
        d = a.xf(); d.i1(); d.i2()) {
            var e = d.i8();
            b.i2(e.a2()) > b.i2(e.a3()) && (a.x3(e), c.ac(e))
        }
        return c
    },
    tf.i4 = function(a) {
        var b = Gf.a(a.xa());
        return (new he).a1(a, b),
        tf.i2(a, b)
    },
    tf.i2 = function(a, b) {
        for (var c = Gf.d(a.x0()), d = a.x9(); d.i1(); d.i2()) {
            var e = d.i9(),
            f = e.al();
            c[b[f]] = e
        }
        return new Ie(c)
    };
    var uf = function() {
        uf.superClass.constructor.call(this),
        this.c0()
    };
    Jb.ext(uf, qe, {
        c0: function() {
            this._bc = 1,
            this._bd = 0
        }
    });
    var vf = function() {
        this._m1 = 20,
        this._m2 = 60,
        this._m3 = 5,
        this._m4 = 0
    };
    Jb.ext(vf, Object, {
        i4: function(a) {
            this._m3 = a
        },
        i5: function(a) {
            this._m4 = a
        },
        i3: function(a) {
            this._m1 = a
        },
        i6: function(a) {
            this._m2 = a
        },
        i2: function(a) {
            this._m5 = a
        },
        t1: function() {
            return this._m2
        },
        a1: function(a, b) {
            for (var c = Gf.d(b.length), d = 0; d < b.length; d++) c[d] = b[d].x1();
            this.a2(a, c)
        },
        a2: function(a, b) {
            for (var c = Gf.a(b.length), d = 0, e = 0; e < b.length; e++) {
                var f = 0,
                g = b[e];
                for (g.i4(); g.i1(); g.i2()) f = Math.max(f, a.g9(g.i9()));
                for (c[e] = f, g.i4(); g.i1(); g.i2()) {
                    var h = (c[e] - a.g9(g.i9())) / 2;
                    a.s4(g.i9(), new Rd(a.gi(g.i9()), d + h))
                }
                var i = this.t1();
                d += c[e] + i,
                g.i4()
            }
        },
        i1: function(a, b, c) {
            this._m6 = a,
            this.t2(b, c)
        }
    });
    var wf = function(a, b) {
        wf.superClass.constructor.call(this)
    };
    Jb.ext(wf, vf, {
        t2: function(a, b) {
            var c = this._m6;
            this._a = c.xc("D"),
            this._h = c.xc("C"),
            this.a1(c, a),
            this.tg(c, a),
            this.tf(a, Me.a5(this._e), this._m5, this._l),
            this.tb(c, this._f[0]),
            this.ta(a),
            this.th(c, this._f[0], a),
            this.b(a),
            this.tb(c, this._f[1]),
            this.ta(a),
            this.th(c, this._f[1], a),
            this.b(a),
            this.a11(this._f[1]),
            this.a12(a),
            this.tb(c, this._f[2]),
            this.ta(a),
            this.th(c, this._f[2], a),
            this.b(a),
            this.tb(c, this._f[3]),
            this.ta(a),
            this.th(c, this._f[3], a),
            this.b(a),
            this.a11(this._f[3]),
            this.a12(a),
            this.tc(c),
            this.tj()
        },
        a11: function(a) {
            for (var b = 0; b < a.length; b++) a[b] = -a[b]
        },
        b: function(a) {
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c.ax()
            }
            for (var d = 0; d < a.length; d++) for (var e = 0,
            f = null,
            g = a[d].x1(); g.i1(); g.i2()) {
                var h = g.i9(),
                i = h.al();
                this._l[i] = e++,
                this._b[i] = f,
                this._k[i] = null,
                null != f && (this._k[f.al()] = h),
                f = h
            }
            var j = this._a;
            this._a = this._h,
            this._h = j;
            for (var k = this._m6.xf(); k.i1(); k.i2()) {
                var l = k.i8(),
                m = this._m6.gn(l);
                this._m6.gt(l, new Rd( - m.x, m.y));
                var n = this._m6.gk(l);
                this._m6.gz(l, new Rd( - n.x, n.y))
            }
            var o = this._l,
            p = function(a, b) {
                return null == a && null != b ? 1 : null != a && null == b ? -1 : null == a && null == b ? 0 : o[a.a2().al()] - o[b.a2().al()]
            },
            q = function(a, b) {
                return null == a && null != b ? 1 : null != a && null == b ? -1 : null == a && null == b ? 0 : o[a.a3().al()] - o[b.a3().al()]
            };
            this._m6.x2(p, q)
        },
        a12: function(a) {
            for (var b = this._m6.xf(); b.i1(); b.i2()) {
                var c = b.i8();
                this._m6.x3(c);
                var d = this._m6.gn(c),
                e = this._m6.gk(c);
                this._m6.gz(c, d),
                this._m6.gt(c, e)
            }
            for (var f = new pe,
            g = 0; g < a.length; g++) f.ae(a[g]);
            for (var h = 0; h < a.length; h++) a[h] = f.au();
            var i = this._l,
            j = function(a, b) {
                return null == a && null != b ? 1 : null != a && null == b ? -1 : null == a && null == b ? 0 : i[a.a2().al()] - i[b.a2().al()]
            },
            k = function(a, b) {
                return null == a && null != b ? 1 : null != a && null == b ? -1 : null == a && null == b ? 0 : i[a.a3().al()] - i[b.a3().al()]
            };
            this._m6.x2(j, k)
        },
        tg: function(a, b) {
            var c = a.x0(),
            d = a.xg();
            this._l = Gf.a(c),
            this._b = Gf.d(c),
            this._k = Gf.d(c),
            this._m = Gf.d(c),
            this._i = Gf.d(c),
            this._o = Gf.d(c),
            this._f = Gf.e(4, c),
            this._c = Gf.a(c),
            this._g = Gf.a(c),
            this._j = Gf.a(c),
            this._d = Gf.b(c),
            this._e = Gf.b(d);
            for (var e = 0; e < b.length; e++) for (var f = 0,
            g = null,
            h = b[e].x1(); h.i1(); h.i2()) {
                var i = h.i9(),
                j = i.al();
                this._l[j] = f++,
                this._b[j] = g,
                this._k[j] = null,
                null != g && (this._k[g.al()] = i),
                g = i
            }
            var k = this._l,
            l = function(a, b) {
                return null == a && null != b ? 1 : null != a && null == b ? -1 : null == a && null == b ? 0 : k[a.a2().al()] - k[b.a2().al()]
            },
            m = function(a, b) {
                return null == a && null != b ? 1 : null != a && null == b ? -1 : null == a && null == b ? 0 : k[a.a3().al()] - k[b.a3().al()]
            };
            a.x2(l, m)
        },
        tb: function(a, b) {
            for (var c = a.x9(); c.i1(); c.i2()) {
                var d = c.i9(),
                e = d.al();
                this._m[e] = d,
                this._i[e] = d,
                b[e] = Number.MAX_VALUE,
                this._o[e] = d,
                this._c[e] = Number.MAX_VALUE,
                this._d[e] = !1,
                this._j[e] = this._g[e] = 0
            }
        },
        ta: function(a) {
            for (var b = 1; b < a.length; b++) for (var c = -1,
            d = a[b]._b; null != d; d = d.a()) {
                var e = d.d(),
                f = e.al(),
                g = e.ak();
                if (0 !== g) {
                    var h, i = Math.floor((g + 1) / 2),
                    j = Math.ceil((g + 1) / 2),
                    k = 1;
                    for (h = e.ae(); i > k; h = h.a7()) k++;
                    for (var l = !1; j >= k && !l; k++) {
                        var m = this._m6.g2(h),
                        n = h.a2(),
                        o = n.al();
                        this._i[f] === e && !this._e[h.a5()] && c < this._l[o] && (c = this._l[o], this._i[o] = e, this._m[f] = this._m[o], this._i[f] = this._m[f], l = !0, this._j[o] = m.i6().x, this._g[f] = m.i7().x),
                        h = h.a7()
                    }
                }
            }
        },
        th: function(a, b, c) {
            for (var d = a.x9(); d.i1(); d.i2()) {
                var e = d.i9(),
                f = e.al();
                this._m[f] === e && this.td(a, e, b)
            }
            for (var g = 0; g < c.length; g++) {
                var h = c[g].x1();
                if (h.i1()) {
                    var i = c[g].x1().i9(),
                    j = i.al();
                    this._o[this._m[j].al()] === i && this.tk(a, i, b)
                }
            }
            for (var k = a.x9(); k.i1(); k.i2()) {
                var l = k.i9(),
                m = l.al(),
                n = this._c[this._o[this._m[m].al()].al()];
                n < Number.MAX_VALUE && (b[m] += n)
            }
        },
        td: function(a, b, c) {
            var d = b.al();
            if (c[d] === Number.MAX_VALUE) {
                c[d] = 0;
                var e = b,
                f = 0;
                do {
                    var g = e.al();
                    if (g !== d && (f -= this._g[g]), this._l[g] > 0) {
                        var h = this._b[g],
                        i = this._m[this._b[g].al()],
                        j = i.al();
                        this.td(a, i, c),
                        this._o[d] === b && (this._o[d] = this._o[j]),
                        this._o[d] === this._o[j] && (c[d] = Math.max(c[d], c[h.al()] + this.ti(a, h, e) - f))
                    }
                    f += this._j[g], e = this._i[g]
                } while ( e !== b );
                f = 0,
                e = b;
                do {
                    var k = e.al();
                    k !== d && (f -= this._g[k]), c[k] = c[d] + f, f += this._j[k], e = this._i[k]
                } while ( e !== b )
            }
        },
        tk: function(a, b, c) {
            var d = b.al();
            if (!this._d[d]) {
                this._d[d] = !0;
                var e = b;
                do {
                    var f = e.al(), g = this._k[f];
                    if (null != g) {
                        var h = g.al(),
                        i = this._o[this._m[h].al()];
                        if (i !== this._o[d]) {
                            var j = c[h] - c[d] - this.ti(a, e, g);
                            this._c[i.al()] !== Number.MAX_VALUE && (j += this._c[i.al()]),
                            this._c[this._o[d].al()] = Math.min(this._c[this._o[d].al()], j)
                        } else this.tk(a, this._m[h], c)
                    }
                    e = this._i[f]
                } while ( e !== b )
            }
        },
        tc: function(a) {
            for (var b = Gf.a(4), c = Gf.a(4), d = a.x9(); d.i1(); d.i2()) {
                var e = d.i9(),
                f = e.al();
                c[0] += this._f[0][f],
                c[1] += this._f[1][f],
                c[2] += this._f[2][f],
                c[3] += this._f[3][f]
            }
            c[0] /= a.xa(),
            c[1] /= a.xa(),
            c[2] /= a.xa(),
            c[3] /= a.xa();
            for (var g = a.x9(); g.i1(); g.i2()) {
                var h = g.i9(),
                i = h.al(),
                j = a.g4(h);
                b[0] = this._f[0][i] - c[0],
                b[1] = this._f[1][i] - c[1],
                b[2] = this._f[2][i] - c[2],
                b[3] = this._f[3][i] - c[3],
                b.sort(Gf.n);
                var k = (b[1] + b[2]) / 2;
                a.s1(h, new Rd(k, j.y))
            }
        },
        ti: function(a, b, c) {
            var d, e = a.gj(b),
            f = a.gj(c);
            return d = e > 1 && f > 1 ? this._m1 + (e + f) / 2 : this._m3 + (e + f) / 2,
            this._l[b.al()] < this._l[c.al()] ? (null != this._a && (d += this._a.i3(c)), null != this._h && (d += this._h.i3(b))) : (null != this._a && (d += this._a.i3(b)), null != this._h && (d += this._h.i3(c))),
            d
        },
        tj: function() {
            this._l = null,
            this._b = null,
            this._k = null,
            this._e = null,
            this._m = null,
            this._i = null,
            this._f = null,
            this._c = null,
            this._o = null,
            this._d = null,
            this._j = null,
            this._g = null
        },
        tf: function(a, b, c, d) {
            for (var e = a.length,
            f = 2; e - 1 > f; f++) for (var g = -1,
            h = 0,
            i = 0,
            j = a[f].x1(), k = a[f].x1(); k.i1(); k.i2()) {
                var l = k.i9(),
                m = null,
                n = !1;
                if (1 === l.ak() && (m = l.ae().a2(), null != c.i1(m) && null != c.i1(l) && (n = !0)), i === a[f].ay() - 1 || n) {
                    for (var o = n ? d[m.al()] : a[f - 1].ay(); i >= h; h++) {
                        for (var p = j.i9(), q = p.am(); q.i1(); q.i2()) {
                            var r = q.i8(),
                            s = d[r.a2().al()]; (g > s || s > o) && b.i7(q.i8(), !0)
                        }
                        j.i2()
                    }
                    g = o
                }
                i++
            }
        }
    });
    var xf = function(a, b) {
        this._b = 20,
        this._a = b,
        this._d = a,
        this._f = {}
    };
    Jb.ext(xf, Object, {
        a3: function(a) {
            this._b = a
        },
        a4: function(a, b, c, d, e) {
            if (this.a2(a)) {
                var f = this.b2(a);
                f._o = b,
                f._m = e,
                f._n = d,
                f._f = c
            }
        },
        b2: function(a) {
            var b = this._f[a._id];
            return null == b && (b = new yf, this._f[a._id] = b),
            b
        },
        a2: function(a) {
            return null != this._f[a._id]
        },
        c: function() {
            for (var a = Me.a1(Gf.a(this._d.xa())), b = Me.a1(Gf.a(this._d.xa())), c = this._d.x9(); c.i1(); c.i2()) {
                var d = c.i9();
                if (this.a2(d)) {
                    var e = this.b2(d);
                    a.i6(d, this._b * (e.c() - 1)),
                    b.i6(d, this._b * (e.b() - 1))
                }
            }
            this._d.x1("D", a),
            this._d.x1("C", b)
        },
        g: function() {
            this._d.x6("D"),
            this._d.x6("C")
        },
        f: function() {
            for (var a = this._d.x9(); a.i1(); a.i2()) {
                var b = a.i9();
                if (this.a2(b)) {
                    var c = this._d.gi(b),
                    d = this._d.gh(b),
                    e = this._d.gj(b),
                    f = this._d.g9(b),
                    g = this.b2(b),
                    h = g._q.ay() + g._b.ay() + g._f,
                    i = g._d.ay() + g._g.ay() + g._o,
                    j = g._i.ay() + g._l.ay() + g._n,
                    k = g._h.ay() + g._k.ay() + g._m,
                    l = this._a.a7(e, h),
                    m = this._a.a7(e, i),
                    n = this._a.a7(f, k),
                    o = this._a.a7(f, j);
                    g.a2(this._a.a8(e, h, l), this._a.a8(e, i, m), this._a.a8(f, k, n), this._a.a8(f, j, o));
                    for (var p = g._j.c1(); p.i1(); p.i2()) {
                        var q = p.i8(),
                        r = this.a1(q),
                        s = this.b1(q),
                        t = new pe;
                        r.b() === s.b() ? (r.c() ? (t.aa(new Rd(c + g._g._bd * m + g._c, d)), t.aa(new Rd(c + g._g._bd * m + g._c, d - this._b)), g._g._bd++, t.aa(new Rd(c + g._g._bd * m + g._c, d - this._b)), t.aa(new Rd(c + g._g._bd * m + g._c, d)), g._g._bd++, g._g._bc = Math.max(g._g._bc, 2)) : r.d() ? (t.aa(new Rd(c + g._b._bd * l + g._p, d + f)), t.aa(new Rd(c + g._b._bd * l + g._p, d + f + this._b)), g._b._bd++, t.aa(new Rd(c + g._b._bd * l + g._p, d + f + this._b)), t.aa(new Rd(c + g._b._bd * l + g._p, d + f)), g._b._bd++, g._b._bc = Math.max(g._b._bc, 2)) : r.f() ? (t.aa(new Rd(c, d + g._i._bd * o + g._a)), t.aa(new Rd(c - this._b, d + g._i._bd * o + g._a)), g._i._bd++, t.aa(new Rd(c - this._b, d + g._i._bd * o + g._a)), t.aa(new Rd(c, d + g._i._bd * o + g._a)), g._i._bd++, g._i._bc = Math.max(g._i._bc, 2)) : r.e() && (t.aa(new Rd(c + e, d + g._h._bd * n + g._e)), t.aa(new Rd(c + e + this._b, d + g._h._bd * n + g._e)), g._h._bd++, t.aa(new Rd(c + e + this._b, d + g._h._bd * n + g._e)), t.aa(new Rd(c + e, d + g._h._bd * n + g._e)), g._h._bd++, g._h._bc = Math.max(g._h._bc, 2)), this._d.m1(q, t)) : r.c() || s.c() ? r.e() || s.e() ? (t.aa(new Rd(c + e - g._d._bd * m - g._c, d)), t.aa(new Rd(c + e - g._d._bd * m - g._c, d - this._b * g._d._bc)), t.aa(new Rd(c + e + this._b * g._h._bc, d - this._b * g._d._bc)), t.aa(new Rd(c + e + this._b * g._h._bc, d + g._h._bd * n + g._e)), t.aa(new Rd(c + e, d + g._h._bd * n + g._e)), g._d._bd++, g._d._bc++, g._h._bd++, g._h._bc++, s.c() && t.ax(), this._d.m1(q, t)) : r.f() || s.f() ? (t.aa(new Rd(c + g._g._bd * m + g._c, d)), t.aa(new Rd(c + g._g._bd * m + g._c, d - this._b * g._g._bc)), t.aa(new Rd(c - this._b * g._i._bc, d - this._b * g._g._bc)), t.aa(new Rd(c - this._b * g._i._bc, d + g._i._bd * o + g._a)), t.aa(new Rd(c, d + g._i._bd * o + g._a)), g._g._bd++, g._g._bc++, g._i._bd++, g._i._bc++, s.c() && t.ax(), this._d.m1(q, t)) : (r.d() || s.d()) && (t.aa(new Rd(c + e - g._d._bd * m - g._c, d)), t.aa(new Rd(c + e - g._d._bd * m - g._c, d - this._b * g._d._bc)), t.aa(new Rd(c + e + this._b * g.b(), d - this._b * g._d._bc)), t.aa(new Rd(c + e + this._b * g.b(), d + f + this._b * g._q._bc)), t.aa(new Rd(c + e - g._q._bd * l - g._p, d + f + this._b * g._q._bc)), t.aa(new Rd(c + e - g._q._bd * l - g._p, d + f)), g._d._bd++, g._d._bc++, g._k._bc++, g._h._bc++, g._q._bc++, g._q._bd++, s.c() && t.ax(), this._d.m1(q, t)) : r.d() || s.d() ? r.e() || s.e() ? (t.aa(new Rd(c + e - g._q._bd * l - g._p, d + f)), t.aa(new Rd(c + e - g._q._bd * l - g._p, d + f + this._b * g._q._bc)), t.aa(new Rd(c + e + this._b * g._k._bc, d + f + this._b * g._q._bc)), t.aa(new Rd(c + e + this._b * g._k._bc, d + f - g._k._bd * n - g._e)), t.aa(new Rd(c + e, d + f - g._k._bd * n - g._e)), g._q._bd++, g._q._bc++, g._k._bd++, g._k._bc++, s.d() && t.ax(), this._d.m1(q, t)) : (r.f() || s.f()) && (t.aa(new Rd(c + g._b._bd * l + g._p, d + f)), t.aa(new Rd(c + g._b._bd * l + g._p, d + f + this._b * g._b._bc)), t.aa(new Rd(c - this._b * g._l._bc, d + f + this._b * g._b._bc)), t.aa(new Rd(c - this._b * g._l._bc, d + f - g._l._bd * o - g._a)), t.aa(new Rd(c, d + f - g._l._bd * o - g._a)), g._b._bd++, g._b._bc++, g._l._bd++, g._l._bc++, s.d() && t.ax(), this._d.m1(q, t)) : (t.aa(new Rd(c, d + f - g._l._bd * o - g._a)), t.aa(new Rd(c - this._b * g._l._bc, d + f - g._l._bd * o - g._a)), t.aa(new Rd(c - this._b * g._l._bc, d + f + this._b * g.a1())), t.aa(new Rd(c + e + this._b * g._k._bc, d + f + this._b * g.a1())), t.aa(new Rd(c + e + this._b * g._k._bc, d + f - g._k._bd * n - g._e)), t.aa(new Rd(c + e, d + f - g._k._bd * n - g._e)), g._l._bd++, g._l._bc++, g._b._bc++, g._q._bc++, g._k._bc++, g._k._bd++, s.f() && t.ax(), this._d.m1(q, t))
                    }
                }
            }
        },
        a5: function(a, b) {
            for (var c = 0; c < a.length; c++) for (var d = a[c], e = b[c], f = d.x1(); f.i1(); f.i2()) {
                var g = f.i9();
                if (this.a2(g)) {
                    var h = this.b2(g);
                    e._g = Math.max(e._g, this._b * (h.d() - 1)),
                    e._j = Math.max(e._j, this._b * (h.a1() - 1))
                }
            }
        },
        a1: function(a) {
            var b = this._d.xc("A"),
            c = null;
            if (null != b && (c = b.i1(a)), null == c || c.g()) {
                var d = this._d.xc("B");
                if (null == d) return of.j(1);
                var e = d.i1(a);
                if (null == e || e.g()) return of.j(1);
                if (e.c()) return of.j(8);
                if (e.f()) return of.j(1);
                if (e.d()) return of.j(4);
                if (e.e()) return of.j(2)
            }
            return c
        },
        b1: function(a) {
            var b = this._d.xc("B"),
            c = null;
            if (null != b && (c = b.i1(a)), null == c || c.g()) {
                var d = this._d.xc("A");
                if (null == d) return of.j(8);
                var e = d.i1(a);
                if (null == e || e.g()) return of.j(8);
                if (e.c()) return of.j(8);
                if (e.f()) return of.j(1);
                if (e.d()) return of.j(4);
                if (e.e()) return of.j(2)
            }
            return c
        }
    });
    var yf = function() {
        this._o = 0,
        this._f = 0,
        this._n = 0,
        this._m = 0,
        this._c = 0,
        this._p = 0,
        this._e = 0,
        this._a = 0,
        this._j = new qe,
        this._g = new uf,
        this._d = new uf,
        this._b = new uf,
        this._q = new uf,
        this._h = new uf,
        this._k = new uf,
        this._i = new uf,
        this._l = new uf
    };
    Jb.ext(yf, Object, {
        a1: function() {
            return Math.max(this._q._bc, this._b._bc)
        },
        d: function() {
            return Math.max(this._d._bc, this._g._bc)
        },
        b: function() {
            return Math.max(this._k._bc, this._h._bc)
        },
        c: function() {
            return Math.max(this._l._bc, this._i._bc)
        },
        a2: function(a, b, c, d) {
            this._c = b,
            this._a = d,
            this._p = a,
            this._e = c,
            this._g.c0(),
            this._d.c0(),
            this._b.c0(),
            this._q.c0(),
            this._k.c0(),
            this._h.c0(),
            this._l.c0(),
            this._i.c0()
        }
    });
    var zf = function(a, b, c, d) {
        this._k = 20,
        this._r = .5,
        this._d = a,
        this._c = b,
        this._j = c,
        this._m = d,
        this._i = null != a.xc("A") || null != a.xc("B"),
        this._t = new Cf(a, b, c, d),
        this._b = new xf(a, this)
    };
    Jb.ext(zf, Object, {
        a6: function(a) {
            this._k = a,
            this._t.a1(a),
            this._b.a3(a)
        },
        g1: function() {
            return this._k
        },
        a9: function(a) {
            return this.c1(),
            a
        },
        a5: function(a) {
            return this.a1(),
            a
        },
        b3: function(a) {
            return this.c1(),
            a = this.c4(a),
            this._b.c(),
            a
        },
        g2: function(a) {
            return this._b.g(),
            a
        },
        e2: function(a) {
            a = this.f(a),
            this._b.f()
        },
        e1: function() {
            this._t.d(),
            null != this._n && this._d.xi(this._n),
            this.a1(),
            this._d = null
        },
        a1: function() {
            this._i && (null != this._q && (this._d.x1("A", this._q), this._q = null), null != this._p && (this._d.x1("B", this._p), this._p = null), null != this._h && (this._d.xj(this._h), this._h = null), null != this._l && (this._d.xj(this._l), this._l = null))
        },
        c1: function() {
            if (this._i) {
                null == this._h && (this._h = this._d.xl()),
                null == this._l && (this._l = this._d.xl());
                for (var a = this._d.xf(); a.i1(); a.i2()) {
                    var b = a.i8(),
                    c = null != this._j.i1(b.a2()),
                    d = null != this._j.i1(b.a3());
                    if (c && !d) {
                        var e = this._j.i1(b.a2());
                        this._m.i4(e) ? this._l.i8(b, of.h(this._d, e)) : this._l.i8(b, of.i(this._d, e))
                    } else if (!c && d) {
                        var f = this._j.i1(b.a3());
                        this._m.i4(f) ? this._h.i8(b, of.i(this._d, f)) : this._h.i8(b, of.h(this._d, f))
                    } else c || d || (this._m.i4(b) ? (this._h.i8(b, of.i(this._d, b)), this._l.i8(b, of.h(this._d, b))) : (this._h.i8(b, of.h(this._d, b)), this._l.i8(b, of.i(this._d, b))))
                }
                this._q = this._d.xc("A"),
                this._p = this._d.xc("B"),
                this._d.x1("A", this._h),
                this._d.x1("B", this._l)
            }
        },
        c4: function(a) {
            this._n = this._d.xk(),
            this._a = this._d.xl(),
            this._g = this._d.xl();
            for (var b = new qe,
            c = new qe,
            d = new qe,
            e = new qe,
            f = new qe,
            g = new qe,
            h = new qe,
            i = new qe,
            j = new qe,
            k = this._d.xk(), l = 0; l < a.length; l++) for (var m = 0,
            n = a[l].x1(); n.i1();) k.i6(n.i9(), m),
            n.i2(),
            m++;
            for (var o = function(a, b) {
                var c = k.i3(a.a3()) - k.i3(b.a3());
                return 0 >= c ? c >= 0 ? 0 : -1 : 1
            },
            p = function(a, b) {
                var c = k.i3(a.a2()) - k.i3(b.a2());
                return 0 >= c ? c >= 0 ? 0 : -1 : 1
            },
            q = 0; q < a.length; q++) for (var r = a[q], s = r._b; null != s; s = s.a()) {
                var t = s.d();
                t.av(o),
                t.au(p);
                var u = 0;
                b.af(),
                c.af(),
                d.af(),
                e.af(),
                f.af(),
                g.af(),
                h.af(),
                i.af(),
                j.af();
                for (var v = t.ap(); v.i1();) {
                    var w = v.i8(),
                    x = this.b1(w);
                    null == x || x.d() || x.g() ? d.aa(w) : x.e() ? b.aa(w) : x.f() ? (c.aa(w), j.aa(w)) : x.c() && (i.aa(w), j.aa(w)),
                    v.i2(),
                    u++
                }
                u = 0;
                for (var y = t.am(); y.i1();) {
                    var z = y.i8(),
                    A = this.a2(z);
                    null == A || A.c() || A.g() ? e.aa(z) : A.e() ? b.aa(z) : A.f() ? (c.aa(z), j.aa(z)) : A.d() && (g.aa(z), j.aa(z)),
                    y.i2(),
                    u++
                }
                var B = k.i3(t);
                if (!j.ar()) for (var C = .1 / j.ay(), D = B - .4; ! j.ar(); D += C) {
                    var E = j.c3();
                    if (E.a2() === t) {
                        var F = this._d.xm();
                        this._n.z1(F, E.a2()),
                        this._d.s7(F, 1, 1),
                        this._c.z1(F, this._c.i1(t)),
                        k.i6(F, D),
                        this._a.i8(E, this._d.gn(E)),
                        this._d.gt(E, ef._A),
                        this._d.xr(E, F, E.a3()),
                        r.ao(F, s)
                    } else {
                        var G = this._d.xm();
                        this._n.z1(G, E.a3()),
                        this._d.s7(G, 1, 1),
                        this._c.z1(G, this._c.i1(t)),
                        k.i6(G, D),
                        this._g.i8(E, this._d.gk(E)),
                        this._d.gz(E, ef._A),
                        this._d.xr(E, E.a2(), G),
                        r.ao(G, s)
                    }
                }
                if (!b.ar()) for (var H = .1 / b.ay(), I = B + .1; ! b.ar(); I += H) {
                    var J = b.c3();
                    if (J.a2() === t) {
                        var K = this._d.xm();
                        this._n.z1(K, J.a2()),
                        this._d.s7(K, 1, 1),
                        this._c.z1(K, this._c.i1(t)),
                        k.i6(K, I),
                        this._a.i8(J, this._d.gn(J)),
                        this._d.gt(J, ef._A),
                        this._d.xr(J, K, J.a3()),
                        s = r.an(K, s)
                    } else {
                        var L = this._d.xm();
                        this._n.z1(L, J.a3()),
                        this._d.s7(L, 1, 1),
                        this._c.z1(L, this._c.i1(t)),
                        k.i6(L, I),
                        this._g.i8(J, this._d.gk(J)),
                        this._d.gz(J, ef._A),
                        this._d.xr(J, J.a2(), L),
                        s = r.an(L, s)
                    }
                }
                var M = zf._z;
                this._b.a2(t) && (M = this._b.b2(t));
                var N = M._b.ay() + g.ay() + t.ao() + f.ay() + M._q.ay();
                if (N > 0) for (var O = this._d.g9(t) / 2, P = this._d.gj(t), Q = this.a7(P, N), R = -.5 * P + this.a8(this._d.gj(t), N, Q) + Q * (M._b.ay() + g.ay()), S = t.ap(); S.i1(); S.i2()) {
                    var T = S.i8();
                    this.c2(T) || null != this._j.i1(T.a2()) || (this._d.g2(T).i8(new Rd(R, O)), R += Q)
                }
                var U = this._t.a3(t),
                V = 0,
                W = 0,
                X = 0,
                Y = 0;
                if (null != U && (V = U._e.ay(), W = U._c.ay(), X = U._b.ay(), Y = U._d.ay()), N = M._g.ay() + V + i.ay() + t.ak() + h.ay() + W + M._d.ay(), N > 0) {
                    for (var Z = this._d.gj(t), $ = this.a7(Z, N), _ = this.a8(Z, N, $), aa = -.5 * Z + _ + $ * (M._g.ay() + V + i.ay()), ba = -this._d.g9(t) / 2, ca = t.am(); ca.i1(); ca.i2()) {
                        var da = ca.i8();
                        this.d1(da) || null != this._j.i1(da.a3()) || (this._d.g2(da).i9(new Rd(aa, ba)), aa += $)
                    }
                    if (null != U) {
                        for (var ea = -.5 * Z + _ + $ * (M._g.ay() + i.ay() + U._e.ay() - 1), fa = U._e.c1(); fa.i1(); fa.i2()) {
                            var ga = fa.i8();
                            this._d.u1(ga),
                            ga.a2() !== t || this.c2(ga) ? this.d1(ga) || (this._d.g2(fa.i8()).i9(new Rd(ea, ba)), ea -= $) : (this._d.g2(fa.i8()).i8(new Rd(ea, ba)), ea -= $),
                            this._d.h1(ga)
                        }
                        ea = .5 * Z - _ - $ * (M._d.ay() + h.ay());
                        for (var ha = U._c.c1(); ha.i1(); ha.i2()) {
                            var ia = ha.i8();
                            this._d.u1(ia),
                            ia.a2() !== t || this.c2(ia) ? this.d1(ia) || (this._d.g2(ha.i8()).i9(new Rd(ea, ba)), ea -= $) : (this._d.g2(ha.i8()).i8(new Rd(ea, ba)), ea -= $),
                            this._d.h1(ia)
                        }
                    }
                }
                this._b.a2(t) && this._b.a4(t, V + i.ay() + t.ak() + h.ay() + W, g.ay() + t.ao() + f.ay(), X + c.ay(), Y + b.ay())
            }
            return this._d.xi(k),
            a
        },
        a7: function(a, b) {
            return 1 >= b ? 0 : a / (b - 1 + 2 * this._r)
        },
        a8: function(a, b, c) {
            return 1 >= b ? .5 * a: .5 * (a - c * (b - 1))
        },
        f: function(a) {
            var b = this.g1();
            this._f = this._d.xk();
            for (var c = 0; c < a.length; c++) for (var d = a[c], e = d._b; null != e;) {
                var f = e.d(),
                g = this._n.i1(f);
                if (null != g || this._t.b2(f)) e = e.a();
                else {
                    var h = new Ie,
                    i = new Ie,
                    j = new Ie,
                    k = new Ie,
                    l = new Ie,
                    m = new Ie,
                    n = new qe,
                    o = new qe,
                    p = new Ff(h, i, j, k, l, m, n, o);
                    this._f.z1(f, p),
                    n.ab(f.am()),
                    o.ab(f.ap());
                    for (var q = e.b(); null != q && this._n.i1(q.d()) === f; q = q.b()) {
                        var r = q.d(),
                        s = this.c3(r);
                        s.f() ? i.ac(r) : s.c() ? k.ac(r) : s.d() && m.ac(r)
                    }
                    var t;
                    for (t = e.a(); null != t && this._n.i1(t.d()) === f; t = t.a()) {
                        var u = t.d(),
                        v = this.c3(u);
                        v.e() ? h.aa(u) : v.c() ? j.aa(u) : v.d() && l.aa(u)
                    }
                    e = t
                }
            }
            for (var w = this.d2(a), x = 0, y = 0; y < a.length; y++) {
                var z = w[y];
                y > 0 && (x += w[y - 1]._j + w[y - 1]._h + w[y - 1]._b),
                x += z._g + z._f + z._a + z._d;
                for (var A = a[y].x1(); A.i1(); A.i2()) {
                    var B = A.i9();
                    this._d.s3(B, this._d.gi(B), this._d.gh(B) + x)
                }
                z._c += x,
                z._i += x
            }
            for (var C = 0; C < a.length; C++) for (var D = a[C], E = D.x1(); E.i1(); E.i2()) {
                var F = E.i9();
                null != this._n.i1(F) && D.av(E)
            }
            for (var G = this,
            H = function(a, b) {
                return G.a3(a) ? G.a3(b) && G._d.gi(a) >= G._d.gi(b) ? -1 : 1 : G.a3(b) ? -1 : G._d.gi(a) >= G._d.gi(b) ? 1 : -1
            },
            I = function(a, b) {
                return G.a3(a) ? G.a3(b) ? G._d.gi(a) >= G._d.gi(b) ? 1 : -1 : 1 : G.a3(b) ? -1 : G._d.gi(a) >= G._d.gi(b) ? -1 : 1
            },
            J = 0; J < a.length; J++) for (var K = w[J], L = a[J].x1(); L.i1(); L.i2()) {
                var M = L.i9();
                if (!this._t.b2(M)) {
                    var N = this._f.i1(M),
                    O = N._d,
                    P = N._a,
                    Q = N._b,
                    R = N._h,
                    S = N._f,
                    T = N._c,
                    U = N._g,
                    V = N._e,
                    W = 0,
                    X = 0,
                    Y = 0,
                    Z = 0,
                    $ = M.ao(),
                    _ = M.ak(),
                    aa = this._d.gi(M),
                    ba = this._d.gh(M),
                    ca = this._d.gj(M),
                    da = this._d.g9(M),
                    ea = this._t.a3(M),
                    fa = zf._z;
                    if (this._b.a2(M) && (fa = this._b.b2(M)), null != ea) {
                        if (W = ea._d.ay(), X = ea._b.ay(), Y = ea._e.ay(), Z = ea._c.ay(), W > 0) for (var ga = fa._h.ay() + O.ay() + W + fa._k.ay(), ha = this.a7(da, ga), ia = this.a8(da, ga, ha), ja = ba + ia + ha * (fa._h.ay() + this.a4(O)), ka = ea._d.c1(); ka.i1(); ka.i2()) {
                            var la = ka.i8();
                            this._d.u1(la),
                            la.a2() === M ? this.c2(la) || this._d.gx(la, new Rd(aa + ca, ja)) : (this.d1(la), this._d.gy(la, new Rd(aa + ca, ja))),
                            ja += ha,
                            this._d.h1(la)
                        }
                        if (X > 0) for (var ma = fa._i.ay() + P.ay() + X + fa._l.ay(), na = this.a7(da, ma), oa = this.a8(da, ma, na), pa = ba + oa + na * (fa._i.ay() + this.a4(P)), qa = ea._b.c1(); qa.i1(); qa.i2()) {
                            var ra = qa.i8();
                            this._d.u1(ra),
                            ra.a2() === M ? this.c2(ra) || this._d.gx(ra, new Rd(aa, pa)) : this.d1(ra) || this._d.gy(ra, new Rd(aa, pa)),
                            pa += na,
                            this._d.h1(ra)
                        }
                    }
                    if (O.ay() > 0) {
                        O.a1(H);
                        for (var sa = fa._h.ay() + O.ay() + W + fa._k.ay(), ta = this.a7(da, sa), ua = this.a8(da, sa, ta), va = ba + ua + ta * fa._h.ay(), wa = !0; ! O.ar();) {
                            var xa = O.x4();
                            if (this.a3(xa)) {
                                wa && (wa = !1, va += ta * W);
                                var ya = xa.ag(),
                                za = this._d.gd(ya),
                                Aa = za.at();
                                if (za.ac(new Rd(Aa.x, K.b())), this.c2(ya)) {
                                    var Ba = this._a.i1(ya);
                                    za.ac(new Rd(Aa.x, Ba.y + this._d.g6(M))),
                                    za.ac(new Rd(Ba.x + this._d.g5(M), Ba.y + this._d.g6(M)))
                                } else za.ac(new Rd(Aa.x, va)),
                                za.ac(new Rd(aa + ca, va));
                                this._d.xr(ya, M, ya.a3()),
                                this._d.m1(ya, za)
                            } else {
                                var Ca = xa.ae(),
                                Da = this._d.gd(Ca),
                                Ea = Da.au();
                                if (Da.ae(new Rd(Ea.x, K.a())), this.d1(Ca)) {
                                    var Fa = this._g.i1(Ca);
                                    Da.ae(new Rd(Ea.x, Fa.y + this._d.g6(M))),
                                    Da.ae(new Rd(Fa.x + this._d.g5(M), Fa.y + this._d.g6(M)))
                                } else Da.ae(new Rd(Ea.x, va)),
                                Da.ae(new Rd(aa + ca, va));
                                this._d.xr(Ca, Ca.a2(), M),
                                this._d.m1(Ca, Da)
                            }
                            this._d.x4(xa),
                            va += ta
                        }
                    }
                    if (P.ay() > 0) {
                        P.a1(I);
                        for (var Ga = fa._i.ay() + P.ay() + X + fa._l.ay(), Ha = this.a7(da, Ga), Ia = this.a8(da, Ga, Ha), Ja = ba + Ia + Ha * fa._i.ay(), Ka = !0; ! P.ar();) {
                            var La = P.x4();
                            if (this.a3(La)) {
                                Ka && (Ka = !1, Ja += Ha * X);
                                var Ma = La.ag(),
                                Na = this._d.gd(Ma),
                                Oa = Na.at();
                                if (Na.ac(new Rd(Oa.x, K.b())), this.c2(Ma)) {
                                    var Pa = this._a.i1(Ma);
                                    Na.ac(new Rd(Oa.x, Pa.y + this._d.g6(M))),
                                    Na.ac(new Rd(Pa.x + this._d.g5(M), Pa.y + this._d.g6(M)))
                                } else Na.ac(new Rd(Oa.x, Ja)),
                                Na.ac(new Rd(aa, Ja));
                                this._d.xr(Ma, M, Ma.a3()),
                                this._d.m1(Ma, Na)
                            } else {
                                var Qa = La.ae(),
                                Ra = this._d.gd(Qa),
                                Sa = Ra.au();
                                if (Ra.ae(new Rd(Sa.x, K.a())), this.d1(Qa)) {
                                    var Ta = this._g.i1(Qa);
                                    Ra.ae(new Rd(Sa.x, Ta.y + this._d.g6(M))),
                                    Ra.ae(new Rd(Ta.x + this._d.g5(M), Ta.y + this._d.g6(M)))
                                } else Ra.ae(new Rd(Sa.x, Ja)),
                                Ra.ae(new Rd(aa, Ja));
                                this._d.xr(Qa, Qa.a2(), M),
                                this._d.m1(Qa, Ra)
                            }
                            this._d.x4(La),
                            Ja += Ha
                        }
                    }
                    var Ua = fa._g.ay() + fa._d.ay() + _ + R.ay() + Q.ay() + Y + Z;
                    ca = this._d.gj(M);
                    var Va = this.a7(ca, Ua),
                    Wa = this.a8(ca, Ua, Va);
                    Ua = fa._b.ay() + fa._q.ay() + $ + T.ay() + S.ay();
                    var Xa = this.a7(ca, Ua),
                    Ya = this.a8(ca, Ua, Xa);
                    if (R.ay() > 0) for (var Za, $a = Va,
                    _a = b,
                    ab = this._d.gi(M) + Wa + $a * (fa._g.ay() + R.ay() - 1), bb = this._d.gh(M), cb = K._c - K._g - R.ay() * _a; ! R.ar(); this._d.x4(Za)) {
                        Za = R.x4();
                        var db = Za.ag(),
                        eb = this._d.gd(db),
                        fb = eb.at();
                        if (eb.ac(new Rd(fb.x, K.b())), eb.ac(new Rd(fb.x, cb)), this.c2(db)) {
                            var gb = this._a.i1(db);
                            eb.ac(new Rd(gb.x + this._d.g5(M), cb)),
                            eb.ac(new Rd(gb.x + this._d.g5(M), gb.y + this._d.g6(M)))
                        } else eb.ac(new Rd(ab, cb)),
                        eb.ac(new Rd(ab, bb)),
                        ab -= $a;
                        cb += _a,
                        this._d.xr(db, M, db.a3()),
                        this._d.m1(db, eb)
                    }
                    if (Q.ay() > 0) for (var hb, ib = Va,
                    jb = b,
                    kb = this._d.gi(M) + this._d.gj(M) - Wa - ib * fa._d.ay(), lb = this._d.gh(M), mb = K._c - K._g - jb; ! Q.ar(); this._d.x4(hb)) {
                        hb = Q.x4();
                        var nb = hb.ag(),
                        ob = this._d.gd(nb),
                        pb = ob.at();
                        if (ob.ac(new Rd(pb.x, K.b())), ob.ac(new Rd(pb.x, mb)), this.c2(nb)) {
                            var qb = this._a.i1(nb);
                            ob.ac(new Rd(qb.x + this._d.g5(M), mb)),
                            ob.ac(new Rd(qb.x + this._d.g5(M), qb.y + this._d.g6(M)))
                        } else ob.ac(new Rd(kb, mb)),
                        ob.ac(new Rd(kb, lb)),
                        kb -= ib;
                        mb -= jb,
                        this._d.xr(nb, M, nb.a3()),
                        this._d.m1(nb, ob)
                    }
                    if (T.ay() > 0) for (var rb, sb = Xa,
                    tb = b,
                    ub = this._d.gi(M) + Ya + sb * (fa._b.ay() + T.ay() - 1), vb = this._d.gh(M) + this._d.g9(M), wb = vb + T.ay() * tb; ! T.ar(); this._d.x4(rb)) {
                        rb = T.x4();
                        var xb = rb.ae(),
                        yb = this._d.gd(xb),
                        zb = yb.au();
                        if (yb.ae(new Rd(zb.x, K.a())), yb.ae(new Rd(zb.x, wb)), this.d1(xb)) {
                            var Ab = this._g.i1(xb);
                            yb.ae(new Rd(Ab.x + this._d.g5(M), wb)),
                            yb.ae(new Rd(Ab.x + this._d.g5(M), Ab.y + this._d.g6(M)))
                        } else yb.ae(new Rd(ub, wb)),
                        yb.ae(new Rd(ub, vb)),
                        ub -= sb;
                        wb -= tb,
                        this._d.xr(xb, xb.a2(), M),
                        this._d.m1(xb, yb)
                    }
                    if (S.ay() > 0) for (var Bb, Cb = Xa,
                    Db = b,
                    Eb = this._d.gi(M) + this._d.gj(M) - Ya - Xa * fa._q.ay(), Fb = this._d.gh(M) + this._d.g9(M), Gb = Fb + Db; ! S.ar(); this._d.x4(Bb)) {
                        Bb = S.x4();
                        var Hb = Bb.ae(),
                        Ib = this._d.gd(Hb),
                        Jb = Ib.au();
                        if (Ib.ae(new Rd(Jb.x, K.a())), Ib.ae(new Rd(Jb.x, Gb)), this.d1(Hb)) {
                            var Kb = this._g.i1(Hb);
                            Ib.ae(new Rd(Kb.x + this._d.g5(M), Gb)),
                            Ib.ae(new Rd(Kb.x + this._d.g5(M), Kb.y + this._d.g6(M)))
                        } else Ib.ae(new Rd(Eb, Gb)),
                        Ib.ae(new Rd(Eb, Fb)),
                        Eb -= Cb;
                        Gb += Db,
                        this._d.xr(Hb, Hb.a2(), M),
                        this._d.m1(Hb, Ib)
                    }
                    for (; ! V.ar();) {
                        var Lb = V.c3(),
                        Mb = this._d.gl(Lb);
                        K.a() + 12 < Mb.y && this._d.g7(Lb).i4(Mb.x, K.a())
                    }
                    for (; ! U.ar();) {
                        var Nb = U.c3(),
                        Ob = this._d.gs(Nb);
                        if (K.b() - 12 > Ob.y) {
                            var Pb = this._d.gf(Nb);
                            Pb.ac(new Rd(Ob.x, K.b())),
                            this._d.s6(Nb, Pb)
                        }
                    }
                }
            }
            for (var Qb = 0; Qb < a.length; Qb++) for (var Rb = a[Qb], Sb = Rb._b; null != Sb; Sb = Sb.a()) {
                var Tb = Sb.d(),
                Ub = this._t.a3(Tb);
                null != Ub && null != Ub._a && (this._d.x4(Ub._a), Rb.aw(Sb.b()))
            }
            return this._d.xi(this._f),
            this._d.xj(this._a),
            this._d.xj(this._g),
            a
        },
        c3: function(a) {
            return this.a3(a) ? this.b1(a.ag()) : this.a2(a.ae())
        },
        b1: function(a) {
            return null == this._h ? zf.s: this._h.i1(a)
        },
        a2: function(a) {
            return null == this._l ? zf.u: this._l.i1(a)
        },
        c2: function(a) {
            if (null == a) return ! 1;
            var b = this.b1(a);
            return null != b && b.a()
        },
        d1: function(a) {
            if (null == a) return ! 1;
            var b = this.a2(a);
            return null != b && b.a()
        },
        a3: function(a) {
            return 1 === a.ao()
        },
        b2: function(a) {
            return 1 === a.ak()
        },
        a4: function(a) {
            for (var b = 0,
            c = a._b; null != c; c = c.a()) this.b2(c.d()) && b++;
            return b
        },
        d2: function(a) {
            for (var b = this._k,
            c = Gf.d(a.length + 1), d = 0; d < a.length; d++) {
                var e = a[d],
                f = new Df;
                c[d] = f,
                f._c = Number.MAX_VALUE,
                f._i = Number.MIN_VALUE;
                for (var g = e.x1(); g.i1(); g.i2()) {
                    var h = g.i9(),
                    i = this._d.gb(h);
                    f._c = Math.min(f._c, i.i2()),
                    f._i = Math.max(f._i, i.i2() + i.i4())
                }
            }
            this._b.a5(a, c);
            for (var j = 0; j < a.length; j++) for (var k = c[j], l = a[j].x1(); l.i1(); l.i2()) {
                var m = l.i9(),
                n = this._f.i1(m);
                null != n && (k._h = Math.max(k._h, Math.max(n._f.ay() * b, n._c.ay() * b)), k._f = Math.max(k._f, Math.max(n._b.ay() * b, n._h.ay() * b)))
            }
            return c
        }
    }),
    zf.s = of.j(2),
    zf.u = of.j(1),
    zf._z = new yf;
    var Af = function() {
        this._af = 0,
        this._b = 0
    };
    Jb.ext(Af, Object, {
        ib: function(a) {
            this._af = a
        },
        ia: function(a, b, c) {
            this.a6(a, b, c),
            this.b2(!1);
            var d = this.g();
            if (this.o() && d > 0) {
                for (var e = this.r(), f = 0; 20 > f && d > 0 && this.o(); f++) {
                    this.b2(!0);
                    var g = this.g();
                    d > g && (this.a7(e), d = g)
                }
                this.b3(e),
                this.b1()
            }
            return this.c()
        },
        a6: function(a, b, c) {
            this._b = (new Date).getTime(),
            this._ac = a,
            this._ah = b;
            var d = this;
            this._p = function(a, b) {
                var c = d._n[a.al()] - d._n[b.al()];
                return c > 0 ? 1 : c >= 0 ? 0 : -1
            },
            this._ad = Gf.d(c);
            for (var e = 0; e < this._ad.length; e++) this._ad[e] = new Ie;
            this._ab = Gf.a(this._ac.x0()),
            this._f = Gf.d(this._ac.x0()),
            this._n = Gf.a(this._ac.x0() + 1);
            var f = this._ab;
            this._o = function(a, b) {
                if (null == a && null != b) return 1;
                if (null != a && null == b) return - 1;
                if (null == a && null == b) return 0;
                var c = a,
                d = b,
                e = c._h,
                g = c.a2(),
                h = d.a2(),
                i = f[g.al()] - f[h.al()];
                if (0 === i) {
                    var j = Af.b(of.h(e, c), e.gn(c)),
                    k = Af.b(of.h(e, d), e.gn(d)),
                    l = j - k;
                    if (0 === l) {
                        var m = f[c.a3().al()] - f[d.a3().al()];
                        if (0 === m) {
                            var n = Af.a(of.i(e, c), e.gk(c)),
                            o = Af.a(of.i(e, d), e.gk(d));
                            return n - o
                        }
                        return m
                    }
                    return l
                }
                return i
            },
            this._l = function(a, b) {
                if (null == a && null != b) return 1;
                if (null != a && null == b) return - 1;
                if (null == a && null == b) return 0;
                var c = a,
                d = b,
                e = c._h,
                g = c.a3(),
                h = d.a3(),
                i = f[g.al()] - f[h.al()];
                if (0 === i) {
                    var j = Af.a(of.i(e, c), e.gk(c)),
                    k = Af.a(of.i(e, d), e.gk(d)),
                    l = j - k;
                    if (0 === l) {
                        var m = f[c.a2().al()] - f[d.a2().al()];
                        if (0 === m) {
                            var n = Af.b(of.h(e, c), e.gn(c)),
                            o = Af.b(of.h(e, d), e.gn(d));
                            return n - o
                        }
                        return m
                    }
                    return l
                }
                return i
            },
            this._z = function(a, b) {
                if (null == a && null != b) return 1;
                if (null != a && null == b) return - 1;
                if (null == a && null == b) return 0;
                var c = a,
                d = b,
                e = c._h,
                f = Af.b(of.h(e, c), e.gn(c)),
                g = Af.b(of.h(e, d), e.gn(d));
                return f - g
            },
            this._e = function(a, b) {
                if (null == a && null != b) return 1;
                if (null != a && null == b) return - 1;
                if (null == a && null == b) return 0;
                var c = a,
                d = b,
                e = c._h,
                f = Af.a(of.i(e, c), e.gk(c)),
                g = Af.a(of.i(e, d), e.gk(d));
                return f - g
            },
            this._ac.x2(this._e, this._z)
        },
        c: function() {
            this._ah = null,
            this._aa = null,
            this._f = null,
            this._n = null,
            this._p = null,
            this._o = null,
            this._l = null,
            this._ac = null;
            var a = this._ad;
            return this._ad = null,
            a
        },
        o: function() {
            var a = (new Date).getTime() - this._b;
            return a <= this._af
        },
        m: function() {
            for (var a = this,
            b = function(b, c) {
                return Math.ceil(a._n[b.a3().al()]) - Math.ceil(a._n[c.a3().al()])
            },
            c = this._ac.x9(); c.i1(); c.i2()) {
                for (var d = c.i9().aw(); d.i1(); d.i2()) this._n[d.i9().al()] = ef.j();
                c.i9().av(b)
            }
        },
        b2: function(a) {
            for (var b = 0; b < this._ad.length; b++) this._ad[b].af();
            if (a) {
                this.m();
                for (var c = 0,
                d = this._ab.length; d > c; c++) this._ab[c] = 0;
                this._ac.x2(null, this._z)
            }
            var e = this._ac.xm();
            this._ah.i7(e, 0);
            for (var f = this._ac.x9(); f.i1(); f.i2()) 0 === f.i9().ak() && f.i9() !== e && this._ac.xo(e, f.i9());
            var g = new de(this);
            g.a6(!0),
            g.a9(this._ac, e),
            this._ad[0].at(),
            this._ac.x4(e),
            this.d()
        },
        a1: function() {
            this._ac.x2(this._o, this._l);
            for (var a = 0,
            b = 1; b < this._ad.length; b++) {
                var c = this.a2(this._ad[b - 1], this._ad[b]);
                a += c
            }
            var d = 0;
            return a += d
        },
        a2: function(a, b) {
            var c = a.ah(),
            d = b.ah(),
            e = new pe,
            f = new pe;
            this._aa = Gf.d(this._ac.x0());
            for (var g = 0; c.i1() && d.i1(); d.i2()) g += this.a8(c.i6(), e, f, !0),
            g += this.a8(d.i6(), f, e, !1),
            c.i2();
            for (; c.i1(); c.i2()) g += this.a8(c.i6(), e, f, !0);
            for (; d.i1(); d.i2()) g += this.a8(d.i6(), f, e, !1);
            return g
        },
        a8: function(a, b, c, d) {
            var e = 0,
            f = 0,
            g = 0;
            if (null != this._aa[a.al()]) for (var h = this._aa[a.al()].a(), i = b._b; i !== h; i = i.a()) {
                var j = i._c;
                j === a ? (e++, g += f, b.aw(i)) : f++
            }
            var k = e * c.ay() + g;
            if (d) for (var l = a.ag(); null != l; l = l.a8()) {
                var m = l.a3();
                this._ab[m.al()] >= this._ab[a.al()] && (this._aa[m.al()] = c.ae(m))
            } else for (var n = a.ae(); null != n; n = n.a7()) {
                var o = n.a2();
                this._ab[o.al()] > this._ab[a.al()] && (this._aa[o.al()] = c.ae(o))
            }
            return k
        },
        g: function() {
            for (var a = this.r(), b = this.a1(), c = !0, d = 0; 3 > d && this.o() && b > 0;) {
                var e = this.k();
                b > e ? (this.a7(a), b = e) : d++,
                c = !c
            }
            if (this.b3(a), this.b1(), b > 0) {
                for (var f = 1,
                g = 0; 1 === f && b > 0; g++) {
                    this.e(),
                    this.i();
                    var h = this.a1();
                    b > h ? (f = 1, this.a7(a)) : f = -1,
                    b = h
                }
                this.b3(a),
                this.b1()
            }
            return b
        },
        e: function() {
            for (var a = this.l(), b = this.r(), c = Gf.d(this._ac.x0()), d = this._ad.length - 1; d >= 0; d--) for (var e = this._ad[d].ah(); e.i1(); e.i2()) {
                var f = e.i6();
                if (1 === f.ak() && 1 === f.ao()) {
                    var g = a.i1(f.ag());
                    if (null != g && null == c[g.al()]) for (var h = this.a4(f, g), i = g.al(), j = c[i] = Gf.d(h + 1), k = j.length - 1; k >= 0; k--) j[k] = new pe
                }
            }
            for (var l = 0; l < this._ad.length; l++) for (var m = this._ad[l].ah(); m.i1(); m.i2()) {
                var n = m.i6();
                if (1 === n.ak() && 1 === n.ao()) {
                    var o = a.i1(n.ag());
                    if (null != o) {
                        var p = o.al(),
                        q = this.a4(n, o) - 1;
                        c[p][q].ae(n.ae())
                    }
                } else for (var r = n.ae(); null != r; r = r.a7()) {
                    var s = a.i1(r);
                    if (null != s) {
                        var t = s.al(),
                        u = this.a4(n, s) - 1;
                        c[t][u].ae(r)
                    }
                }
            }
            for (var v = this._ac.x9(); v.i1(); v.i2()) {
                var w = v.i9();
                if (null != c[w.al()]) for (var x = w.ag(); null != x; x = x.a8()) {
                    var y = a.i1(x);
                    if (null != y) for (var z = c[y.al()]; z[0].ay() > 0;) {
                        for (var A, B = 0;;) {
                            A = z[B].am();
                            var C = A.a3();
                            if (1 !== C.ak() || 1 !== C.ao()) break;
                            B++
                        }
                        var D = z[B].at().a3();
                        B--,
                        D = A.a2(),
                        A = z[B].at();
                        for (var E = A.a3(); B >= 0;) if (b[D.al()] !== b[E.al()] && (this._ab[D.al()] = b[E.al()]), D = D.ae().a2(), --B >= 0) {
                            var F = z[B].at();
                            E = F.a3()
                        }
                    }
                }
            }
            this.b1(),
            this._ac.xj(a)
        },
        i: function() {
            for (var a = this.f(), b = this.r(), c = Gf.d(this._ac.x0()), d = 0; d < this._ad.length; d++) for (var e = this._ad[d].ah(); e.i1(); e.i2()) {
                var f = e.i6();
                if (1 === f.ak() && 1 === f.ao()) {
                    var g = a.i1(f.ae());
                    if (null != g && null == c[g.al()]) for (var h = this.a4(g, f), i = g.al(), j = c[i] = Gf.d(h + 1), k = j.length - 1; k >= 0; k--) j[k] = new pe
                }
            }
            for (var l = this._ad.length - 1; l >= 0; l--) for (var m = this._ad[l].ah(); m.i1(); m.i2()) {
                var n = m.i6();
                if (1 === n.ak() && 1 === n.ao()) {
                    var o = a.i1(n.ae());
                    if (null != o) {
                        var p = o.al(),
                        q = this.a4(o, n) - 1;
                        c[p][q].ae(n.ag())
                    }
                } else for (var r = n.ag(); null != r; r = r.a8()) {
                    var s = a.i1(r);
                    if (null != s) {
                        var t = s.al(),
                        u = this.a4(s, n) - 1;
                        c[t][u].ae(r)
                    }
                }
            }
            for (var v = this._ac.x9(); v.i1(); v.i2()) {
                var w = v.i9();
                if (null != c[w.al()]) for (var x = w.ae(); null != x; x = x.a7()) {
                    var y = a.i1(x);
                    if (null != y) for (var z = c[y.al()]; z[0].ay() > 0;) {
                        for (var A, B = 0;;) {
                            A = z[B].am();
                            var C = A.a2();
                            if (1 !== C.ak() || 1 !== C.ao()) break;
                            B++
                        }
                        var D = z[B].at().a2();
                        B--,
                        D = A.a3(),
                        A = z[B].at();
                        for (var E = A.a2(); B >= 0;) if (b[D.al()] !== b[E.al()] && (this._ab[D.al()] = b[E.al()]), D = D.ag().a3(), --B >= 0) {
                            var F = z[B].at();
                            E = F.a2()
                        }
                    }
                }
            }
            this.b1(),
            this._ac.xj(a)
        },
        a4: function(a, b) {
            return this._ah.i2(a) - this._ah.i2(b)
        },
        l: function() {
            for (var a = Me.a6(Gf.d(this._ac.xg())), b = this._ac.x9(); b.i1(); b.i2()) {
                var c = b.i9();
                if (c.ao() > 1) {
                    for (var d = 0,
                    e = c.ag(); null != e; e = e.a8()) {
                        var f = e.a3();
                        1 === f.ak() && 1 === f.ao() && d++
                    }
                    if (d > 1) for (var g = c.ag(); null != g; g = g.a8()) {
                        var h = g,
                        i = h.a3();
                        if (1 === i.ak() && 1 === i.ao()) {
                            for (; 1 === i.ak() && 1 === i.ao(); i = h.a3()) a.i8(h, c),
                            h = i.ag();
                            a.i8(h, c)
                        }
                    }
                }
            }
            return a
        },
        f: function() {
            for (var a = Me.a6(Gf.d(this._ac.xg())), b = this._ac.x9(); b.i1(); b.i2()) {
                var c = b.i9();
                if (c.ak() > 1) {
                    for (var d = 0,
                    e = c.ae(); null != e; e = e.a7()) {
                        var f = e.a2();
                        1 === f.ak() && 1 === f.ao() && d++
                    }
                    if (d > 1) for (var g = c.ae(); null != g; g = g.a7()) {
                        var h = g,
                        i = h.a2();
                        if (1 === i.ak() && 1 === i.ao()) {
                            for (; 1 === i.ak() && 1 === i.ao(); i = h.a2()) a.i8(h, c),
                            h = i.ae();
                            a.i8(h, c)
                        }
                    }
                }
            }
            return a
        },
        k: function() {
            for (var a = 1; a < this._ad.length; a++) {
                for (var b = this._ad[a], c = b.ah(); c.i1(); c.i2()) {
                    var d = c.i6();
                    this._n[d.al()] = this.a5(d, b.ay(), d.am(), this._ad[a - 1].ay()),
                    this._n[d.al()] += this._ab[d.al()] / (3 * this._ad[a - 1].ay())
                }
                this.a3(b, this._p)
            }
            return this.a1()
        },
        a5: function(a, b, c, d) {
            var e = 0;
            if (0 === c.i7()) e = d * this._ab[a.al()] / b;
            else {
                for (; c.i1(); c.i2()) {
                    var f = c.i8();
                    e += f.a2() === a ? this._ab[f.a3().al()] : this._ab[f.a2().al()]
                }
                e /= c.i7()
            }
            return e
        },
        a7: function(a) {
            Gf.f(this._ab, a, a.length)
        },
        b3: function(a) {
            Gf.f(a, this._ab, a.length)
        },
        r: function() {
            var a = Gf.a(this._ab.length);
            return this.a7(a),
            a
        },
        d: function() {
            for (var a = 0; a < this._ad.length; a++) for (var b = 0,
            c = this._ad[a].ah(); c.i1();) this._ab[c.i6().al()] = b,
            c.i2(),
            b++
        },
        b1: function() {
            for (var a = 0; a < this._ad.length; a++) {
                for (var b = this._ad[a], c = b._b; null != c; c = c.a()) {
                    var d = c.d();
                    this._f[this._ab[d.al()]] = d
                }
                for (var e = 0,
                f = b._b; null != f;) f.c(this._f[e]),
                f = f.a(),
                e++
            }
        },
        a3: function(a, b) {
            for (var c = a.ah(), d = 0; d < a.ay(); c.i2()) this._f[d] = c.i6(),
            d++;
            Gf.s(this._f, a.ay(), b);
            for (var e = 0,
            f = a._b; null != f;) f.c(this._f[e]),
            this._ab[this._f[e].al()] = e,
            f = f.a(),
            e++
        }
    }),
    Af.b = function(a, b) {
        if (null == a) return 0;
        var c = a.a() ? Math.floor(b.x) : 0,
        d = a.a() ? Math.floor(b.y) : 0;
        return a.e() ? 1e4 - d: a.f() ? -1e4 + d: a.c() ? -2e4 - c: c
    },
    Af.a = function(a, b) {
        if (null == a) return 0;
        var c = a.a() ? Math.floor(b.x) : 0,
        d = a.a() ? Math.floor(b.y) : 0;
        return a.e() ? 1e4 + d: a.f() ? -1e4 - d: a.d() ? -2e4 - c: c
    };
    var Bf = function() {
        Bf.superClass.constructor.call(this),
        this._i6 = 0,
        this._i3 = 2147483647,
        this._i0 = 60,
        this._iz = 20,
        this._i2 = 20,
        this._i4 = 20,
        this.i5(!1),
        this._i7 = new tf,
        this._i1 = new Af,
        this._i8 = new wf
    };
    Jb.ext(Bf, Pe, {
        j2: function() {
            return this._i2
        },
        i4: function(a) {
            return ! 0
        },
        i3: function(a) {
            this._i6 = (new Date).getTime(),
            nf.d(a, !1);
            var b = a.xk(),
            c = a.xk(),
            d = a.xl(),
            e = new qe,
            f = new zf(a, b, c, d);
            f.a6(this.j2()),
            this._i8.i3(this._iz),
            this._i8.i6(this._i0),
            this._i8.i4(this._i2),
            this._i8.i5(this._i4),
            this._i8.i2(c);
            for (var g = this._i7.i1(a, b, e), h = e.c1(); h.i1(); h.i2()) {
                var i = h.i8();
                d.i7(i, !0);
                var j = a.gn(i);
                a.gt(i, a.gk(i)),
                a.gz(i, j)
            }
            this.a2(a, b, c),
            g = f.a9(g);
            var k = this.j1(a, b, g);
            k = f.a5(k),
            k = f.b3(k),
            this._i8.i1(a, k, b),
            k = f.g2(k),
            f.e2(k),
            this.b(a, c),
            this.w(a),
            this.a1(a, e),
            f.e1(),
            a.xj(d),
            a.xi(c),
            a.xi(b)
        },
        j1: function(a, b, c) {
            if (this._i1 instanceof Af) {
                var d = this._i1,
                e = (new Date).getTime() - this._i6;
                d.ib(this._i3 - e)
            }
            var f = this._i1.ia(a, b, c);
            return f
        },
        a1: function(a, b) {
            for (var c = b.c1(); c.i1(); c.i2()) {
                var d = c.i8(),
                e = a.gs(d),
                f = a.gl(d);
                a.x3(d);
                var g = a.gp(d);
                a.s5(d, g.a()),
                a.gy(d, e),
                a.gx(d, f)
            }
        },
        b: function(a, b) {
            for (var c = a.x9(); c.i1(); c.i2()) {
                var d = c.i9(),
                e = b.i1(d);
                if (null != e && !a.xp(e)) {
                    for (var f = d.am().i8().a2(); null != b.i1(f); f = d.am().i8().a2()) d = f;
                    a.u1(e);
                    for (var g = d.ae(), h = new pe; null != b.i1(g.a3()); g = g.a3().ag()) {
                        var i = a.gs(g);
                        h.aa(i),
                        h.az(a.gf(g));
                        var j = a.gl(g);
                        j.equals(i) || h.aa(j)
                    }
                    var k = a.gs(g);
                    h.aa(k),
                    h.az(a.gf(g));
                    var l = a.gl(g);
                    l.equals(k) || h.aa(l),
                    a.m1(e, h)
                }
            }
            for (var m = a.x9(); m.i1(); m.i2()) null != b.i1(m.i9()) && a.x4(m.i9())
        },
        w: function(a) {
            for (var b = a.xf(); b.i1(); b.i2()) {
                var c = b.i8(),
                d = a.g2(c);
                if (d.i1() > 0) {
                    var e = new nd,
                    f = a.gc(c),
                    g = f.c(),
                    h = g.i6();
                    g.i2();
                    var i = h.x,
                    j = h.y;
                    if (g.i1()) {
                        var k = g.i6(),
                        l = k.x,
                        m = k.y;
                        for (g.i2(); g.i1(); g.i2()) {
                            var n = g.i6(),
                            o = n.x,
                            p = n.y,
                            q = (i - o) * (m - p) / (j - p) + o;
                            Math.abs(q - l) >= 1 && (e.add(k), i = l, j = m),
                            k = n,
                            l = o,
                            m = p
                        }
                    }
                    e.size() < d.i1() && a.s5(c, new Wd(e))
                }
            }
        },
        a2: function(a, b, c) {
            var d = a.g8().c1();
            for (d.i5(); d.i1(); d.i3()) {
                var e = d.i8().a2(),
                f = d.i8().a3(),
                g = b.i2(f) - b.i2(e);
                if (g > 1) {
                    for (var h = null,
                    i = null,
                    j = e; g > 1; g--) h = a.xm(),
                    a.s7(h, 1, 1),
                    a.s4(h, ef._A),
                    i = a.xo(j, h),
                    j === e && a.gt(i, a.gn(d.i8())),
                    b.i7(h, b.i2(j) + 1),
                    c.z1(h, d.i8()),
                    j = h;
                    i = a.xo(h, f),
                    a.gz(i, a.gk(d.i8())),
                    a.h1(d.i8())
                }
            }
        }
    });
    var Cf = function(a, b, c, d) {
        this._i = 20,
        this._j = a,
        this._g = b,
        this._a = c,
        this._h = d
    };
    Jb.ext(Cf, Object, {
        a1: function(a) {
            this._i = a
        },
        b2: function(a) {
            return null == this._e ? !1 : this._e.i4(a)
        },
        a3: function(a) {
            return null == this._f ? null: this._f.i1(a)
        },
        d: function() {
            this._j.xi(this._f),
            this._j.xi(this._e)
        }
    });
    var Df = function() {
        this._c = 0,
        this._i = 0,
        this._g = 0,
        this._j = 0,
        this._f = 0,
        this._h = 0,
        this._d = 0,
        this._e = 0,
        this._a = 0,
        this._b = 0
    };
    Jb.ext(Df, Object, {
        a: function() {
            return this._c - this._g - this._f - this._a
        },
        b: function() {
            return this._i + this._j + this._h + this._b
        }
    });
    var Ef = function() {
        this._d = new qe,
        this._b = new qe,
        this._c = new qe,
        this._e = new qe
    };
    Jb.ext(Ef, Object, {});
    var Ff = function(a, b, c, d, e, f, g, h) {
        this._d = a,
        this._a = b,
        this._b = c,
        this._h = d,
        this._f = e,
        this._c = f,
        this._e = g,
        this._g = h
    };
    Jb.ext(Ff, Object, {});
    var Gf = {};
    Gf.a = function(a, b) {
        for (var c = [], d = 0; a > d; d++) c[d] = b || 0;
        return c
    },
    Gf.b = function(a) {
        for (var b = [], c = 0; a > c; c++) b[c] = !1;
        return b
    },
    Gf.c = function(a, b) {
        if (a instanceof Rd) return a.x < b.x ? -1 : a.x > b.x ? 1 : a.y < b.y ? -1 : a.y <= b.y ? 0 : 1;
        if (a instanceof Sd) return b.width > a.width ? -1 : b.width < a.width ? 1 : b.height > a.height ? -1 : b.height >= a.height ? 0 : 1;
        if (a instanceof Ud) return a.x < b.x ? -1 : a.x > b.x ? 1 : a.y < b.y ? -1 : a.y > b.y ? 1 : b.width > a.width ? -1 : b.width < a.width ? 1 : b.height > a.height ? -1 : b.height >= a.height ? 0 : 1;
        throw "Unkown Type: " + a
    },
    Gf.d = function(a) {
        for (var b = [], c = 0; a > c; c++) b[c] = null;
        return b
    },
    Gf.e = function(a, b) {
        for (var c = [], d = 0; a > d; d++) c[d] = Gf.a(b);
        return c
    },
    Gf.f = function(a, b, c) {
        for (var d = 0; c > d; d++) b[d] = a[d]
    },
    Gf.s = function(a, b, c) {
        var d = [];
        Gf.f(a, d, b),
        d.sort(c),
        Gf.f(d, a, b)
    },
    Gf.n = function(a, b) {
        return a - b
    }
} (this);
var TWEEN = TWEEN ||
function() {
    var a = [];
    return {
        REVISION: "14",
        getAll: function() {
            return a
        },
        removeAll: function() {
            a = []
        },
        add: function(b) {
            a.push(b)
        },
        remove: function(b) {
            b = a.indexOf(b),
            -1 !== b && a.splice(b, 1)
        },
        update: function(b) {
            if (0 === a.length) return ! 1;
            for (var c = 0,
            b = void 0 !== b ? b: "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); c < a.length;) a[c].update(b) ? c++:a.splice(c, 1);
            return ! 0
        }
    }
} ();
TWEEN.Tween = function(a) {
    var b, c = {},
    d = {},
    e = {},
    f = 1e3,
    g = 0,
    h = !1,
    i = !1,
    j = 0,
    k = null,
    l = TWEEN.Easing.Linear.None,
    m = TWEEN.Interpolation.Linear,
    n = [],
    o = null,
    p = !1,
    q = null,
    r = null,
    s = null;
    for (b in a) c[b] = parseFloat(a[b], 10);
    this.to = function(a, b) {
        return void 0 !== b && (f = b),
        d = a,
        this
    },
    this.start = function(b) {
        TWEEN.add(this),
        i = !0,
        p = !1,
        k = void 0 !== b ? b: "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(),
        k += j;
        for (var f in d) {
            if (d[f] instanceof Array) {
                if (0 === d[f].length) continue;
                d[f] = [a[f]].concat(d[f])
            }
            c[f] = a[f],
            0 == c[f] instanceof Array && (c[f] *= 1),
            e[f] = c[f] || 0
        }
        return this
    },
    this.stop = function() {
        return i ? (TWEEN.remove(this), i = !1, null !== s && s.call(a), this.stopChainedTweens(), this) : this
    },
    this.stopChainedTweens = function() {
        for (var a = 0,
        b = n.length; b > a; a++) n[a].stop()
    },
    this.delay = function(a) {
        return j = a,
        this
    },
    this.repeat = function(a) {
        return g = a,
        this
    },
    this.yoyo = function(a) {
        return h = a,
        this
    },
    this.easing = function(a) {
        return l = a,
        this
    },
    this.interpolation = function(a) {
        return m = a,
        this
    },
    this.chain = function() {
        return n = arguments,
        this
    },
    this.onStart = function(a) {
        return o = a,
        this
    },
    this.onUpdate = function(a) {
        return q = a,
        this
    },
    this.onComplete = function(a) {
        return r = a,
        this
    },
    this.onStop = function(a) {
        return s = a,
        this
    },
    this.update = function(b) {
        var i;
        if (k > b) return ! 0; ! 1 === p && (null !== o && o.call(a), p = !0);
        var s = (b - k) / f,
        s = s > 1 ? 1 : s,
        t = l(s);
        for (i in d) {
            var u = c[i] || 0,
            v = d[i];
            v instanceof Array ? a[i] = m(v, t) : ("string" == typeof v && (v = u + parseFloat(v, 10)), "number" == typeof v && (a[i] = u + (v - u) * t))
        }
        if (null !== q && q.call(a, t), 1 == s) {
            if (! (g > 0)) {
                for (null !== r && r.call(a), i = 0, s = n.length; s > i; i++) n[i].start(b);
                return ! 1
            }
            isFinite(g) && g--;
            for (i in e)"string" == typeof d[i] && (e[i] += parseFloat(d[i], 10)),
            h && (s = e[i], e[i] = d[i], d[i] = s),
            c[i] = e[i];
            k = b + j
        }
        return ! 0
    }
},
TWEEN.Easing = {
    Linear: {
        None: function(a) {
            return a
        }
    },
    Quadratic: {
        In: function(a) {
            return a * a
        },
        Out: function(a) {
            return a * (2 - a)
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a: -.5 * (--a * (a - 2) - 1)
        }
    },
    Cubic: {
        In: function(a) {
            return a * a * a
        },
        Out: function(a) {
            return--a * a * a + 1
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * a: .5 * ((a -= 2) * a * a + 2)
        }
    },
    Quartic: {
        In: function(a) {
            return a * a * a * a
        },
        Out: function(a) {
            return 1 - --a * a * a * a
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * a * a: -.5 * ((a -= 2) * a * a * a - 2)
        }
    },
    Quintic: {
        In: function(a) {
            return a * a * a * a * a
        },
        Out: function(a) {
            return--a * a * a * a * a + 1
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * a * a * a: .5 * ((a -= 2) * a * a * a * a + 2)
        }
    },
    Sinusoidal: {
        In: function(a) {
            return 1 - Math.cos(a * Math.PI / 2)
        },
        Out: function(a) {
            return Math.sin(a * Math.PI / 2)
        },
        InOut: function(a) {
            return.5 * (1 - Math.cos(Math.PI * a))
        }
    },
    Exponential: {
        In: function(a) {
            return 0 === a ? 0 : Math.pow(1024, a - 1)
        },
        Out: function(a) {
            return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
        },
        InOut: function(a) {
            return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? .5 * Math.pow(1024, a - 1) : .5 * ( - Math.pow(2, -10 * (a - 1)) + 2)
        }
    },
    Circular: {
        In: function(a) {
            return 1 - Math.sqrt(1 - a * a)
        },
        Out: function(a) {
            return Math.sqrt(1 - --a * a)
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
        }
    },
    Elastic: {
        In: function(a) {
            var b, c = .1;
            return 0 === a ? 0 : 1 === a ? 1 : (!c || 1 > c ? (c = 1, b = .1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI), -(c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / .4)))
        },
        Out: function(a) {
            var b, c = .1;
            return 0 === a ? 0 : 1 === a ? 1 : (!c || 1 > c ? (c = 1, b = .1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI), c * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / .4) + 1)
        },
        InOut: function(a) {
            var b, c = .1;
            return 0 === a ? 0 : 1 === a ? 1 : (!c || 1 > c ? (c = 1, b = .1) : b = .4 * Math.asin(1 / c) / (2 * Math.PI), 1 > (a *= 2) ? -.5 * c * Math.pow(2, 10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / .4) : .5 * c * Math.pow(2, -10 * (a -= 1)) * Math.sin(2 * (a - b) * Math.PI / .4) + 1)
        }
    },
    Back: {
        In: function(a) {
            return a * a * (2.70158 * a - 1.70158)
        },
        Out: function(a) {
            return--a * a * (2.70158 * a + 1.70158) + 1
        },
        InOut: function(a) {
            return 1 > (a *= 2) ? .5 * a * a * (3.5949095 * a - 2.5949095) : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)
        }
    },
    Bounce: {
        In: function(a) {
            return 1 - TWEEN.Easing.Bounce.Out(1 - a)
        },
        Out: function(a) {
            return 1 / 2.75 > a ? 7.5625 * a * a: 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
        },
        InOut: function(a) {
            return.5 > a ? .5 * TWEEN.Easing.Bounce.In(2 * a) : .5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + .5
        }
    }
},
TWEEN.Interpolation = {
    Linear: function(a, b) {
        var c = a.length - 1,
        d = c * b,
        e = Math.floor(d),
        f = TWEEN.Interpolation.Utils.Linear;
        return 0 > b ? f(a[0], a[1], d) : b > 1 ? f(a[c], a[c - 1], c - d) : f(a[e], a[e + 1 > c ? c: e + 1], d - e)
    },
    Bezier: function(a, b) {
        var c, d = 0,
        e = a.length - 1,
        f = Math.pow,
        g = TWEEN.Interpolation.Utils.Bernstein;
        for (c = 0; e >= c; c++) d += f(1 - b, e - c) * f(b, c) * a[c] * g(e, c);
        return d
    },
    CatmullRom: function(a, b) {
        var c = a.length - 1,
        d = c * b,
        e = Math.floor(d),
        f = TWEEN.Interpolation.Utils.CatmullRom;
        return a[0] === a[c] ? (0 > b && (e = Math.floor(d = c * (1 + b))), f(a[(e - 1 + c) % c], a[e], a[(e + 1) % c], a[(e + 2) % c], d - e)) : 0 > b ? a[0] - (f(a[0], a[0], a[1], a[1], -d) - a[0]) : b > 1 ? a[c] - (f(a[c], a[c], a[c - 1], a[c - 1], d - c) - a[c]) : f(a[e ? e - 1 : 0], a[e], a[e + 1 > c ? c: e + 1], a[e + 2 > c ? c: e + 2], d - e)
    },
    Utils: {
        Linear: function(a, b, c) {
            return (b - a) * c + a
        },
        Bernstein: function(a, b) {
            var c = TWEEN.Interpolation.Utils.Factorial;
            return c(a) / c(b) / c(a - b)
        },
        Factorial: function() {
            var a = [1];
            return function(b) {
                var c, d = 1;
                if (a[b]) return a[b];
                for (c = b; c > 1; c--) d *= c;
                return a[b] = d
            }
        } (),
        CatmullRom: function(a, b, c, d, e) {
            var a = .5 * (c - a),
            d = .5 * (d - b),
            f = e * e;
            return (2 * b - 2 * c + a + d) * e * f + ( - 3 * b + 3 * c - 2 * a - d) * f + a * e + b
        }
    }
},
function() {
    function b(a) {
        a.setStyle("select.offset", 1),
        a.setStyle("select.width", 1)
    }
    function c(a, b, f) {
        if (b = b || [], a.length <= 3) return b.push(a),
        b;
        for (var g = [], h = a.length, i = [], j = [], k = 0, l = 0; h > l; l++) {
            var m = a[l],
            n = a[l + 1 === h ? 0 : l + 1],
            o = {
                x: n.x - m.x,
                y: n.y - m.y
            };
            i.push(o),
            j.push(m),
            k += (n.x - m.x) * (n.y + m.y)
        }
        f = void 0 === f ? 0 > k: f;
        for (var p = i.length,
        q = !1,
        l = 0; p - 1 > l; l++) if (d(i[l], i[l + 1], f)) {
            for (var r = l + 1,
            s = null,
            t = 0; p > t; t++) if (e(a[t], a[r - 1], a[r], f) < 0 && e(a[t], a[r], a[r + 1 === h ? 0 : r + 1], f) < 0) {
                s = t;
                break
            }
            if (null === s && (s = r - 2, 0 > s && (s += a.length)), null != s) {
                var u = s;
                u > r && (u -= a.length);
                for (var v = u; r >= v; v++) {
                    var w = v;
                    0 > w && (w += a.length),
                    g.push(a[w])
                }
                b.push(g);
                for (var v = r - 1; v > u; v--) {
                    var w = v;
                    0 > w && (w += a.length);
                    var x = a[w],
                    y = j.indexOf(x);
                    j.splice(y, 1)
                }
                c(j, b, f),
                q = !0
            }
            break
        }
        return j.length > 0 && !q && b.push(j),
        b
    }
    function d(a, b, c) {
        var d = c ? 1 : -1;
        return (a.x * b.y - b.x * a.y) * d < 0 ? !0 : !1
    }
    function e(a, b, c, d) {
        var e = d ? 1 : -1;
        if (!a || !b || !c) return 1;
        var f = -a.x * b.y - b.x * c.y - c.x * a.y + c.x * b.y + b.x * a.y + a.x * c.y;
        return f * e
    }
    OUTLINE_SHAPE = "dshape",
    WALL_INNER_PATH = "wallInnerPic",
    WALL_OUTER_PATH = "wallOuterPic",
    WALL_CLOSED = "shapenode.closed",
    WALL_SIZE = "size",
    POLE_IMAGE_PATH = "poleTexture",
    USE_TEXTURE = "useTexture",
    OUTFRAME_IMAGE_PATH = "framePic",
    POLE_SEGMENTS = "poleSegments",
    IS_INNER_WALL = "isInnerWall",
    BELONG_ID = "edgeIndex",
    BLOCK_OFFSET = "offset",
    IMAGE_SRC = "picture",
    SPACE_POS_Y = "positionY",
    SPACE_SIZE = "size",
    BTYPE = "bType",
    GID = "gid",
    OID = "oid",
    SPACE_POSITION = "position",
    SHAPE_TYPE = "className",
    DESIGN_SCALE = "oscale",
    SPACE_SCALE = "scale",
    SPACE_ROTATION = "rot",
    SIZE_LENGTH = "length",
    SIZE_DEPTH = "depth",
    SIZE_HEIGHT = "height",
    TEXTURE = "texture",
    PRIMITIVE_NAME = "primitiveName",
    HOST_NODE_ID = "hostNodeId",
    FLOOR_HEIGHT = "floorHeight",
    BID = "businessId",
    GENERAL = "General",
    CUSTOM_PROPS = "customProps",
    SPE_STR = "specularStrength",
    TRA_PAR = "transparent",
    OPA = "opacity",
    ANGLE = "angle",
    MAIN_VISIBLE = "mainVisible",
    LIB_PRIMITIVES = "primitivesLib",
    LIB_ASSEMBLES = "assemblesLib",
    LIB_GRAPH = "graphLib",
    LIB_COMPONENTS = "componentLib",
    TAG_ANIMATION = "animation",
    FLOOR_NAME = "floorName",
    FLOOR_HEIGHT = "floorHeight",
    FLOOR_VISIBLE = "floorVisible",
    FLOOR_REF = "floorRef",
    FLOOR_LAYER = "floorLayer",
    PATH = "path",
    SEGMENTSH = "segmentsH",
    SEGMENTSR = "segmentsR",
    ARC = "arc",
    START_CLOSED = "startClosed",
    END_CLOSED = "endClosed",
    VERTICES = "vertices",
    FACES = "faces",
    UVS = "uvs",
    LOAD_RESOURCE_TYPE = "loadResource",
    CLOUD_KEY = "cloudKey",
    CLOUD_PASSWORD = "cloudPassword",
    TYPE_LOCAL = "local",
    TYPE_CLOUD = "cloud",
    MONO_URL = "https://mono-design.cn/api",
    MONO_URL_LOGIN = "https://mono-design.cn/login",
    MONO_URL_LOGOUT = "https://mono-design.cn/logout",
    SHOW_FLOOR = "showFloor",
    ALL_VIEW_SELECTABLE = "allViewSelectable",
    AMBIENT_LIGHT_ON = "ambientLightOn",
    AMBIENT_LIGHT_COLOR = "ambientLightColor",
    POINT_LIGHT_ON = "pointLightOn",
    POINT_LIGHT_POSITION = "pointLightPosition",
    POINT_LIGHT_COLOR = "pointLightColor",
    POINT_LIGHT_INTENSITY = "pointLightIntensity",
    POINT_LIGHT_ON1 = "pointLightOn1",
    POINT_LIGHT_POSITION1 = "pointLightPosition1",
    POINT_LIGHT_COLOR1 = "pointLightColor1",
    POINT_LIGHT_INTENSITY1 = "pointLightIntensity1",
    POINT_LIGHT_ON2 = "pointLightOn2",
    POINT_LIGHT_POSITION2 = "pointLightPosition2",
    POINT_LIGHT_COLOR2 = "pointLightColor2",
    POINT_LIGHT_INTENSITY2 = "pointLightIntensity2",
    POINT_LIGHT_ON3 = "pointLightOn3",
    POINT_LIGHT_POSITION3 = "pointLightPosition3",
    POINT_LIGHT_COLOR3 = "pointLightColor3",
    POINT_LIGHT_INTENSITY3 = "pointLightIntensity3",
    POINT_LIGHT_ON4 = "pointLightOn4",
    POINT_LIGHT_POSITION4 = "pointLightPosition4",
    POINT_LIGHT_COLOR4 = "pointLightColor4",
    POINT_LIGHT_INTENSITY4 = "pointLightIntensity4",
    POINT_LIGHT_ON5 = "pointLightOn5",
    POINT_LIGHT_POSITION5 = "pointLightPosition5",
    POINT_LIGHT_COLOR5 = "pointLightColor5",
    POINT_LIGHT_INTENSITY5 = "pointLightIntensity5",
    SHOW_PROPERTY_SHEET = "showPropertySheet",
    SHOW_AXIS = "showAxis",
    SHOW_AXIS_TEXT = "showAxisText",
    SHOW_DIM = "showDim",
    SHOW_COORD = "showCoord",
    SHOW_TARGET_FLAG = "showTargetFlag",
    SHOW_GRID = "showGrid",
    GRID_GAP = "gridGap",
    SNAPGRID = "snapGrid",
    DECIMAL_NUMBER = "decimalNumber",
    IS_FULL_ROTATION = "isFullRotation",
    IS_FULL_ROTATION_COMPONENT = "isFullRotationComponent",
    ZOOM_SPEED = "zoomSpeed",
    ROTATE_SPEED = "rotateSpeed",
    PAN_SPEED = "panSpeed",
    MAX_DISTANCE = "maxDistance",
    MIN_DISTANCE = "minDistance",
    ZOOM_SPEED_COMPONENT = "zoomSpeedComponent",
    ROTATE_SPEED_COMPONENT = "rotateSpeedComponent",
    PAN_SPEED_COMPONENT = "panSpeedComponent",
    MAX_DISTANCE_COMPONENT = "maxDistanceComponent",
    MIN_DISTANCE_COMPONENT = "minDistanceComponent",
    SHOW_ORIGINAL_FLAG = "showOriginalFlag",
    SCALE_MIN_LIMIT = "scaleMinLimit",
    SCALE_MAX_LIMIT = "scaleMaxLimit",
    ENABLE_SCALE = "enableScale",
    COMPONENT_TEMPLATES = "componentTemplates",
    PUBLIC_TEMPLATES = "Public Templates",
    TEMPLATES = "Private Templates",
    ROOMS = "Rooms",
    SUBTITLE_ROOM = "Room",
    SUBTITLE_COMPONENT = "Component",
    SUBTITLE_MODEL = "Model",
    DEFALUT_POINTS_SHAPE = "-200,0,-200,200,0,-200,200,0,200,-200,0,200",
    PropertyConsts = {
        ROOM_PRIVATE_CATEGORY: "roomPrivateCategory",
        ROOM_PUBLIC_CATEGORY: "roomPublicCategory",
        COMPONENT_PRIVATE_CATEGORY: "componentPrivateCategory",
        COMPONENT_PUBLIC_CATEGORY: "componentPublicCategory",
        SCOPE_PRIMITIVE: 0,
        SCOPE_PUBLIC: 1,
        Font: {
            fontFamily: ["gentilis", "helvetiker", "optimer"],
            fontStyle: ["bold", "normal"]
        },
        WRAPMODE: ["six-each", "front-other", "back-other", "left-other", "right-other", "top-other", "bottom-other"],
        CUSTOM_PROPS: ["p1", "p2", "p3", "p4"],
        FloorStyle: {
            BUFFER_NODE_FLOOR: "Half Transparent",
            PLANE_FLOOR: "Wireframe"
        },
        FloorSize: {
            SMALL: "Small",
            MEDIUM: "Medium",
            LARGE: "Large"
        },
        LocalStorage: {
            FLOOR_STYLE: "floorStyle",
            FLOOR_SIZE: "floorSize",
            SELECT_STYLE: "selectStyle"
        },
        COMPONENTFLOOR: "componentFloor",
        MONO_KEY: "mono2025",
        MONO_IMG_PRE: "https://mono-design.cn/",
        MONO_URL_PRE: "https://mono-design.cn/",
        TYPE_ROOMS: "rooms",
        TYPE_COMPONENT: "component",
        TYPE_ROOTCATEGORY: "rootCategory",
        DEFAULT_IMAGE: "crash.png",
        NEAR_PLANE: "nearPlane",
        FAR_PLANE: "farPlane",
        FOV: "fov",
        NEAR_PLANE_COMPONENT: "nearPlaneComponent",
        FAR_PLANE_COMPONENT: "farPlaneComponent",
        FOV_COMPONENT: "fovComponent",
        ORDER_BY_ASC: 0,
        ORDER_BY_DESC: 1,
        LINK_STYPE: ["", "orthogonal.x", "orthogonal.x.n", "orthogonal.y", "orthogonal.y.n", "orthogonal.z", "orthogonal.z.n", "control"],
        SELECT_STYLE: {
            WIREFRAME: "wireframe",
            NORMAL: "normal",
            BORDER: "border"
        },
        Layer: {
            WALL: "Wall",
            FLOOR: "Floor",
            WINDOW: "Window",
            DOOR: "Door",
            PIPE: "Pipe",
            BILLBOARD: "Billboard",
            TEMPLATE: "Template",
            DEFAULT: "default"
        },
        LAYERID: "layerId",
        ENABLE_EASING: "enableEasing",
        TEMPLATE_AUTHOR: "templateAuthor",
        SHOW_RULER_GUIDES: "showRulerGuides",
        SHOW_RULER: "showRuler",
        SCALE_UNIT_TEXT: "scaleUnitText"
    },
    Utils = {
        Path: "images/",
        RelativePath: "",
        renderNetwork: function(a, b, c) {
            a.setRenderCallback(c)
        },
        createDraggableNetwork: function(a) {
            if (!a) var a = new twaver.network.Network;
            return a.getView().addEventListener("dragover",
            function(a) {
                return a.preventDefault ? a.preventDefault() : a.returnValue = !1,
                a.dataTransfer.dropEffect = "copy",
                !1
            },
            !1),
            a.setEditableFunction(function(a) {
                return "unresize" !== a.getClient("resize")
            }),
            a.getView().addEventListener("drop",
            function(b) {
                b.stopPropagation && b.stopPropagation(),
                b.preventDefault ? b.preventDefault() : b.returnValue = !1;
                var c = b.dataTransfer.getData("Text");
                Utils._handle2dDrop(b, c, a)
            },
            !1),
            a
        },
        _handle2dDrop: function(a, b, c) {
            if (!b) return ! 1;
            var d = JSON.parse(b),
            e = c.getElementBox();
            if (void 0 !== d.className && "twaver.Grid" === d.className) {
                var f, g, h, i;
                e.forEach(function(a) {
                    a instanceof ImageNode && (f = a.getWidth(), g = a.getHeight(), h = a.getLocation(), i = a)
                });
                var j = Utils._createGrid(f, g, h, i);
                e.add(j)
            } else if ("Material" === d.classType) {
                var k = c.getElementAt(a);
                console.log(k),
                k instanceof twaver.Follower && !(k.getParent() instanceof ImageNode) ? (Utils.registerImage(Utils.Path + d.material, c), k.setImage(Utils.Path + d.material), k.setClient("material", d.material), handleText2d(c)) : null == k && e.forEach(function(a) {
                    if (a instanceof ImageNode) {
                        var b = Utils.Path + d.material;
                        Utils.registerImage(b, c),
                        a.setImage(b),
                        0 == faceObject.faceIndex ? faceObject.element.setStyle("right.m.texture.image", b) : 1 == faceObject.faceIndex ? faceObject.element.setStyle("left.m.texture.image", b) : 2 == faceObject.faceIndex ? faceObject.element.setStyle("top.m.texture.image", b) : 3 == faceObject.faceIndex ? faceObject.element.setStyle("bottom.m.texture.image", b) : 4 == faceObject.faceIndex ? faceObject.element.setStyle("front.m.texture.image", b) : 5 == faceObject.faceIndex && faceObject.element.setStyle("back.m.texture.image", b)
                    }
                })
            } else if ("Cube" === d.classType) if (_twaver.isShiftDown(a)) Utils.showPortDialog(c, a, d, b);
            else {
                var i = c.getElementAt(a),
                l = Utils.Path + d.material,
                f = d.args.x,
                g = d.args.y,
                m = Utils._createFollower(a, i, l, d.resize, f, g, b, c);
                e.add(m),
                e.getSelectionModel().setSelection(m),
                handleText2d(c)
            } else if ("Template" === d.classType) {
                var n = Utils.Path + "default_texture.png";
                if (loadResource === TYPE_CLOUD) modelManager.loadTemplatesAssembleSize(d.id, this,
                function(d) {
                    var f = c.getElementAt(a),
                    g = Utils._createFollower(a, f, n, "unresize", d.x, d.y, b, c);
                    e.add(g),
                    handleText2d(c)
                });
                else {
                    var o = modelManager.loadTemplatesAssembleSize(d.id),
                    i = c.getElementAt(a),
                    m = Utils._createFollower(a, i, n, "unresize", o.x, o.y, b, c);
                    e.add(m),
                    handleText2d(c)
                }
            }
        },
        _createGrid: function(a, b, c, d) {
            var e = new CGrid;
            return e.setLocation(c),
            e.setSize(a, b),
            e.setStyle("grid.border", 1),
            e.setStyle("grid.row.count", 3),
            e.setStyle("grid.column.count", 3),
            e.setStyle("grid.deep", 1),
            e.setStyle("whole.alpha", .6),
            e.setClient("grid.outer.padding", 0),
            e.setClient("width", a),
            e.setClient("height", b),
            e.setClient("location", c),
            e.setClient("offset", .1),
            e.setStyle("grid.padding", 1),
            e.setParent(d),
            e
        },
        _createFollower: function(a, b, c, d, e, f, g, h) {
            var i = new twaver.Follower;
            if (Utils.registerImage(c, h, "component"), i.setImage(c), i.setClient("text", g), i.setClient("resize", d), b instanceof twaver.Grid) {
                var j = h.getLogicalPoint(a),
                k = b.getCellObject(j);
                if (null != k) {
                    "unresize" === d && (i.setStyle("follower.fill.cell", !1), i.setWidth(e * h.zoom), i.setHeight(f * h.zoom)),
                    i.setStyle("follower.row.index", k.rowIndex),
                    i.setStyle("follower.column.index", k.columnIndex),
                    i.setParent(b),
                    i.setHost(b);
                    var l = i.getParent().getParent(),
                    m = i.getCenterLocation().x - l.getCenterLocation().x,
                    n = i.getCenterLocation().y - l.getCenterLocation().y;
                    i.setClient("offsetX", m / h.zoom),
                    i.setClient("offsetY", n / h.zoom);
                    var o = b.getClient("offset");
                    i.setClient("offset", o + .15),
                    i.setClient("selfID", i.getId()),
                    i.setClient("hostCell", b),
                    console.log("translate to 2d")
                }
            }
            return i
        },
        createDraggableNetwork3D: function(a) {
            if (!a) var a = new(new mono.Network3D);
            return a.getRootView().addEventListener("dragover",
            function(a) {
                return a.preventDefault ? a.preventDefault() : a.returnValue = !1,
                a.dataTransfer.dropEffect = "copy",
                !1
            },
            !1),
            a.getRootView().addEventListener("drop",
            function(b) {
                b.stopPropagation && b.stopPropagation(),
                b.preventDefault ? b.preventDefault() : b.returnValue = !1;
                var c = b.dataTransfer.getData("Text");
                return c ? (Utils._handle3dDrop(b, c, a), !1) : !1
            },
            !1),
            a.getRootView().setAttribute("draggable", "true"),
            a
        },
        _findFirstObjectByMouse: function(a, b, c) {
            c || (c = function(a) {
                return ! (a instanceof mono.Billboard || a.getClient(PropertyConsts.COMPONENTFLOOR))
            });
            var d = a.getElementsByMouseEvent(b);
            if (d.length) for (var e = 0; e < d.length; e++) {
                var f = d[e],
                g = f.element;
                if (c(g)) return f
            }
            return null
        },
        _init3dObject: function(a) {
            var c = Utils.Path + "default_texture.png";
            a.setStyle("m.texture.image", c),
            a.setStyle("m.texture.wrapS", mono.RepeatWrapping),
            a.setStyle("m.texture.wrapT", mono.RepeatWrapping),
            a.setStyle("m.texture.repeat", new mono.Vec2(3, 3)),
            a.setStyle("m.side", mono.DoubleSide),
            a.setStyle("m.type", "phong"),
            a.setEditable(!0),
            a.setSelectable(!0),
            b(a)
        },
        _createPath: function(a, b) {
            var c = b || 1,
            d = new mono.Path;
            if (a instanceof Array) for (var e = a.concat(); e && e.length > 0;) {
                var f = e.shift();
                "m" === f && d.moveTo(parseInt(e.shift() * c), parseInt(e.shift() * c), parseInt(e.shift() * c)),
                "l" === f && d.lineTo(parseInt(e.shift() * c), parseInt(e.shift() * c), parseInt(e.shift() * c)),
                "c" === f && d.curveTo(parseInt(e.shift() * c), parseInt(e.shift() * c), parseInt(e.shift() * c), parseInt(e.shift() * c), parseInt(e.shift() * c), parseInt(e.shift() * c));
            }
            return d
        },
        _createPrimitiveObject: function(a, b) {
            var c, d = ("mono." + a.className, Utils.Path + "default_texture.png", a.args);
            if ("Cube" === a.className && (c = new mono.Cube(d.x, d.y, d.z)), "Sphere" === a.className && (c = new mono.Sphere(d.radius)), "Cylinder" === a.className) {
                var e = window.prompt("Segment count:", d.radialSegments);
                if (null === e) return;
                c = new mono.Cylinder(d.radiusTop, d.radiusBottom, d.height, e),
                d.smooth ? (c.setStyle("m.normalType", mono.NormalTypeSmooth), c.setStyle("top.m.normalType", mono.NormalTypeFlat), c.setStyle("bottom.m.normalType", mono.NormalTypeFlat)) : c.setStyle("m.normalType", mono.NormalTypeFlat)
            }
            if ("Torus" === a.className && (c = new mono.Torus(d.radius, d.tube, d.radialSegments, d.tubularSegments)), "PathNode" === a.className && (c = new mono.PathNode(Utils._createPath(d.path), d.pathSegments, d.radius, d.shapeSegments, d.startCap, d.endCap), c.setSegmentsCap(10), d.startCapSize && c.setStartCapSize(d.startCapSize), d.endCapSize && c.setEndCapSize(d.endCapSize)), "TextNode" === a.className) {
                var f = [{
                    label: "Text:",
                    id: "text3d",
                    value: d.text,
                    tab: "Properties"
                },
                {
                    label: "Font:",
                    id: "font3d",
                    type: "select",
                    options: PropertyConsts.Font.fontFamily,
                    value: d.font,
                    tab: "Properties"
                },
                {
                    label: "Style:",
                    id: "style3d",
                    type: "select",
                    options: PropertyConsts.Font.fontStyle,
                    value: d.style,
                    tab: "Properties"
                }],
                g = "Text Property",
                h = function(a) {
                    var c = new mono.TextNode(a.text3d, null, d.height, a.font3d, a.style3d),
                    e = d.scale || 1;
                    c.setScale(e, e, e),
                    Utils._init3dObject(c),
                    b.add(c),
                    b.getSelectionModel().clearSelection(),
                    c.setSelected(!0)
                };
                return void Utils.showInputDialog(f, g, !0, h)
            }
            return Utils._init3dObject(c),
            c
        },
        _createLatheObject: function(a) {
            var b = new GridNetwork;
            b.setInteractions([new twaver.canvas.interaction.CreateShapeNodeInteraction(b, window.RoundPipeShapeNode), new twaver.canvas.interaction.EditInteraction(b, !1), new twaver.canvas.interaction.DefaultInteraction(b)]),
            b.setEditPointSize(10),
            b.addElementByInteraction = function(a) {
                twaver.canvas.Network.prototype.addElementByInteraction.call(this, a),
                setTimeout(function() {
                    b.setInteractions([new twaver.canvas.interaction.EditInteraction(b, !1), new twaver.canvas.interaction.SelectInteraction(b), new twaver.canvas.interaction.MoveInteraction(b, !1), new twaver.canvas.interaction.DefaultInteraction(b)])
                },
                500)
            };
            var c = new twaver.Node("axis");
            Utils.registerImage(Utils.Path + "axis.png"),
            c.setImage(Utils.Path + "axis.png"),
            c.setLocation(400, 100),
            c.setStyle("select.style", "none"),
            b.setEditableFunction(function(a) {
                return a === c ? !1 : !0
            }),
            b.getElementBox().add(c);
            var d = document.createElement("div"),
            e = document.createElement("p");
            e.innerHTML = "Note:double click to end path",
            d.appendChild(e),
            d.style.width = "800px",
            d.style.height = "400px",
            d.appendChild(b.getView()),
            setTimeout(function() {
                b.adjustBounds({
                    width: 800,
                    height: 400
                }),
                b.getView().style.position = "relative"
            },
            100);
            var f = [{
                id: "shapePath",
                type: "div",
                value: d,
                tab: "Path"
            },
            {
                label: "Height Segments:",
                id: "segmentsH",
                value: 64,
                tab: "Properties"
            },
            {
                label: "Radius Segments:",
                id: "segmentsR",
                value: 20,
                tab: "Properties"
            },
            {
                label: "Rotation Angle:",
                id: "rotationAngle",
                value: 360,
                tab: "Properties"
            },
            {
                label: "Start Closed:",
                id: "startClosed",
                checked: !1,
                type: "checkbox",
                tab: "Properties"
            },
            {
                label: "End Closed:",
                id: "endClosed",
                checked: !1,
                type: "checkbox",
                tab: "Properties"
            }],
            g = "Lathe Property",
            h = function(b, c) {
                var d = new mono.Path;
                if (b) {
                    var e, f = b.getElementBox().getDatas();
                    f.forEach(function(a) {
                        a instanceof PipeShapeNode && (e = a)
                    });
                    var g = b.getElementBox().getDataById("axis"),
                    h = g.getRect(),
                    i = {
                        x: h.x + 7,
                        y: h.y + h.height
                    };
                    if (e) {
                        var j = e.getPoints();
                        if (j && j.size() > 1) {
                            var k = j.get(0);
                            d.moveTo(k.x - i.x, i.y - k.y, 0);
                            for (var l = 1; l < j.size(); l++) k = j.get(l),
                            d.lineTo(k.x - i.x, i.y - k.y, 0)
                        }
                        var m = parseInt(c.segmentsH),
                        n = parseInt(c.segmentsR),
                        o = parseInt(c.rotationAngle) * Math.PI / 180,
                        p = new mono.LatheNode(d, m, n, o, c.startClosed, c.endClosed);
                        p.setStyle("m.side", TGL.DoubleSide).setStyle("m.texture.image", "images/default_texture.png"),
                        a.add(p)
                    }
                }
            };
            Utils.showInputDialog(f, g, !0, h, this, [b])
        },
        _createPipeObject: function(a) {
            var b = a.getInteractions(),
            c = !1;
            b.forEach(function(b) {
                b instanceof ComponentsDragPipeInteraction && (b = new ComponentsDragPipeInteraction(a), c = !0)
            }),
            c || (b.push(new ComponentsDragPipeInteraction(a)), a.setInteractions(b))
        },
        _setDropPosition: function(a, b, c) {
            var d = b.getElementsByMouseEvent(a);
            if (d.length) {
                var e = d[0],
                f = (e.element, e.point);
                c.setPosition(f)
            }
        },
        _handle3dDrop: function(a, c, d, e) {
            var f = JSON.parse(c);
            if ("Primitive" === f.classType) {
                var g = Utils._createPrimitiveObject(f, d.getDataBox());
                g && (Utils._setDropPosition(a, d, g), d.getDataBox().add(g), d.getDataBox().getSelectionModel().clearSelection(), g.setEditable(!0), g.setSelectable(!0))
            }
            if ("Pipe" === f.classType && Utils._createPipeObject(d), "Combo" === f.classType) {
                for (var h = (f.className, Utils.Path + "default_texture.png"), i = f.primitives, j = f.ops, k = 0; k < i.length; k++) {
                    var l = i[k],
                    g = Utils._createPrimitiveObject(l);
                    g && (l.position && g.setPosition(l.position.x, l.position.y, l.position.z), l.rotation && g.setRotation(l.rotation.x, l.rotation.y, l.rotation.z), b(g)),
                    i[k] = g
                }
                var m = new mono.ComboNode(i, j, !0);
                b(m),
                Utils._setDropPosition(a, d, g),
                d.getDataBox().add(m),
                d.getDataBox().getSelectionModel().clearSelection(),
                m.setEditable(!0),
                m.setSelectable(!0)
            }
            if ("Lathe" === f.classType && Utils._createLatheObject(d.getDataBox()), "Billboard" === f.classType) {
                var n, o = Utils._findFirstObjectByMouse(d, a);
                o && (n = o.element);
                var h = Utils.Path + f.material,
                g = new mono.Billboard;
                if (g.setStyle("m.texture.image", h), g.setStyle("m.alignment", mono.BillboardAlignment.bottomCenter), g.setStyle("m.transparent", !1), g.setStyle("m.opacity", 1), g.setStyle("m.vertical", !0), n) {
                    g.setParent(n),
                    n.boundingBox || n.computeBoundingBox();
                    var p = n.boundingBox.max.y;
                    g.setPosition(0, p, 0)
                } else Utils._setDropPosition(a, d, g);
                g.setEditable(!0),
                g.setSelectable(!0),
                g.setScale(f.args.x, f.args.y, 1),
                d.getDataBox().add(g)
            }
            if ("Cube" === f.classType) {
                var q = Utils.Path + f.material,
                r = Utils.Path + "brush_metal.png",
                s = f.args,
                t = !1;
                f.transparent && (t = f.transparent);
                var g = new mono.Cube(s.x, s.y, s.z);
                g.setStyle("m.texture.image", r),
                g.setStyle("m.texture.repeat", new mono.Vec2(1, 1)),
                g.setClient("shape", f.shape);
                var u = ["front"];
                f.faces && (u = f.faces);
                for (var v = 0; v < u.length; v++) {
                    var w = u[v];
                    g.setStyle(w + ".m.texture.image", q),
                    g.setStyle(w + ".m.transparent", t)
                }
                g.setEditable(!0),
                g.setSelectable(!0),
                b(g),
                Utils._setDropPosition(a, d, g);
                var o = Utils._findFirstObjectByMouse(d, a);
                if (Utils.stickOnSurface(g, d, a, o), f.text) {
                    var c = window.prompt("Text:", f.text.content),
                    x = new mono.TextNode(c, null, f.text.height, f.text.font, f.text.style),
                    y = f.text.scale || 1;
                    x.setScale(y, y, y),
                    x.setEditable(!0),
                    x.setSelectable(!0),
                    x.setParent(g),
                    x.editTransformToParent = !0,
                    x.setStyle("m.texture.image", Utils.Path + f.text.material),
                    b(x);
                    var o = Utils._findFirstObjectByMouse(d, a);
                    Utils.stickOnSurface(x, d, a, o),
                    f.text.position && x.setPosition(g.getPosition().x + f.text.position.x, g.getPosition().y + f.text.position.y, g.getPosition().z + f.text.position.z),
                    f.text.rotation && x.setRotation(g.getRotation().x + f.text.rotation.x, g.getRotation().y + f.text.rotation.y, g.getRotation().z + f.text.rotation.z),
                    d.getDataBox().add(x)
                }
                d.getDataBox().add(g);
                var z;
                if (f.panel) {
                    if (z = new mono.Cube(f.panel.x, f.panel.y, f.panel.z), z.setStyle("m.texture.image", r), f.panel.pic) {
                        var A = Utils.Path + f.panel.pic;
                        z.setStyle("front.m.texture.image", A)
                    }
                    z.setParent(g),
                    z.editTransformToParent = !0,
                    z.getPosition().z += g.depth / 2,
                    b(z),
                    d.getDataBox().add(z);
                    var B = g.getId() + ":" + z.getId();
                    g.setGroupId(B),
                    z.setGroupId(B)
                }
                if (e) {
                    g.setClient("cellID", e.getId());
                    var C = faceObject.element.depth;
                    "verticalCard" === f.shape ? (g.setHeight(e.getHeight()), z && z.setHeight(e.getHeight())) : "horizontalCard" === f.shape ? (g.setWidth(e.getWidth()), z && z.setWidth(e.getWidth())) : "cube" === f.shape && (g.setWidth(e.getWidth()), g.setHeight(e.getHeight()), g.setDepth(C / 10));
                    var D = e.getClient("offsetX"),
                    E = e.getClient("offsetY");
                    setPositionByRelative(faceObject.faceIndex, g, D, E)
                }
            }
            if ("Material" === f.classType) {
                var h = f.material ? Utils.Path + f.material: null,
                F = 1,
                G = 1,
                H = !0,
                t = !1;
                f.texture && (F = f.texture.row, G = f.texture.column),
                void 0 !== f.visible && (H = f.visible),
                f.transparent && (t = f.transparent);
                var o = Utils._findFirstObjectByMouse(d, a);
                if (o) if (f.texture) {
                    var I = [{
                        label: "Row:",
                        id: "row",
                        value: F
                    },
                    {
                        label: "Column:",
                        id: "column",
                        value: G
                    },
                    {
                        label: "Scope:",
                        id: "useForAllFaces",
                        type: "checkbox",
                        inner: "Use this material for all faces"
                    }];
                    Utils.showInputDialog(I, "Set Material", !0, this.setMaterial, this, [h, H, t, o])
                } else {
                    var J = {};
                    J.row = F,
                    J.column = G,
                    this.setMaterial(h, H, t, o, J, f.wrapMode)
                }
            }
            if ("Dye-Color" === f.classType) {
                var o = Utils._findFirstObjectByMouse(d, a),
                K = f.color;
                if (o && K) {
                    var g = o.element,
                    I = [{
                        label: "Scope:",
                        id: "useForAllFaces",
                        type: "checkbox",
                        inner: "Use this dye color for all faces"
                    }];
                    Utils.showInputDialog(I, "Set Dye Color", !0, this.setDyeColor, this, [K, o])
                }
            }
            if ("Template" === f.classType) {
                var L = "Load Template",
                M = [{
                    label: "",
                    "class": "lb-save-template",
                    id: "opentemp",
                    name: "templates",
                    type: "radio",
                    checked: !0,
                    inner: "Open template in the scense"
                },
                {
                    label: "",
                    "class": "lb-save-template",
                    id: "loadtemp",
                    name: "templates",
                    type: "radio",
                    checked: !1,
                    inner: "Insert template in the scense"
                }];
                Utils.showInputDialog(M, L, !0,
                function(b) {
                    var c = Utils._findFirstObjectByMouse(d, a),
                    e = modelManager.loadComponentTemplate(d.getDataBox(), f.id, b.opentemp, this,
                    function(e) {
                        b.opentemp || (Utils._setDropPosition(a, d, e), e.setPositionY(e.getHeight() / 2), Utils.stickOnSurface(e, d, a, c))
                    });
                    e && !b.opentemp && (Utils._setDropPosition(a, d, e), e.setPositionY(e.getHeight() / 2), Utils.stickOnSurface(e, d, a, c))
                })
            }
            d.getView().focus()
        },
        stickOnSurface: function(a, b, c, d) {
            if (d) {
                var e = d.face,
                f = d.element,
                g = d.point;
                f.getPosition(),
                g = f.worldToLocal(g),
                a.setParent(f),
                a.setPosition(g.x, g.y, g.z),
                a.getPosition().z += 1,
                a.setClient("faceIndex", e.materialIndex);
                var h = e.normal.clone();
                f.setClient("parentFaceIndex", e.materialIndex);
                for (var i, j, k = a.getParent(); k;) i = k,
                j = i.getClient("parentFaceIndex"),
                k = k.getParent();
                0 == j ? h = new mono.Vec3(1, 0, 0) : 1 == j ? h = new mono.Vec3( - 1, 0, 0) : 2 == j ? h = new mono.Vec3(0, 1, 0) : 3 == j ? h = new mono.Vec3(0, -1, 0) : 4 == j ? h = new mono.Vec3(0, 0, 1) : 5 == j && (h = new mono.Vec3(0, 0, -1)),
                h = h.applyMatrix4((new mono.Mat4).extractRotation(f.matrix)),
                h.normalize();
                var l = new mono.Vec3(0, 0, 1),
                m = Math.acos(h.dot(l) / h.length() / l.length()),
                n = (new mono.Vec3).crossVectors(h, l).normalize(),
                o = new mono.Mat4;
                o.makeRotationAxis(n, -m);
                var p = (new mono.Vec3).setEulerFromRotationMatrix((new mono.Mat4).extractRotation(o)),
                p = f.getRotation();
                a.setRotation(p)
            }
            Utils.isCtrlDown(c) && a.setRotationZ(a.getRotation().z + Math.PI / 2)
        },
        setDyeColor: function(a, b, c) {
            var d = b.face,
            e = b.element,
            f = d.materialIndex;
            if (c.useForAllFaces) {
                var g = "m.color";
                e.setStyle(g, a),
                g = "m.ambient",
                e.setStyle(g, a)
            } else {
                var g = "m.color";
                e.getIndexSideMapping() && (g = e.getIndexSideMapping()[f] + "." + g),
                e.setStyle(g, a),
                g = "m.ambient",
                e.getIndexSideMapping() && (g = e.getIndexSideMapping()[f] + "." + g),
                e.setStyle(g, a)
            }
        },
        setMaterial: function(a, b, c, d, e, f) {
            repeatRow = parseInt(e.row),
            repeatColumn = parseInt(e.column);
            var g, h = d.element,
            i = d.face,
            j = i.materialIndex,
            k = e.useForAllFaces,
            l = h.getIndexSideMapping();
            if (!f && l && (g = h.getIndexSideMapping()[j], g += "."), void 0 === g) {
                var m = ["m.texture.image", "m.texture.repeat", "m.visible", "m.transparent"];
                for (nameIndex in m) {
                    var n, o = m[nameIndex],
                    p = h.getStyle(o, !0, !0) || [];
                    if ("m.texture.image" === o && a && (n = a), "m.texture.repeat" === o && (n = new mono.Vec2(repeatRow, repeatColumn)), "m.visible" === o && (n = b), "m.transparent" === o && (n = c), k) for (var q = 0; q < p.length; q++) p[q] = n;
                    else p[j] = n;
                    h.setStyle(o, p)
                }
                f && (h.setStyle("m.texture.image", a), h.setStyle("m.texture.repeat", new mono.Vec2(1, 1)), h.setWrapMode(f))
            } else if (k) {
                if (l) for (var q = 0; q < h.getIndexSideMapping().length; q++) {
                    var g = h.getIndexSideMapping()[q];
                    g += ".",
                    h.setStyle(g + "m.texture.image", null),
                    h.setStyle(g + "m.texture.repeat", null),
                    h.setStyle(g + "m.visible", null),
                    h.setStyle(g + "m.transparent", null)
                }
                h.setStyle("m.texture.image", a),
                h.setStyle("m.texture.repeat", new mono.Vec2(repeatRow, repeatColumn)),
                h.setStyle("m.visible", b),
                h.setStyle("m.transparent", c)
            } else h.setStyle(g + "m.texture.image", a),
            h.setStyle(g + "m.texture.repeat", new mono.Vec2(repeatRow, repeatColumn)),
            h.setStyle(g + "m.visible", b),
            h.setStyle(g + "m.transparent", c)
        },
        registerImage: function(a, b, c, d, e, f) {
            var g = new Image;
            a.startsWith("data:image") ? g.src = a: (g.crossOrigin = "", g.src = Utils.RelativePath + a);
            var h = arguments;
            f && (a = f),
            g.onload = function() {
                "component" == c ? twaver.Util.registerImage(a, g, g.width, g.height, b) : twaver.Util.registerImage(a, g, g.width, g.height),
                d && d.call(e, g.width, g.height);
                for (var f = 1; f < h.length; f++) {
                    var i = h[f];
                    i && i.invalidateElementUIs && i.invalidateElementUIs(),
                    i && i.invalidateDisplay && i.invalidateDisplay()
                }
            }
        },
        getImageName: function(a) {
            var b = a.lastIndexOf("/"),
            c = a;
            return b >= 0 && (c = a.substring(b + 1)),
            b = c.lastIndexOf("."),
            b >= 0 && (c = c.substring(0, b)),
            c
        },
        addMask: function(a) {
            var b;
            return parseInt(document.body.scrollWidth),
            parseInt(document.body.scrollHeight),
            b = document.createElement("div"),
            a ? b.setAttribute("id", "mask_" + a) : b.setAttribute("id", "mask"),
            b.setAttribute("class", "mask"),
            document.body.appendChild(b),
            b
        },
        randomInt: function(a) {
            return Math.floor(Math.random() * a)
        },
        randomColor: function() {
            var a = Utils.randomInt(255),
            b = Utils.randomInt(255),
            c = Utils.randomInt(255);
            return "#" + Utils._formatNumber(a << 16 | b << 8 | c)
        },
        _formatNumber: function(a) {
            for (var b = a.toString(16); b.length < 6;) b = "0" + b;
            return b
        },
        changeTwoDecimal: function(a) {
            return Utils.changeDecimalDigit(a, 2)
        },
        rChangeTwoDecimal: function(a) {
            return a ? parseFloat(a.toString().replace(/[^\d\.-]/g, "")) : 0
        },
        changeDecimalDigit: function(a, b) {
            b = b > 0 && 20 >= b ? b: 2,
            a = Utils.rChangeTwoDecimal(a),
            a = parseFloat((a + "").replace(/[^\d\.-]/g, "")).toFixed(b) + "";
            var c = a.split(".")[0].split("").reverse(),
            d = a.split(".")[1];
            for (t = "", i = 0; i < c.length; i++) t += c[i];
            var e = t.split("").reverse().join("") + "." + d;
            return parseFloat(e)
        },
        disposeDialog: function(a) {
            document.getElementById("mask_" + a) ? document.body.removeChild(document.getElementById("mask_" + a)) : document.body.removeChild(document.getElementById("mask")),
            document.body.removeChild(document.getElementById(a))
        },
        parameterReset: function(a, b) {
            if (this.setButtonStyle(a), "ScaleReset" === a) {
                var c = document.getElementById(b + "X");
                c.value = parseFloat(1).toFixed(decimalNumber),
                c = document.getElementById(b + "Y"),
                c.value = parseFloat(1).toFixed(decimalNumber),
                c = document.getElementById(b + "Z"),
                c.value = parseFloat(1).toFixed(decimalNumber)
            } else if ("PositionReset" === a) {
                var c = document.getElementById(b + "X");
                c.value = parseFloat(0).toFixed(decimalNumber),
                c = document.getElementById(b + "Y"),
                c.value = parseFloat(0).toFixed(decimalNumber),
                c = document.getElementById(b + "Z"),
                c.value = parseFloat(0).toFixed(decimalNumber)
            } else if ("RotationReset" === a) {
                var c = document.getElementById(b + "X");
                c.value = 0,
                c = document.getElementById(b + "Y"),
                c.value = 0,
                c = document.getElementById(b + "Z"),
                c.value = 0
            } else if ("TextureReset" === a) {
                var c = document.getElementById(b + "C");
                c.value = 1,
                c = document.getElementById(b + "R"),
                c.value = 1
            } else if ("normalReset" === a) {
                var c = document.getElementById(b + "C");
                c.value = 1,
                c = document.getElementById(b + "R"),
                c.value = 1
            }
        },
        setButtonStyleHover: function(a) {
            var b = document.getElementById(a);
            b.setAttribute("class", "parameterReset_hover")
        },
        setButtonStyle: function(a) {
            var b = document.getElementById(a);
            b.setAttribute("class", "parameterReset")
        },
        showInputDialog: function(a, b, c, d, e, f, g, h, i) {
            if (a) {
                var j, k, l = [],
                m = [],
                n = [],
                o = {};
                if (g) {
                    var p = [{
                        label: "p1",
                        id: "p1",
                        tab: "User Properties",
                        readonly: !1,
                        "class": "customlabel"
                    },
                    {
                        label: "p2",
                        id: "p2",
                        tab: "User Properties",
                        readonly: !1,
                        "class": "customlabel"
                    },
                    {
                        label: "p3",
                        id: "p3",
                        tab: "User Properties",
                        readonly: !1,
                        "class": "customlabel"
                    },
                    {
                        label: "p4",
                        id: "p4",
                        tab: "User Properties",
                        readonly: !1,
                        "class": "customlabel"
                    }];
                    a = a.concat(p)
                }
                for (var q = 0,
                r = a.length; r > q; q++) {
                    var s = a[q];
                    k = s.tab || GENERAL,
                    j = o[k] || document.createElement("form");
                    var t = s.id,
                    u = s.type ? s.type: "text";
                    if (s.label, "div" !== u) {
                        var v = document.createElement("input");
                        "undefined" != typeof s.label && v.setAttribute("value", s.label),
                        v.tabIndex = "-1",
                        s.readonly !== !1 && v.setAttribute("readonly", !0),
                        s["class"] ? v.setAttribute("class", s["class"]) : v.setAttribute("class", "field"),
                        s.labelId ? v.setAttribute("id", s.labelId) : s.id && v.setAttribute("id", "label" + s.id);
                        var w = "select" === u,
                        x = document.createElement("input");
                        if (w) {
                            x = document.createElement("select"),
                            x.style.width = "304px";
                            var y = s.value,
                            z = s.options;
                            if (z) for (var A = 0; A < z.length; A++) {
                                var B = z[A],
                                C = document.createElement("option");
                                C.innerHTML = B,
                                C.setAttribute("value", B),
                                y && y === B && C.setAttribute("selected", "true"),
                                x.appendChild(C)
                            }
                        }
                        if (!w && (x.setAttribute("type", u), s.pick ? (x.style.borderRight = "0px", x.style.width = "272px") : x.setAttribute("size", 40), s.list)) {
                            var D = t + "_datalist";
                            x.setAttribute("list", D);
                            var E = document.createElement("datalist");
                            E.setAttribute("id", D);
                            for (var F = 0; F < s.list.length; F++) {
                                var G = s.list[F],
                                H = document.createElement("option");
                                H.setAttribute("value", G),
                                E.appendChild(H)
                            }
                            s.datalist = E
                        }
                        if (void 0 === u || "input" === u || "text" === u || "password" === u ? x.setAttribute("class", "input") : "label" === u || x.setAttribute("class", "input-r"), s.name && x.setAttribute("name", s.name), s.pick && (x.pickImage = !0), void 0 !== s.display && (s.display ? (v.style.display = "block", x.style.display = "block") : (v.style.display = "none", x.style.display = "none")), void 0 === s.min || isNaN(s.min) || x.setAttribute("min", s.min), void 0 === s.max || isNaN(s.max) || x.setAttribute("max", s.max), s.listener && (x[s.eve] = s.listener), 0 == s.editable && (x.setAttribute("readonly", "readonly"), x.style.border = "0px", x.style.borderBottom = "1px solid #ABADB3"), "checkbox" === u || "radio" === u) {
                            var I = s.checked;
                            void 0 === I && (I = !1),
                            I && x.setAttribute("checked", I)
                        }
                        if (s.id && (x.setAttribute("id", s.id), "User Properties" == s.tab ? m.push(s.id) : l.push(s.id)), Utils.isNotNull(s.value) && x.setAttribute("value", s.value), "multipleF" != u && "multipleS" !== u && "multipleT" !== u && "button" !== u && j.appendChild(v), ("multipleF" === u || "multipleS" === u || "multipleT" === u) && ("undefined" != typeof s.labelMinor && v.setAttribute("value", s.labelMinor), s["class"] ? v.setAttribute("class", s["class"]) : v.setAttribute("class", "fieldlabel"), "textureRepeatC" === s.id || "normalScaleC" === s.id ? v.style.width = "48px": "textureRepeatR" === s.id || "normalScaleR" === s.id ? v.style.width = "30px": "shapeW" === s.id ? v.style.width = "17px": "shapeH" === s.id || "shapeD" === s.id ? v.style.width = "11px": "ambientLightColor" === s.id ? v.style.width = "50px": "pointLightColor" === s.idTyle ? v.style.width = "50px": "pointLightPosition" === s.idTyle ? v.style.width = "65px": "pointLightIntensity" === s.idTyle && (v.style.width = "70px"), j.appendChild(v)), "range" === u) {
                            var J = document.createElement("div"),
                            K = document.createElement("output");
                            K.value = x.value,
                            K.style.paddingLeft = "10px",
                            K.setAttribute("id", "rangeValue"),
                            function(a, b) {
                                a.addEventListener("change",
                                function() {
                                    b.value = a.value
                                })
                            } (x, K),
                            J.appendChild(x),
                            J.appendChild(K),
                            j.appendChild(J)
                        } else if ("textArea" === u) {
                            var L = document.createElement("div"),
                            K = document.createElement("textarea");
                            K.setAttribute("id", t),
                            K.value = s.value,
                            K.style.width = "500px",
                            K.style.height = "300px",
                            L.appendChild(K),
                            j.appendChild(L)
                        } else if ("multipleF" === u || "multipleS" === u || "multipleT" === u) x.style.width = "84px",
                        x.style.marginLeft = "1px",
                        "textureRepeatC" === s.id || "textureRepeatR" === s.id || "normalScaleC" === s.id || "normalScaleR" === s.id ? x.style.width = "106px": "shapeW" === s.id || "shapeH" === s.id || "shapeD" === s.id ? x.style.width = "81px": "ambientLightColor" === s.id ? x.style.width = "60px": "pointLightColor" === s.idTyle ? x.style.width = "60px": "pointLightPosition" === s.idTyle ? x.style.width = "115px": "pointLightIntensity" === s.idTyle && (x.style.width = "60px"),
                        j.appendChild(x);
                        else if ("label" == u);
                        else if ("button" == u) {
                            var M = document.createElement("input");
                            M.id = s.label,
                            M.setAttribute("type", "button"),
                            M.setAttribute("class", "parameterReset"),
                            M.setAttribute("title", "reset"),
                            "PositionReset" === s.label ? (M.setAttribute("onclick", "Utils.parameterReset('PositionReset','position')"), M.setAttribute("onmouseover", "Utils.setButtonStyleHover('PositionReset')"), M.setAttribute("onmouseout", "Utils.setButtonStyle('PositionReset')")) : "RotationReset" === s.label ? (M.setAttribute("onclick", "Utils.parameterReset('RotationReset','rotation')"), M.setAttribute("onmouseover", "Utils.setButtonStyleHover('RotationReset')"), M.setAttribute("onmouseout", "Utils.setButtonStyle('RotationReset')")) : "ScaleReset" === s.label ? (M.setAttribute("onclick", "Utils.parameterReset('ScaleReset','scale')"), M.setAttribute("onmouseover", "Utils.setButtonStyleHover('ScaleReset')"), M.setAttribute("onmouseout", "Utils.setButtonStyle('ScaleReset')")) : "TextureReset" === s.label ? (M.setAttribute("onclick", "Utils.parameterReset('TextureReset','textureRepeat')"), M.setAttribute("onmouseover", "Utils.setButtonStyleHover('TextureReset')"), M.setAttribute("onmouseout", "Utils.setButtonStyle('TextureReset')")) : "normalReset" === s.label && (M.setAttribute("onclick", "Utils.parameterReset('normalReset','normalScale')"), M.setAttribute("onmouseover", "Utils.setButtonStyleHover('normalReset')"), M.setAttribute("onmouseout", "Utils.setButtonStyle('normalReset')")),
                            M.setAttribute("onmousedown", "Utils.stopPropagation(event)"),
                            j.appendChild(M)
                        } else j.appendChild(x);
                        if (s.inner && s.display !== !1) {
                            var N = document.createElement("label");
                            N.setAttribute("class", "innerLabel"),
                            N.innerHTML = s.inner,
                            j.appendChild(N)
                        }
                        if (s.pick) {
                            var O = document.createElement("input");
                            O.setAttribute("class", "image-pick-button"),
                            O.setAttribute("name", "pick"),
                            O.setAttribute("type", "button"),
                            O.onclick = s.pickFunction,
                            j.appendChild(O)
                        }
                        if (void 0 === s["return"]) {
                            var P = document.createElement("div");
                            P.setAttribute("class", "clear"),
                            j.appendChild(P)
                        }
                        s.datalist && j.appendChild(s.datalist),
                        o[k] = j
                    } else j ? j.appendChild(s.value) : (j = document.createElement("div"), j.style.width = "800px", j.style.height = "400px", j.appendChild(s.value)),
                    o[k] = j,
                    s.id && l.push(s.id)
                }
                var Q = new TabPanel;
                for (var R in o) Q.addTab(R, o[R]);
                Q.setTabChangedFunction(function(a) {
                    Utils.setDialogRect("dialog_id"),
                    h && h(a)
                });
                var S = i ? i: "input_dialog_id";
                Utils.showDialog(S, Q.getView(), b, c, !1, null, d, e, f, l, m, n)
            }
        },
        showDialog: function(a, b, c, d, e, f, g, h, i, j, k, l) {
            Utils.addMask(a);
            var m = document.createElement("div");
            m.setAttribute("id", a),
            m.setAttribute("title", c),
            f ? m.setAttribute("class", f) : m.setAttribute("class", "dialog");
            var n = document.createElement("div");
            n.setAttribute("id", "dialog_title" + a),
            n.setAttribute("class", "dialog-title-div");
            var o = document.createElement("img");
            if (o.setAttribute("class", "new_icon"), o.setAttribute("src", "images/tw.png"), n.appendChild(o), c) {
                var p = document.createElement("span");
                p.innerHTML = c,
                p.setAttribute("class", "nd"),
                m.appendChild(p),
                n.appendChild(p)
            }
            if (e) {
                var q = document.createElement("img");
                q.setAttribute("src", "images/index01_03.png"),
                q.setAttribute("class", "delete"),
                q.onclick = function() {
                    Utils.disposeDialog(a)
                },
                n.appendChild(q)
            }
            m.appendChild(n);
            var r = document.createElement("div");
            if (r.setAttribute("class", "clear"), n.appendChild(r), b && "string" == typeof b) {
                var s = document.createElement("div");
                s.innerHTML = b,
                f || s.setAttribute("class", "inner"),
                m.appendChild(s)
            }
            if (b && "object" == typeof b) {
                var s = document.createElement("div");
                if (s.appendChild(b), f || s.setAttribute("class", "inner"), m.appendChild(s), b.resetRect) {
                    var t = document.getElementById("mask");
                    document.getElementById("mask_" + a) && (t = document.getElementById("mask_" + a));
                    var u = t.offsetWidth,
                    v = t.offsetHeight;
                    b.style.width = parseInt(.8 * u) + "px",
                    b.style.height = parseInt(.7 * v) + "px"
                }
            }
            var w = {};
            if (d) {
                if (g) {
                    var x = document.createElement("button");
                    x.setAttribute("class", "cbt"),
                    x.onclick = function() {
                        Utils.disposeDialog(a)
                    };
                    var y = document.createElement("a");
                    y.appendChild(x),
                    m.appendChild(y)
                }
                var z = document.createElement("button");
                z.setAttribute("class", "obt");
                var A = document.createElement("a");
                A.appendChild(z),
                g ? z.onclick = function() {
                    if (k && k.length > 0) {
                        for (var b = {},
                        c = 0; c < k.length; c++) {
                            var d = k[c],
                            e = document.getElementById("label" + d).value,
                            f = document.getElementById(d).value;
                            b[e] = f
                        }
                        w.customProps = b
                    }
                    if (j) for (var c = 0; c < j.length; c++) {
                        var l = j[c],
                        m = "";
                        document.getElementById(l) && (w[l] = document.getElementById(l).value, m = document.getElementById(l).type),
                        "checkbox" === m || "radio" === m ? w[l] = document.getElementById(l).checked: "select" === m ? w[l] = document.getElementById(l).selected: "file" === m && (w[l] = document.getElementById(l).files)
                    }
                    var n = [];
                    i && (n = i),
                    n.push(w);
                    var o = g.apply(h, n); ("undefined" == typeof o || o) && Utils.disposeDialog(a)
                }: z.onclick = function() {
                    Utils.disposeDialog(a)
                },
                m.appendChild(A)
            }
            return document.body.appendChild(m),
            Utils.setDialogRect(a),
            m.setAttribute("tabindex", -1),
            m.focus(),
            m.onkeydown = function(a) {
                window.event ? keynum = a.keyCode: a.which && (keynum = a.which),
                !Utils.isShiftDown(a) && 13 == keynum && z && z.click()
            },
            Utils.move("dialog_title" + a, a),
            w
        },
        getMouseP: function(a) {
            a = a || window.event;
            var b = a.pageX || a.pageY ? {
                x: a.pageX,
                y: a.pageY
            }: {
                x: a.clientX + document.body.scrollLeft - document.body.clientLeft,
                y: a.clientY + document.body.scrollTop - document.body.clientTop
            };
            return b
        },
        move: function(a, b) {
            a = document.getElementById(a),
            b = document.getElementById(b),
            b.moving = !1,
            a.onmousedown = function(a) {
                var c = Utils.getMouseP(a),
                d = {
                    x: c.x - b.offsetLeft,
                    y: c.y - b.offsetTop
                };
                document.onmousemove = function(a) {
                    var c = Utils.getMouseP(a);
                    b.style.left = c.x - d.x + "px",
                    b.style.top = c.y - d.y + "px",
                    b.moving = !0
                },
                document.onmouseup = function() {
                    b.moving && (window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(), this.onmousemove = null, b.moving = !1)
                }
            }
        },
        setDialogRect: function(a) {
            var b = document.getElementById("mask");
            if (document.getElementById("mask_" + a) && (b = document.getElementById("mask_" + a)), b) {
                var c = b.offsetWidth,
                d = b.offsetHeight,
                e = document.getElementById(a),
                f = e.offsetWidth,
                g = e.offsetHeight;
                e.style.left = c / 2 - f / 2 + "px",
                e.style.top = d / 2 - g / 2 + "px"
            }
        },
        createRoom: function(a) {
            "room" === a ? (document.body.removeChild(document.getElementById("mask_newEditor")), document.body.removeChild(document.getElementById("newEditor")), Utils.checkLoadLocalImage()) : "component" === a && (document.location.href = "index.html?showEditor=false")
        },
        createComponent: function(a) {
            "room" === a ? document.location = "components.html": "component" === a && (document.body.removeChild(document.getElementById("mask_newEditor")), document.body.removeChild(document.getElementById("newEditor")), Utils.checkLoadLocalImage())
        },
        createLayerRow: function(a, b, c, d, e) {
            var f = new TreeComboBox(a, null, !0, e.getRoots(), null, null, c),
            g = {
                id: b,
                value: f.getView(),
                type: "div",
                tab: d
            };
            return g
        },
        createImageRow: function(a, b, c, d) {
            var e = localStorage.getItem(LOAD_RESOURCE_TYPE) === TYPE_CLOUD ? {
                label: a,
                id: b,
                value: c,
                pick: !0,
                tab: d,
                pickFunction: function() {
                    Utils.pickImage(b)
                }
            }: {
                label: a,
                id: b,
                value: c,
                tab: d
            };
            return e
        },
        pickImage: function(a) {
            var b = new TextureImagePanel;
            b.init(),
            Utils.showDialog("imagepane", b.getView(), "Select Image", !0, !1, null, Utils.setImageCategory, Utils, [a, b])
        },
        setImageCategory: function(a, b) {
            var c = b.getLastNetworkData();
            c && document.getElementById(a) && (document.getElementById(a).value = c.getClient("path"))
        },
        pickAnimation: function(a, b, c) {
            var b = document.getElementById(a).value,
            d = new twaver.LayerBox,
            e = d.getDataById("default");
            if (Utils.isNotNull(b) && "" != b) {
                var f = b.split(";");
                for (var g in f) {
                    var h = new twaver.Layer;
                    0 == g && (h = e);
                    var i = f[g],
                    j = i ? i.split(":") : ["", "", ""],
                    k = j[0],
                    l = j[1],
                    m = parseFloat(j[2]),
                    n = j.length > 3 ? parseInt(j[3]) : 1500,
                    o = j.length > 4 ? parseInt(j[4]) : 0,
                    p = j.length > 5 ? j[5] : "Linear.None";
                    h.setClient("action", k),
                    h.setClient("anchor", l),
                    h.setClient("value", m),
                    h.setClient("time", n),
                    h.setClient("delay", o),
                    h.setClient("easing", p),
                    d.getDataById(h.getId()) || d.add(h)
                }
            } else e.setClient("time", 1500),
            e.setClient("delay", 0),
            e.setClient("easing", "Linear.None");
            var q = new AnimationTable(d);
            q.showDialog(a)
        },
        queryString: function(a, b) {
            var c = new RegExp("" + b + "=([^&?]*)", "ig");
            return a.match(c) ? a.match(c)[0].substr(b.length + 1) : null
        },
        getImageSrc: function(a) {
            var b = "";
            return b = a.indexOf("http") >= 0 ? a: a.indexOf("base64") >= 0 ? a: a.indexOf(Utils.Path) >= 0 ? a: Utils.Path + a
        },
        showPortDialog: function(a, b, c, d) {
            var e = [{
                label: "Rows:",
                id: "rows",
                type: "input",
                value: 2
            },
            {
                label: "Columns:",
                id: "columns",
                type: "input",
                value: 2
            }];
            Utils.showInputDialog(e, "Port Params", !0, this.createPortByMat, this, [a, b, c, d])
        },
        createPortByMat: function(a, b, c, d, e) {
            var f = parseInt(e.rows),
            g = parseInt(e.columns),
            h = a.getElementBox(),
            i = a.getElementAt(b);
            if (i instanceof twaver.Grid) {
                var j = (c.resize, a.getLogicalPoint(b)),
                k = i.getCellObject(j);
                Utils.registerImage(Utils.Path + c.material, a, "component");
                for (var l = 0; f > l; l++) for (var m = 0; g > m; m++) {
                    var n = new twaver.Follower;
                    if (n.setImage(Utils.Path + c.material), n.setClient("text", d), n.setClient("resize", c.resize), h.getSelectionModel().setSelection(n), null != k) {
                        "unresize" === c.resize && (n.setStyle("follower.fill.cell", !1), n.setWidth(c.args.x * a.zoom), n.setHeight(c.args.y * a.zoom)),
                        n.setParent(i),
                        n.setHost(i),
                        n.setStyle("follower.row.index", k.rowIndex + l),
                        n.setStyle("follower.column.index", k.columnIndex + m);
                        var o = n.getParent().getParent(),
                        p = n.getCenterLocation().x - o.getCenterLocation().x,
                        q = n.getCenterLocation().y - o.getCenterLocation().y;
                        n.setClient("offsetX", p / a.zoom),
                        n.setClient("offsetY", q / a.zoom);
                        var r = i.getClient("offset");
                        n.setClient("offset", r + .15),
                        n.setClient("selfID", n.getId()),
                        n.setClient("hostCell", i),
                        h.add(n)
                    }
                }
                handleText2d(a)
            }
        },
        showTemplateDialog: function(a, b, c, d, e) {
            var f = [{
                label: "Rows :",
                id: "rows",
                type: "input",
                value: 2
            },
            {
                label: "Columns :",
                id: "columns",
                type: "input",
                value: 2
            },
            {
                label: "X Gap :",
                id: "xGap",
                type: "input",
                value: 20
            },
            {
                label: "Y Gap :",
                id: "yGap",
                type: "input",
                value: 20
            }];
            Utils.showInputDialog(f, "Template Params", !0, this.createTemplateByMat, this, [a, b, c, d, e])
        },
        createTemplateByMat: function(a, b, c, d, e, f) {
            var g = parseInt(f.rows),
            h = parseInt(f.columns),
            i = parseInt(f.xGap),
            j = parseInt(f.yGap),
            k = [];
            if (d.loadFromCloud) for (var e = function(a, d, e) {
                processHost(a, c),
                a._host ? a._host.setCenterLocation({
                    x: b.getLogicalPoint(c).x + (a.getWidth() + i) * e,
                    y: b.getLogicalPoint(c).y + (a.getHeight() + j) * d
                }) : a.setCenterLocation({
                    x: b.getLogicalPoint(c).x + (a.getWidth() + i) * e,
                    y: b.getLogicalPoint(c).y + (a.getHeight() + j) * d
                }),
                k.push(a),
                b.getSelectionModel().clearSelection(),
                k.forEach(function(a) {
                    b.getSelectionModel().appendSelection(a)
                })
            },
            l = 0; g > l; l++) for (var m = 0; h > m; m++) a._createElement(b, b.getLogicalPoint(c), d, e, l, m);
            else for (var l = 0; g > l; l++) for (var m = 0; h > m; m++) {
                var n = a._createElement(b, b.getLogicalPoint(c), d, e);
                n._host ? n._host.setCenterLocation({
                    x: b.getLogicalPoint(c).x + (n.getWidth() + i) * m,
                    y: b.getLogicalPoint(c).y + (n.getHeight() + j) * l
                }) : n.setCenterLocation({
                    x: b.getLogicalPoint(c).x + (n.getWidth() + i) * m,
                    y: b.getLogicalPoint(c).y + (n.getHeight() + j) * l
                })
            }
        },
        checkPointFlag: function(a, b, c, d) {
            if ("undefined" != typeof c) if (b) b.setShowPoint(c);
            else if (c) {
                b = new TargetFlagNode(d);
                var e = borderPane.getView();
                if (d == p.ORIGINAL_POINT) var f = 0,
                g = 0;
                else var f = e.offsetWidth - ACCORDION_WIDTH,
                g = e.offsetHeight;
                b.setCenterLocation(f / 2, g / 2),
                a.getElementBox().add(b)
            }
        },
        isCtrlDown: function(a) {
            return a.ctrlKey || a.metaKey
        },
        isAltDown: function(a) {
            return a.altKey
        },
        isShiftDown: function(a) {
            return a.shiftKey
        },
        getVersion: function() {
            return "2.1.5"
        },
        createPointLight: function(a, b) {
            var c = new mono.PointLight(16777215, 1),
            d = 1e4;
            return "undefined" != typeof a && (d = a),
            c.setPosition(d, d, d),
            0 == b && c.setVisible(!1),
            c
        },
        clearLocalStorage: function() {
            localStorage && (localStorage.clear(), alert("success"))
        },
        setNetworkBackground: function(a, b) {
            var c = localStorage.getItem(b);
            c || (c = "#FFFFFF"),
            a.setClearColor(c)
        },
        copyDatasToBoxAnchor: function(a, b) {
            var c = modelManager.serializeDatasInfo(a, network._scaleUnitValue);
            console.log(c),
            b.copyAnchor = c
        },
        pasteBoxAnchorToBox: function(a, b) {
            var c = [];
            if (a.copyAnchor) {
                var d = modelManager.parseSketch(JSON.parse(a.copyAnchor));
                if (d instanceof Array) for (var e in d) b && d[e].setClient("floorName", b),
                a.add(d[e]),
                c.push(d[e])
            }
            return c
        },
        string2Boolean: function(a) {
            return a ? "false" === a ? !1 : !0 : !1
        },
        string2Float: function(a, b) {
            return a ? parseFloat(a) : defautValue
        },
        loadPropertiesFromLocalStorage: function(a, b, c, d, e) {
            var f = localStorage.getItem(LOAD_RESOURCE_TYPE);
            f ? loadResource = f: document.URL.startsWith(PropertyConsts.MONO_URL_PRE) && (loadResource = TYPE_CLOUD);
            var f = localStorage.getItem(DECIMAL_NUMBER);
            f && (decimalNumber = parseInt(f)),
            f = localStorage.getItem(CLOUD_KEY),
            f && (cloudKey = f),
            f = localStorage.getItem(CLOUD_PASSWORD),
            f && (cloudPassword = f),
            f = localStorage.getItem(AMBIENT_LIGHT_ON),
            f && b.setVisible(Utils.string2Boolean(f)),
            f = localStorage.getItem(AMBIENT_LIGHT_COLOR),
            f && b.setColor(f),
            f = localStorage.getItem(PropertyConsts.LocalStorage.SELECT_STYLE),
            f && (selectStyle = f);
            for (var g = 1; g <= c.length; g++) {
                if (f = localStorage.getItem(POINT_LIGHT_ON + g + ""), f && c[g - 1].setVisible(Utils.string2Boolean(f)), f = localStorage.getItem(POINT_LIGHT_POSITION + g + "")) {
                    var h = f.split(",");
                    3 == h.length ? c[g - 1].setPosition(h[0], h[1], h[2]) : c[g - 1].setPosition(h[0], h[0], h[0])
                }
                f = localStorage.getItem(POINT_LIGHT_COLOR + g + ""),
                f && c[g - 1].setColor(f),
                f = localStorage.getItem(POINT_LIGHT_INTENSITY + g + ""),
                f && c[g - 1].setIntensity(parseFloat(f))
            }
            if (a) f = localStorage.getItem(PropertyConsts.LocalStorage.FLOOR_STYLE),
            f && (floorStyle = f),
            f = localStorage.getItem(PropertyConsts.LocalStorage.FLOOR_SIZE),
            f && (floorSize = f),
            f = localStorage.getItem(SHOW_FLOOR),
            f && (showFloor = Utils.string2Boolean(f), showFloor || d.remove(viewFloor)),
            f = localStorage.getItem(ALL_VIEW_SELECTABLE),
            f && (allViewSelectable = Utils.string2Boolean(f));
            else {
                if (f = localStorage.getItem(SHOW_PROPERTY_SHEET), Utils.isNotNull(f) ? (showPropertySheet = Utils.string2Boolean(f), showPropertySheet ? borderPane.setRight(sheetPane) : borderPane.setRight(null)) : borderPane.setRight(null), f = localStorage.getItem(SHOW_TARGET_FLAG)) var i = Utils.string2Boolean(f);
                if (f = localStorage.getItem(SHOW_ORIGINAL_FLAG)) var j = Utils.string2Boolean(f);
                f = localStorage.getItem(SHOW_GRID),
                Utils.isNotNull(f) ? showGrid = Utils.string2Boolean(f) : showGrid = !0,
                f = localStorage.getItem(PropertyConsts.SHOW_RULER_GUIDES),
                Utils.isNotNull(f) ? showRulerGuides = Utils.string2Boolean(f) : showRulerGuides = !1,
                f = localStorage.getItem(PropertyConsts.SHOW_RULER),
                Utils.isNotNull(f) ? showRuler = Utils.string2Boolean(f) : showRuler = !0,
                e[0] instanceof GridNetwork && setTimeout(function() {
                    0 == showGrid ? e[0].setShowGrid(!1) : e[0].setShowGrid(!0)
                },
                100)
            }
            f = localStorage.getItem(ENABLE_SCALE),
            f && (enableScale = Utils.string2Boolean(f)),
            f = localStorage.getItem(SHOW_AXIS),
            f && (showAxis = Utils.string2Boolean(f)),
            f = localStorage.getItem(SHOW_AXIS_TEXT),
            f && (showAxisText = Utils.string2Boolean(f)),
            f = localStorage.getItem(PropertyConsts.ENABLE_EASING),
            f && (enableEasing = Utils.string2Boolean(f)),
            f = localStorage.getItem(SHOW_DIM),
            f && (showDim = Utils.string2Boolean(f)),
            f = localStorage.getItem(SHOW_COORD),
            f && (showCoord = Utils.string2Boolean(f)),
            a && (f = localStorage.getItem(IS_FULL_ROTATION_COMPONENT), f && (isFullRotation = Utils.string2Boolean(f), "undefined" != typeof e[1] && (isFullRotation ? e[1].getInteractions()[1].yRistrict = !1 : (e[1].getInteractions()[1].yRistrict = !0, reset4CCamera(6, 3)))), f = localStorage.getItem(SCALE_MIN_LIMIT), f && (scaleMinLimit = Utils.string2Float(f, .1)), f = localStorage.getItem(SCALE_MAX_LIMIT), f && (scaleMaxLimit = Utils.string2Float(f, 100)), f = localStorage.getItem(ZOOM_SPEED_COMPONENT), f && (comZoomSpeed = parseFloat(f)), f = localStorage.getItem(ROTATE_SPEED_COMPONENT), f && (comRotateSpeed = parseFloat(f)), f = localStorage.getItem(PAN_SPEED_COMPONENT), f && (comPanSpeed = Utils.string2Float(f)), f = localStorage.getItem(MAX_DISTANCE_COMPONENT), f && (comMaxDistance = parseFloat(f)), f = localStorage.getItem(MIN_DISTANCE_COMPONENT), f && (comMinDistance = parseFloat(f)), f = localStorage.getItem(PropertyConsts.NEAR_PLANE_COMPONENT), f && (comNearPlane = parseFloat(f)), f = localStorage.getItem(PropertyConsts.FAR_PLANE_COMPONENT), f && (comFarPlane = parseFloat(f)), f = localStorage.getItem(PropertyConsts.FOV_COMPONENT), f && (comFov = parseFloat(f))),
            a || (f = localStorage.getItem(IS_FULL_ROTATION), f && (isFullRotation = Utils.string2Boolean(f), "undefined" != typeof defaultInteraction && (isFullRotation ? defaultInteraction.yRistrict = !1 : (defaultInteraction.yRistrict = !0, defaultInteraction.yLowerLimitAngle = -Math.PI / 8, defaultInteraction.yUpLimitAngle = Math.PI / 2))), f = localStorage.getItem(ZOOM_SPEED), f && (zoomSpeed = parseInt(f)), f = localStorage.getItem(ROTATE_SPEED), f && (rotateSpeed = parseInt(f)), f = localStorage.getItem(PAN_SPEED), f && (panSpeed = Utils.string2Float(f)), f = localStorage.getItem(MAX_DISTANCE), f && (maxDistance = parseInt(f)), f = localStorage.getItem(MIN_DISTANCE), f && (minDistance = parseInt(f)), f = localStorage.getItem(PropertyConsts.NEAR_PLANE), f && (nearPlane = parseFloat(f)), f = localStorage.getItem(PropertyConsts.FAR_PLANE), f && (farPlane = parseFloat(f)), f = localStorage.getItem(PropertyConsts.FOV), f && (fov = parseFloat(f)));
            var k = localStorage.getItem(a ? "componentBackground": "roomBackground");
            if (e instanceof Array && e.length) for (var g = 0; g < e.length; g++) {
                var l = e[g];
                if (l instanceof GridNetwork) Utils.checkPointFlag(l, targetFlagElement, i),
                Utils.checkPointFlag(l, originalFlagElement, j, p.ORIGINAL_POINT),
                l.invalidateElementVisibility();
                else if (l instanceof mono.Network3D && (l.setShowAxis(showAxis), l.setShowAxisText(showAxisText), k && l.setClearColor(k), Utils.isNotNull(enableEasing))) {
                    var m, n = l.getInteractions();
                    n && n.forEach(function(a) {
                        a instanceof mono.DefaultInteraction && (m = a)
                    }),
                    m && m.setEasing(enableEasing)
                }
            }
        },
        validateCloudKeyCallback: function(a, b, c, d) {
            var e = JSON.parse(a);
            if (e.error) alert(e.error);
            else {
                var f = e.value;
                if (!f) return void alert("Cloud key is invalid");
                if (f.end_date) {
                    var g = new Date;
                    if (Date.parse(f.end_date) - g < 0) return void alert("Cloud key is past due")
                }
                localStorage.setItem(CLOUD_KEY, b),
                localStorage.setItem(CLOUD_PASSWORD, c),
                d ? (accordion4C.clearAllCategories(), fillComponentCategoryView(), refreshComponentAccordion(accordion4C.getAccodion().getCurrentTitle())) : (accordionPane.clearAllCategories(), fillCategoryView(), refreshAccordion(accordionPane.getAccodion().getCurrentTitle()))
            }
        },
        validateCloudKey: function(a, b, c, d) {
            return a ? void Utils.doLogin(a, b, this, d) : void alert("Cloud key is required")
        },
        doLogin: function(a, b, c, d) {
            var e = {
                arguments: {
                    username: a,
                    password: b
                }
            };
            require(MONO_URL_LOGIN, e, d, c)
        },
        login: function(a, b, c, d) {
            var e = new XMLHttpRequest;
            e.timeout = 15e3,
            e.ontimeout = function() {
                d && d.call(c, {
                    error: "request timeout"
                })
            };
            var f = new FormData;
            f.append("username", a),
            f.append("password", b),
            e.open("post", MONO_URL_LOGIN, !0),
            e.withCredentials = !0,
            e.onreadystatechange = function() {
                4 == e.readyState && 200 == e.status && d && d.call(c, http.responseText)
            },
            e.send(f)
        },
        doLogout: function() {
            if (confirm("Logout?")) {
                var a = {
                    arguments: {}
                };
                document.location.href = "login.html",
                localStorage.setItem("mono-user", ""),
                require(MONO_URL_LOGOUT, a)
            }
        },
        isNotNull: function(a) {
            return void 0 !== a && "undefined" !== a && null !== a && "null" !== a && "" !== a
        },
        registerRandomImage: function(a, b) {
            var c = new Image;
            c.src = Utils.RelativePath + b,
            c.crossOrigin = "",
            arguments,
            c.onload = function() {
                twaver.Util.registerImage(a, c, c.width, c.height),
                c.onload = null
            }
        },
        handlerTexture: function(a, b, c) {
            var d;
            if (Utils.isNotNull(a)) {
                if (a instanceof Array) {
                    d = [];
                    for (var e = 0; e < a.length; e++) {
                        var f = Utils.handlerTexture(a[e], b, c);
                        d.push(f)
                    }
                } else "string" != typeof a || a.startsWith("data:image") || a.startsWith("http") ? d = a.startsWith("http") && c && a.indexOf("%") >= 0 ? decodeURI(a) : a: (d = Utils.RelativePath + a, b && (d = PropertyConsts.MONO_IMG_PRE + d));
                return d
            }
            return d
        },
        scaleCanvas: function(a, b, c) {
            var d = a.width,
            e = a.height;
            void 0 == b && (b = d),
            void 0 == c && (c = e);
            var f = e > d ? d: e,
            g = d > f ? (d - f) / 2 : 0,
            h = e > f ? (e - f) / 2 : 0,
            i = document.createElement("canvas"),
            j = i.getContext("2d");
            return i.width = b,
            i.height = c,
            j.drawImage(a, g, h, f, f, 0, 0, b, c),
            i
        },
        checkLoadLocalImage: function() {
            try {
                var a = document.createElement("canvas"),
                b = new Image;
                b.src = Utils.getImageSrc("floor.png");
                var c = a.getContext("2d");
                c.fillStyle = "#EEEEFF",
                c.fillRect(0, 0, 400, 300),
                b.onload = function() {
                    c.drawImage(b, 0, 0, 100, 100);
                    try {
                        c.getImageData(0, 0, 100, 100)
                    } catch(a) {
                        if (console.log(a), console.log(a.name), console.log(a.message), "SecurityError" === a.name && (a.message.indexOf("the canvas has been tainted by cross-origin data") >= 0 || a.message.indexOf("SecurityError: DOM Exception 18") >= 0)) {
                            var d = "<div class='error_dialog'><span class='r_title'>Get cross-origin data</span><p>Your browser can not access local file and will get security error.<br>click <a href='http://twaver.servasoft.com/?p=7366' target='_blank'>twaver.servasoft.com</a> to get solution</p></div>";
                            Utils.showDialog("errorDialog", d, "Warning", !1, !0, "loadimagedialog")
                        }
                    }
                }
            } catch(d) {
                console.log(d)
            }
        },
        paintArrow: function(a, b, c, d, e, f) {
            if (a && b && c) {
                a.moveTo(b.x, b.y),
                a.lineTo(c.x, c.y);
                var g = c.x,
                h = c.y;
                e = e || 10,
                f = f || 5,
                d = d || "up",
                a.moveTo(g, h),
                "up" == d ? (a.lineTo(g - e / 2, h + f), a.lineTo(g + e / 2, h + f)) : "right" == d ? (a.lineTo(g - f, h - e / 2), a.lineTo(g - f, h + e / 2)) : "left" == d ? (a.lineTo(g + f, h + e / 2), a.lineTo(g + f, h - e / 2)) : "down" == d && (a.lineTo(g + e / 2, h - f), a.lineTo(g - e / 2, h - f)),
                a.lineTo(g, h),
                a.fill()
            }
        },
        isTargetFlag: function(a) {
            return a && a instanceof TargetFlagNode && a.getType() == p.TARGET_POINT
        },
        isOriginalFlag: function(a) {
            return a && a instanceof TargetFlagNode && a.getType() == p.ORIGINAL_POINT
        },
        createSelectInput: function(a, b, c) {
            if (a && !(a.length <= 0)) {
                var d = document.createElement("select");
                b && (c = c || "onchange", d[c] = b);
                for (var e = 0; e < a.length; e++) {
                    var f = a[e],
                    g = document.createElement("option");
                    g.setAttribute("value", f),
                    g.innerHTML = f,
                    d.appendChild(g)
                }
            }
        },
        categoryCache: {},
        publicCategoryCache: {},
        initCategory: function(a, b, c, d) {
            Object.getOwnPropertyNames(a).length <= 0 ? Utils.getTemplateCategory(a, b, c, d) : d && d()
        },
        getTemplateCategory: function(a, b, c, d) {
            function e(a, b, c) {
                if (c.type && c.type == PropertyConsts.TYPE_COMPONENT) {
                    var d = a[c.type];
                    d || (a[c.type] = d = {})
                }
                if (d) {
                    var e = d[b];
                    e || (d[b] = e = {})
                } else {
                    var e = a[b];
                    e || (a[b] = e = {})
                }
                if (e.children ? e.children.push(c) : e.children = [c], c.type && c.type == PropertyConsts.TYPE_COMPONENT && b == PropertyConsts.TYPE_ROOTCATEGORY) {
                    var f = a[b];
                    f || (a[b] = f = {}),
                    f.children ? f.children.push(c) : f.children = [c]
                }
                return e
            }
            var f = {};
            Utils.isNotNull(c) && (f.scope = c);
            var g = {
                module: b,
                method: "search",
                arguments: f
            },
            h = function() {
                if (1 === arguments.length) {
                    var b = JSON.parse(arguments[0]);
                    if (b.error) return void alert(b.error);
                    for (var c = b.value,
                    f = 0; f < c.length; f++) {
                        var g = c[f];
                        g.type && g.type == PropertyConsts.TYPE_COMPONENT && (a[g.type] || (a[g.type] = {}), a[g.type][g.id] = g),
                        a[g.id] = g
                    }
                    for (var f = 0; f < c.length; f++) {
                        var g = c[f];
                        g.parent_id ? e(a, g.parent_id, g) : e(a, PropertyConsts.TYPE_ROOTCATEGORY, g)
                    }
                    d && d()
                }
            };
            require(MONO_URL, g, h, this)
        },
        requestMono: function(a, b, c) {
            require(MONO_URL, a, b, c)
        },
        stopPropagation: function(a) {
            a.stopPropagation && a.stopPropagation(),
            a.preventDefault ? a.preventDefault() : a.returnValue = !1
        },
        convert2Radian: function(a) {
            return a * Math.PI / 180
        },
        convert2Angle: function(a) {
            return 180 * a / Math.PI
        },
        showLoginDialog: function() {
            var a = [{
                label: "Cloud Key:",
                id: "key"
            },
            {
                label: "Cloud Password:",
                type: "password",
                id: "password"
            }];
            Utils.showInputDialog(a, "Login", !0,
            function() {
                var a = document.getElementById("key").value,
                b = document.getElementById("password").value;
                Utils.validateCloudKey(a, b, !1,
                function(c) {
                    var d = JSON.parse(c);
                    if (d.error) alert(d.error);
                    else {
                        var e = d.value;
                        e ? Date.parse(e.end_date) - new Date < 0 ? alert("Cloud key is past due") : (localStorage.setItem(LOAD_RESOURCE_TYPE, TYPE_CLOUD), localStorage.setItem(CLOUD_KEY, a), localStorage.setItem(CLOUD_PASSWORD, b)) : alert("Cloud key is invalid")
                    }
                    location.reload()
                })
            },
            this)
        },
        generateAssembleId: function(a) {
            return a = a || mono.Math.generateUUID()
        },
        setButtonsStyle: function(a, b) {
            if (a) for (var c = 0; c < a.length; c++) if (a[c] !== b) {
                var d = document.getElementById(a[c]);
                d.setAttribute("class", a[c])
            } else {
                var e = document.getElementById(b);
                e.setAttribute("class", b + "_hover")
            }
        },
        createLinkHandle: function(a) {
            var b = a.getSelectionModel().getSelection();
            if (! (2 != b.size() || b.get(0) instanceof mono.Link || b.get(1) instanceof mono.Link)) {
                var c = [{
                    label: "Link Style:",
                    id: "linkStyle",
                    type: "select",
                    options: PropertyConsts.LINK_STYPE,
                    value: "orthogonal.y"
                },
                {
                    label: "Link Color:",
                    id: "linkColor",
                    value: "blue"
                },
                {
                    label: "Link Size:",
                    id: "linkSize",
                    value: 5
                },
                {
                    label: "Link Extend:",
                    id: "linkExtend",
                    value: 0
                },
                {
                    label: "Link point data:",
                    id: "linkPoints",
                    tab: "Link Points",
                    type: "textArea",
                    readonly: !1,
                    value: ""
                }];
                this.showInputDialog(c, "Link Properties", !0, this.createLinkDialogHandle, this, [a], !0)
            }
        },
        createLinkDialogHandle: function(a, b) {
            var c = a.getSelectionModel().getSelection(),
            d = new TGL.Link(c.get(0), c.get(1));
            if (d.setExtend(parseFloat(b.linkExtend)), d.setLinkType(b.linkStyle), d.s({
                "m.color": b.linkColor,
                "m.linewidth": parseFloat(b.linkSize)
            }), "control" == b.linkStyle && b.linkPoints) {
                for (var e = b.linkPoints.toString().replace(/\s/g, ",").replace(/\r\n/g, ","), f = e.split(","), g = [], h = 0; h < f.length; h += 3) isNaN(parseFloat(f[h])) || g.push(new TGL.Vec3(parseFloat(f[h]), parseFloat(f[h + 1]), parseFloat(f[h + 2])));
                d.setControls(g)
            }
            a.add(d)
        },
        scale3DElement: function(a, b) {
            var c = a.getPosition().clone();
            a.setPosition(c.x * b, c.y * b, c.z * b);
            var d = a.getClassName();
            switch (d = d.replace("TGL.", "mono.")) {
            case "mono.Cube":
                a.setWidth(a.getWidth() * b),
                a.setHeight(a.getHeight() * b),
                a.setDepth(a.getDepth() * b);
                break;
            case "mono.Sphere":
                a.setRadius(a.getRadius() * b);
                break;
            case "mono.Cylinder":
                a.setRadiusTop(a.getRadiusTop() * b),
                a.setRadiusBottom(a.getRadiusBottom() * b),
                a.setHeight(a.getHeight() * b);
                break;
            case "mono.Torus":
                a.setRadius(a.getRadius() * b),
                a.setTube(a.getTube() * b);
                break;
            case "mono.Billboard":
                var e = a.getScale();
                a.setScale(e.x * b, e.y * b, 1);
                break;
            case "mono.PathNode":
                a.setRadius(a.getRadius() * b);
                var f = a.getPath(),
                g = f.toArray(),
                h = Utils._createPath(g, b);
                a.setPath(h);
                break;
            case "mono.TextNode":
                var i = a.getScale();
                a.setHeight(a.getHeight() * b),
                a.setScale(i.x * b, i.y * b, i.z * b);
                break;
            case "mono.ComboNode":
                var j = a.getCombos(),
                k = a.getStyle("m.texture.image", !0),
                l = a.getStyle("m.texture.repeat", !0),
                m = [];
                for (var n in j) Utils.scale3DElement(j[n], b),
                m.push(j[n]);
                a.setCombos(m),
                a.setStyle("m.texture.image", k),
                a.setStyle("m.texture.repeat", l);
                break;
            case "mono.LatheNode":
                var f = a.getPath(),
                g = f.toArray(),
                h = Utils._createPath(g, b);
                a.setPath(h);
                break;
            case "mono.Entity":
            }
        }
    };
    var f = function(a) {
        for (var b = box.getNodes().toArray(), c = b.length, d = 0; c > d; d++) {
            var e = b[d];
            e.isSelected() && e.setRotationZ(e.getRotation().z + a)
        }
    };
    $rSelected = f;
    var g = function() {
        var a = box.getSelectionModel().getSelection(),
        b = a.size();
        if (0 === b) alert("Select one or more objects.");
        else {
            var c = "";
            1 === b && (c = a.get(0).getGroupId());
            for (var d = window.prompt("Group ID:", c), e = 0; b > e; e++) {
                var f = a.get(e);
                f.setGroupId(d)
            }
        }
    };
    $group = g;
    var h = function(a) {
        var b = [];
        b.push();
        var c = [{
            label: "Select align pattern:",
            id: "group_on_ground",
            name: "align",
            type: "radio",
            checked: !0,
            inner: '<img src="' + Utils.Path + '../images/align_group_on_ground.png" />   Group align on ground'
        },
        {
            label: "",
            id: "group_under_ground",
            name: "align",
            type: "radio",
            checked: !1,
            inner: '<img src="' + Utils.Path + '../images/align_group_under_ground.png" />   Group align under ground'
        },
        {
            label: "",
            id: "on_ground",
            name: "align",
            type: "radio",
            checked: !1,
            inner: '<img src="' + Utils.Path + '../images/align_on_ground.png" />   Align on ground'
        },
        {
            label: "",
            id: "under_ground",
            name: "align",
            type: "radio",
            checked: !1,
            inner: '<img src="' + Utils.Path + '../images/align_under_ground.png" />   Align under ground'
        },
        {
            label: "",
            id: "center",
            name: "align",
            type: "radio",
            checked: !1,
            inner: '<img src="' + Utils.Path + '../images/align_center_3d.png" />   Align center'
        },
        {
            label: "",
            id: "top",
            name: "align",
            type: "radio",
            checked: !1,
            inner: '<img src="' + Utils.Path + '../images/align_top_3d.png" />   Align top'
        },
        {
            label: "",
            id: "bottom",
            name: "align",
            type: "radio",
            checked: !1,
            inner: '<img src="' + Utils.Path + '../images/align_bottom_3d.png" />   Align bottom'
        }];
        Utils.showInputDialog(c, "Align Pattern", !0, j, this, [a])
    },
    j = function(a, b) {
        for (var c = (b.group_on_ground || b.group_under_ground, new Array), d = a.getSelectionModel().getSelection(), e = d.size(), f = 0; e > f; f++) {
            var g = d.get(f);
            c.push(g)
        }
        var h, i;
        if (c.length > 0) for (var f = 0; f < c.length; f++) {
            var g = c[f];
            if (g && !g.getParent()) {
                var j = g.getWorldBoundingBox();
                j && (b.under_ground && g.setPositionY(g.getPosition().y - j.max.y), b.on_ground && g.setPositionY(g.getPosition().y - j.min.y), (!h || h < j.max.y) && (h = j.max.y), (!i || i > j.min.y) && (i = j.min.y))
            }
        }
        if (!b.under_ground && !b.on_ground && (h || i) && c.length > 0) for (var f = 0; f < c.length; f++) {
            var g = c[f];
            if (g && !g.getParent()) {
                if (b.top) {
                    var k = h - g.getWorldBoundingBox().max.y;
                    g.setPositionY(g.getPosition().y + k)
                }
                if (b.group_under_ground && g.setPositionY(g.getPosition().y - h), b.bottom) {
                    var k = g.getWorldBoundingBox().min.y - i;
                    g.setPositionY(g.getPosition().y - k)
                }
                b.group_on_ground && g.setPositionY(g.getPosition().y - i),
                b.center && g.setPositionY((h + i) / 2)
            }
        }
    };
    $align3d = h;
    var k = function() {
        var a = [];
        a.push();
        var b = [{
            label: "Select layout pattern:",
            id: "star",
            name: "layout",
            type: "radio",
            checked: !0,
            inner: '<img src="' + Utils.Path + '../images/align_group_on_ground.png" />   Star layout'
        }];
        Utils.showInputDialog(b, "Layout Pattern", !0, l, this, [box])
    },
    l = function(a, b) {
        for (var c = (b.group_on_ground || b.group_under_ground, new Array), d = a.getSelectionModel().getSelection(), e = d.size(), f = 0; e > f; f++) {
            var g = d.get(f);
            g.getParent() || c.push(g)
        }
        var h, i, j, k = new mono.Vec3(0, 1, 0);
        if (c.length > 0) for (var f = 0; f < c.length; f++) {
            var g = c[f];
            if (g && !g.getParent()) {
                g.setRotation(0, 0, 0),
                0 == f && (h = g.getPosition().x, i = g.getPosition().y, j = g.getPosition().z),
                g.setPosition(h, i, j);
                var l = g.getWorldBoundingBox();
                if (l) {
                    var m = l.max.x - l.min.x;
                    if (g.setPositionX(g.getPosition().x + m / 2), f > 0) {
                        var n = 2 * Math.PI / c.length * f;
                        g.rotateFromAxis(k, new mono.Vec3(h - g.getPosition().x, i - g.getPosition().y, j - g.getPosition().z), n)
                    }
                }
            }
        }
    };
    $layout3d = k;
    var m = function(a) {
        for (var b = new Array,
        c = box.getSelectionModel().getSelection(), d = c.size(), e = 0; d > e; e++) {
            var f = c.get(e);
            b.push(f)
        }
        n(b, a)
    };
    $combo = m;
    var n = function(a, b) {
        if (a.length > 1) {
            for (var c = [], d = 1; d < a.length; d++) c.push(b);
            for (var e = new mono.ComboNode(a, c), d = 0; d < a.length; d++) {
                var f = a[d];
                box.remove(f)
            }
            Utils.setComboCentralized(e),
            box.add(e)
        }
    };
    Utils.setComboCentralized = function(a) {
        if (a) {
            a.setCentralized(!0);
            var b = a.getOffsetPosition(),
            c = a.getPosition();
            b && a.setPosition(c.x + b.x, c.y + b.y, c.z + b.z)
        }
    };
    var o = function() {
        var a = (new Date).getFullYear(),
        b = "<div id = 'about' class='mar' style='margin-top:0px;'><p>MONO DESIGN is a TWaver online 2D/3D modelling tool.</p><br><p>Visit our website to get more information:</p><p><a href='http://twaver.servasoft.com'>twaver.servasoft.com</a></p><p><a href='http://doc.servasoft.com/'>doc.servasoft.com</a></p><br><p>Contact us:<a href='mailto:info@servasoftware.com'>info@servasoftware.com</a></p><br><p>&copy; Copyright " + a + " <b>Serva Software LLC.</b> All rights reserved.</p><br></div>";
        Utils.showDialog("dialog-about", b, "About MONO DESIGN " + Utils.getVersion(), !0, !1)
    };
    $showabout = o,
    Utils.getUnPredefinedFloorLayers = function(a) {
        var b = new twaver.List;
        return a.getLayerBox().getRoots().forEach(function(a) {
            a.getClient("floorLayer") && !a.getClient("predefined") && b.add(a)
        }),
        b
    },
    Utils.addInteractionComboBox = function(a, b) {
        var c = twaver.Util.isTouchable ? ["Touch", "None"] : ["Default-Lazy", "Edit-Live"],
        d = function() {
            "Default-Lazy" === this.value ? (allNetworks[2].setDefaultInteractions(!0), allNetworks[2]._lazyMoveAnimate = null) : "Edit-Live" === this.value && allNetworks[2].setEditInteractions()
        };
        Utils.addComboBox(a, c, d, b)
    },
    Utils.addComboBox = function(a, b, c, d) {
        var e = document.createElement("select");
        return e.style.verticalAlign = "top",
        e.setAttribute("class", "combobox-comp"),
        b.forEach(function(a) {
            var b = document.createElement("option");
            b.appendChild(document.createTextNode(a)),
            b.setAttribute("value", a),
            e.appendChild(b)
        }),
        c && e.addEventListener("change", c, !1),
        d && (e.value = d),
        a.appendChild(e),
        e
    },
    Utils.getLayerByFloorName = function(a, b) {
        var c = null;
        return a.forEach(function(a) {
            return a.getClient("floorName") == b ? void(c = a) : void 0
        }),
        c
    },
    Utils.createProgressBar = function(a, b) {
        var c = document.createElement("div");
        c.style.width = a + "px",
        c.style.height = b + "px",
        c.style.position = "absolute";
        for (var d = 1; 8 >= d; d++) {
            var e = document.createElement("div");
            e.className = "blockG",
            e.id = "rotateG_0" + d,
            c.appendChild(e)
        }
        return c
    },
    Utils.createToolTipDiv = function(a, b) {
        if (NaN != parseInt(a) && NaN != parseInt(b)) {
            a = parseInt(a),
            b = parseInt(b);
            var c = document.createElement("div");
            c.style.width = a + "px",
            c.style.height = b + "px",
            c.style.zIndex = "1001",
            c.style.display = "none",
            c.id = "toolTipId",
            c.setAttribute("class", "bubble arrow"),
            c.style.backgroundColor = "#FCFBF7",
            c.style.backgroundImage = "url(images/loading.png)",
            c.style.backgroundRepeat = "no-repeat",
            document.body.appendChild(c);
            var d = document.createElement("span");
            d.id = "toolTipTextId",
            d.innerHTML = "",
            d.style.color = "rgb(240,120,25)",
            d.style.fontSize = "11px",
            d.style.position = "absolute",
            d.style.top = "3px",
            d.style.left = "5px",
            d.style.width = "205px",
            c.appendChild(d)
        }
    },
    Utils.addNumberCommas = function(a) {
        a += "",
        x = a.split("."),
        x1 = x[0],
        x2 = x.length > 1 ? "." + x[1] : "";
        for (var b = /(\d+)(\d{3})/; b.test(x1);) x1 = x1.replace(b, "$1,$2");
        return x1 + x2
    },
    Utils.loginMONO = function(a, b) {
        if (!a || !b) return void alert("username and password is required");
        var c = new XMLHttpRequest,
        d = new FormData;
        d.append("username", a),
        d.append("password", b),
        c.open("post", "https://mono-design.cn/login", !0),
        c.withCredentials = !0,
        c.onreadystatechange = function() {
            if (4 == c.readyState && 200 == c.status) {
                var b = JSON.parse(c.responseText);
                b.error ? alert(b.error) : (localStorage.setItem("mono-user", a), localStorage.setItem("loadResource", "cloud"))
            }
        },
        c.send(d)
    },
    Utils.setupLogout = function() {
        var a = document.getElementById("main_toolbar");
        if (a) {
            var b = localStorage.getItem("mono-user");
            null == b ? a.innerHTML += '<img src="images/user.png"><a href="login.html"> Login</a>': a.innerHTML += '<img src="images/user.png"><a id="user" href="#" onclick="Utils.showUserProfile();" title="Click show your profile">' + b + '</a> | <a id="logout" href="#" onclick="Utils.doLogout();">Logout</a>'
        }
    },
    Utils.ready = function(a) {
        return "complete" == document.readyState ? a() : void(window.addEventListener ? window.addEventListener("load", a, !1) : window.attachEvent ? window.attachEvent("onload", a) : window.onload = a)
    },
    Utils.ready(function() {
        Utils.setupLogout()
    }),
    Utils.showUserProfile = function() {
        var a = (localStorage.getItem("mono-user"), {
            arguments: {},
            method: "getSelf",
            module: "users"
        });
        require(MONO_URL, a, Utils.showUserProfileDialog)
    },
    Utils.publishTemplate = function(a, b, c) {
        var d = (localStorage.getItem("mono-user"), {
            arguments: {
                template_id: a,
                category_id: c
            },
            method: "publish",
            module: "templates"
        });
        require(MONO_URL, d,
        function(a) {
            var c = 'Template "' + b + '" has been published successfully.';
            alert(c)
        })
    },
    Utils.unpublishTemplate = function(a, b, c) {
        var d = (localStorage.getItem("mono-user"), {
            arguments: {
                template_id: a,
                category_id: c
            },
            method: "unpublish",
            module: "templates"
        });
        require(MONO_URL, d,
        function(a) {
            var c = 'Template "' + b + '" has been unpublished successfully.';
            alert(c)
        })
    },
    Utils.showUserProfileDialog = function(a) {
        var b = JSON.parse(a),
        c = b.value,
        d = [{
            label: "User:",
            id: "user",
            readonly: !0,
            value: c.user,
            editable: !1
        },
        {
            label: "Valid From:",
            id: "start_date",
            readonly: !0,
            value: Utils.formatDate(c.start_date),
            editable: !1
        },
        {
            label: "Valid Thru:",
            id: "end_date",
            readonly: !0,
            value: Utils.formatDate(c.end_date),
            editable: !1
        },
        {
            label: "Old Password:",
            id: "old_password",
            readonly: !1,
            type: "password",
            value: "",
            editable: !0
        },
        {
            label: "New Password:",
            id: "password",
            readonly: !1,
            type: "password",
            value: "",
            editable: !0
        },
        {
            label: "Confirm Password:",
            id: "password2",
            readonly: !1,
            type: "password",
            value: "",
            editable: !0
        }],
        e = function(a) {
            if (a.password != a.password2) return void alert("New password and confirm password do not match");
            if (!a.password || a.length < 8) return void alert("New password should at least 8 characters");
            var b = {
                module: "users",
                method: "changepw",
                arguments: {
                    old_password: a.old_password,
                    new_password: a.password
                }
            };
            require(MONO_URL, b,
            function() {
                alert("New password has been set up")
            })
        };
        Utils.showInputDialog(d, "User Profile", !0, e, this, [], null, null)
    },
    Utils.formatDate = function(a) {
        if (a) {
            var b = Date.parse(a),
            c = new Date(b),
            d = new Date(c).format("yyyy-MM-dd");
            return d
        }
        return ""
    },
    Utils.setPolygonOffset = function(a, b, c) {
        var d = "m.polygonOffset";
        if (c && (d = c + "." + d), a) {
            var e = d + "Factor",
            f = d + "Units";
            a.setStyle(d, !0),
            a.setStyle(e, 1),
            a.setStyle(f, b)
        }
    },
    Utils.updateBoxInfo = function(a) {
        if (!a.batch) {
            var b = document.getElementById("boxInfo");
            if (b) {
                for (var c = a.getDatas().toArray(), d = 0, e = 0, f = 0; f < c.length; f++) {
                    var g = c[f];
                    if (g.faces) {
                        if (g.getClient(PropertyConsts.COMPONENTFLOOR)) continue;
                        e += g.faces.length,
                        d++
                    }
                }
                d = Utils.addNumberCommas(d),
                e = Utils.addNumberCommas(e),
                b.innerHTML = "Objects: " + d + "<br>Faces: " + e
            }
        }
    },
    Utils.updateFpsInfo = function(a, b) {
        var c = document.getElementById("fpsInfo");
        c && (c.innerHTML = "FPS: " + a + "<br>TPF: " + b + " ms")
    },
    Utils.setupEightLights = function(a, b) {
        b = b || 5e3;
        for (var c = .5,
        d = [[1, 1, 1], [ - 1, 1, 1], [1, 1, -1], [ - 1, 1, -1], [1, -1, 1], [ - 1, -1, 1], [1, -1, -1], [ - 1, -1, -1]], e = 0; e < d.length; e++) {
            var f = d[e][0] * b,
            g = d[e][1] * b,
            h = d[e][2] * b,
            i = new mono.PointLight(16777215, c);
            i.setPosition(f, g, h),
            a.add(i)
        }
    },
    Utils.createNetworkInfoTag = function(a, b, c) {
        var d = document.createElement("span");
        d.innerHTML = "",
        d.style.position = "absolute",
        d.style.left = "2px",
        d.style.background = "transparent",
        d.style.width = "200px",
        d.style.top = c,
        d.style.color = "#AAAAAA",
        d.setAttribute("id", b),
        a.appendChild(d)
    },
    Utils.setupNetworkInfoTags = function(a) {
        var b = document.createElement("div");
        Utils.createNetworkInfoTag(b, "boxInfo", "0px"),
        Utils.createNetworkInfoTag(b, "fpsInfo", "25px"),
        b.setAttribute("class", "network3d-boxinfo"),
        a.getRootView().appendChild(b)
    },
    Utils.createToggleImage = function(a, b, c) {
        c = c || document.body;
        var d = document.createElement("div");
        d.setAttribute("class", a),
        c.appendChild(d);
        var e = document.createElement("div");
        return e.setAttribute("class", b),
        e.style.display = "block",
        d.appendChild(e),
        e
    },
    Utils.createLeftToggleImage = function(a, b, c) {
        var d = Utils.createToggleImage("hidden-left-div", "left-expand-img", c);
        d.onclick = function() {
            var c = document.getElementsByClassName("hidden-left-div")[0];
            "left-expand-img" == this.getAttribute("class") ? (this.setAttribute("class", "left-expand-img left-collapse-img"), c.setAttribute("class", "hidden-left-div hidden-left-collapse-div"), a()) : (c.setAttribute("class", "hidden-left-div"), this.setAttribute("class", "left-expand-img"), b())
        }
    },
    Utils.createTopToggleImage = function(a, b, c) {
        var d = Utils.createToggleImage("hidden-top-div", "top-expand-img", c);
        d.onclick = function() {
            var c = document.getElementsByClassName("hidden-top-div")[0],
            d = document.getElementById("menubar");
            "top-expand-img" == this.getAttribute("class") ? (this.setAttribute("class", "top-expand-img top-collapse-img"), c.setAttribute("class", "hidden-top-div hidden-top-collapse-div"), d.style.display = "none", a()) : (c.setAttribute("class", "hidden-top-div"), this.setAttribute("class", "top-expand-img"), d.style.display = "block", b())
        }
    },
    Utils.isMainNode = function(a) {
        var b = !1;
        return a && a.getClient && Utils.isNotNull(a.getClient("mainVisible")) && 0 == a.getClient("mainVisible") && (b = !0),
        b
    },
    Utils.setBox3DSelectStyle = function(a, b) {
        a.forEach(function(a) {
            a instanceof mono.Entity && Utils.setElementSelectStyle(a, b)
        })
    },
    Utils.setElementSelectStyle = function(a, b) {
        b == PropertyConsts.SELECT_STYLE.WIREFRAME ? a.setStyle("select.style", "outline.wireframe") : b == PropertyConsts.SELECT_STYLE.NORMAL ? a.setStyle("select.style", "outline.normal") : b == PropertyConsts.SELECT_STYLE.BORDER && a.setStyle("select.style", "border")
    },
    Utils.setElementCustomProps = function(a, b, c) {
        var d = b.getClient(CUSTOM_PROPS);
        if (d) for (var e in d) {
            var f = d[e];
            void 0 == c[f] && b.setClient(f, null)
        }
        if (c) {
            var g;
            for (var e in c) g = c[e],
            b.setClient(g, a.getClient(g));
            b.setClient(CUSTOM_PROPS, c)
        }
    },
    Utils.isFloorVisibleByFloorName = function(a, b) {
        var c = !0;
        return b.forEach(function(b) {
            return b.getClient("floorName") == a ? c = b.getClient("floorVisible") : void 0
        }),
        c
    },
    Utils.transforAndScaleCanvasContext = function(a, b) {
        var c = a.getContext("2d");
        if (!b && a.isTransfor && a.width && a.height) return c;
        if (devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = c.webkitBackingStorePixelRatio || c.mozBackingStorePixelRatio || c.msBackingStorePixelRatio || c.oBackingStorePixelRatio || c.backingStorePixelRatio || 1, ratio = devicePixelRatio / backingStoreRatio, devicePixelRatio !== backingStoreRatio) {
            var d = a.width,
            e = a.height;
            a.width = d * ratio,
            a.height = e * ratio,
            a.style.width = d + "px",
            a.style.height = e + "px",
            c.scale(ratio, ratio)
        }
        return a.width && a.height && (a.isTransfor = !0),
        c
    },
    Date.prototype.format = function(a) {
        var b = {
            "M+": this.getMonth() + 1,
            "d+": this.getDate(),
            "h+": this.getHours(),
            "m+": this.getMinutes(),
            "s+": this.getSeconds(),
            "q+": Math.floor((this.getMonth() + 3) / 3),
            S: this.getMilliseconds()
        };
        /(y+)/.test(a) && (a = a.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)));
        for (var c in b) new RegExp("(" + c + ")").test(a) && (a = a.replace(RegExp.$1, 1 == RegExp.$1.length ? b[c] : ("00" + b[c]).substr(("" + b[c]).length)));
        return a
    },
    Number.prototype.format = function(a, b, c, d) {
        var e = "\\d(?=(\\d{" + (b || 3) + "})+" + (a > 0 ? "\\D": "$") + ")",
        f = this.toFixed(Math.max(0, ~~a));
        return (d ? f.replace(".", d) : f).replace(new RegExp(e, "g"), "$&" + (c || ","))
    },
    ImageShapeNode = function() {
        ImageShapeNode.superClass.constructor.apply(this, arguments),
        this.setClient(IMAGE_SRC, Utils.Path + "room.png"),
        this.setStyle("vector.outline.color", "#333333"),
        this.setStyle("vector.outline.width", 10),
        this.setClient("shapenode.closed", !0),
        this.setClient("focusColor", "green"),
        this.setClient("resizeBorderWidth", 10),
        this.setClient("resizeBorderLength", 18),
        this.setClient("resizeBorderGap", 10),
        this.setClient("resizeBorderColor", "yellow"),
        this.setClient("wallInnerPic", Utils.Path + "wall00-inner.png"),
        this.setClient("wallOuterPic", Utils.Path + "wall00.png"),
        this.setClient("lightMapPic", Utils.Path + "lightmap.png"),
        this.setClient("size", {
            x: 0,
            y: 300,
            z: 10
        }),
        this.setClient("useTexture", !1),
        this.setClient("framePic", Utils.Path + "wall00-frame.png"),
        this.setClient("fill", !0),
        this.setClient("showDim", showDim),
        this.setClient("dimLeadLength", 35),
        this.setClient("dimLineOffset", .7),
        this.setClient("dimLineWidth", 1),
        this.setClient("dimColor", "#F07819"),
        this.setClient("dimTextGap", 5),
        this.setClient("dimTextFont", "12px Arial"),
        this.setClient("dimArrowWidth", 8),
        this.setClient("dimArrowHeight", 3),
        this.setClient("showCoord", showCoord),
        this.setClient("coordTextColor", "white"),
        this.setClient("coordTextFont", "12px Arial"),
        this.setClient("coordTextOffsetX", 0),
        this.setClient("coordTextOffsetY", 20),
        this.setClient("coordTextAlign", "center"),
        this.setClient("coordTextBaseline", "middle"),
        this.setClient("coordTextBackground", "rgba(240,120,25,0.7)"),
        this.setClient("decimalNumber", 0),
        this.setClient("room.gap.right", 100),
        this.setClient("room.gap.bottom", 100),
        this.offsetY = 0,
        this.offsetX = 0,
        this.negatedYInterval = !1
    },
    twaver.Util.ext("ImageShapeNode", twaver.ShapeNode, {
        getCanvasUIClass: function() {
            return ImageShapeNodeUI
        },
        getElementUIClass: function() {
            return ImageShapeNodeUI
        },
        getVectorUIClass: function() {
            return ImageShapeNodeUI
        },
        onChildRemoved: function(a, b) {
            this.refreshChilden()
        },
        onChildAdded: function(a, b) {
            this.refreshChilden()
        },
        onPropertyChanged: function(a) {
            ImageShapeNode.superClass.onPropertyChanged.call(this, a),
            "points" === a.property && this.refreshChilden()
        },
        checkBlockOnEdge: function(a) {
            var b = !1;
            return this.getChildren().forEach(function(c) {
                c.getClient("edgeIndex") === a && (b = !0)
            }),
            b
        },
        refreshChilden: function() {
            this.getChildren().forEach(function(a) {
                a.refresh()
            })
        },
        translate3d: function(a, b, c) {
            var d = new Array,
            e = this.getPoints(),
            f = this.getCenterLocation(),
            g = new twaver.List;
            e.forEach(function(a) {
                g.add({
                    x: a.x - f.x,
                    y: a.y - f.y
                })
            });
            var h = e.size();
            if (! (0 >= h)) {
                2 == h && this.setClient("shapenode.closed", !1);
                var i = this.getClient("shapenode.closed");
                this._wallInnerPic = "" === this.getClient("wallInnerPic") ? null: Utils.handlerTexture(this.getClient("wallInnerPic")),
                this._wallOuterPic = "" === this.getClient("wallOuterPic") ? null: Utils.handlerTexture(this.getClient("wallOuterPic")),
                this._wallFramePic = "" === this.getClient("framePic") ? null: Utils.handlerTexture(this.getClient("framePic")),
                this._lightMapPic = "" === this.getClient("lightMapPic") ? null: Utils.handlerTexture(this.getClient("lightMapPic")),
                this instanceof InnerWallShapeNode && (this._wallOuterPic = this._wallInnerPic),
                this.floorName = this.getClient("floorName"),
                this.floorHeight = this.getClient("floorHeight");
                var j = this.getClient("size"),
                k = this.getClient("useTexture"),
                l = this.getClient("transparent"),
                m = this.getClient("opacity"),
                n = this.getClient(CUSTOM_PROPS),
                o = this.getClient(PropertyConsts.LAYERID);
                this.deep = 10;
                var p = 300;
                this.repeat = 50,
                j && (this.deep = j.z, p = j.y),
                0 == k && (this.repeat = p);
                for (var q = new mono.Path,
                r = 0; h > r; r++) {
                    if (c) var s = g.get(r);
                    else var s = e.get(r);
                    0 == r ? q.moveTo(s.x, -s.y, 0) : q.lineTo(s.x, -s.y, 0)
                }
                i && q.closePath();
                var t = this.getId(),
                u = a.getDataById(t),
                v = new mono.PathCube({
                    path: q,
                    width: this.deep,
                    height: p,
                    repeat: this.repeat
                });
                a.startBatch(),
                v.setStyle("m.texture.image", this._wallOuterPic),
                v.setStyle("inside.m.texture.image", this._wallInnerPic),
                v.setStyle("top.m.texture.image", this._wallFramePic),
                v.setStyle("bottom.m.texture.image", this._wallFramePic),
                v.setStyle("aside.m.texture.image", this._wallFramePic),
                v.setStyle("zside.m.texture.image", this._wallFramePic),
                v.setStyle("m.transparent", l),
                v.setStyle("inside.m.lightmap.image", this._lightMapPic),
                v.setStyle("outside.m.lightmap.image", this._lightMapPic),
                v.setStyle("m.opacity", m);
                var w = this.getClient("shapeNodeIndex");
                Utils.setPolygonOffset(v, 2 * -w),
                a.endBatch();
                var x = [],
                y = [];
                x.push(v);
                for (var z = 0; z < b.length; z++) {
                    var A = b[z],
                    B = this.createBlocks(a, A, d, f);
                    x.push(B),
                    y.push("-")
                }
                return ! u && t && (u = t ? new mono.ComboNode(x, y, !1, t) : new mono.ComboNode),
                x.length > 0 && u.setCombos(x),
                y && u.setOperators(y),
                u.setStyle("m.type", "phong"),
                u.setClient("floorName", this.floorName),
                u.setPositionY(this.floorHeight || 0),
                u.setPositionX(f.x),
                u.setPositionZ(f.y),
                u.setEditable(!0),
                u.setSelectable(!0),
                Utils.setElementCustomProps(this, u, n),
                o && u.setClient(PropertyConsts.LAYERID, o),
                a.getDataById(t) || a.add(u),
                d.push(u),
                d
            }
        },
        createBlocks: function(a, b, c, d) {
            var e = new mono.Path,
            f = b.getCenterLocation(),
            g = b.getClient("leftPoint"),
            h = b.getClient("rightPoint");
            g = {
                x: g.x - d.x,
                y: g.y - d.y
            },
            h = {
                x: h.x - d.x,
                y: h.y - d.y
            },
            e.moveTo(g.x, -g.y, 0),
            e.lineTo(h.x, -h.y, 0);
            var i = b.getClient("height"),
            j = b.getClient("positionY"),
            k = new mono.PathCube(e, this.deep, i, null, this.repeat);
            if (k.setStyle("m.texture.image", this._wallFramePic), k.setPositionY(j || 0), !b.isCutoff()) {
                var l = b.getBlockPicture(),
                m = b.getStyle("vector.outline.width"),
                n = b.getBlockWidth() + m,
                o = b.getBlockHeight(),
                p = b.getBlockDepth(),
                q = h.x - g.x,
                r = h.y - g.y,
                s = b.getAngle(q, -r),
                t = new MaterialDesc,
                u = b.getClient("transparent"),
                v = b.getClient("opacity"),
                w = b.getClient(PropertyConsts.LAYERID);
                t.transparent = !0,
                null == l ? (t.color = "white", t.alpha = 0) : t.texture = l,
                a.getDataById(b.getId()) && a.removeById(b.getId());
                var x = b.getClient(CUSTOM_PROPS),
                y = GeometryTranslater.get3DGeometry(t, "mono.Cube", {
                    x: n,
                    y: o,
                    z: p
                },
                {
                    x: f.x,
                    y: j + (this.floorHeight || 0) + o / 2,
                    z: f.y
                },
                null, null, null, {
                    id: b.getId()
                });
                y.setRotationY(s),
                y.setClient("floorName", this.floorName),
                y.setClient("animation", b.getClient("animation")),
                y.setStyle("m.specularStrength", b.getClient("specularStrength")),
                y.setStyle("m.opacity", 1),
                y.setStyle("m.transparent", !1),
                y.setStyle("front.m.transparent", u),
                y.setStyle("front.m.opacity", v),
                y.setStyle("back.m.transparent", u),
                y.setStyle("back.m.opacity", v),
                y.setStyle("m.polygonOffset", !0),
                y.setStyle("m.polygonOffsetFactor", .1),
                y.setStyle("m.polygonOffsetUnits", 1),
                y.setEditable(!1),
                y.setSelectable(!1),
                y.setWidth(n),
                b.getClient("horizontalFlip") && y.setStyle("back.m.texture.flipX", b.getClient("horizontalFlip")),
                w && y.setClient(PropertyConsts.LAYERID, w),
                Utils.setElementCustomProps(b, y, x),
                a.getDataById(b.getId()) || a.add(y),
                this.setBlockMapPropety(b, y),
                c.push(y)
            }
            return k
        },
        setBlockMapPropety: function(a, b) {
            var c = a.getClient("envmap"),
            d = a.getClient("reflectRatio") || 1,
            e = a.getClient("normalmap"),
            f = a.getClient("normalScale") || {
                x: 1,
                y: 1
            },
            g = a.getClient("normalType"),
            h = a.getClient("specularmap"),
            i = a.getClient("specular"),
            j = a.getClient("lightmap");
            b.s({
                "front.m.envmap.image": c ? [c, c, c, c, c, c] : null,
                "m.reflectRatio": d,
                "front.m.normalmap.image": e,
                "back.m.normalmap.image": e,
                "m.normalScale": new mono.Vec2(f.x, f.y),
                "m.normalType": g,
                "front.m.specularmap.image": h,
                "m.specular": i,
                "m.lightmap.image": j
            })
        },
        isPointOnPoints: function(a) {
            for (var b = this.getPoints(), c = 0; c < b.size(); c++) if (_twaver.math.getDistance(a, b.get(c)) <= 10) return ! 0;
            return ! 1
        },
        getPointIndex: function(a) {
            var b = this.getPoints();
            if (b.size() < 2) return - 1;
            for (var c = 0; c < b.size(); c++) if (_twaver.math.getDistance(a, b.get(c)) <= 10) return - 1;
            for (var d, e = b.get(0), c = 1; c < b.size(); c++) {
                if (d = b.get(c), this.isPointOnLine(a, e, d, 10)) return c - 1;
                e = d
            }
            return e = b.get(0),
            this.isPointOnLine(a, e, d, 10) ? b.size() - 1 : -1
        },
        isPointOnLine: function(a, b, c, d) {
            0 > d && (d = 0);
            var e = this.getDistanceFromPointToLine(a, b, c);
            return d >= e && a.x >= Math.min(b.x, c.x) - d && a.x <= Math.max(b.x, c.x) + d && a.y >= Math.min(b.y, c.y) - d && a.y <= Math.max(b.y, c.y) + d
        },
        getDistanceFromPointToLine: function(a, b, c) {
            if (b.x === c.x) return Math.abs(a.x - b.x);
            var d = (c.y - b.y) / (c.x - b.x),
            e = (c.x * b.y - b.x * c.y) / (c.x - b.x);
            return Math.abs(d * a.x - a.y + e) / Math.sqrt(d * d + 1)
        },
        setOffsetYofPoints: function(a) {
            this.offsetY = a
        },
        setOffsetXofPoints: function(a) {
            this.offsetX = a
        },
        getOffsetYofPoints: function() {
            return this.offsetY
        },
        getOffsetXofPoints: function() {
            return this.offsetX
        },
        setNegatedYInterval: function(a) {
            this.negatedYInterval = a
        },
        getNegatedYInterval: function() {
            return this.negatedYInterval
        }
    }),
    ImageShapeNodeUI = function(a, b) {
        ImageShapeNodeUI.superClass.constructor.apply(this, arguments)
    },
    twaver.Util.ext("ImageShapeNodeUI", twaver.vector.ShapeNodeUI, {
        drawDefaultBody: function(a) {
            var b = this._element;
            if (b._points && !(b._points.size() < 1)) {
                var c = this._getZoomPoints(),
                d = b._segments,
                e = b.getStyle("vector.outline.width"),
                f = b.getStyle("vector.outline.pattern"),
                g = b.getStyle("vector.outline.width"),
                h = b.getStyle("vector.outline.color"),
                i = b.getClient("shapenode.closed"),
                j = twaver.Util.getRect(c),
                k = a;
                e > 0 && twaver.Util.grow(j, e, e);
                var l, m = this._network.isSelected(this._element),
                n = this._element.getClient("resizeBorderWidth"),
                o = this._element.getClient("resizeBorderLength"),
                p = this._element.getClient("resizeBorderGap"),
                q = this._element.getClient("resizeBorderColor"),
                r = b.getClient("showDim"),
                s = b.getClient("showCoord");
                m && (l = _twaver.clone(j)),
                k = this.setShadow(this, k),
                k.beginPath();
                var t = twaver.Util.getImageAsset(b.getClient(IMAGE_SRC));
                t && (k.fillStyle = k.createPattern(t.getImage(), "repeat")),
                k.lineWidth = g,
                k.strokeStyle = h,
                _twaver.g.drawLinePoints(k, c, f, d, i),
                b.getClient("fill") && k.fill(),
                k.stroke();
                var u = b.getClient("focusIndex");
                if (u >= 0) {
                    var v = c.get(u),
                    w = c.get(u === c.size() - 1 ? 0 : u + 1);
                    k.beginPath(),
                    k.strokeStyle = b.getClient("focusColor"),
                    k.moveTo(v.x, v.y),
                    k.lineTo(w.x, w.y),
                    k.stroke()
                }
                if (m) {
                    k.lineWidth = n + 2,
                    k.strokeStyle = "black",
                    k.beginPath(),
                    this._borderLines = [];
                    var x, y, z;
                    x = {
                        x: l.x - p,
                        y: l.y - p
                    },
                    y = {
                        x: x.x,
                        y: x.y + o
                    },
                    z = {
                        x: x.x + o,
                        y: x.y
                    },
                    this._addBorderLine(k, x, y, z),
                    x = {
                        x: l.x + l.width + p,
                        y: l.y - p
                    },
                    y = {
                        x: x.x - o,
                        y: x.y
                    },
                    z = {
                        x: x.x,
                        y: x.y + o
                    },
                    this._addBorderLine(k, x, y, z),
                    x = {
                        x: l.x + l.width + p,
                        y: l.y + l.height + p
                    },
                    y = {
                        x: x.x,
                        y: x.y - o
                    },
                    z = {
                        x: x.x - o,
                        y: x.y
                    },
                    this._addBorderLine(k, x, y, z),
                    x = {
                        x: l.x - p,
                        y: l.y + l.height + p
                    },
                    y = {
                        x: x.x + o,
                        y: x.y
                    },
                    z = {
                        x: x.x,
                        y: x.y - o
                    },
                    this._addBorderLine(k, x, y, z),
                    k.stroke(),
                    k.beginPath(),
                    k.lineWidth = n,
                    k.strokeStyle = q,
                    o -= 1,
                    x = {
                        x: l.x - p,
                        y: l.y - p
                    },
                    y = {
                        x: x.x,
                        y: x.y + o
                    },
                    z = {
                        x: x.x + o,
                        y: x.y
                    },
                    k.moveTo(y.x, y.y),
                    k.lineTo(x.x, x.y),
                    k.lineTo(z.x, z.y),
                    x = {
                        x: l.x + l.width + p,
                        y: l.y - p
                    },
                    y = {
                        x: x.x - o,
                        y: x.y
                    },
                    z = {
                        x: x.x,
                        y: x.y + o
                    },
                    k.moveTo(y.x, y.y),
                    k.lineTo(x.x, x.y),
                    k.lineTo(z.x, z.y),
                    x = {
                        x: l.x + l.width + p,
                        y: l.y + l.height + p
                    },
                    y = {
                        x: x.x,
                        y: x.y - o
                    },
                    z = {
                        x: x.x - o,
                        y: x.y
                    },
                    k.moveTo(y.x, y.y),
                    k.lineTo(x.x, x.y),
                    k.lineTo(z.x, z.y),
                    x = {
                        x: l.x - p,
                        y: l.y + l.height + p
                    },
                    y = {
                        x: x.x + o,
                        y: x.y
                    },
                    z = {
                        x: x.x,
                        y: x.y - o
                    },
                    k.moveTo(y.x, y.y),
                    k.lineTo(x.x, x.y),
                    k.lineTo(z.x, z.y),
                    k.stroke()
                }
                m && (s && this.drawCoord(k), r && this.drawDim(k))
            }
        },
        validateBodyBounds: function() {
            ImageShapeNodeUI.superClass.validateBodyBounds.call(this);
            var a = this._element;
            if (a._points && !(a._points.size() < 1)) {
                var b = this._getZoomPoints();
                if (! (b.size() < 2)) {
                    var c = a.getStyle("vector.outline.width"),
                    d = this.getPathRect("vector", !0);
                    c > 0 && twaver.Util.grow(d, c, c);
                    var e = this._network.isSelected(this._element),
                    f = this._element.getClient("resizeBorderWidth"),
                    g = this._element.getClient("resizeBorderGap");
                    e && twaver.Util.grow(d, (f + g) / this._network.getZoom() * 2 + 2, (f + g) / this._network.getZoom() * 2 + 2),
                    this.addBodyBounds(d)
                }
            }
        },
        _addBorderLine: function(a, b, c, d) {
            this._borderLines.push({
                point1: c,
                point2: b
            }),
            this._borderLines.push({
                point1: b,
                point2: d
            }),
            a.moveTo(c.x, c.y),
            a.lineTo(b.x, b.y),
            a.lineTo(d.x, d.y)
        },
        isPointOnBorderLine: function(a) {
            if (!this._borderLines) return null;
            for (var b = this._element.getClient("resizeBorderWidth"), c = 0; c < this._borderLines.length; c++) {
                var d = this._borderLines[c];
                if (this._element.isPointOnLine(a, d.point1, d.point2, b)) return Math.floor(c / 2)
            }
            return null
        },
        drawDim: function(a) {
            function b(a, b, e) {
                var f = _twaver.math.getCenterPoint(a, b),
                g = angle1 = _twaver.math.getAngle(a, b);
                b.x < a.x && (g = Math.PI + g);
                var h = e.toFixed(2),
                k = d.measureText(h).width,
                l = _twaver.math.createMatrix(g, a.x, a.y),
                n = l.transform({
                    x: a.x,
                    y: a.y - i
                }),
                q = l.transform({
                    x: a.x,
                    y: a.y - i * j
                });
                l = _twaver.math.createMatrix(g, b.x, b.y);
                var r = l.transform({
                    x: b.x,
                    y: b.y - i
                }),
                s = l.transform({
                    x: b.x,
                    y: b.y - i * j
                }),
                t = c.getPointBetween(q, s, .5 - (k / 2 + m) / e),
                u = c.getPointBetween(q, s, .5 + (k / 2 + m) / e),
                v = c.getPointBetween(q, s, o / e);
                l = _twaver.math.createMatrix(g, v.x, v.y);
                var w = l.transform({
                    x: v.x,
                    y: v.y - p
                }),
                x = l.transform({
                    x: v.x,
                    y: v.y + p
                }),
                y = c.getPointBetween(q, s, 1 - o / e);
                l = _twaver.math.createMatrix(g, y.x, y.y);
                var z = l.transform({
                    x: y.x,
                    y: y.y - p
                }),
                A = l.transform({
                    x: y.x,
                    y: y.y + p
                });
                d.beginPath(),
                d.moveTo(a.x, a.y),
                d.lineTo(n.x, n.y),
                d.moveTo(b.x, b.y),
                d.lineTo(r.x, r.y),
                d.moveTo(q.x, q.y),
                d.lineTo(t.x, t.y),
                d.moveTo(u.x, u.y),
                d.lineTo(s.x, s.y),
                d.moveTo(q.x, q.y),
                d.lineTo(w.x, w.y),
                d.moveTo(q.x, q.y),
                d.lineTo(x.x, x.y),
                d.moveTo(s.x, s.y),
                d.lineTo(z.x, z.y),
                d.moveTo(s.x, s.y),
                d.lineTo(A.x, A.y),
                d.stroke(),
                d.save(),
                f = {
                    x: (q.x + s.x) / 2,
                    y: (q.y + s.y) / 2
                },
                d.translate(f.x, f.y),
                d.rotate(angle1),
                d.translate( - f.x, -f.y),
                d.fillText(h, f.x, f.y),
                d.restore()
            }
            var c = this,
            d = a,
            e = this._element,
            f = this._getZoomPoints(),
            g = e.getPoints();
            if (f && !(f.size() < 2) && this._network.isSelected(e)) {
                var h = this.getBodyRect(),
                i = e.getClient("dimLeadLength"),
                j = e.getClient("dimLineOffset"),
                k = e.getClient("dimLineWidth"),
                l = e.getClient("dimColor"),
                m = e.getClient("dimTextGap"),
                n = e.getClient("dimTextFont"),
                o = e.getClient("dimArrowWidth"),
                p = e.getClient("dimArrowHeight"),
                q = {
                    x: h.x - i,
                    y: h.y - i,
                    width: h.width + 2 * i,
                    height: h.height + 2 * i
                };
                this.isClockwise() && (i = -i),
                this.addBodyBounds(q),
                d = this.setShadow(this, d),
                d.strokeStyle = l,
                d.lineWidth = k,
                d.fillStyle = l,
                d.font = n,
                d.textAlign = "center",
                d.textBaseline = "middle";
                for (var r = f.get(0), s = g.get(0), t = 1, u = f.size(); u > t; t++) {
                    var v = f.get(t),
                    w = g.get(t),
                    x = _twaver.math.getDistance(s, w);
                    s = w,
                    b(r, v, x),
                    r = v
                }
                if (u > 2) {
                    var x = _twaver.math.getDistance(s, g.get(0));
                    b(r, f.get(0), x)
                }
            }
        },
        getPointBetween: function(a, b, c) {
            return {
                x: a.x + (b.x - a.x) * c,
                y: a.y + (b.y - a.y) * c
            }
        },
        isClockwise: function(a) {
            var b = this._element,
            a = b.getPoints();
            if (!a || a.size() < 2) return ! 0;
            for (var c = 0,
            d = a.size(), e = 0; d > e; e++) {
                var f = a.get(e),
                g = a.get(e + 1 === d ? 0 : e + 1);
                c += (g.x - f.x) * (g.y + f.y)
            }
            return c > 0
        },
        drawCoord: function(a) {
            var b = a,
            c = this._element,
            d = this._getZoomPoints(),
            e = c.getPoints();
            if (d && e) {
                var f = this.getBodyRect(),
                g = c.getClient("coordTextColor"),
                h = c.getClient("coordTextFont"),
                i = c.getClient("coordTextOffsetX"),
                j = c.getClient("coordTextOffsetY"),
                k = c.getClient("coordTextAlign"),
                l = c.getClient("coordTextBaseline"),
                m = c.getClient("coordTextBackground"),
                n = c.getClient("decimalNumber"),
                o = {
                    x: f.x - 100,
                    y: f.y - 50,
                    width: f.width + 200,
                    height: f.height + 100
                };
                this.addBodyBounds(o),
                b = this.setShadow(this, b),
                b.save(),
                b.font = h;
                for (var p = 0,
                q = d.size(); q > p; p++) {
                    var r = d.get(p),
                    s = e.get(p),
                    t = "(" + (r.x + c.getOffsetXofPoints()).toFixed(n) + ", " + (r.y * (c.getNegatedYInterval() ? -1 : 1) + c.getOffsetYofPoints()).toFixed(n) + ")";
                    s && (t = "(" + (s.x + c.getOffsetXofPoints()).toFixed(n) + ", " + (s.y * (c.getNegatedYInterval() ? -1 : 1) + c.getOffsetYofPoints()).toFixed(n) + ")");
                    var u = _twaver.g.getTextSize(b.font, t);
                    b.fillStyle = m,
                    b.fillRect(r.x - u.width / 2 + i, r.y - u.height / 2 + j, u.width, u.height),
                    b.fillStyle = g,
                    b.textAlign = k,
                    b.textBaseline = l,
                    b.fillText(t, r.x, r.y + j)
                }
                b.restore()
            }
        }
    }),
    InnerWallShapeNode = function() {
        InnerWallShapeNode.superClass.constructor.apply(this, arguments),
        this.setClient(IMAGE_SRC, Utils.Path + "room.png"),
        this.setStyle("vector.outline.color", "#333333"),
        this.setStyle("vector.outline.width", 5),
        this.setClient("shapenode.closed", !1),
        this.setClient("focusColor", "green"),
        this.setClient("resizeBorderWidth", 10),
        this.setClient("resizeBorderLength", 25),
        this.setClient("resizeBorderGap", 10),
        this.setClient("resizeBorderColor", "yellow"),
        this.setClient("size", {
            x: 0,
            y: 230,
            z: 4
        }),
        this.setClient("repeat", {
            row: 1,
            column: 1
        })
    },
    twaver.Util.ext("InnerWallShapeNode", ImageShapeNode, {
        translate3d: function(a, b, c) {
            var d = this.getPoints(),
            e = d.size();
            if (! (0 >= e)) {
                for (var f = 0; e > f; f++) this.setStyle("inner_wall_" + f, !0);
                return ImageShapeNode.prototype.translate3d.call(this, a, b, c)
            }
        }
    }),
    FloorShapeNode = function() {
        FloorShapeNode.superClass.constructor.apply(this, arguments),
        this.setClient(IMAGE_SRC, Utils.Path + "floor02_3d.png"),
        this.setStyle("vector.outline.color", "#FFFFFF"),
        this.setStyle("vector.outline.width", 0),
        this.setClient("shapenode.closed", !0),
        this.setClient("focusColor", "blue"),
        this.setClient("repeat", 100),
        this.setClient("size", {
            x: 0,
            y: 0,
            z: .1
        }),
        this.setClient("transparent", !1),
        this.setClient("opacity", 1)
    },
    twaver.Util.ext("FloorShapeNode", ImageShapeNode, {
        translate3d: function(a, b, c) {
            var d = this.getPoints(),
            e = d.size(),
            f = this.getCenterLocation(),
            g = new twaver.List;
            if (d.forEach(function(a) {
                g.add({
                    x: a.x - f.x,
                    y: a.y - f.y
                })
            }), !(0 >= e || 2 >= e)) {
                for (var h = this.getClient("floorHeight"), i = this.getClient("floorName"), j = this.getClient("transparent"), k = this.getClient("opacity"), l = Utils.handlerTexture("" === this.getClient(IMAGE_SRC) ? null: this.getClient(IMAGE_SRC)), m = this.getClient("repeat"), n = this.getClient(CUSTOM_PROPS), o = this.getClient(PropertyConsts.LAYERID), p = new mono.Path, q = 0; e > q; q++) {
                    var r = g.get(q);
                    0 == q ? p.moveTo(r.x, -r.y, 0) : p.lineTo(r.x, -r.y, 0)
                }
                var s = .1,
                e = this.getClient("size");
                e && (s = e.z),
                s = parseFloat(s || 1);
                var t = a.getDataById(this.getId());
                if (!t) var t = new mono.ShapeNode({
                    id: this.getId(),
                    path: p
                });
                return h = (h || 0) - 1,
                t.setPath(p),
                t.setPositionX(f.x),
                t.setPositionZ(f.y),
                t.setAmount(s),
                t.setVertical(!0),
                t.setRepeat(m),
                t.setStyle("m.texture.image", l),
                t.setStyle("m.type", "phong"),
                t.setStyle("m.transparent", j),
                t.setStyle("m.opacity", k),
                t.setClient("floorName", i),
                t.setPositionY(h),
                t.setSelectable(!1),
                Utils.setElementCustomProps(this, t, n),
                o && t.setClient(PropertyConsts.LAYERID, o),
                a.getDataById(this.getId()) || a.add(t),
                t
            }
        }
    }),
    mono.Floor = function(a) {
        this.material = new mono.EntityMaterial,
        this.materialSize = 1,
        mono.BufferNode.call(this),
        this.points = a._as ? a._as: a,
        this.points = c(this.points),
        this.compuateBufferData(),
        this.renderDepth = 1e3
    },
    mono.extend(mono.Floor, mono.BufferNode, {
        constructor: mono.Floor,
        fixCenter: function() {
            var a = new Array;
            if (this.points) {
                for (var b = 0,
                c = 0,
                d = 0; d < this.points.length; d++) {
                    var e = this.points[d];
                    b += e.x,
                    c += e.y
                }
                b /= this.points.length,
                c /= this.points.length;
                for (var d = 0; d < this.points.length; d++) {
                    var e = this.points[d];
                    a.push({
                        x: e.x - b,
                        y: e.y - c
                    })
                }
                this.points = a,
                this.setPosition(new mono.Vec3(e.x, 0, e.y))
            }
        },
        compuateBufferData: function() {
            for (var a = {},
            b = 0,
            c = 0,
            d = 0,
            e = 0,
            f = 0,
            c = 0; c < this.points.length; c++) {
                var g = this.points[c];
                d += 3 * g.length,
                e += 3 * (g.length - 2),
                f += 2 * g.length
            }
            var h = new Float32Array(d);
            for (a.array = h, a.itemSize = 3, a.numItems = d, this.attributes.position = a, c = 0; c < this.points.length; c++) for (var g = this.points[c], i = 0; i < g.length; i++) {
                var j = g[i],
                k = j.length ? j[0] : j.x,
                l = j.length ? j[1] : j.y;
                h[b] = k,
                h[b + 1] = 0,
                h[b + 2] = l,
                b += 3
            }
            this.offsets = [{
                index: 0,
                count: e
            }];
            var m = {};
            m.array = new Uint16Array(e),
            this.attributes.index = m,
            b = 0;
            var n = 0;
            for (c = 0; c < this.points.length; c++) {
                for (var g = this.points[c], i = 0; i < g.length - 2; i++) m.array[b] = n,
                m.array[b + 1] = n + i + 1,
                m.array[b + 2] = n + i + 2,
                b += 3;
                n += g.length
            }
            var o = {};
            o.itemSize = 2,
            o.numItems = f,
            o.array = new Float32Array(f),
            this.attributes.uv = o;
            var p = this.getRect();
            for (b = 0, c = 0; c < this.points.length; c++) for (var g = this.points[c], i = 0; i < g.length; i++) {
                var j = g[i],
                k = j.length ? j[0] : j.x,
                q = j.length ? j[1] : j.y,
                r = (k - p.x) / p.width,
                s = (q - p.y) / p.height;
                o.array[b] = r,
                o.array[b + 1] = s,
                b += 2
            }
            this.verticesNeedUpdate = !0,
            this.elementsNeedUpdate = !0,
            this.uvsNeedUpdate = !0
        },
        getRect: function() {
            for (var a = null,
            b = 0; b < this.points.length; b++) {
                var c = this.points[b];
                if (null === a) a = this.getPointsRect(c);
                else {
                    var d = this.getPointsRect(c);
                    a = this.unionRect(a, d)
                }
            }
            return a
        },
        unionRect: function(a, b) {
            if (a && b) {
                var c = {};
                return c.x = Math.min(a.x, b.x),
                c.y = Math.min(a.y, b.y),
                c.width = Math.max(a.x + a.width, b.x + b.width) - c.x,
                c.height = Math.max(a.y + a.height, b.y + b.height) - c.y,
                c
            }
            return null
        },
        getPointsRect: function(a) {
            if (!a) return null;
            a._as && (a = a._as);
            var b = a.length;
            if (0 >= b) return null;
            for (var c = a[0], d = c.length ? c[0] : c.x, e = c.length ? c[1] : c.y, f = {
                x: d,
                y: e,
                width: 0,
                height: 0
            },
            g = 1; b > g; g++) {
                c = a[g];
                var d = c.length ? c[0] : c.x,
                e = c.length ? c[1] : c.y,
                h = Math.min(f.x, d),
                i = Math.max(f.x + f.width, d),
                j = Math.min(f.y, e),
                k = Math.max(f.y + f.height, e);
                f.x = h,
                f.y = j,
                f.width = i - h,
                f.height = k - j
            }
            return f
        }
    }),
    PrimitiveNode = function() {
        PrimitiveNode.superClass.constructor.apply(this, arguments),
        this.setClient("oscale", 100),
        this.setClient("scaleFont", "18px Verdana"),
        this.setClient("scaleColor", "black"),
        this.setClient("maskColor", "white"),
        this.setClient("maskAlpha", .5),
        this.setClient("tipsFont", "12px Calibri"),
        this.setClient("tips", "Scroll to Scale"),
        this.setClient("selectedColor", "yellow"),
        this.setStyle("label.position", "center"),
        this.setStyle("select.style", "null"),
        this.setClient("vertical", !0),
        this.setImage("primitiveNode_Image")
    },
    twaver.Util.ext("PrimitiveNode", twaver.Follower, {
        translate3d: function(a, b) {
            var c = this.getClient("scale"),
            d = this.getClient("oscale"),
            e = this.getClient("size"),
            f = this.getClient("assembleSize"),
            g = this.getClient("rot"),
            h = this.getClient("texture"),
            i = this.getClient("className"),
            j = this.getClient("transparent"),
            k = this.getClient("opacity"),
            l = null,
            m = this.getClient(CUSTOM_PROPS),
            n = this.getClient("vertical"),
            o = this.getClient(PropertyConsts.LAYERID);
            l = h ? h instanceof Array ? h: h instanceof twaver.List ? h.toArray() : h.indexOf(Utils.Path) >= 0 ? h: Utils.Path + h: Utils.Path + PropertyConsts.DEFAULT_IMAGE,
            this.setClient(IMAGE_SRC, l);
            var p = this.getClient("repeat"),
            q = this.getClient("types"),
            r = this.getClient("colors"),
            s = this.getClient("visible"),
            t = this.getClient("other"),
            u = this.getClient("positionY"),
            v = this.getClient("floorHeight"),
            w = this.getClient("flipX"),
            x = this.getClient("flipY"),
            y = this.getClient("envmap"),
            z = this.getClient("reflectRatio"),
            A = this.getClient("normalmap"),
            B = this.getClient("normalScale"),
            C = this.getClient("normalType"),
            D = this.getClient("specularmap"),
            E = this.getClient("specular"),
            F = this.getClient("lightmap"),
            G = {
                repeat: p,
                types: q,
                color: r,
                transparent: j,
                opacity: k,
                visible: s,
                flipX: w,
                flipY: x,
                envmap: y,
                reflectRatio: z,
                normalmap: A,
                normalScale: B,
                normalType: C,
                specularmap: D,
                specular: E,
                lightmap: F
            },
            H = new MaterialDesc;
            l instanceof Array && (H.tType = l.length),
            H.texture = l;
            for (var I in G) {
                var J = G[I];
                this.setArrayStyleValue(I, J, H)
            }
            t && Utils.isNotNull(t.openTop) && (H.openTop = t.openTop),
            t && Utils.isNotNull(t.openBottom) && (H.openBottom = t.openBottom),
            H.color = this.getClient("colors"),
            H.ambient = this.getClient("ambient"),
            t = t || {},
            e = e || f,
            t.id = this.getId();
            var K = this.get3DShape(H, i, e, t, a);
            if (K.setName(this.getClient("primitiveName")), K) {
                Utils.setElementCustomProps(this, K, m),
                o && K.setClient(PropertyConsts.LAYERID, o);
                var L = this.getClient(OID);
                L && K.setClient(OID, L);
                var M = this.getClient(BID);
                M && K.setClient(BID, M),
                g && K.setRotation(g.x, g.y, g.z),
                Utils.isNotNull(this.getAngle()) && 0 != this.getAngle() && (isSettingRotation = !0, K.setRotation(0, 0, 0), isSettingRotation = !1, K.rotateFromWorldYAxis(Utils.convert2Radian( - this.getAngle())));
                var N = this.getCenterLocation();
                if (null == this.getHost() || this.getHost() instanceof FloorShapeNode) {
                    if (N) {
                        K.setPositionX(N.x),
                        f ? K.setPositionY(f.y / 2) : K.setPositionY(0),
                        K.setPositionZ(N.y);
                        var O = this.getClient("off");
                        O && (K.setPositionX(N.x - O.x), K.setPositionZ(N.y - O.z))
                    }
                } else if (N) {
                    var P = this.getClient("position");
                    P && K.setPosition(P.x, P.y, P.z)
                }
                var c = this.getClient("scale");
                c || (c = new mono.Vec3(1, 1, 1)),
                c && (d && (d /= 100, c = new mono.Vec3(c.x * d, c.y * d, c.z * d), K.setPositionY(K.getPosition().y * d)), K.setScale(c)),
                void 0 !== n && K.setStyle("m.vertical", n),
                u = u ? u: 0,
                K.setPositionY(K.getPosition().y + u),
                v && K.setPositionY(K.getPosition().y + v),
                K.setEditable(!0),
                K.setSelectable(!0);
                var Q = this.getClient(TAG_ANIMATION);
                Q && K.setClient(TAG_ANIMATION, Q);
                var R = this.getClient("animationGroup");
                R && K.setClient("animationGroup", R);
                var S = this.getClient("mainVisible");
                Utils.isNotNull(S) && (K.setClient("mainVisible", S), K.setStyle("m.transparent", !0), K.setStyle("m.opacity", .001)),
                K.setClient("floorName", this.getClient("floorName")),
                K.setGroupId(this.getClient("groupid")),
                K.setClient("nodeId", this.getId()),
                this.getClient("isEntity") && K.setClient("isEntity", !0);
                var T = parseFloat(this.getClient("scaleValue"));
                if (T) if (K instanceof mono.Billboard) {
                    K.setPositionX(parseFloat(K.getPositionX() * T)),
                    K.setPositionY(parseFloat(K.getPositionY() * T)),
                    K.setPositionZ(parseFloat(K.getPositionZ() * T));
                    var c = K.getScale();
                    K.setScale(parseFloat(c.x * T), parseFloat(c.y * T), parseFloat(c.z * T))
                } else if (K instanceof mono.Cube) {
                    var U = K.getWidth(),
                    V = K.getHeight(),
                    W = K.getDepth();
                    K.setWidth(U * T),
                    K.setHeight(V * T),
                    K.setDepth(W * T),
                    this.getParent() && (K.setPositionX(parseFloat(K.getPositionX() * T)), K.setPositionY(parseFloat(K.getPositionY() * T)), K.setPositionZ(parseFloat(K.getPositionZ() * T)))
                } else {
                    K.setPositionX(parseFloat(K.getPositionX() * T)),
                    K.setPositionY(parseFloat(K.getPositionY() * T)),
                    K.setPositionZ(parseFloat(K.getPositionZ() * T));
                    var c = K.getScale();
                    K.setScale(parseFloat(c.x * T), parseFloat(c.y * T), parseFloat(c.z * T))
                }
                if (K instanceof mono.PointLight) {
                    if (this.getClient("lightPosition")) {
                        var X = this.getClient("lightPosition").split(",");
                        3 === X.length && K.setPosition(new mono.Vec3(parseFloat(X[0]), parseFloat(X[1]), parseFloat(X[2])))
                    }
                    this.getClient("lightColor") && K.setColor(this.getClient("lightColor")),
                    this.getClient("lightIntensity") && K.setIntensity(parseFloat(this.getClient("lightIntensity")))
                }
                if (K instanceof mono.SpotLight) {
                    if (this.getClient("lightPosition")) {
                        var X = this.getClient("lightPosition").split(",");
                        3 === X.length && K.setPosition(new mono.Vec3(parseFloat(X[0]), parseFloat(X[1]), parseFloat(X[2])))
                    } else K.setPositionY(100);
                    this.getClient("lightColor") && K.setColor(this.getClient("lightColor")),
                    this.getClient("lightIntensity") && K.setIntensity(parseFloat(this.getClient("lightIntensity"))),
                    this.getClient("angle") && K.setAngle(parseFloat(this.getClient("angle")))
                }
                return this.afterTranslate3d(K),
                K
            }
        },
        setArrayStyleValue: function(a, b, c) {
            b && (b instanceof twaver.List && (b = b.toArray()), (b instanceof Array && b.length > 0 || !b instanceof Array) && (c[a] = b))
        },
        afterTranslate3d: function(a) {
            mono.AniUtil.resetAnimatedFlag(a)
        },
        get3DShape: function(a, b, c, d, e) {
            var f = $gt3d(a, b, c, null, null, null, null, d, this, e);
            return f.setSelectable(!0),
            f
        },
        getVectorUIClass: function() {
            return PrimitiveNodeUI
        }
    }),
    PrimitiveNodeUI = function(a, b) {
        PrimitiveNodeUI.superClass.constructor.apply(this, arguments)
    },
    twaver.Util.ext("PrimitiveNodeUI", twaver.vector.NodeUI, {
        validateBodyBounds: function() {
            PrimitiveNodeUI.superClass.validateBodyBounds.call(this);
            var a = this.getBodyRect();
            0 != this._element.getAngle() && (a = this._element.getOriginalRect()),
            this.addBodyBounds(a)
        }
    }),
    twaver.Util.registerShape("triangle",
    function(a, b, c, d) {
        var e = c.getOriginalRect(),
        f = e.width,
        g = e.height;
        f > 12 / d.getZoom() && (f -= 12 / d.getZoom()),
        g > 12 / d.getZoom() && (g -= 12 / d.getZoom()),
        a.moveTo( - f / 2, g / 2),
        a.lineTo(f / 2, g / 2),
        a.lineTo(0, 0),
        a.lineTo( - f / 2, g / 2),
        a.closePath()
    }),
    twaver.Util.registerShape("small_triangle",
    function(a, b, c, d) {
        if (c.getHost()) {
            var e = c.getOriginalRect(),
            f = 8 / d.getZoom();
            f > e.width && (f = e.width),
            f > e.height && (f = e.height),
            e.height / 2 < f && (f = 0),
            a.moveTo(0, 0),
            a.lineTo(0, f)
        }
    }),
    twaver.Util.registerImage("primitiveNode_Image", {
        v: [{
            shape: "rect",
            fill: function(a) {
                var b = network.isSelected(a),
                c = a.getClient("maskColor");
                return b && (c = a.getClient("selectedColor")),
                c
            },
            alpha: '<%=getClient("maskAlpha")%>',
            rect: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 12 / network.getZoom() && (c -= 12 / network.getZoom()),
                d > 12 / network.getZoom() && (d -= 12 / network.getZoom()),
                [ - c / 2, -d / 2, c, d]
            }
        },
        {
            shape: "rect",
            alpha: 1,
            lineColor: "#927652",
            lineWidth: 6,
            rect: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 6 / network.getZoom() && (c -= 6 / network.getZoom()),
                d > 6 / network.getZoom() && (d -= 6 / network.getZoom()),
                [ - c / 2, -d / 2, c, d]
            }
        },
        {
            shape: "line",
            fill: "gray",
            lineWidth: 1,
            p1: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 12 / network.getZoom() ? c -= 12 / network.getZoom() : c = 0,
                d > 12 / network.getZoom() ? d -= 12 / network.getZoom() : d = 0,
                {
                    x: -c / 2,
                    y: -d / 2
                }
            },
            p2: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 12 / network.getZoom() ? c -= 12 / network.getZoom() : c = 0,
                d > 12 / network.getZoom() ? d -= 12 / network.getZoom() : d = 0,
                {
                    x: c / 2,
                    y: d / 2
                }
            }
        },
        {
            shape: "line",
            fill: "gray",
            lineWidth: 1,
            p1: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 12 / network.getZoom() ? c -= 12 / network.getZoom() : c = 0,
                d > 12 / network.getZoom() ? d -= 12 / network.getZoom() : d = 0,
                {
                    x: -c / 2,
                    y: d / 2
                }
            },
            p2: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 12 / network.getZoom() ? c -= 12 / network.getZoom() : c = 0,
                d > 12 / network.getZoom() ? d -= 12 / network.getZoom() : d = 0,
                {
                    x: c / 2,
                    y: -d / 2
                }
            }
        },
        {
            shape: "triangle",
            fill: "#927652",
            data: {
                w: 90,
                h: 90
            },
            alpha: .4
        },
        {
            shape: "small_triangle",
            position: 0,
            lineWidth: 8,
            lineColor: "#927652",
            translate: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 17 / network.getZoom() ? c -= 17 / network.getZoom() : c = 0,
                d -= 11 / network.getZoom(),
                {
                    x: -c / 2,
                    y: -d / 2
                }
            }
        },
        {
            shape: "small_triangle",
            position: 1,
            lineWidth: 8,
            lineColor: "#927652",
            translate: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 17 / network.getZoom() ? c -= 17 / network.getZoom() : c = 0,
                d -= 11 / network.getZoom(),
                {
                    x: c / 2,
                    y: -d / 2
                }
            }
        },
        {
            shape: "small_triangle",
            position: 0,
            lineWidth: 8,
            lineColor: "#927652",
            translate: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 17 / network.getZoom() ? c -= 17 / network.getZoom() : c = 0,
                d -= 25 / network.getZoom(),
                {
                    x: -c / 2,
                    y: d / 2
                }
            }
        },
        {
            shape: "small_triangle",
            position: 1,
            lineWidth: 8,
            lineColor: "#927652",
            translate: function(a) {
                var b = a.getOriginalRect(),
                c = b.width,
                d = b.height;
                return c > 17 / network.getZoom() ? c -= 17 / network.getZoom() : c = 0,
                d -= 25 / network.getZoom(),
                {
                    x: c / 2,
                    y: d / 2
                }
            }
        }]
    }),
    Block = function() {
        Block.superClass.constructor.apply(this, arguments),
        this.setClient("length", 90),
        this.setClient("edgeIndex", -1),
        this.setClient("offset", .5),
        this.setClient("gap", 0),
        this.setClient("angle", 0),
        this.setClient("focus", !1),
        this.setStyle("vector.outline.width", 2),
        this.setStyle("vector.outline.color", "gray"),
        this.setStyle("vector.fill.color", "white"),
        this.setSize(0, 0),
        this.setClient("fullWidth", !1),
        this.setClient("horizontalFlip", !1),
        this.setImage("image_block"),
        this.isDoor() && (this.blockPicture = this.blockPicture || Utils.Path + "door00_3d.png", this.blockWidth = this.blockWidth || 80, this.blockHeight = this.blockHeight || 200, this.blockDepth = this.blockDepth || 10, this.positionY = this.positionY || 0, this.setClient("depth", this.blockDepth)),
        this.isWindow() && (this.blockPicture = this.blockPicture || Utils.Path + "window00_3d.png", this.blockWidth = this.blockWidth || 100, this.blockHeight = this.blockHeight || 120, this.blockDepth = this.blockDepth || 10, this.positionY = this.positionY || (this.height - this.blockHeight) / 2, this.setClient("depth", this.blockDepth));
        var a = this.getClient("transparent"),
        b = this.getClient("opacity");
        this.setStyle("m.transparent", a),
        this.setStyle("m.opacity", b),
        this.isCutoff() && (this.blockWidth = this.blockWidth || 100, this.blockHeight = this.blockHeight || 100, this.positionY = this.positionY || (this.height - this.blockHeight) / 2, this.blockPicture || (this.blockPicture = new mono.BasicMaterial({
            color: "green",
            transparent: !0,
            opacity: .5
        }))),
        this.setClient("height", this.blockHeight),
        this.setClient("positionY", this.positionY)
    },
    twaver.Util.ext("Block", twaver.Node, {
        onPropertyChanged: function(a) {
            Block.superClass.onPropertyChanged.call(this, a),
            !this.getParent() || "C:length" !== a.property && "C:edgeIndex" !== a.property && "C:offset" !== a.property && "C:gap" !== a.property || this.refresh()
        },
        refresh: function() {
            var a = this.getParent(),
            b = this.getClient("edgeIndex"),
            c = this.getClient("offset"),
            d = a.getPoints();
            if (d && b >= 0 && b < d.size()) {
                var e = d.get(b),
                f = d.get(b === d.size() - 1 ? 0 : b + 1),
                g = f.x - e.x,
                h = f.y - e.y,
                i = {
                    x: e.x + g * c,
                    y: e.y + h * c
                },
                j = this.getAngle(g, h),
                k = this.getStyle("vector.outline.width"),
                l = this.getClient("gap"),
                m = this.getClient("length") / 2 + k / 2,
                n = a.getStyle("vector.outline.width") / 2 + k / 2 + l,
                o = twaver.Util.getRect([twaver.Util.transformPoint(i, j, -m, -n).point, twaver.Util.transformPoint(i, j, m, -n).point, twaver.Util.transformPoint(i, j, m, n).point, twaver.Util.transformPoint(i, j, -m, n).point]);
                this.setSize(o.width, o.height),
                this.setCenterLocation(i),
                this.setClient("angle", j),
                this.setClient("leftPoint", twaver.Util.transformPoint(i, j, -m, 0).point),
                this.setClient("rightPoint", twaver.Util.transformPoint(i, j, m, 0).point)
            }
        },
        getAngle: function(a, b) {
            return 0 === a ? 0 === b ? 0 : b > 0 ? Math.PI / 2 : -Math.PI / 2 : Math.atan(b / a)
        },
        getEdgeIndex: function() {
            return this.getClient("edgeIndex")
        },
        isDoor: function() {
            return this instanceof Door
        },
        isWindow: function() {
            return this instanceof Window
        },
        isCutoff: function() {
            return this instanceof Cutoff
        },
        getBlockWidth: function() {
            return Math.abs(this.getClient("length"))
        },
        getBlockHeight: function() {
            return Math.abs(this.getClient("height"))
        },
        getBlockDepth: function() {
            return Math.abs(this.getClient("depth"))
        },
        getBlockPicture: function() {
            return this.getClient("picture")
        },
        getBlockPositionY: function() {
            return Math.abs(this.getClient("positionY"))
        }
    }),
    Door = function() {
        Door.superClass.constructor.apply(this, arguments),
        this.setClient("positionY", 0)
    },
    twaver.Util.ext("Door", Block, {}),
    Window = function() {
        Window.superClass.constructor.apply(this, arguments),
        this.setClient("positionY", 100)
    },
    twaver.Util.ext("Window", Block, {}),
    Cutoff = function() {
        Cutoff.superClass.constructor.apply(this, arguments),
        this.setClient("positionY", 100)
    },
    twaver.Util.ext("Cutoff", Block, {}),
    twaver.Util.registerImage("image_block", {
        rotate: '<%=getClient("angle")*180/Math.PI%>',
        diameter: function(a) {
            var b = 10,
            c = a.getParent();
            return c && (b = c.getStyle("vector.outline.width") + 2 * a.getClient("gap")),
            b / network.getZoom()
        },
        v: [{
            shape: "rect",
            rect: function(a) {
                var b = a.getClient("length");
                b && (b = Math.abs(b));
                var c = a.getParent(),
                d = 10;
                c && (d = c.getStyle("vector.outline.width") + 2 * a.getClient("gap"));
                var e = this.diameter(a);
                return b > e && (b -= e),
                d /= network.getZoom(),
                [ - b / 2, -d / 2, b, d]
            },
            lineWidth: '<%=getStyle("vector.outline.width")%>',
            lineColor: '<%if(getClient("focus")){return "green"}else{return getStyle("vector.outline.color")}%>',
            fill: '<%=getStyle("vector.fill.color")%>'
        },
        {
            shape: "line",
            x1: function(a) {
                if (a instanceof Window || a instanceof Door) {
                    var b = a.getClient("length");
                    b && (b = Math.abs(b));
                    var c = this.diameter(a);
                    return b > c && (b -= c),
                    -b / 2
                }
                return 0
            },
            y1: 0,
            x2: function(a) {
                if (a instanceof Window || a instanceof Door) {
                    var b = a.getClient("length");
                    b && (b = Math.abs(b));
                    var c = this.diameter(a);
                    return b > c && (b -= c),
                    b / 2
                }
                return 0
            },
            y2: 0,
            lineWidth: 1,
            lineColor: '<%if(getClient("focus")){return "green"}else{return getStyle("vector.outline.color")}%>',
            lineDash: function(a) {
                return a instanceof Window ? [10, 2] : void 0
            }
        },
        {
            shape: "circle",
            cx: function(a) {
                var b = a.getClient("length");
                b && (b = Math.abs(b));
                var c = this.diameter(a);
                return b > c && (b -= c),
                -b / 2
            },
            cy: 0,
            r: function(a) {
                if (null == network || !network.getSelectionModel().contains(a)) return 0;
                var b = a.getParent(),
                c = 10;
                return b && (c = b.getStyle("vector.outline.width") + 2 * a.getClient("gap")),
                c /= network.getZoom(),
                c / 2
            },
            lineWidth: 1,
            fill: "yellow",
            stroke: "black"
        },
        {
            shape: "circle",
            cx: function(a) {
                var b = a.getClient("length");
                b && (b = Math.abs(b));
                var c = this.diameter(a);
                return b > c && (b -= c),
                b / 2
            },
            cy: 0,
            r: function(a) {
                if (null == network || !network.getSelectionModel().contains(a)) return 0;
                var b = a.getParent(),
                c = 10;
                return b && (c = b.getStyle("vector.outline.width") + 2 * a.getClient("gap")),
                c /= network.getZoom(),
                c / 2
            },
            lineWidth: 1,
            fill: "yellow",
            stroke: "black"
        }]
    }),
    PipeShapeNode = function() {
        PipeShapeNode.superClass.constructor.apply(this, arguments),
        this.setClient(IMAGE_SRC, Utils.Path + "default_texture.png"),
        this.setStyle("vector.outline.color", "red"),
        this.setStyle("vector.outline.width", 5),
        this.setClient("shapenode.closed", !0),
        this.setClient("focusColor", "blue"),
        this.setClient("shapenode.closed", !1),
        this.setClient("fill", !1),
        this.setClient("radius", 10),
        this.setClient("segments", 20),
        this.setClient("positionY", 100),
        this.setClient("startCap", "none"),
        this.setClient("endCap", "none"),
        this.setClient("startCapSize", "1"),
        this.setClient("endCapSize", "1"),
        this.setClient("repeat", {
            row: 100,
            column: 3
        }),
        this.setClient("pointPositions", {}),
        this.setClient("adjust", !1),
        this.setClient("adjust.degree", 10),
        this.setClient("transparent", !1),
        this.setClient("opacity", 1)
    },
    twaver.Util.ext("PipeShapeNode", ImageShapeNode, {
        getPointPositionY: function(a) {
            var b = this.getClient("floorHeight") || 0,
            c = "" + a,
            d = this.getClient("pointPositions")[c];
            return d ? parseInt(d + b) : parseInt(this.getClient("positionY") + b)
        },
        translate3d: function(a, b, c) {
            var d = this.getClient("floorName"),
            e = this.getPoints(),
            f = this.getClient("startCap"),
            g = this.getClient("endCap"),
            h = this.getClient("startCapSize"),
            i = this.getClient("endCapSize"),
            j = this.getClient("transparent"),
            k = this.getClient("opacity"),
            l = this.getClient(CUSTOM_PROPS),
            m = this.getClient(PropertyConsts.LAYERID),
            n = new mono.Path;
            if (e && e.size() > 1) {
                n.moveTo(e.get(0).x, this.getPointPositionY(0), e.get(0).y);
                for (var o = 1; o < e.size(); o++) n.lineTo(e.get(o).x, this.getPointPositionY(o), e.get(o).y)
            }
            var p = parseInt(this.getClient("radius"));
            n = this.adjustPath(n);
            var q = parseInt(this.getClient("segments")),
            r = a.getDataById(this.getId());
            r || (r = new mono.PathNode({
                id: this.getId()
            })),
            r.setPath(n),
            r.setSegments(q),
            r.setRadius(p),
            r.setSegmentsR(50),
            r.setStartCap(f),
            r.setEndCap(g),
            r.setStartCapSize(h),
            r.setEndCapSize(i);
            var s = "" === this.getClient(IMAGE_SRC) ? null: this.getClient(IMAGE_SRC),
            t = this.getClient("repeat");
            return t || (t = {
                row: 100,
                column: 3
            }),
            r.setStyle("m.texture.image", s),
            r.setStyle("m.texture.wrapS", mono.RepeatWrapping),
            r.setStyle("m.texture.wrapT", mono.RepeatWrapping),
            r.setStyle("m.texture.repeat", new mono.Vec2(t.row, t.column)),
            r.setStyle("m.side", mono.DoubleSide),
            r.setStyle("m.type", "phong"),
            r.setStyle("m.transparent", j),
            r.setStyle("m.opacity", k),
            r.setEditable(!1),
            r.setSelectable(!1),
            r.setClient("floorName", d),
            Utils.setElementCustomProps(this, r, l),
            m && r.setClient(PropertyConsts.LAYERID, m),
            a.getDataById(this.getId()) || a.add(r),
            r
        },
        adjustPath: function(a) {
            if (this.getClient("adjust")) {
                var b = this.getClient("adjust.degree") || 10,
                c = parseInt(this.getClient("radius"));
                return mono.PathNode.prototype.adjustPath(a, c, b)
            }
            return a
        }
    }),
    RoundPipeShapeNode = function() {
        RoundPipeShapeNode.superClass.constructor.apply(this, arguments),
        this.setClient("adjust", !0),
        this.setStyle("vector.outline.color", "green")
    },
    twaver.Util.ext("RoundPipeShapeNode", PipeShapeNode, {}),
    function() {
        abc = {},
        modelnode = {},
        modelimp = {},
        interaction = {},
        gadgets = {},
        modellib = {},
        editnodes = {},
        DEFAULT_THUMBNAIL = "crash.png",
        MaterialDesc = function() {
            this.type = "phong",
            this.sides = mono.DoubleSide,
            this.repeat = null,
            this.tType = 6,
            this.wraps = mono.RepeatWrapping,
            this.wrapt = mono.RepeatWrapping,
            this.transparent = !1,
            this.opacity = null,
            this.texture = []
        },
        twaver.Util.ext("MaterialDesc", Object, {
            wrap3DStyle: function(a) {
                var b = {};
                if (this.texture = Utils.handlerTexture(this.texture), this.texture && (b[M_MAP_SRC] = this.texture), this.type || (this.type = "phong"), this.repeat) if (2 != this.repeat.length || this.repeat[0] instanceof Array) {
                    if (this.repeat instanceof Array) {
                        var c = [];
                        for (var d in this.repeat) c.push(new mono.Vec2(this.repeat[d][0], this.repeat[d][1]));
                        this.repeat = c
                    }
                } else this.repeat = new mono.Vec2(this.repeat[0], this.repeat[1]);
                else this.repeat = new mono.Vec2(1, 1);
                b[M_MAP_REPEAT] = this.repeat,
                this.type && (b[M_TYPE] = this.type),
                this.transparent instanceof Array ? b[M_TRANSPARENT] = this.transparent: void 0 != this.transparent && (b[M_TRANSPARENT] = this.transparent),
                this.opacity instanceof Array ? b[M_OPACITY] = this.opacity: void 0 != this.opacity ? b[M_OPACITY] = this.opacity: b[M_OPACITY] = 1,
                this.visible instanceof Array ? b[M_VISIBLE] = this.visible: !1 === this.visible ? b[M_VISIBLE] = !1 : b[M_VISIBLE] = !0,
                this.flipX instanceof Array ? b[M_TEXTURE_FLIPX] = this.flipX: !0 === this.flipX ? b[M_TEXTURE_FLIPX] = !0 : b[M_TEXTURE_FLIPX] = !1,
                this.flipY instanceof Array ? b[M_TEXTURE_FLIPY] = this.flipY: !0 === this.flipY ? b[M_TEXTURE_FLIPY] = !0 : b[M_TEXTURE_FLIPY] = !1,
                this.specularStrength instanceof Array ? b[M_SPECULARSTRENGTH] = this.specularStrength: void 0 != this.specularStrength && (b[M_SPECULARSTRENGTH] = this.specularStrength),
                this.polygonOffset instanceof Array ? b[M_POLYGONOFFSET] = this.polygonOffset: !0 === this.polygonOffset ? b[M_POLYGONOFFSET] = !0 : b[M_POLYGONOFFSET] = !1,
                this.polygonOffsetFactor instanceof Array ? b[M_POLYGONOFFSETFACTOR] = this.polygonOffsetFactor: void 0 != this.polygonOffsetFactor && (b[M_POLYGONOFFSETFACTOR] = this.polygonOffsetFactor),
                this.polygonOffsetUnits instanceof Array ? b[M_POLYGONOFFSETUNITS] = this.polygonOffsetUnits: void 0 != this.polygonOffsetUnits && (b[M_POLYGONOFFSETUNITS] = this.polygonOffsetUnits),
                this.envmap instanceof Array ? b["m.envmap.image"] = this.envmap: void 0 != this.envmap && (b["m.envmap.image"] = this.envmap),
                this.reflectRatio instanceof Array ? b["m.reflectRatio"] = this.reflectRatio: void 0 != this.reflectRatio && (b["m.reflectRatio"] = this.reflectRatio),
                this.normalmap instanceof Array ? b["m.normalmap.image"] = this.normalmap: void 0 != this.normalmap && (b["m.normalmap.image"] = this.normalmap),
                this.normalScale instanceof Array ? b["m.normalScale"] = this.normalScale: void 0 != this.normalScale && (b["m.normalScale"] = this.normalScale),
                this.normalType instanceof Array ? b["m.normalType"] = this.normalType: void 0 != this.normalType && (b["m.normalType"] = this.normalType),
                this.specularmap instanceof Array ? b["m.specularmap.image"] = this.specularmap: void 0 != this.specularmap && (b["m.specularmap.image"] = this.specularmap),
                this.specular instanceof Array ? b["m.specular"] = this.specular: void 0 != this.specular && (b["m.specular"] = this.specular),
                this.lightmap instanceof Array ? b["m.lightmap.image"] = this.lightmap: void 0 != this.lightmap && (b["m.lightmap.image"] = this.lightmap),
                this.type && (b[M_TYPE] = this.type),
                this.ambient && (b[M_AMBIENT] = this.ambient),
                b[M_SIDE] = mono.DoubleSide,
                this.color && (b[M_COLOR] = this.color),
                a instanceof mono.Billboard || (a.setStyle(M_WRAPS, mono.RepeatWrapping), a.setStyle(M_WRAPT, mono.RepeatWrapping)),
                a instanceof mono.Cylinder && (this.openTop && a.setOpenTop(!0), this.openBottom && a.setOpenBottom(this.openBottom)),
                a.s(b)
            }
        }),
        Cylinder_faces = ["side", "top", "bottom"],
        MaterialDesc.faces = ["right", "left", "top", "bottom", "front", "back"],
        M_MAP_SRC = "m.texture.image",
        M_MAP_REPEAT = "m.texture.repeat",
        M_VISIBLE = "m.visible",
        M_TRANSPARENT = "m.transparent",
        M_COLOR = "m.color",
        M_WRAPS = "m.texture.wrapS",
        M_WRAPT = "m.texture.wrapT",
        M_OPACITY = "m.opacity",
        M_CUBE_REPEAT = [1, 1],
        M_TYPE = "m.type",
        M_SIDE = "m.side",
        M_ALIGNMENT = "m.alignment",
        M_AMBIENT = "m.ambient",
        M_TEXTURE_FLIPX = "m.texture.flipX",
        M_TEXTURE_FLIPY = "m.texture.flipY",
        M_SPECULARSTRENGTH = "m.specularStrength",
        M_POLYGONOFFSET = "m.polygonOffset",
        M_POLYGONOFFSETFACTOR = "m.polygonOffsetFactor",
        M_POLYGONOFFSETUNITS = "m.polygonOffsetUnits",
        GeometryTranslater = {},
        GeometryTranslater.get3DGeometryFromModelImp = function(a) {
            var b = modelManager.getModelLib(),
            c = b.getValue(a, "size"),
            d = b.getValue(a, "pos"),
            e = b.getValue(a, "className");
            e || (e = b.getValue(a, "type"));
            var f = b.getValue(a, "scale"),
            g = b.getValue(a, "dt"),
            h = b.getValue(a, "repeat"),
            i = b.getValue(a, "types"),
            j = b.getValue(a, "color"),
            k = b.getValue(a, "transparent"),
            l = b.getValue(a, "opacity"),
            m = b.getValue(a, "visible"),
            n = b.getValue(a, "ambient"),
            o = b.getValue(a, TAG_ANIMATION),
            p = b.getValue(a, "animationGroup"),
            q = b.getValue(a, CUSTOM_PROPS),
            r = b.getValue(a, "flipX"),
            s = b.getValue(a, "flipY"),
            t = b.getValue(a, "specularStrength"),
            u = b.getValue(a, "polygonOffset"),
            v = b.getValue(a, "polygonOffsetFactor"),
            w = b.getValue(a, "polygonOffsetUnits"),
            x = b.getValue(a, "openTop"),
            y = b.getValue(a, "openBottom"),
            z = b.getValue(a, "object3dId"),
            A = b.getValue(a, "scaleValue"),
            B = b.getValue(a, "mainVisible"),
            C = b.getValue(a, OID),
            D = new MaterialDesc;
            D.type = i,
            D.repeat = h,
            D.texture = g,
            D.color = j,
            D.opacity = l,
            D.transparent = k,
            D.visible = m,
            D.ambient = n,
            D.flipX = r,
            D.flipY = s,
            D.openTop = x,
            D.openBottom = y,
            D.specularStrength = t,
            D.polygonOffset = u,
            D.polygonOffsetFactor = v,
            D.polygonOffsetUnits = w,
            D.envmap = b.getValue(a, "envmap"),
            D.reflectRatio = b.getValue(a, "reflectRatio"),
            D.normalmap = b.getValue(a, "normalmap"),
            D.normalScale = b.getValue(a, "normalScale"),
            D.normalType = b.getValue(a, "normalType"),
            D.specularmap = b.getValue(a, "specularmap"),
            D.specular = b.getValue(a, "specular"),
            D.lightmap = b.getValue(a, "lightmap"),
            g instanceof Array ? D.tType = 6 : D.tType = 1;
            var E = b.getValue(a, "rot"),
            F = GeometryTranslater.get3DOtherGeometry(a, e),
            G = GeometryTranslater.get3DGeometry(D, e, c, d, f, E, void 0, F);
            if (o && G.setClient(TAG_ANIMATION, o), p && G.setClient("animationGroup", p), q) {
                var H;
                for (var I in q) H = q[I],
                G.setClient(H, b.getValue(a, H));
                G.setClient(CUSTOM_PROPS, q)
            }
            for (var I = 0; 6 > I; I++) {
                var J = b.getValue(a, "face" + I);
                J && G.setClient("face" + I, J)
            }
            return z && G.setClient("object3dId", z),
            A && G.setClient("scaleValue", A),
            Utils.isNotNull(B) && G.setClient("mainVisible", B),
            C && G.setClient(OID, C),
            G
        },
        GeometryTranslater.get3DGeometry = function(a, b, c, d, e, f, g, h, i, j) {
            b || (b = "mono.Cube"),
            0 != b.indexOf("mono.") && (b = "mono." + b);
            var k = null,
            l = null;
            switch (h && (l = h.id), l && j && (k = j.getDataById(l)), b) {
            case "mono.Cube":
                k || (k = l ? new mono.Cube({
                    id: l
                }) : new mono.Cube),
                c && (k.setWidth(c.x), k.setHeight(c.y), k.setDepth(c.z)),
                h.wrapMode && k.setWrapMode(h.wrapMode);
                break;
            case "mono.Sphere":
                k || (k = l ? new mono.Sphere({
                    id: l
                }) : new mono.Sphere),
                c && c.x && k.setRadius(c.x / 2);
                break;
            case "mono.Cylinder":
                k || (k = l ? new mono.Cylinder({
                    id: l
                }) : new mono.Cylinder);
                var m = null;
                h && (m = h.radialSegments),
                m || (m = 4),
                c.x && k.setRadiusTop(c.x),
                c.z && k.setRadiusBottom(c.z),
                c.y && k.setHeight(c.y),
                m && k.setSegmentsR(m);
                break;
            case "mono.Torus":
                k || (k = l ? new mono.Torus({
                    id: l
                }) : new mono.Torus),
                h.radius && k.setRadius(h.radius),
                h.tube && k.setTube(h.tube),
                h.radialSegments && k.setSegmentsR(h.radialSegments),
                h.tubularSegments && k.setSegmentsT(h.tubularSegments),
                h.arc && k.setArc(h.arc);
                break;
            case "mono.Billboard":
                k || (k = l ? new mono.Billboard(l) : new mono.Billboard);
                var n = mono.BillboardAlignment.bottomCenter;
                h && h.alignment && (n = h.alignment),
                e || c && (e = {
                    x: c.x,
                    y: c.y,
                    z: 1
                }),
                k.setStyle(M_ALIGNMENT, n);
                break;
            case "mono.Floor":
                g && (k = new mono.Floor(g));
                break;
            case "mono.PathNode":
                k || (k = l ? new mono.PathNode({
                    id: l
                }) : new mono.PathNode),
                h && (h.radius && k.setRadius(parseFloat(h.radius)), h.path && k.setPath(Utils._createPath(h.path)), h.segments && k.setSegments(parseInt(h.segments)), h.segmentsR && k.setSegmentsR(parseInt(h.segmentsR)), h.startCap && k.setStartCap(h.startCap), h.endCap && k.setEndCap(h.endCap), h.startCapSize && k.setStartCapSize(parseFloat(h.startCapSize)), h.endCapSize && k.setEndCapSize(parseFloat(h.endCapSize)), h.segmentsCap && k.setSegmentsCap(parseInt(h.segmentsCap)));
                break;
            case "mono.TextNode":
                k || (k = l ? new mono.TextNode({
                    id: l
                }) : new mono.TextNode),
                h && (h.text && k.setText(h.text), h.height && k.setHeight(h.height), h.weight && k.setWeight(h.weight), h.style && k.setStyle(h.style), h.curveSegments && k.setCurveSegments(h.curveSegments), h.bevelEnabled && k.setBevelEnabled(h.bevelEnabled), h.textSize && k.setSize(h.textSize));
                break;
            case "mono.ComboNode":
                var o = [];
                if (h.combos && h.combos.length > 1) for (var p = 0; p < h.combos.length; p++) {
                    var q = h.combos[p].id,
                    r = modelManager.getModelNode(q);
                    if (r) {
                        var s = ModelFactory.getModelFromModelNode(modelManager.getModelLib(), r);
                        if (s instanceof modelimp.ModelImp) for (var t = s.get2DObjects(), u = 0; u < t.length; u++) {
                            i ? t[u].setHost(i) : t[u].setHost(new twaver.Node);
                            var v = t[u].translate3d();
                            j && j.remove(v),
                            o.push(v)
                        }
                    }
                }
                k || (k = l ? new mono.ComboNode({
                    id: l
                }) : new mono.ComboNode),
                o.length > 0 && (k.setCombos(o), h.operators && k.setOperators(h.operators)),
                h.centralized && Utils.setComboCentralized(k),
                a.texture == Utils.Path + PropertyConsts.DEFAULT_IMAGE && (a.texture = null);
                break;
            case "mono.LatheNode":
                k || (k = l ? new mono.LatheNode({
                    id: l
                }) : new mono.LatheNode),
                h && (h.path && k.setPath(Utils._createPath(h.path)), h.segmentsH && k.setSegmentsH(h.segmentsH), h.segmentsR && k.setSegmentsR(h.segmentsR), h.arc && k.setArc(h.arc), void 0 !== h.startClosed && k.setStartClosed(h.startClosed), void 0 !== h.endClosed && k.setEndClosed(h.endClosed));
                break;
            case "mono.Entity":
                if (k || (k = l ? new mono.Entity({
                    id: l
                }) : new mono.Entity), h) {
                    if (h.vertices && k.setVertices(h.vertices), h.faces) {
                        var w = [];
                        k.setFaces(w)
                    }
                    h.uvs && k.setUvs(h.uvs)
                }
                break;
            case "mono.PointLight":
                k || (k = l ? new mono.PointLight({
                    id: l
                }) : new mono.PointLight);
                break;
            case "mono.SpotLight":
                k || (l ? (k = new mono.SpotLight({
                    id: l
                }), k._id = l) : k = new mono.SpotLight)
            }
            return d && k.setPosition(d.x, d.y, d.z),
            f && k.setRotation(f.x, f.y, f.z),
            e && k.setScale(e.x, e.y, e.z),
            h && Utils.isNotNull(h.mainVisible) && k.setClient("mainVisible", h.mainVisible),
            a && a.wrap3DStyle(k),
            k
        },
        GeometryTranslater.get2DGeometry = function(a, b, c) {
            var c = getValue(this, "size"),
            d = getValue(this, "pos"),
            e = new PrimitiveNode,
            f = getValue(this, "ov", PropertyConsts.DEFAULT_IMAGE);
            c && e.setClient("size", c);
            var g = getValue(this, "scale");
            g && e.setClient("scale", g);
            var h = getValue(this, "dt");
            h && e.setClient("texture", h);
            var i = getValue(this, "rot");
            i && e.setClient("rot", i);
            var j = getValue(this, "scaleValue");
            j && e.setClient("scaleValue", j),
            f && (e.setImage(f), Utils.registerImage(Utils.Path + f)),
            e.setName(this.pid),
            d && e.setClient("position", d),
            this.ishost && (e.ishost = !0);
            var b = getValue(this, "className", "mono.Cube");
            return e.setClient("className", b),
            e
        },
        GeometryTranslater.get3DCombination = function(a) {
            var b, c, d, e, f = a.operations,
            g = a.primitives,
            h = 1;
            if (g.length >= 2 && f.length == g.length - 1) {
                b = g[0],
                d = new mono.CSG(b);
                for (var i = 0; i < f.length; i++) {
                    c = g[h],
                    e = new mono.CSG(c);
                    var j = f[i];
                    "+" == j ? d = d.union(e) : "-" == j && (d = d.substract(e))
                }
            }
        },
        GeometryTranslater.copyPropertyForRoom2D = function(a, b, c) {
            var d = b,
            e = a;
            if ($cpc(e, d), e[WALL_INNER_PATH] && d.setClient(WALL_INNER_PATH, e[WALL_INNER_PATH]), e[WALL_OUTER_PATH] && d.setClient(WALL_OUTER_PATH, e[WALL_OUTER_PATH]), !1 === c.getValue(e, WALL_CLOSED) && d.setClient("shapenode.closed", !1), e[WALL_SIZE]) {
                var f = e[WALL_SIZE];
                d.setClient(WALL_SIZE, {
                    x: 0,
                    y: f[1],
                    z: f[2]
                })
            }
            e[POLE_IMAGE_PATH] && d.setClient(POLE_IMAGE_PATH, e[POLE_IMAGE_PATH]),
            !0 === c.getValue(e, USE_TEXTURE) && d.setClient(USE_TEXTURE, !0),
            e[OUTFRAME_IMAGE_PATH] && d.setClient(OUTFRAME_IMAGE_PATH, e[OUTFRAME_IMAGE_PATH]),
            e.lightmap && d.setClient("lightMapPic", e.lightmap)
        },
        GeometryTranslater.copyCommonPropertyFor2D = function(a, b) {
            var c = b;
            if (c.setClient(GID, a[GID]), a[OID] && c.setClient(OID, a[OID]), a[BID] && c.setClient(BID, a[BID]), a[PRIMITIVE_NAME] && c.setClient(PRIMITIVE_NAME, a[PRIMITIVE_NAME]), a[FLOOR_NAME] && c.setClient(FLOOR_NAME, a[FLOOR_NAME]), a[FLOOR_HEIGHT] && c.setClient(FLOOR_HEIGHT, a[FLOOR_HEIGHT]), a[CUSTOM_PROPS]) {
                var d = a[CUSTOM_PROPS];
                for (var e in d) {
                    var f = d[e];
                    c.setClient(f, a[f])
                }
                c.setClient(CUSTOM_PROPS, d)
            }
            a[PropertyConsts.LAYERID] && c.setClient(PropertyConsts.LAYERID, a[PropertyConsts.LAYERID]),
            a[TRA_PAR] && c.setClient(TRA_PAR, a[TRA_PAR]),
            a[OPA] && c.setClient(OPA, a[OPA])
        },
        GeometryTranslater.copyPropertyForStandObject2D = function(a, b, c) {
            var d = b,
            e = a;
            if ($cpc(a, b), e[SPACE_SCALE]) {
                var f = e[SPACE_SCALE];
                d.setClient(DESIGN_SCALE, 100 * f[0])
            }
            var g = c.getValue(e, SPACE_POSITION);
            g && d.setCenterLocation(g[0], g[2]);
            var h = c.getValue(e, SPACE_ROTATION);
            h && d.setClient(SPACE_ROTATION, h);
            var i = c.getValue(e, SPACE_POS_Y);
            i && d.setClient(SPACE_POS_Y, i);
            var j = c.getValue(e, "selectable");
            void 0 != j && d.setClient("selectable", j);
            var k = c.getValue(e, ANGLE);
            k && d.setAngle(k)
        },
        GeometryTranslater.get3DOtherGeometry = function(a, b) {
            function c(b) {
                a.wrapMode && (b.wrapMode = a.wrapMode)
            }
            function d(b) {
                a.path && (b.path = a.path),
                a.segments && (b.segments = a.segments);
                var c = a.getValue(a, "segmentsR");
                c && (b.segmentsR = c),
                a.startCap && (b.startCap = a.startCap),
                a.endCap && (b.endCap = a.endCap),
                a.startCapSize && (b.startCapSize = a.startCapSize),
                a.endCapSize && (b.endCapSize = a.endCapSize),
                a.segmentsCap && (b.segmentsCap = a.segmentsCap)
            }
            function e(b) {
                a.text && (b.text = a.text),
                a.textSize && (b.textSize = a.textSize),
                a.height && (b.height = a.height),
                a.weight && (b.weight = a.weight),
                a.style && (b.style = a.style),
                a.curveSegments && (b.curveSegments = a.curveSegments),
                a.bevelEnabled && (b.bevelEnabled = a.bevelEnabled)
            }
            function f(b) {
                a.operators && (b.operators = a.operators),
                a.combos && (b.combos = a.combos),
                a.centralized && (b.centralized = a.centralized)
            }
            function g(b) {
                a[PATH] && (b.path = a[PATH]),
                a[SEGMENTSH] && (b.segmentsH = a[SEGMENTSH]),
                a[SEGMENTSR] && (b.segmentsR = a[SEGMENTSR]),
                a[ARC] && (b.arc = a[ARC]),
                void 0 !== a[START_CLOSED] && (b.startClosed = a[START_CLOSED]),
                void 0 !== a[END_CLOSED] && (b.endClosed = a[END_CLOSED])
            }
            function h(b) {
                a[VERTICES] && (b.vertices = a[VERTICES]),
                a[FACES] && (b.faces = a[FACES]),
                a[UVS] && (b.uvs = a[UVS])
            }
            var i = {},
            j = a.getValue(a, "radialSegments");
            j && (i.radialSegments = j),
            a.radius && (i.radius = a.radius),
            a.tube && (i.tube = a.tube),
            a.tubularSegments && (i.tubularSegments = a.tubularSegments),
            a.arc && (i.arc = a.arc);
            var k = a.getValue(a, "alignment");
            return k && (i.alignment = k),
            "mono.Cube" === b ? c(i) : "mono.PathNode" === b ? d(i) : "mono.TextNode" === b ? e(i) : "mono.ComboNode" === b ? f(i) : "mono.LatheNode" === b ? g(i) : "mono.Entity" === b && h(i),
            i
        },
        $gt3d = GeometryTranslater.get3DGeometry,
        $cpfr = GeometryTranslater.copyPropertyForRoom2D,
        $cpc = GeometryTranslater.copyCommonPropertyFor2D,
        $cpfs2 = GeometryTranslater.copyPropertyForStandObject2D,
        $gt3dog = GeometryTranslater.get3DOtherGeometry,
        modellib.ModelNode = function() {},
        twaver.Util.ext("modellib.ModelNode", Object, {
            getID: function() {
                var a = this.pid;
                return a || (a = this.assembleid),
                a || (a = this.id),
                a
            },
            getType: function() {
                return this.type
            },
            getThumbnail: function() {
                return this.thumbnail ? this.thumbnail: DEFAULT_THUMBNAIL
            },
            getOverview: function() {
                return this.ov ? this.ov: this.getThumbnail()
            },
            getContents: function() {
                return this.children
            },
            getTips: function() {
                return this.tips ? this.tips: this.id
            },
            getLabel: function() {
                return this.label = this.label ? this.label: this.name,
                this.label = this.label ? this.label: this.id,
                this.label
            },
            getTexture: function() {
                return this.dt ? this.dt: DEFAULT_THUMBNAIL
            },
            getClassType: function() {
                return this.classType
            },
            getClassName: function() {
                return this.className
            }
        }),
        modellib.ModelNode.TYPE_ASSEMBLE = "assemble",
        modellib.ModelNode.TYPE_PRIMITIVE = "primitive",
        modellib.Assemble = function(a) {
            this.id = a,
            this.children = []
        },
        twaver.Util.ext("modellib.Assemble", Object, {
            addChild: function(a) {
                if (a instanceof modellib.Assemble) {
                    var b = {
                        id: a.id
                    };
                    a.pos && (b.pos = a.pos),
                    a.rot && (b.rot = a.rot),
                    this._children.push(b)
                }
                this.children.push(a)
            },
            setHost: function(a) {
                var b = this.findByID(a);
                b && (b.ishost = !0)
            },
            findByID: function(a) {
                return f(this.children, a)
            }
        }),
        modellib.ModelLibEvent = function() {},
        modellib.ModelLibEvent.LIBCONTENT_ADDED = "lib.contents.added",
        modellib.ModelLibEvent.LIBCONTENT_REMOVED = "lib.contents.removed",
        modellib.ModelLibrary = function() {
            this._library = {},
            this._primitives = {},
            this._assembles = {},
            this._categories = {},
            this._subTitles = {},
            this.targetCount = 3,
            this._contentsChangedispatcher = new twaver.EventDispatcher
        },
        twaver.Util.ext("modellib.ModelLibrary", Object, {
            parsePrimitives: function(a, b, c, d) {
                for (var e = a.length,
                f = 0; e > f; f++) {
                    var g = new modellib.ModelNode(modellib.ModelNode.TYPE_PRIMITIVE),
                    h = a[f];
                    for (var i in h) g[i] = h[i];
                    this.addPrimitive(g)
                }
                this.targetCount--,
                c && c.call(d, b, "executed")
            },
            parseAssembles: function(a, b, c, d) {
                for (var e = a.length,
                f = 0; e > f; f++) {
                    var g = new modellib.ModelNode(modellib.ModelNode.TYPE_ASSEMBLE),
                    h = a[f];
                    for (var i in h) g[i] = h[i];
                    this.addAssemble(g)
                }
                this.targetCount--,
                c && c.call(d, b, "executed")
            },
            parseLib: function(a, b, c, d) {
                this._categories = a.categories;
                for (var e = 0; e < this._categories.length; e++) {
                    var f = this._categories[e];
                    this._library[f.id] = f;
                    for (var g = f.contents,
                    h = 0; h < g.length; h++) {
                        var i = g[h];
                        this._subTitles[i.subtitle] = i
                    }
                }
                this.targetCount--,
                c && c.call(d, b, "executed")
            },
            isLoaded: function() {
                return 0 == this.targetCount
            },
            getCategories: function() {
                var a = [];
                for (var b in this._library) a.push(this._library[b]);
                return a
            },
            getChildren: function(a) {
                return this._library[a]
            },
            getModelNode: function(a) {
                var b = this._assembles[a];
                return b || (b = this._primitives[a]),
                b
            },
            getModelNodeByTemplateName: function(a) {
                var b = null;
                if (this._assembles) for (var c in this._assembles) this._assembles[c].templateName == a && (b = this._assembles[c]);
                return b
            },
            addModelNode: function(a) {
                modellib.ModelNode.TYPE_ASSEMBLE == a.getType() ? this.addAssemble(a) : this.addPrimitive(a)
            },
            addPrimitive: function(a) {
                if (a && a.id) {
                    var b = a.id;
                    this._primitives[b] || (this._primitives[b] = a)
                }
            },
            addAssemble: function(a) {
                if (a && a.id) {
                    var b = a.id;
                    this._assembles[b] || (this._assembles[b] = a)
                }
            },
            removeAccemble: function(a) {
                this._accemble[a] && (this._accemble[a], delete this._accemble[a])
            },
            fireContentsChangedEvent: function(a) {
                this._contentsChangedispatcher.fire(a)
            },
            addContentsChangedListener: function(a, b) {
                this._contentsChangedispatcher.add(a, b)
            },
            getDefaultModelValue: function(a, b) {
                var c = this.getModelNode(a);
                return c ? c[b] : null
            },
            getValue: function(a, b, c) {
                if (!a) return null;
                var d = a[b];
                return (void 0 === d || null === d) && (d = this.getDefaultModelValue(a.id, b)),
                (void 0 === d || null === d) && 3 == arguments.length && (d = arguments[2]),
                d
            },
            getModelNodeContents: function(a) {
                var b = null;
                if (a.getContents && (b = a.getContents()), !b) {
                    var c = this.getModelNode(a.id);
                    c || (c = this.getModelNode(a.pid)),
                    c && (b = c.getContents())
                }
                return b
            }
        }),
        modellib.ModelManager = function() {
            modellib.ModelManager.superClass.constructor.apply(this, arguments),
            this._modellib = new modellib.ModelLibrary,
            this.init(),
            this.initSerializationSettings(),
            localStorage.getItem(LIB_PRIMITIVES) || localStorage.setItem(LIB_PRIMITIVES, "{}"),
            localStorage.getItem(LIB_ASSEMBLES) || localStorage.setItem(LIB_ASSEMBLES, "{}"),
            localStorage.getItem(LIB_GRAPH) || localStorage.setItem(LIB_GRAPH, "{}"),
            localStorage.getItem(LIB_COMPONENTS) || localStorage.setItem(LIB_COMPONENTS, "{}"),
            this.roots = [],
            this.assembleCache = [],
            this.primitivesCache = [],
            this.nodesMap = {},
            this.lastAssemble = null,
            this.buildings = [],
            this.equipments = [],
            this.targets = [],
            this.pipes = [],
            this.floors = [],
            this.roomAssembles = [],
            this.roomPrimitives = [],
            this.jsonVersion = 1.1
        },
        twaver.Util.ext("modellib.ModelManager", Object, {
            lastAssemble: null,
            init: function() {
                this.loadResource = localStorage.getItem(LOAD_RESOURCE_TYPE) || TYPE_LOCAL,
                this._modellib.addContentsChangedListener(this.onLibContentsChanged, this)
            },
            initSerializationSettings: function() {
                mono.SerializationSettings.setClientType(MAIN_VISIBLE, "boolean"),
                mono.SerializationSettings.setClientType(OID, "string"),
                mono.SerializationSettings.setClientType(TAG_ANIMATION, "string")
            },
            getModelLib: function() {
                return this._modellib
            },
            parsePrimitives: function(a) {
                this._modellib.parsePrimitives(a),
                this.loadSharedPrimitive()
            },
            parseAssembles: function(a) {
                this._modellib.parseAssembles(a),
                this.loadSharedAssemble(a)
            },
            parseLib: function(a) {
                this._modellib.parseLib(a)
            },
            wrapModelNodeIntoItem: function(a, b, c, d) {
                var e = this.getModelNode(b);
                if (e || a != TEMPLATES || (e = this._modellib.getModelNodeByTemplateName(c)), e) {
                    e.label = e.label || c,
                    e.tips = e.tips || c,
                    e.templateName = c;
                    var f = {
                        className: this._modellib.getValue(e, "shape") || e.getClassName(),
                        image: d ? d: e.getThumbnail(),
                        classType: e.getClassType(),
                        actionType: this._modellib.getValue(e, "actionType"),
                        tooltip: e.getTips(),
                        label: e.getLabel(),
                        dragImage: e.getOverview(),
                        image3d: e.getTexture(),
                        id: e.id,
                        embeded: e.embeded,
                        json: e.json,
                        args: e.args,
                        texture: e.texture,
                        material: e.material,
                        color: e.color,
                        material_index: e.material_index,
                        resize: e.resize,
                        panel: e.panel,
                        shape: e.shape,
                        faces: e.faces,
                        transparent: e.transparent,
                        layer: e.layer,
                        wrapMode: e.wrapMode,
                        visible: e.visible
                    },
                    g = this._modellib.getValue(e, "type");
                    g && (f.type = g);
                    var h = this._modellib.getValue(e, "radialSegments");
                    return h && (f.radialSegments = h),
                    f
                }
                if (e = this.getSharedGraph(b)) {
                    var i = c,
                    j = d ? d: e.thumbnail;
                    j = d ? d: "crash.png";
                    var f = {
                        className: "Graph",
                        image: j,
                        classType: "Graph",
                        actionType: "loadTemplate",
                        tooltip: i,
                        label: i,
                        dragImage: j,
                        id: b
                    };
                    return f
                }
                return null
            },
            getModelNode: function(a) {
                return this._modellib.getModelNode(a)
            },
            getCategory: function(a) {
                return JSON.parse(localStorage.getItem(a))
            },
            getSharedComponent: function(a) {
                var b = JSON.parse(localStorage.getItem(LIB_COMPONENTS));
                return b ? b[a] : null
            },
            getSharedGraph: function(a) {
                var b = JSON.parse(localStorage.getItem(LIB_GRAPH));
                return b ? b[a] : null
            },
            getSharedAssemble: function(a) {
                var b = this.getSharedAssembles();
                return b ? b[a] : null
            },
            getSharedPrimitive: function(a) {
                var b = this.getSharedPrimitives();
                return b ? b[a] : null
            },
            getSharedComponent: function(a) {
                var b = this.getSharedComponents();
                return b ? b[a] : null
            },
            removeShareComponent: function(a) {
                var b = this.getSharedComponents();
                if (b && b[a]) {
                    delete b[a];
                    var c = JSON.stringify(b);
                    localStorage.setItem(LIB_COMPONENTS, c)
                }
            },
            removeShareCategory: function(a, b) {
                var c = localStorage.getItem(LOAD_RESOURCE_TYPE);
                if (c === TYPE_CLOUD) this.deleteItemFromDB(b, null, this);
                else {
                    if (a) {
                        var d = null,
                        e = null;
                        if (d = JSON.parse(localStorage.getItem(a))) for (var f = 0; f < d.contents.length; f++) e = d.contents[f],
                        e && ModelUtils.containsID(e.children, b) && ModelUtils.removeChild(e.children, b)
                    }
                    "Templates" === a && this.removeShareItem(b),
                    localStorage.setItem(a, JSON.stringify(d))
                }
            },
            deleteItemFromDB: function(a, b, c) {
                var d = {
                    method: "remove",
                    module: "templates",
                    arguments: {
                        id: a
                    }
                };
                require(MONO_URL, d, b, c)
            },
            removeShareAssemble: function(a) {
                var b = this.getSharedAssembles();
                if (b && b[a]) {
                    delete b[a];
                    var c = JSON.stringify(b);
                    localStorage.setItem(LIB_ASSEMBLES, c)
                }
            },
            removeShareGraph: function(a) {
                var b = this.getSharedGraphLibrary();
                if (b && b[a]) {
                    delete b[a];
                    var c = JSON.stringify(b);
                    localStorage.setItem(LIB_GRAPH, c)
                }
            },
            removeShareItem: function(a) {
                var b = this.getSharedAssembles();
                if (b && b[a]) {
                    for (var c = b[a], d = c.children, e = this.getSharedPrimitives(), f = 0; f < d.length; f++) {
                        var g = d[f].id;
                        e[g] && delete e[g]
                    }
                    var h = JSON.stringify(e);
                    localStorage.setItem(LIB_PRIMITIVES, h),
                    delete b[a];
                    var i = JSON.stringify(b);
                    localStorage.setItem(LIB_ASSEMBLES, i)
                } else {
                    var j = this.getSharedGraphLibrary();
                    if (j && j[a]) {
                        delete j[a];
                        var k = JSON.stringify(j);
                        localStorage.setItem(LIB_GRAPH, k)
                    }
                }
            },
            shareGraph: function(a, b, c, d, e) {
                if (c) {
                    var f = null,
                    g = null;
                    if (a && (f = this.getCategory(a), f || (f = {
                        id: a,
                        contents: []
                    }), f)) {
                        for (var h = 0; h < f.contents.length; h++) b == f.contents[h].subtitle && (g = f.contents[h]);
                        g || (g = {
                            subtitle: b,
                            children: []
                        },
                        f.contents.push(g))
                    }
                    var i = this.getSharedGraphLibrary();
                    if (i) {
                        i[c.id] = c,
                        g && (ModelUtils.containsID(g.children, c.id) || g.children.push({
                            id: c.id,
                            name: e,
                            thumbnail: d
                        }));
                        var j = JSON.stringify(i);
                        localStorage.setItem(LIB_GRAPH, j),
                        localStorage.setItem(a, JSON.stringify(f))
                    }
                }
            },
            sharePrimitive: function(a, b, c, d) {
                if (c) {
                    var e = null,
                    f = null;
                    if (a && (e = JSON.parse(localStorage.getItem(a)), e || (e = {
                        id: a,
                        contents: []
                    }), e)) {
                        for (var g = 0; g < e.contents.length; g++) b == e.contents[g].subtitle && (f = e.contents[g]);
                        f || (f = {
                            subtitle: b,
                            children: []
                        },
                        e.contents.push(f))
                    }
                    var h = this.getSharedPrimitives();
                    if (h) {
                        if (c instanceof Array) for (var g = 0; g < c.length; g++) h[c[g].id] = c[g],
                        f && (ModelUtils.containsID(f.children, c[g].id) || f.children.push(c[g]));
                        else h[c.id] = c,
                        f && (ModelUtils.containsID(f.children, c.id) || f.children.push(c));
                        var i = JSON.stringify(h);
                        localStorage.setItem(LIB_PRIMITIVES, i),
                        d && localStorage.setItem(a, JSON.stringify(e))
                    }
                }
            },
            shareAssemble: function(a, b, c, d, e) {
                if (c) {
                    var f = null,
                    g = null;
                    if (a && (f = JSON.parse(localStorage.getItem(a)), f || (f = {
                        id: a,
                        contents: []
                    }), f)) {
                        for (var h = 0; h < f.contents.length; h++) b == f.contents[h].subtitle && (g = f.contents[h]);
                        g || (g = {
                            subtitle: b,
                            children: []
                        },
                        f.contents.push(g))
                    }
                    var i = this.getSharedAssembles();
                    if (i) {
                        if (c instanceof Array) for (var h = 0; h < c.length; h++) i[c[h].id] = c[h],
                        g && c[h].templateName === d && (ModelUtils.containsID(g.children, c[h].id) || g.children.push({
                            id: c[h].id,
                            name: d,
                            thumbnail: e
                        }));
                        else i[c.id] = c,
                        g && c.templateName === d && (ModelUtils.containsID(g.children, c.id) || g.children.push({
                            id: c.id,
                            name: d,
                            thumbnail: e
                        }));
                        var j = JSON.stringify(i);
                        localStorage.setItem(LIB_ASSEMBLES, j),
                        localStorage.setItem(a, JSON.stringify(f))
                    }
                }
            },
            getSharedPrimitives: function() {
                return JSON.parse(localStorage.getItem(LIB_PRIMITIVES))
            },
            getSharedAssembles: function() {
                return JSON.parse(localStorage.getItem(LIB_ASSEMBLES))
            },
            getSharedGraphLibrary: function() {
                return JSON.parse(localStorage.getItem(LIB_GRAPH))
            },
            getSharedComponents: function() {
                return JSON.parse(localStorage.getItem(LIB_COMPONENTS))
            },
            loadResourceFile: function(a, b) {
                var c = document.createElement("script");
                c.setAttribute("type", "text/javascript"),
                c.setAttribute("src", "resources/" + a),
                b && (c.onload = b.call(c, a, "loaded")),
                document.getElementsByTagName("head")[0].appendChild(c)
            },
            loadGraph: function(a, b, c, d, e) {
                var f = new twaver.ElementBox,
                g = this.loadGraphto2d(f, b, e),
                h = this.show3D(f, a, g, c, d);
                return {
                    box2d: f,
                    box3d: h
                }
            },
            loadGraphto2d: function(a, b, c) {
                var d = null,
                e = null;
                if (b) {
                    var f = b.scaleValue,
                    g = this.parseSketch(b, !1, c);
                    if (g instanceof Array) {
                        var h, i;
                        a.forEach(function(a) {
                            Utils.isTargetFlag(a) ? h = a: Utils.isOriginalFlag(a) && (i = a)
                        });
                        for (var j = 0; j < g.length; j++) if (g[j] instanceof twaver.Layer) {
                            var k = !1,
                            l = Utils.getUnPredefinedFloorLayers(a);
                            l.forEach(function(a) {
                                return a.getClient("floorRef") ? void(k = !0) : void 0
                            }),
                            a.getLayerBox().getDataById(g[j].getId()) || Utils.getLayerByFloorName(a.getLayerBox(), g[j].getClient(FLOOR_NAME)) || (k && g[j].getClient("floorRef") && g[j].setClient("floorRef", !1), a.getLayerBox().add(g[j]))
                        } else g[j] instanceof TargetFlagNode ? (Utils.isTargetFlag(g[j]) ? (h && a.remove(h), h = g[j], d = g[j]) : Utils.isOriginalFlag(g[j]) && (i && a.remove(i), i = g[j], e = g[j]), a.add(g[j])) : g[j] && a.add(g[j])
                    }
                    this.scale = 1 / parseFloat(f),
                    this.scale = this.scale || 1;
                    var m = this,
                    n = {};
                    a.forEach(function(a) {
                        a instanceof PrimitiveNode && (n[a.getId()] = a.getCenterLocation())
                    }),
                    a.forEach(function(a) {
                        if (a instanceof twaver.ShapeNode) {
                            if (a instanceof PipeShapeNode) {
                                var b = a.getStyle("vector.outline.width"),
                                c = Math.abs(Math.log(m.scale));
                                b = m.scale > 1 ? b / Math.pow(1.5, c) : b * Math.pow(1.5, c),
                                a.setStyle("vector.outline.width", b)
                            }
                            var d = new twaver.List,
                            e = a.getPoints();
                            e.forEach(function(a) {
                                d.add({
                                    x: a.x / m.scale,
                                    y: a.y / m.scale
                                })
                            }),
                            a.setPoints(d)
                        } else if (a instanceof Window || a instanceof Door || a instanceof Cutoff) {
                            var f = a.getClient("length"),
                            g = a.getStyle("vector.outline.width"),
                            c = Math.abs(Math.log(m.scale));
                            g = m.scale > 1 ? g / Math.pow(1.5, c) : g * Math.pow(1.5, c),
                            a.setStyle("vector.outline.width", g),
                            a.setClient("length", f / m.scale)
                        }
                    }),
                    a.forEach(function(a) {
                        if (a instanceof PrimitiveNode) {
                            var b = parseFloat(1) / parseFloat(a.scaleValue || 1),
                            c = a.getHeight(),
                            d = a.getWidth();
                            a.setHeight(c / b),
                            a.setWidth(d / b);
                            var e = n[a.getId()] || a.getCenterLocation(),
                            f = {
                                x: e.x / m.scale,
                                y: e.y / m.scale
                            };
                            a.setCenterLocation(f)
                        }
                    })
                }
                return {
                    targetPoint: d,
                    originalPoint: e
                }
            },
            addPrimitiveInfoIntoModelLib: function(a, b) {
                var c = new modellib.ModelNode(a);
                ModelUtils.copyProperties(c, b),
                c.type = "primitive",
                c.shape = "PrimitiveModel",
                this._modellib.addPrimitive(c)
            },
            addAssembleInfoIntoModelLib: function(a, b) {
                var c = new modellib.ModelNode(a);
                ModelUtils.copyProperties(c, b),
                c.type = "assemble",
                c.shape = "AssembleModel",
                this._modellib.addAssemble(c)
            },
            loadSharedPrimitive: function() {
                var a;
                if (a = arguments.length > 0 ? arguments[0] : this.getSharedPrimitives(), a instanceof Array) for (var b = 0; b < a.length; b++) this.addPrimitiveInfoIntoModelLib(modellib.ModelNode.TYPE_PRIMITIVE, a[b]);
                else for (var c in a) this.addPrimitiveInfoIntoModelLib(modellib.ModelNode.TYPE_PRIMITIVE, a[c])
            },
            loadSharedAssemble: function() {
                if (arguments.length > 0 ? assembles = arguments[0] : assembles = this.getSharedAssembles(), assembles instanceof Array) for (var a = 0; a < assembles.length; a++) this.addAssembleInfoIntoModelLib(modellib.ModelNode.TYPE_ASSEMBLE, assembles[a]);
                else for (var b in assembles) this.addAssembleInfoIntoModelLib(modellib.ModelNode.TYPE_ASSEMBLE, assembles[b])
            },
            parseSketch: function(a, b, c) {
                var d = a.assembles,
                e = a.primitives,
                f = a.sketch;
                e && this.loadSharedPrimitive(e),
                d && this.loadSharedAssemble(d);
                var g = this.parseCustomSketch(f, b, c);
                return this.wrapImageShapeNodeHost(g),
                g
            },
            wrapImageShapeNodeHost: function(a) {
                var b = {};
                if (a instanceof Array) {
                    for (var c = 0; c < a.length; c++) a[c] && a[c].getClient("primitiveName") && a[c].setName(a[c].getClient("primitiveName")),
                    a[c] && a[c].getClient(OID) && (b[a[c].getClient(OID)] = a[c].getId());
                    for (var c = 0; c < a.length; c++) if (a[c] && a[c] instanceof ImageShapeNode) {
                        a[c].getClient(OID) && a[c].setClient(OID, a[c].getId());
                        var d = a[c].getClient("hostNodeId");
                        d && a[c].setClient("hostNodeId", b[d])
                    }
                }
            },
            parseCustomSketch: function(a, b, c) {
                var d = a.buildings,
                e = a.equipments,
                f = a.floors,
                g = a.pipes,
                h = a.layers,
                i = a.targets,
                j = [];
                if (h instanceof Array) for (var k = 0; k < h.length; k++) j = j.concat(this.parseLayer(h[k], b));
                if (d instanceof Array) for (var k = 0; k < d.length; k++) {
                    var l = d[k];
                    j = j.concat(this.parseCustomBuilding(l, b))
                }
                if (e instanceof Array) for (var k = 0; k < e.length; k++) j = j.concat(this.parseStandObject3D(e[k], b, c));
                if (f instanceof Array) for (var k = 0; k < f.length; k++) j = j.concat(this.parseFloor(f[k], b));
                if (g instanceof Array) for (var k = 0; k < g.length; k++) j = j.concat(this.parsePipes(g[k], b));
                if (i && i instanceof Array) for (var k = 0; k < i.length; k++) j = j.concat(this.parseTarget(i[k], b));
                return j
            },
            parseLayer: function(a, b) {
                if (!b) {
                    var c = new twaver.Layer;
                    return c.setClient(FLOOR_NAME, a[FLOOR_NAME]),
                    c.setClient(FLOOR_HEIGHT, a[FLOOR_HEIGHT]),
                    c.setClient(FLOOR_VISIBLE, a[FLOOR_VISIBLE]),
                    c.setClient(FLOOR_REF, a[FLOOR_REF]),
                    c.setClient(FLOOR_LAYER, a[FLOOR_LAYER]),
                    [c]
                }
            },
            parseCustomBuilding: function(a, b) {
                var c = [],
                d = this._modellib.getValue(a, IS_INNER_WALL) ? new InnerWallShapeNode: new ImageShapeNode,
                e = a.children,
                f = this._modellib.getValue(a, OUTLINE_SHAPE);
                if (f.length % 3 == 0) {
                    for (var g = [], h = 0; h < f.length; h += 3) g.push({
                        x: f[h],
                        y: f[h + 2]
                    });
                    d.setPoints(new twaver.List(g))
                }
                if ($cpfr(a, d, this._modellib), e instanceof Array) for (var h = 0; h < e.length; h++) {
                    var i = e[h];
                    if (i.children) c = c.concat(this.parseCustomBuilding(i));
                    else {
                        var j = null,
                        k = i.bType;
                        j = "window" === k ? new Window: "door" === k ? new Door: "cutoff" === k ? new Cutoff: new Block;
                        var l = i[IMAGE_SRC],
                        m = i[SPACE_SIZE];
                        i[SIZE_LENGTH] && j.setClient(SIZE_LENGTH, i[SIZE_LENGTH]),
                        i[TAG_ANIMATION] && j.setClient(TAG_ANIMATION, i[TAG_ANIMATION]),
                        i[SIZE_HEIGHT] && j.setClient(SIZE_HEIGHT, i[SIZE_HEIGHT]),
                        i[FLOOR_NAME] && j.setClient(FLOOR_NAME, i[FLOOR_NAME]),
                        i[FLOOR_HEIGHT] && j.setClient(FLOOR_HEIGHT, i[FLOOR_HEIGHT]),
                        i[SIZE_LENGTH] || i[SIZE_HEIGHT] || (m || (m = this._modellib.getValue(this.getModelNode(i.gid), SPACE_SIZE)), m && (j.setClient(SIZE_LENGTH, m[0]), j.setClient(SIZE_HEIGHT, m[1])));
                        var n = i[SPACE_POS_Y];
                        if (n)"door" != k && j.setClient(SPACE_POS_Y, n);
                        else {
                            var o = i[SPACE_POSITION];
                            o && "door" != k && j.setClient(SPACE_POS_Y, o[1])
                        }
                        l && j.setClient(IMAGE_SRC, l),
                        j.setClient(BELONG_ID, i[BELONG_ID]),
                        j.setClient(SHAPE_TYPE, "BlockModel"),
                        j.setClient(GID, i.gid),
                        j.setClient(BLOCK_OFFSET, i[BLOCK_OFFSET]),
                        j.setClient(SPE_STR, i[SPE_STR]),
                        j.setClient("transparent", i[TRA_PAR]),
                        j.setClient("opacity", i[OPA]),
                        i.envmap && j.setClient("envmap", i.envmap),
                        i.reflectRatio && j.setClient("reflectRatio", i.reflectRatio),
                        i.normalmap && j.setClient("normalmap", i.normalmap),
                        i.normalScale && j.setClient("normalScale", i.normalScale),
                        i.normalType && j.setClient("normalType", i.normalType),
                        i.specularmap && j.setClient("specularmap", i.specularmap),
                        i.specular && j.setClient("specular", i.specular),
                        i.lightmap && j.setClient("lightmap", i.lightmap),
                        this.parseCustomProps(j, i),
                        d.addChild(j)
                    }
                }
                if (b) {
                    var p = new mono.DataBox;
                    return d.translate3d(p, d.getChildren().toArray()),
                    c = c.concat(p.getNodes().toArray())
                }
                var q = [d];
                return q = q.concat(d.getChildren().toArray())
            },
            parseStandObject3D: function(a, b, c) {
                var d = [],
                e = this._modellib.getModelNode(a.gid);
                if (e) {
                    var f = ModelFactory.getModelFromModelNode(this._modellib, e);
                    if (b) {
                        d = d.concat(f.get3DObjects());
                        var g = f.hostModel3DNode;
                        if (g) {
                            var h = this._modellib.getValue(a, SPACE_POSITION),
                            i = this._modellib.getValue(a, SPACE_POS_Y);
                            h && (i && (h.y += i), g.setPosition(h[0], h[1], h[2]));
                            var j = this._modellib.getValue(a, "scale"),
                            k = this._modellib.getValue(a, DESIGN_SCALE);
                            j || (j = [1, 1, 1]),
                            k instanceof Array && (j = [j[0] * k[0], j[1] * k[1], j[2] * k[2]]),
                            g.setScale(j[0], j[1], j[2]);
                            var l = this._modellib.getValue(a, "rot");
                            l && g.setRotation(l[0], l[1], l[2]),
                            g[GID] = a[GID],
                            g[OID] = a[OID]
                        }
                    } else {
                        d = d.concat(f.get2DObjects(!c));
                        var g = f.mainNode;
                        g || (g = d[0]),
                        g && ($cpfs2(a, g, this._modellib), g.scaleValue = f.scaleValue)
                    }
                }
                return d
            },
            parseFloor: function(a, b) {
                var c = [],
                d = new FloorShapeNode;
                d[GID] = a[GID],
                d[OID] = a[OID];
                var e = this.getModelNode(a[GID]),
                f = this._modellib.getValue(a, OUTLINE_SHAPE);
                if (f || e && (f = this._modellib.getValue(e, OUTLINE_SHAPE)), f && f.length % 3 == 0) {
                    for (var g = [], h = 0; h < f.length; h += 3) g.push({
                        x: f[h],
                        y: f[h + 2]
                    });
                    d.setPoints(new twaver.List(g))
                }
                var i = this._modellib.getValue(a, IMAGE_SRC);
                i || e && (i = this._modellib.getValue(e, "dt")),
                i && (refreshNetwork ? Utils.registerImage(i, null, null, refreshNetwork) : Utils.registerImage(i), d.setClient(IMAGE_SRC, i));
                var j = this._modellib.getValue(a, HOST_NODE_ID);
                j && d.setClient(HOST_NODE_ID, j);
                var k = this._modellib.getValue(a, FLOOR_NAME);
                k && d.setClient(FLOOR_NAME, k);
                var l = this._modellib.getValue(a, FLOOR_HEIGHT);
                l && d.setClient(FLOOR_HEIGHT, l);
                var m = this._modellib.getValue(a, "repeat");
                m && d.setClient("repeat", m);
                var n = this._modellib.getValue(a, "size");
                n && d.setClient("size", n);
                var o = this._modellib.getValue(a, TRA_PAR);
                o && d.setClient(TRA_PAR, o);
                var p = this._modellib.getValue(a, OPA);
                if (p && d.setClient(OPA, p), this.parseCustomProps(d, a), b) {
                    var q = new mono.DataBox;
                    return d.translate3d(q, d.getChildren().toArray()),
                    c = c.concat(q.getNodes().toArray())
                }
                return [d]
            },
            parsePipes: function(a, b) {
                var c = [],
                d = new PipeShapeNode;
                if (a.className && "RoundPipeShapeNode" == a.className && (d = new RoundPipeShapeNode), a[GID] && (d.setClient(GID, a[GID]), d[GID] = a[GID]), a[OID] && d.setClient(OID, a[OID]), a.repeat && d.setClient("repeat", a.repeat), Utils.isNotNull(a.positionY) && d.setClient("positionY", a.positionY), a[OUTLINE_SHAPE]) var e = a[OUTLINE_SHAPE];
                var e = a[OUTLINE_SHAPE];
                if (e && e.length % 3 == 0) {
                    for (var f = [], g = 0; g < e.length; g += 3) f.push({
                        x: e[g],
                        y: e[g + 2]
                    });
                    d.setPoints(new twaver.List(f))
                }
                if (a[FLOOR_NAME] && d.setClient(FLOOR_NAME, a[FLOOR_NAME]), a.startCap && d.setClient("startCap", a.startCap), a.endCap && d.setClient("endCap", a.endCap), a.startCapSize && d.setClient("startCapSize", a.startCapSize), a.endCapSize && d.setClient("endCapSize", a.endCapSize), a.radius && d.setClient("radius", a.radius), a.segments && d.setClient("segments", a.segments), a[IMAGE_SRC] && d.setClient(IMAGE_SRC, a[IMAGE_SRC]), a.pointPositions && d.setClient("pointPositions", a.pointPositions), this.parseCustomProps(d, a), b) {
                    var h = new mono.DataBox;
                    return d.translate3d(h, d.getChildren().toArray()),
                    c = c.concat(h.getNodes().toArray())
                }
                return [d]
            },
            parseTarget: function(a) {
                var b = new TargetFlagNode(a.type);
                return b.setCenterLocation(a.x, a.z),
                b.setClient(SPACE_POS_Y, a.y),
                b.setShowPoint(a.visible),
                [b]
            },
            parseCustomProps: function(a, b) {
                var c = this._modellib.getValue(b, CUSTOM_PROPS);
                if (c) {
                    for (var d in c) a.setClient(c[d], this._modellib.getValue(b, c[d]));
                    a.setClient(CUSTOM_PROPS, c)
                }
                var e = this._modellib.getValue(b, PropertyConsts.LAYERID);
                e && a.setClient(PropertyConsts.LAYERID, e)
            },
            loadTemplate: function(a, b) {
                var c = this;
                if ("object" == typeof b) {
                    var d = b,
                    e = {
                        module: "templates",
                        method: "getData",
                        arguments: {
                            id: d.id
                        }
                    },
                    f = function() {
                        var b = JSON.parse(arguments[0]);
                        if (b.error) return void alert(b.error);
                        var d = JSON.parse(b.value);
                        c.loadDataCheck(cloudKey, this.loadGraphto2d, [a, d]),
                        refreshNetwork()
                    };
                    require(MONO_URL, e, f, this)
                } else {
                    var g = this.getSharedGraph(b);
                    this.loadGraphto2d(a, g),
                    refreshNetwork()
                }
            },
            loadDataCheck: function(a, b, c) {
                var d = c[1],
                e = this;
                if (d) {
                    for (var f = [], g = d.sketch.equipments, h = 0; h < g.length; h++) {
                        var i = this._modellib.getModelNode(g[h].gid);
                        i || f.indexOf(g[h].gid) < 0 && f.push(g[h].gid)
                    }
                    if (f.length > 0) {
                        var j = {
                            module: "templates",
                            method: "getDatas",
                            arguments: {
                                gids: f.join(",")
                            }
                        },
                        k = function() {
                            var a = JSON.parse(arguments[0]);
                            if (a.error) return void alert(a.error);
                            var d = a.value;
                            if (d && d.length > 0) for (h in d) {
                                var f = JSON.parse(d[h].data);
                                f.primitives || f.assembles ? (e.loadSharedPrimitive(f.primitives), e.loadSharedAssemble(f.assembles)) : (e.loadSharedPrimitive(f.primitivesCache), e.loadSharedAssemble(f.assembleCache))
                            }
                            b.apply(e, c)
                        };
                        require(MONO_URL, j, k, this)
                    } else b.apply(e, c)
                }
            },
            loadDataFromRoom: function(a, b) {
                var c, d, e = new twaver.ElementBox,
                f = this.parseSketch(a);
                if (f instanceof Array) for (var g = 0; g < f.length; g++) f[g] instanceof twaver.Layer ? e.getLayerBox().add(f[g]) : f[g] instanceof TargetFlagNode ? (Utils.isTargetFlag(f[g]) ? c = f[g] : Utils.isOriginalFlag(f[g]) && (d = f[g]), e.add(f[g])) : e.add(f[g]);
                this.show3D(e, b, {
                    targetPoint: c,
                    originalPoint: d
                })
            },
            loadDatafromComponent: function(a, b, c) {
                this.loadSharedPrimitive(b.primitives),
                this.loadSharedAssemble(b.assembles);
                var d = {
                    x: 120,
                    y: 100
                },
                e = this._modellib.getModelNode(c);
                if (e) {
                    var f = ModelFactory.getModelFromModelNode(this._modellib, e);
                    if (f instanceof modelimp.ModelImp) {
                        var g, h = (a.getDataBox(), new twaver.ElementBox),
                        i = f.get2DObjects();
                        i[0] && (f.mainNode ? (f.mainNode.setCenterLocation(d), f.mainNode instanceof PrimitiveNode && f.mainNode.setName(f.id), g = f.mainNode) : (i[0].setCenterLocation(d), i[0] instanceof PrimitiveNode && i[0].setName(f.id), g = i[0]), g && (g.getX() < 0 && g.setX(0), g.getY() < 0 && g.setY(0)));
                        for (var j = 0; j < i.length; j++) h.add(i[j]);
                        this.show3D(h, a)
                    }
                }
            },
            show3D: function(a, b, c, d, e) {
                b || (b = new mono.Network3D);
                var f = b.getDataBox(),
                g = [];
                if (e || (f.clear(), f.getAlarmBox().clear()), c) var h = c.targetPoint,
                i = c.originalPoint;
                var j = {},
                k = 0;
                f.startBatch(),
                a.forEach(function(a) {
                    var c = a;
                    if (c instanceof twaver.ShapeNode) {
                        var d = c.getPoints(),
                        e = d.size();
                        if (e > 0 && c instanceof ImageShapeNode) {
                            c.setClient("shapeNodeIndex", k++);
                            var h = c.getChildren(),
                            i = [];
                            h && h.forEach(function(a) {
                                a instanceof Block && i.push(a)
                            });
                            var l = c.translate3d(f, i, b);
                            l instanceof Array ? g = g.concat(l) : g.push(l)
                        }
                    } else c instanceof PrimitiveNode && (j[c.getId()] = c.translate3d(f, b))
                }),
                a.forEach(function(a) {
                    var b = a;
                    if (b.getHost) {
                        var c = b.getHost();
                        c && j[b.getId()].setParent(j[c.getId()])
                    }
                });
                var l = [];
                for (var m in j) j[m].getParent() || l.push(j[m]);
                f.getRoots().forEachReverse(function(a) {
                    a instanceof mono.ComboNode && a.getClient("entity") && f.remove(a)
                });
                for (var n = 0; n < l.length; n++) {
                    var o = l[n];
                    if (!f.getDataById(o.getId())) {
                        var p = o.getDescendants();
                        if (o.getClient("isEntity")) {
                            p.push(o);
                            var q = new mono.ComboNode(p, null, !0, "entity" + o.getId());
                            q.setPosition(o.getPosition()),
                            q.setClient("floorName", o.getClient("floorName")),
                            q.setClient(BID, o.getClient(BID)),
                            q.setClient("entity", !0),
                            f.add(q)
                        } else f.addByDescendant(o)
                    }
                }
                if (f.endBatch(), j = null, i && i.isShowPoint()) {
                    g = g.concat(l);
                    for (var m = 0; m < g.length; m++) {
                        var r = g[m];
                        if (!r.getParent() && r instanceof mono.Entity) {
                            var s = r.getPosition();
                            if (s) {
                                var t = i.getCenterLocation();
                                s.x = s.x - t.x,
                                s.y = s.y - i.getClient(SPACE_POS_Y),
                                s.z = s.z - t.y,
                                r.setPosition(s)
                            }
                        }
                    }
                }
                if (h && h.isShowPoint()) {
                    var u = h.getCenterLocation(),
                    v = new mono.Vec3(u.x, 100, u.y);
                    b.getCamera().look(v);
                    for (var w = b.getInteractions(), m = 0; m < w.length; m++) w[m] instanceof mono.DefaultInteraction && (w[m].target = v)
                }
                return f
            },
            loadGraphUrl: function(a, b, c, d, e, f) {
                var g = this;
                this.loadFile(b,
                function(b) {
                    var h = JSON.parse(b);
                    if (h) {
                        var i = g.loadGraph(a, h, c, d);
                        f && f.call(e, i.box2d, i.box3d)
                    }
                })
            },
            loadGraphDatas: function(a) {
                var b = this,
                c = new mono.Network3D;
                return this.loadFile(a,
                function(a) {
                    var d = JSON.parse(a);
                    d && b.loadGraph(c, d)
                }),
                c.getDataBox().getDatas()
            },
            loadFile: function(a, b) {
                if (a) {
                    var c = new XMLHttpRequest;
                    void 0 !== b && c.addEventListener("load",
                    function(a) {
                        b(a.target.responseText)
                    },
                    !1),
                    c.open("GET", a, !0),
                    c.send(null)
                }
            },
            loadComponentDatas: function(a, b) {
                var c = {};
                if (this.loadResource === TYPE_CLOUD) {
                    var d = {
                        module: "templates",
                        method: "getData",
                        arguments: {
                            id: a
                        }
                    };
                    require(MONO_URL, d, b, this)
                } else {
                    var e = modelManager.getSharedComponent(a);
                    e && (c = e.data)
                }
                return c
            },
            loadCloudTemplateById: function(a, b, c, d, e) {
                var f = this,
                g = {
                    module: "templates",
                    method: "getData",
                    arguments: {
                        id: b
                    }
                };
                loadCloud = function() {
                    var b = JSON.parse(arguments[0]);
                    if (b.error) return void alert(b.error);
                    if (!b.value) return void alert("No Template with Id " + id);
                    var g, h = JSON.parse(b.value);
                    if (h.primitives && h.primitives.length > 0 && h.assembles && h.assembles.length > 0 || h.primitivesCache && h.assembleCache) {
                        var i = a ? a.getDataBox() : null;
                        g = f.loadComponentTemplateFromContents(i, b.value, c, !1),
                        e && e.call(d, g)
                    } else f.loadDataCheck(null,
                    function() {
                        var b = f.loadGraph(a, h, !0);
                        e && e.call(d, b)
                    },
                    [a, h, !0])
                },
                require(MONO_URL, g, loadCloud, this)
            },
            loadTemplateFromCloud: function(a, b, c, d) {
                var e = {
                    module: "templates",
                    method: "search",
                    arguments: {
                        name: b
                    }
                },
                f = this,
                g = function() {
                    if (1 === arguments.length) {
                        var h = JSON.parse(arguments[0]);
                        if (h.error) return void alert(h.error);
                        if (!h.value || h.value.length <= 0) return void alert(b + " dese not exist");
                        var i = h.value[0];
                        e = {
                            module: "templates",
                            method: "getData",
                            arguments: {
                                id: i.id
                            }
                        },
                        g = function() {
                            var e = JSON.parse(arguments[0]);
                            if (e.error) return void alert(e.error);
                            if (!e.value) return void alert("No Template with name " + b);
                            var g = JSON.parse(e.value);
                            "Component" === i.type ? f.loadDatafromComponent(a, g, b) : f.loadDataCheck(c, f.loadGraph, [a, g, d])
                        },
                        require(MONO_URL, e, g, this)
                    }
                };
                require(MONO_URL, e, g, this)
            },
            exportRoomToTemplate: function(a, b, c, d, e, f, g, h, i) {
                var j = d;
                if (!j) return alert("Template name is required"),
                !1;
                if (this.loadResource === TYPE_CLOUD && !e) return alert("Template category is required"),
                !1;
                j || (j = "Your Graph");
                var k = this.serializeGraphInfo(a);
                if (k.id = Utils.generateAssembleId(), this.loadResource === TYPE_CLOUD) {
                    var l = JSON.stringify(k);
                    if (i) m = {
                        module: "templates",
                        method: "update",
                        arguments: {
                            id: f,
                            name: d,
                            data: l,
                            category: e,
                            gid: k.id,
                            icon: b,
                            author: g,
                            tags: h,
                            preview: c
                        }
                    };
                    else var m = {
                        module: "templates",
                        method: "add",
                        arguments: {
                            name: d,
                            data: l,
                            category: e,
                            scope: 0,
                            gid: k.id,
                            icon: b,
                            preview: c,
                            author: g,
                            tag: h
                        }
                    };
                    var n = function() {
                        if (1 === arguments.length) {
                            var a = JSON.parse(arguments[0]);
                            if (a.error) return void alert(a.error);
                            alert("Models have been export to the cloud library.")
                        }
                    };
                    require(MONO_URL, m, n, this)
                } else this.shareGraph(TEMPLATES, SUBTITLE_ROOM, k, b, j),
                alert("Models have been export to the local library.");
                return k
            },
            serializeDatasInfo: function(a, b) {
                for (var c = a.size(), d = 0; c > d; d++) this.dfs2DNodes(a.get(d));
                for (var e = {
                    buildings: this.buildings,
                    equipments: this.equipments,
                    pipes: this.pipes,
                    floors: this.floors
                },
                f = {
                    primitives: [],
                    assembles: [],
                    sketch: e
                },
                d = 0; c > d; d++) delete a.get(d).visited;
                return b && (f.scaleValue = b),
                this.buildings = [],
                this.equipments = [],
                this.floors = [],
                this.pipes = [],
                JSON.stringify(f)
            },
            serializeGraphInfo: function(a, b) {
                for (var c = a.getDatas(), d = c.size(), e = 0; d > e; e++) this.dfs2DNodes(c.get(e));
                var f = [],
                g = Utils.getUnPredefinedFloorLayers(a);
                if (g && g.size() > 0) {
                    var h = this;
                    g.forEach(function(a) {
                        f.push(h.dfs2DLayers(a))
                    })
                }
                var i = {
                    buildings: this.buildings,
                    equipments: this.equipments,
                    targets: this.targets,
                    pipes: this.pipes,
                    floors: this.floors,
                    layers: f
                },
                j = {
                    primitives: [],
                    assembles: [],
                    sketch: i
                };
                b && (this.handlePrimitivesInfo(), this.handleAssemblesInfo(), j = {
                    primitives: this.roomPrimitives,
                    assembles: this.roomAssembles,
                    sketch: i
                });
                var k = a.getClient("scaleValue");
                k && (j.scaleValue = k);
                for (var e = 0; d > e; e++) delete c.get(e).visited;
                return this.buildings = [],
                this.equipments = [],
                this.targets = [],
                this.floors = [],
                this.pipes = [],
                this.layerInfo = [],
                this.roomPrimitives = [],
                this.roomAssembles = [],
                j
            },
            handleAssemblesInfo: function() {
                for (var a, b, c = this.roomAssembles,
                d = 0; d < c.length; d++) {
                    a = c[d],
                    b = a.getContents();
                    for (var e = 0; e < b.length; e++) {
                        var f = b[e],
                        g = this.getModelNode(f.id);
                        for (var h in f)"id" != h && f[h] == g[h] && (f[h] = void 0);
                        f.type = void 0,
                        f.shape = void 0
                    }
                    a.type = void 0,
                    a.shape = void 0
                }
            },
            handlePrimitivesInfo: function() {
                for (var a, b = this.roomPrimitives,
                c = 0; c < b.length; c++) a = b[c],
                a.type = void 0,
                a.shape = void 0
            },
            searchTemplatesFromDB: function(a, b, c, d, e) {
                var f = {
                    module: "templates",
                    method: "search",
                    arguments: {
                        scope: b,
                        category: e
                    }
                };
                require(MONO_URL, f, c, d)
            },
            getPreviewById: function(a, b, c) {
                var d = (localStorage.getItem(CLOUD_KEY), {
                    module: "templates",
                    method: "getPreview",
                    arguments: {
                        id: a
                    }
                });
                require(MONO_URL, d, b, c, !0)
            },
            dfs2DNodes: function(a) {
                if (!a.visited) {
                    a.visited = !0;
                    var b, c = a.getParent();
                    if (c) c instanceof ImageShapeNode && (b = this.getBlockInfo(a));
                    else if (b = this.getBasicInfo(a), a instanceof PipeShapeNode) this.wrapPipeInfo(b, a),
                    this.pipes.push(b);
                    else if (a instanceof FloorShapeNode) this.wrapFloorInfo(b, a),
                    this.floors.push(b);
                    else if (a instanceof ImageShapeNode) {
                        var d = a.getChildren().size();
                        if (this.wrapRoomInfo(b, a), this.buildings.push(b), d > 0) for (var e = a.getChildren(), f = 0; d > f; f++) {
                            var g = e.get(f);
                            b.children.push(this.dfs2DNodes(g))
                        }
                    } else a instanceof TargetFlagNode ? (b = this.pointsFlagInfo(b, a), this.targets.push(b)) : this.equipments.push(b);
                    return a.visited = !1,
                    b
                }
            },
            dfs2DLayers: function(a) {
                var b = {};
                return b[FLOOR_NAME] = a.getClient(FLOOR_NAME),
                b[FLOOR_HEIGHT] = a.getClient(FLOOR_HEIGHT),
                b[FLOOR_VISIBLE] = a.getClient(FLOOR_VISIBLE),
                b[FLOOR_REF] = a.getClient(FLOOR_REF),
                b[FLOOR_LAYER] = a.getClient(FLOOR_LAYER),
                b
            },
            getBasicInfo: function(a) {
                var b = a.getClient(GID);
                b && !g(this.roomAssembles, b) && this.buildingAssembles(b);
                var c = a.getClient(OID),
                d = ModelUtils.covertTo3DPosition(a),
                e = {
                    id: a.getId(),
                    oid: c
                };
                e[GID] = b,
                e[SPACE_POSITION] = [d.x, d.y, d.z],
                e[SPACE_POS_Y] = a.getClient(SPACE_POS_Y),
                e[SPACE_ROTATION] = a.getClient(SPACE_ROTATION),
                e[PRIMITIVE_NAME] = a.getClient(PRIMITIVE_NAME),
                e[FLOOR_NAME] = a.getClient(FLOOR_NAME),
                e[FLOOR_HEIGHT] = a.getClient(FLOOR_HEIGHT),
                e[BID] = a.getClient(BID),
                e[ANGLE] = a.getAngle();
                var f = a.getClient(DESIGN_SCALE);
                f && (f /= 100, e[SPACE_SCALE] = [f, f, f]);
                var h = a.getClient("animation");
                h && "" != h && (e.animation = h);
                var i = a.getClient(CUSTOM_PROPS);
                if (i) {
                    for (var j in i) {
                        var k = i[j];
                        e[k] = a.getClient(k)
                    }
                    e.customProps = i
                }
                var l = a.getClient(PropertyConsts.LAYERID);
                return l && (e.layerId = l),
                e
            },
            pointsFlagInfo: function(a, b) {
                a = {};
                var c = b.getLocation();
                return a.x = c.x,
                a.y = b.getClient(SPACE_POS_Y),
                a.z = c.y,
                a.visible = b.isShowPoint(),
                a.type = b.getType(),
                a
            },
            wrapPipeInfo: function(a, b) {
                a.dshape = this.getDShapeOfImageShapedNode(b),
                b instanceof RoundPipeShapeNode && (a.className = "RoundPipeShapeNode"),
                a.repeat = b.getClient("repeat"),
                a[IMAGE_SRC] = b.getClient(IMAGE_SRC),
                a.pointPositions = b.getClient("pointPositions"),
                a.startCap = b.getClient("startCap"),
                a.endCap = b.getClient("endCap"),
                a.startCapSize = b.getClient("startCapSize"),
                a.endCapSize = b.getClient("endCapSize"),
                a.radius = b.getClient("radius"),
                a.segments = b.getClient("segments"),
                a.positionY = b.getClient("positionY")
            },
            wrapFloorInfo: function(a, b) {
                a.dshape = this.getDShapeOfImageShapedNode(b),
                a[IMAGE_SRC] = b.getClient(IMAGE_SRC),
                a.repeat = b.getClient("repeat"),
                a.size = b.getClient("size");
                var c = b.getClient("hostNodeId");
                c && "" != c && (a.hostNodeId = c),
                a[TRA_PAR] = b.getClient(TRA_PAR),
                a[OPA] = b.getClient(OPA)
            },
            wrapRoomInfo: function(a, b) {
                var c = modelManager.getModelNode(a[GID]);
                a.dshape = this.getDShapeOfImageShapedNode(b),
                a.children = [];
                var d = b.getClient(USE_TEXTURE); ! 0 === d ? a[USE_TEXTURE] = !0 : a[USE_TEXTURE] = !1;
                var e = b.getClient(WALL_SIZE),
                f = !0;
                if (e) {
                    var g = this._modellib.getValue(c, WALL_SIZE);
                    g && e.x == g.x && e.y == g.y && e.z == g.z && (f = !1)
                }
                f && (a[WALL_SIZE] = [e.x, e.y, e.z], f = !1);
                var h = b.getClient(WALL_CLOSED); ! 1 === h && (a[WALL_CLOSED] = !1),
                a[POLE_IMAGE_PATH] = b.getClient(POLE_IMAGE_PATH),
                a[OUTFRAME_IMAGE_PATH] = b.getClient(OUTFRAME_IMAGE_PATH),
                a[WALL_INNER_PATH] = b.getClient(WALL_INNER_PATH),
                a[WALL_OUTER_PATH] = b.getClient(WALL_OUTER_PATH),
                a[IS_INNER_WALL] = b instanceof InnerWallShapeNode;
                var i = b.getClient(OID);
                i && "" != i && (a[OID] = i),
                b.getClient(TRA_PAR),
                b.getClient(OPA),
                a[TRA_PAR] = b.getClient(TRA_PAR),
                a[OPA] = b.getClient(OPA),
                a.lightmap = b.getClient("lightMapPic")
            },
            getDShapeOfImageShapedNode: function(a) {
                for (var b = a.getPoints(), c = [], d = b.size(), e = 0; d > e; e++) {
                    var f = b.get(e);
                    c = c.concat([f.x, 0, f.y])
                }
                return c
            },
            buildingAssembles: function(a) {
                var b = this.getModelNode(a);
                if (b) if (b.children && b.children.length > 0) {
                    this.roomAssembles.push(b);
                    for (var c = 0; c < b.children.length; c++) {
                        var d = b.children[c].id;
                        this.buildingAssembles(d)
                    }
                } else if (!g(this.roomPrimitives, b.id) && (this.roomPrimitives.push(b), "mono.ComboNode" === b.className && b.combos)) for (var e = b.combos,
                c = 0; c < e.length; c++) this.buildingAssembles(e[c].id)
            },
            getBlockInfo: function(a) {
                info = this.getBasicInfo(a),
                a instanceof Window ? info[BTYPE] = "window": a instanceof Door ? info[BTYPE] = "door": a instanceof Cutoff && (info[BTYPE] = "cutoff"),
                this.getModelNode(info[GID]),
                info[BELONG_ID] = a.getClient(BELONG_ID),
                info[IMAGE_SRC] = a.getClient(IMAGE_SRC);
                var b = a.getClient(SPACE_SIZE);
                return info[SPACE_POSITION][1] = a.getClient(SPACE_POS_Y),
                b ? info[SPACE_SIZE] = [b.x, b.y, b.z] : info[SPACE_SIZE] = [a.getClient(SIZE_LENGTH), a.getClient(SIZE_HEIGHT), a.getClient(SIZE_DEPTH)],
                info[BLOCK_OFFSET] = a.getClient(BLOCK_OFFSET),
                info[SPE_STR] = a.getClient(SPE_STR),
                info[TRA_PAR] = a.getClient(TRA_PAR),
                info[OPA] = a.getClient(OPA),
                a.getClient("envmap") && (info.envmap = a.getClient("envmap")),
                a.getClient("reflectRatio") && (info.reflectRatio = a.getClient("reflectRatio")),
                a.getClient("normalmap") && (info.normalmap = a.getClient("normalmap")),
                a.getClient("normalScale") && (info.normalScale = a.getClient("normalScale")),
                a.getClient("normalType") && (info.normalType = a.getClient("normalType")),
                a.getClient("specularmap") && (info.specularmap = a.getClient("specularmap")),
                a.getClient("specular") && (info.specular = a.getClient("specular")),
                a.getClient("lightmap") && (info.lightmap = a.getClient("lightmap")),
                console.log(info),
                info
            },
            organizeComponentsDrawing: function(a) {
                var b = (this.serializeComponentsInfo(a), {
                    primitives: this.primitivesCache,
                    assembles: this.assembleCache
                });
                return this.disposeComponents(a.getNodes().toArray(), a.getBillboards().toArray()),
                b
            },
            exportComponentToTemplate: function(a, b, c, d, e, f, g, h, i, j, k) {
                var l = d;
                return l ? this.loadResource !== TYPE_CLOUD || e ? void this.organizeAssembles(a, l, null, b, c, e, f, g, h, i, j, k) : (alert("Template category is required"), !1) : (alert("Template name is required"), !1)
            },
            serializeComponentsInfo: function(a, b, c, d) {
                for (var e = a.getNodes().toArray(), f = a.getBillboards().toArray(), g = 0; g < e.length; g++) {
                    var h = e[g];
                    h.getClient(PropertyConsts.COMPONENTFLOOR || h instanceof mono.Floor) || this.serialize3DDate(h, e, f, a)
                }
                for (var i = this.assembleCache,
                j = 0; j < i.length; j++) {
                    var k = i[j].boundingBox;
                    if (k) {
                        i[j].assembleSize = k.size();
                        var l = ModelUtils.getCenterOfBoundingBox(k);
                        l = {
                            x: l.x,
                            y: l.y,
                            z: l.z
                        },
                        i[j].off = l
                    }
                    0 != j && delete i[j].boundingBox
                }
                for (var g = 0; g < f.length; g++) if (!f[g].visited) {
                    var m = {};
                    this.getInfoOfBillboard(m, f[g]),
                    this.primitivesCache.push(m),
                    this.roots.push(f[g]),
                    this.nodesMap[f[g].getId()] = f[g]
                }
                var n = null;
                if (this.roots.length > 1 || 1 == this.roots.length && 0 == this.assembleCache.length) {
                    var o = Utils.generateAssembleId(c);
                    n = new modellib.Assemble(o);
                    for (var g = 0; g < this.roots.length; g++) {
                        var h = this.roots[g],
                        p = null;
                        p = h.assembleID ? {
                            id: h.assembleID
                        }: {
                            id: this.roots[g].getId()
                        },
                        h.oid && (p.oid = h.oid),
                        this.wrapAnimation(p, h),
                        this.wrapCustomProps(p, h),
                        n && n.addChild(p)
                    }
                    var q = mono.Utils.getBoundingBox(this.roots, !0);
                    n.assembleSize = q.size();
                    var l = ModelUtils.getCenterOfBoundingBox(q);
                    l = {
                        x: l.x,
                        y: l.y,
                        z: l.z
                    },
                    n.off = l,
                    n.ishost = !0,
                    b && (n.templateName = b),
                    this.assembleCache.push(n)
                } else {
                    var r = ModelUtils.indexInArray(this.assembleCache, this.roots[0].assembleID);
                    n = this.assembleCache[r];
                    var o = Utils.generateAssembleId(c);
                    this.roots[0].assembleID = o,
                    b && (n.templateName = b),
                    n.id = o,
                    n.ishost = !0
                }
                if (n && n.children.length > 0) {
                    n.scaleValue = comScaleValue,
                    n.isEntity = d;
                    for (var s = n.off,
                    t = !1,
                    g = 0; g < n.children.length; g++) {
                        var p = n.children[g];
                        p.ishost && (t = !0)
                    }
                    for (var g = 0; g < n.children.length; g++) {
                        var p = n.children[g];
                        t ? p.ishost && this.setChildPosition(p, s) : this.setChildPosition(p, s)
                    }
                }
                return this.assembleCache.length > 0 && delete this.assembleCache[0].boundingBox,
                n
            },
            setChildPosition: function(a, b) {
                var c = a.id;
                c.startsWith("assemble") && (c = c.substring("assemble".length, c.length));
                var d = this.nodesMap[c].getPosition();
                a.pos = {
                    x: d.x - b.x,
                    y: d.y - b.y,
                    z: d.z - b.z
                }
            },
            organizeAssembles: function(a, b, c, d, e, f, g, h, i, j, k, l) {
                console.log(e);
                var m = this.serializeComponentsInfo(a, b, null, j);
                if (this.loadResource === TYPE_CLOUD) {
                    for (var n, o = 0; o < this.assembleCache.length; o++) this.assembleCache[o].ishost && (k && l && (this.assembleCache[o].id = l), n = this.assembleCache[o].id, j && (this.assembleCache[o].isEntity = !0));
                    var p = {
                        primitives: this.primitivesCache,
                        assembles: this.assembleCache
                    },
                    q = JSON.stringify(p);
                    console.log(q);
                    var r;
                    r = k ? {
                        module: "templates",
                        method: "update",
                        arguments: {
                            id: g,
                            name: b,
                            data: q,
                            category: f,
                            method: "Component",
                            gid: n,
                            icon: d,
                            author: h,
                            tags: i,
                            preview: e
                        }
                    }: {
                        module: "templates",
                        method: "add",
                        arguments: {
                            name: b,
                            data: q,
                            category: f,
                            method: "Component",
                            scope: 0,
                            gid: n,
                            icon: d,
                            author: h,
                            tags: i,
                            preview: e
                        }
                    };
                    var s = function() {
                        if (1 === arguments.length) {
                            var a = JSON.parse(arguments[0]);
                            if (a.error) return void alert(a.error);
                            alert("Models have been export to the cloud library.")
                        }
                    };
                    require(MONO_URL, r, s, this)
                } else {
                    for (var o = 0; o < this.primitivesCache.length; o++) this.sharePrimitive("Private Templates", "Component", this.primitivesCache[o], !1);
                    m && (this.shareAssemble("Private Templates", "Component", m, b, d), delete m.off);
                    for (var t = this.assembleCache,
                    u = 0; o < t.length; u++) t[u].ishost && j && (t[u].isEntity = !0),
                    modelManager.shareAssemble("Private Templates", "Component", t[u], b, d);
                    alert("Models have been export to the local library.")
                }
                console.log("primitives ext lib:\n" + localStorage.getItem(LIB_PRIMITIVES)),
                console.log(localStorage.getItem(LIB_PRIMITIVES).length),
                console.log("assemble ext lib:\n" + localStorage.getItem(LIB_ASSEMBLES)),
                this.disposeComponents(a.getNodes().toArray(), a.getBillboards().toArray())
            },
            loadComponentTemplateFromContents: function(a, b, c, d) {
                var e, f = JSON.parse(b);
                if (f.primitives && f.assembles || f.primitivesCache && f.assembleCache) {
                    this.loadSharedPrimitive(f.primitives || f.primitivesCache),
                    this.loadSharedAssemble(f.assembles || f.assembleCache);
                    var g = this.getTemplateGID(f.assembles || f.assembleCache);
                    g && (e = this.create3DElementsFromModelNode(a, g, d)),
                    c && e && e.setParent(c)
                }
                return e
            },
            getTemplateGID: function(a) {
                var b;
                if (a) for (var c = 0; c < a.length; c++) if (a[c].ishost || a[c].templateName) {
                    b = a[c].id;
                    break
                }
                return b
            },
            loadComponentTemplateFromURL: function(a, b, c, d, e) {
                var f = this;
                this.loadFile(b,
                function(b) {
                    if (b) {
                        var g = f.loadComponentTemplateFromContents(a, b, c, !1);
                        e && e.call(d, g)
                    }
                })
            },
            loadComponentTemplate: function(a, b, c, d, e) {
                if (this.loadResource !== TYPE_CLOUD) return this.create3DElementsFromModelNode(a, b, c);
                var f = {
                    module: "templates",
                    method: "get",
                    arguments: {
                        id: b
                    }
                },
                g = function() {
                    var b = JSON.parse(arguments[0]);
                    if (b.error) return void alert(b.error);
                    var f = b.value;
                    if (f) {
                        var g = JSON.parse(f.data);
                        console.log(f.data),
                        g.primitives || g.assembles ? (this.loadSharedPrimitive(g.primitives), this.loadSharedAssemble(g.assembles)) : (this.loadSharedPrimitive(g.primitivesCache), this.loadSharedAssemble(g.assembleCache));
                        var h = this.create3DElementsFromModelNode(a, f.gid, c, f.version);
                        e && e.call(d, h)
                    }
                };
                require(MONO_URL, f, g, this)
            },
            create3DElementsFromModelNode: function(a, b, c, d) {
                var e, f = !c,
                g = this.getModelNode(b);
                if (g || (g = this._modellib.getModelNodeByTemplateName(b)), g) {
                    var h = ModelFactory.getModelFromModelNode(this._modellib, g);
                    if (h instanceof modelimp.ModelImp) {
                        var i = h.get3DObjects(f);
                        if (a) for (var j = parseFloat(h.scaleValue) / parseFloat(a.scaleValue || 1), k = 0; k < i.length; k++) Utils.scale3DElement(i[k], j),
                        a.add(i[k]);
                        2 != i.length || c || i[0] instanceof mono.Cube && (i[0].setSelectable(h.mainNode.isSelectable()), i[0].setEditable(h.mainNode.isEditable()), i[0].setClient("mainVisible", !1), a.remove(h.mainNode, !0), h.mainNode = i[0]),
                        h.mainNode ? e = h.mainNode: h.rootNodes && 1 == h.rootNodes.length && (e = h.rootNodes[0])
                    }
                }
                return e
            },
            getHostNodeAssembleSize: function(a) {
                var b, c = this.getModelNode(a);
                if (c || (c = this._modellib.getModelNodeByTemplateName(a)), c) {
                    var d = ModelFactory.getModelFromModelNode(this._modellib, c);
                    d && (b = d.assembleSize),
                    d instanceof modelimp.ModelImp && d.mainNode && d.mainNode.getClient("assembleSize") && (b = d.mainNode.getClient("assembleSize"))
                }
                return b
            },
            loadTemplatesAssembleSize: function(a, b, c) {
                if (this.loadResource !== TYPE_CLOUD) return this.getHostNodeAssembleSize(a);
                var d = {
                    module: "templates",
                    method: "get",
                    arguments: {
                        id: a
                    }
                },
                e = function() {
                    var a = JSON.parse(arguments[0]);
                    if (a.error) return void alert(a.error);
                    var d = a.value;
                    if (d) {
                        var e = JSON.parse(d.data);
                        this.loadSharedPrimitive(e.primitives),
                        this.loadSharedAssemble(e.assembles);
                        var f = this.getHostNodeAssembleSize(d.gid);
                        c && c.call(b, f)
                    }
                };
                require(MONO_URL, d, e, this)
            },
            disposeComponents: function(a, b) {
                this.nodesMap = {},
                this.assembleCache = [],
                this.primitives = [],
                this.primitivesCache = [],
                this.roots = [];
                for (var c = 0; c < a.length; c++) delete a[c].visited,
                delete a[c].assembleID;
                for (var c = 0; c < b.length; c++) delete b[c].visited
            },
            serialize3DDate: function(a, b, c, d) {
                if (!a.visited) {
                    if (a.visited = !0, !ModelUtils.containsInArray(b, a.getId(), "_id") && !ModelUtils.containsInArray(c, a.getId(), "_id")) return;
                    a.getParent() || this.roots.push(a);
                    var e = this.pushPrimitive(a, d);
                    if (this.nodesMap[a.getId()] = a, a.getChildren().size() > 0) {
                        var f, g = a.getChildren(),
                        h = this.createAssembleID(a.getId()),
                        i = ModelUtils.indexInArray(this.assembleCache, h);
                        f = i >= 0 ? this.assembleCache[i] : new modellib.Assemble(h);
                        var j = {
                            id: e.id,
                            oid: a.getClient(OID)
                        };
                        this.wrapAnimation(j, a),
                        this.wrapCustomProps(j, a),
                        f.addChild(j),
                        a.assembleID = f.id;
                        var k = mono.Utils.getBoundingBox([a], !0);
                        f.boundingBox = k,
                        f.setHost(a.getId()),
                        ModelUtils.containsInArray(this.assembleCache, f.id) || this.assembleCache.push(f);
                        for (var l = 0; l < g._as.length; l++) {
                            var m = g._as[l];
                            if (this.serialize3DDate(m, b, c, d), m.getChildren()._as.length <= 0) {
                                var j = {
                                    id: m.getId(),
                                    pos: m.getPosition(),
                                    oid: m.getClient(OID)
                                };
                                this.wrapAnimation(j, m),
                                this.wrapCustomProps(j, m),
                                f.addChild(j)
                            } else {
                                var n = this.createAssembleID(m.getId()),
                                j = {
                                    id: n,
                                    pos: m.getPosition(),
                                    oid: m.getClient(OID)
                                };
                                this.wrapAnimation(j, m),
                                this.wrapCustomProps(j, m),
                                f.addChild(j)
                            }
                        }
                    }
                }
            },
            pushPrimitive: function(a, b) {
                var c = this.getModelInfo(a);
                return this.primitivesCache.push(c),
                c
            },
            getCommonInfo: function(a) {
                var b = {};
                return b.id = a.getId(),
                a.getScale() && (b.scale = a.getScale()),
                a.getPosition() && (b.pos = a.getPosition()),
                a.getRotation() && (b.rot = a.getRotation()),
                a.getGroupId() && (b.groupid = a.getGroupId()),
                b
            },
            getStyleInfo: function(a, b) {
                b.styleMap[M_AMBIENT] && (a.ambient = b.getStyle(M_AMBIENT)),
                b.styleMap[M_COLOR] && (a.color = b.getStyle(M_COLOR)),
                b.styleMap[M_MAP_SRC] && (a.dt = b.getStyle(M_MAP_SRC)),
                b.styleMap[M_TRANSPARENT] && (a.transparent = b.getStyle(M_TRANSPARENT)),
                b.styleMap[M_TYPE] && (a.types = b.getStyle(M_TYPE)),
                b.styleMap[M_VISIBLE] && (a.visible = b.getStyle(M_VISIBLE)),
                b.styleMap[M_OPACITY] && (a.opacity = b.getStyle(M_OPACITY)),
                b.styleMap[M_TEXTURE_FLIPX] && (a.flipX = b.getStyle(M_TEXTURE_FLIPX)),
                b.styleMap[M_TEXTURE_FLIPY] && (a.flipY = b.getStyle(M_TEXTURE_FLIPY)),
                b.styleMap[M_SPECULARSTRENGTH] && (a.specularStrength = b.getStyle(M_SPECULARSTRENGTH)),
                b.styleMap[M_POLYGONOFFSET] && (a.polygonOffset = b.getStyle(M_POLYGONOFFSET)),
                b.styleMap[M_POLYGONOFFSETFACTOR] && (a.polygonOffsetFactor = b.getStyle(M_POLYGONOFFSETFACTOR)),
                b.styleMap[M_POLYGONOFFSETUNITS] && (a.polygonOffsetUnits = b.getStyle(M_POLYGONOFFSETUNITS)),
                b.styleMap["m.envmap.image"] && (a.envmap = b.getStyle("m.envmap.image")),
                b.styleMap["m.reflectRatio"] && (a.reflectRatio = b.getStyle("m.reflectRatio")),
                b.styleMap["m.normalmap.image"] && (a.normalmap = b.getStyle("m.normalmap.image")),
                b.styleMap["m.normalScale"] && (a.normalScale = b.getStyle("m.normalScale")),
                b.styleMap["m.normalType"] && (a.normalType = b.getStyle("m.normalType")),
                b.styleMap["m.specularmap.image"] && (a.specularmap = b.getStyle("m.specularmap.image")),
                b.styleMap["m.specular"] && (a.specular = b.getStyle("m.specular")),
                b.styleMap["m.lightmap.image"] && (a.lightmap = b.getStyle("m.lightmap.image"));
                var c = b.getStyle(M_MAP_REPEAT);
                if (a.repeat = [], c instanceof Array) for (var d = 0; d < c.length; d++) c[d] ? a.repeat.push([c[d].x, c[d].y]) : a.repeat.push([1, 1]);
                else a.repeat = [c.x, c.y]
            },
            getClientInfo: function(a, b) {
                b.getClient("object3dId") && (a.object3dId = b.getClient("object3dId")),
                b.getClient("scaleValue") && (a.scaleValue = b.getClient("scaleValue")),
                Utils.isNotNull(b.getClient("mainVisible")) && (a.mainVisible = b.getClient("mainVisible")),
                b.getClient(OID) && (a.oid = b.getClient(OID)),
                b.getClient("animationGroup") && (a.animationGroup = b.getClient("animationGroup"))
            },
            getModelInfo: function(a) {
                var b = this.getCommonInfo(a);
                return this.getObject3DInfo(b, a),
                this.getStyleInfo(b, a),
                this.getClientInfo(b, a),
                b
            },
            getObject3DInfo: function(a, b) {
                return b instanceof mono.Cube ? this.getInfoOfCube(a, b) : b instanceof mono.Sphere ? this.getInfoOfSphere(a, b) : b instanceof mono.Cylinder ? this.getInfoOfCylinder(a, b) : b instanceof mono.Torus ? this.getInfoOfTorus(a, b) : b instanceof mono.PathNode ? this.getInfoOfPathNode(a, b) : b instanceof mono.TextNode ? this.getInfoOfTextNode(a, b) : b instanceof mono.ComboNode ? this.getInfoOfComboNode(a, b) : b instanceof mono.LatheNode ? this.getInfoOfLatheNode(a, b) : b instanceof mono.Billboard ? this.getInfoOfBillboard(a, b) : b instanceof mono.Entity ? this.getInfoOfEntity(a, b) : a
            },
            getInfoOfCube: function(a, b) {
                a.size = {
                    x: b.width,
                    y: b.height,
                    z: b.depth
                },
                a.className = "mono.Cube";
                for (var c = 0; 6 > c; c++) b.getClient("face" + c) && (a["face" + c] = b.getClient("face" + c));
                var d = (b.material, b.getWrapMode());
                return d && (a.wrapMode = d),
                a
            },
            getInfoOfSphere: function(a, b) {
                var c = 2 * b.radius;
                return a.size = {
                    x: c,
                    y: c,
                    z: c
                },
                b.material,
                a.className = "mono.Sphere",
                a
            },
            getInfoOfBillboard: function(a, b) {
                return a.id = b.getId(),
                a.scale = {
                    x: b.getScale().x,
                    y: b.getScale().y,
                    z: b.getScale().z
                },
                a.className = "mono.Billboard",
                a.dt = b.getStyle(M_MAP_SRC),
                a.alignment = b.getStyle(M_ALIGNMENT),
                a.transparent = b.getStyle(M_TRANSPARENT),
                a.opacity = b.getStyle(M_OPACITY),
                a.pos = {
                    x: b.getPosition().x,
                    y: b.getPosition().y,
                    z: b.getPosition().z
                },
                a[OID] = b.getClient(OID),
                a
            },
            getInfoOfCylinder: function(a, b) {
                var c = b.radiusTop,
                d = b.radiusBottom,
                e = b.height;
                return a.size = {
                    x: c,
                    y: e,
                    z: d
                },
                b.material,
                a.className = "mono.Cylinder",
                a.radialSegments = b.segmentsR,
                a.openTop = b.openTop,
                a.openBottom = b.openBottom,
                a
            },
            getInfoOfTorus: function(a, b) {
                a[SHAPE_TYPE] = "mono.Torus",
                a.radialSegments = b.segmentsR,
                a.radius = b.radius,
                a.tube = b.tube,
                a.tubularSegments = b.segmentsT,
                a.arc = b.arc;
                var c = b.radius + b.tube;
                return a[SPACE_SIZE] = {
                    x: c,
                    y: c,
                    z: c
                },
                a
            },
            getInfoOfPathNode: function(a, b) {
                return a[SHAPE_TYPE] = "mono.PathNode",
                a.radius = b.radius,
                a.path = b.getPath().toArray(),
                a.segments = b.segments,
                a.segmentsR = b.segmentsR,
                a.startCap = b.startCap,
                a.endCap = b.endCap,
                a.startCapSize = b.startCapSize,
                a.endCapSize = b.endCapSize,
                a.segmentsCap = b.segmentsCap,
                a
            },
            getInfoOfTextNode: function(a, b) {
                return a[SHAPE_TYPE] = "mono.TextNode",
                a.text = b.text,
                a.textSize = b.size,
                a.height = b.height,
                a.weight = b.weight,
                a.style = b.style,
                a.curveSegments = b.curveSegments,
                a.bevelEnabled = b.bevelEnabled,
                a
            },
            getInfoOfComboNode: function(a, b) {
                var c = [];
                if (a[SHAPE_TYPE] = "mono.ComboNode", a.operators = b.getOperators(), b.getCombos()) for (var d = b.getCombos(), e = 0; e < d.length; e++) {
                    var f = this.pushPrimitive(d[e]);
                    c.push({
                        id: f.id
                    })
                }
                return a.combos = c,
                a.centralized = b.isCentralized(),
                a
            },
            getInfoOfLatheNode: function(a, b) {
                return a[SHAPE_TYPE] = "mono.LatheNode",
                a[PATH] = b.getPath().toArray(),
                a[SEGMENTSH] = b.getSegmentsH(),
                a[SEGMENTSR] = b.getSegmentsR(),
                a[ARC] = b.getArc(),
                a[START_CLOSED] = b.isStartClosed(),
                a[END_CLOSED] = b.isEndClosed(),
                a
            },
            getInfoOfEntity: function(a, b) {
                return a[SHAPE_TYPE] = "mono.Entity",
                a[VERTICES] = b.getVertices(),
                a[FACES] = b.getFaces(),
                a[UVS] = b.getUvs(),
                a
            },
            createAssembleID: function(a) {
                return "assemble" + a
            },
            wrapAnimation: function(a, b) {
                var c = b.getClient("animation");
                c && "" != c && (a.animation = c)
            },
            wrapCustomProps: function(a, b) {
                var c = b.getClient(CUSTOM_PROPS),
                d = PropertyConsts.CUSTOM_PROPS,
                e = !1,
                f = !0;
                if (c) for (var g in c) {
                    if (!d[g]) {
                        f = !1;
                        break
                    }
                    if (c[g] != d[g]) {
                        f = !1;
                        break
                    }
                }
                if (f) {
                    var h;
                    for (var i in c) b.getClient(c[i]) && (e = !0)
                } else e = !0;
                if (e && c) {
                    var h;
                    for (var i in c) h = c[i],
                    a[h] = b.getClient(h);
                    a.customProps = c
                }
            }
        }),
        ModelUtils = {};
        var a;
        ModelUtils.setDefaultModelManager = function(b) {
            a = b
        };
        var b = (180 / Math.PI, Math.PI / 180),
        c = function(a) {
            return a * b
        },
        d = function(a) {
            return a ? !0 : !1
        };
        require = function(a, b, c, d, f) {
            e(a, b, c, d, f)
        };
        var e = function(a, b, c, e, f) {
            if (d(a) || c("error: url error, " + a), !navigator.onLine) return void alert("NETWORK CONNECT ERROR");
            var g = Utils.createProgressBar(40, 50),
            h = new FormData,
            i = b.module;
            i && (a += "/" + i);
            var j = b.method;
            j && (a += "/" + j);
            var k = b.arguments;
            if (k) for (var l in k) h.append(l, k[l]);
            var m = new XMLHttpRequest;
            m.open("POST", a, !0),
            m.withCredentials = !0,
            m.timeout = 15e4;
            var n;
            m.ontimeout = function() {
                g && g.parentNode && g.parentNode.removeChild(g),
                n && n.parentNode && n.parentNode.removeChild(n),
                alert("request timeout")
            },
            setTimeout(function() {
                if ((4 != m.readyState || 200 != m.status) && !f) {
                    n = Utils.addMask("progressBars"),
                    n.style.zIndex = 1001,
                    g.style.zIndex = 1002;
                    var a = n.offsetWidth,
                    b = n.offsetHeight;
                    g.style.left = a / 2 - 20 + "px",
                    g.style.top = b / 2 - 25 + "px",
                    document.body.appendChild(g)
                }
            },
            1e3);
            var o = function(a) {
                c && c.call(this.scope, a)
            };
            o.scope = e,
            m.onreadystatechange = function() {
                if (navigator.onLine || (g && g.parentNode && g.parentNode.removeChild(g), n && n.parentNode && n.parentNode.removeChild(n), alert("NETWORK CONNECT ERROR")), 404 == m.status && (g && g.parentNode && g.parentNode.removeChild(g), n && n.parentNode && n.parentNode.removeChild(n)), 4 == m.readyState && 200 == m.status) {
                    if (c) {
                        var a = JSON.parse(m.responseText);
                        a.error ? "Login First" == a.error ? document.location.href = "login.html": alert(a.error) : c.call(e, m.responseText)
                    }
                    g && g.parentNode && g.parentNode.removeChild(g),
                    n && n.parentNode && n.parentNode.removeChild(n)
                }
            },
            m.send(h)
        },
        f = function(a, b) {
            for (var c = 0; c < a.length; c++) if (b == a[c].id) return a[c];
            return null
        };
        ModelUtils.containsInArray = function(a, b, c) {
            return ModelUtils.indexInArray(a, b, c) >= 0 ? !0 : !1
        },
        ModelUtils.indexInArray = function(a, b, c) {
            c || (c = "id");
            for (var d = 0; d < a.length; d++) if (b == a[d][c]) return d;
            return - 1
        };
        var g = function(a, b) {
            if (a && a instanceof Array) for (var c = 0; c < a.length; c++) {
                var d = a[c];
                if (d && d.id == b) return ! 0
            }
            return ! 1
        };
        ModelUtils.covertTo3DPosition = function(a) {
            var b = a.getCenterLocation(),
            c = {};
            c.x = b.x;
            var d = a.getClient("size");
            return d && (c.y = d.y / 2),
            c.z = b.y,
            c
        },
        ModelUtils.isEquals = function(a, b) {
            return a ? a.x == b.x && a.y == b.y && a.z == b.z: b ? !1 : !0
        },
        ModelUtils.containsID = function(a, b) {
            for (var c = 0; c < a.length; c++) if (b == a[c].id) return ! 0;
            return ! 1
        },
        ModelUtils.removeChild = function(a, b) {
            for (var c, d = 0; d < a.length; d++) b == a[d].id && (c = a[d]);
            if (c) {
                var e = a.indexOf(c);
                e > -1 && a.splice(e, 1)
            }
        },
        ModelUtils.copyProperties = function(a, b, c) {
            for (var d in b) d != c && (a[d] = b[d])
        },
        ModelUtils.copyNeedProperties = function(a, b) {
            for (var c in b) a[c] ? a[c] != b[c] && (a[c] = b[c]) : a[c] = b[c]
        },
        ModelUtils.mergeBoundingBox = function(a, b, c) {
            a || (a = new mono.BoundingBox),
            b || (b = new mono.BoundingBox);
            var d = (b.max.x - b.min.x) / 2,
            e = (b.max.y - b.min.y) / 2,
            f = (b.max.z - b.min.z) / 2,
            g = c.x + d,
            h = c.y + e,
            i = c.z + f,
            j = c.x - d,
            k = c.y - e,
            l = c.z - f,
            m = {
                x: a.max.x > g ? a.max.x: g,
                y: a.max.y > h ? a.max.y: h,
                z: a.max.z > i ? a.max.z: i
            },
            n = {
                x: a.min.x < j ? a.min.x: j,
                y: a.min.y < k ? a.min.y: k,
                z: a.min.z < l ? a.min.z: l
            };
            return new mono.BoundingBox(n, m)
        },
        ModelUtils.getCenterOfBoundingBox = function(a) {
            return {
                x: (a.max.x + a.min.x) / 2,
                y: (a.max.y + a.min.y) / 2,
                z: (a.max.z + a.min.z) / 2
            }
        },
        modelimp.ModelImp = function() {
            modelimp.ModelImp.superClass.constructor.apply(this)
        },
        twaver.Util.ext("modelimp.ModelImp", Object, {
            parse: function(a) {
                this._modelnode = a
            },
            getContents: function() {
                return this._contents
            },
            get3DObjects: function() {
                return default3DShape
            },
            get2DObjects: function() {
                return defautl2DShape
            },
            getValue: function(a, b, c) {
                if (!a) return null;
                var d = a[b];
                return (void 0 === d || null === d) && 3 == arguments.length && (d = arguments[2]),
                d
            }
        }),
        modelimp.AssembleModel = function() {
            modelimp.AssembleModel.superClass.constructor.apply(this),
            this._contents = [],
            this.hostModelNode = null,
            this.mainNode = null,
            this.version
        },
        twaver.Util.ext("modelimp.AssembleModel", modelimp.ModelImp, {
            appendChild: function(a) {
                this._contents.push(a)
            },
            get3DObjects: function(a) {
                for (var b = [], c = 0; c < this._contents.length; c++) {
                    var d = this._contents[c];
                    this._contents[c].get3DObjects || console.log("aaaaaa");
                    var e = this._contents[c].get3DObjects(this.version);
                    if (a && (this.ishost || this.templateName)) {
                        var f = this.getValue(this, "assembleSize");
                        this.mainNode = new mono.Cube(f.x, f.y, f.z),
                        this.mainNode.setClient("mainVisible", !1),
                        this.mainNode.setStyle("m.transparent", !0),
                        this.mainNode.setStyle("m.opacity", .001)
                    }
                    d.ishost && (this.hostModelNode = e[0], this.pos && this.hostModelNode.setPosition(this.pos.x, this.pos.y, this.pos.z)),
                    b = b.concat(e)
                }
                if (!a && this.mainNode && (this.mainNode = void 0), this.hostModelNode) for (var c = 0; c < b.length; c++) this.hostModelNode != b[c] && (b[c].getParent() || b[c].setParent(this.hostModelNode));
                if (this.mainNode) {
                    b = b.concat(this.mainNode);
                    for (var c = 0; c < b.length; c++) this.mainNode != b[c] && (b[c].getParent() || b[c].setParent(this.mainNode))
                }
                this.rootNodes = [];
                for (var c = 0; c < b.length; c++) b[c].getParent() || this.rootNodes.push(b[c]);
                return b
            },
            get2DObjects: function(a) {
                for (var b = [], c = 0; c < this._contents.length; c++) {
                    var d = this._contents[c],
                    e = this._contents[c].get2DObjects();
                    if (a && (this.ishost || this.templateName)) {
                        var f = this.getValue(this, "assembleSize");
                        this.mainNode = new PrimitiveNode,
                        this.mainNode.setClient("mainVisible", !1),
                        this.mainNode.setClient("assembleSize", f),
                        this.mainNode.setClient("gid", this.id),
                        this.mainNode.setSize(f.x, f.z),
                        this.isEntity && this.mainNode.setClient("isEntity", !0)
                    }
                    d.ishost && (this.hostModelNode = e[0]),
                    b = b.concat(e)
                }
                if (!a && this.mainNode && (this.mainNode = void 0), this.hostModelNode) {
                    var g = (this.getValue(this, "rot"), this.getValue(this, "pos"));
                    g && (this.hostModelNode.setCenterLocation({
                        x: g.x,
                        y: g.y
                    }), this.hostModelNode.setClient("position", g));
                    var h = this.getValue(this, "scaleValue");
                    h && this.hostModelNode.setClient("scaleValue", h);
                    for (var i = this.hostModelNode.getCenterLocation(), c = 0; c < b.length; c++) if (this.hostModelNode != b[c]) {
                        var j = b[c].getCenterLocation();
                        b[c].getHost() || (b[c].setCenterLocation({
                            x: i.x + j.x,
                            y: i.y + j.y
                        }), b[c].setHost(this.hostModelNode), b[c].setParent(this.hostModelNode))
                    }
                }
                if (this.mainNode) {
                    b = b.concat(this.mainNode);
                    for (var c = 0; c < b.length; c++) this.mainNode != b[c] && (b[c].getParent() || (b[c].setParent(this.mainNode), b[c].setHost(this.mainNode)))
                }
                return b
            }
        }),
        modelimp.PrimitiveModel = function() {
            modelimp.PrimitiveModel.superClass.constructor.apply(this),
            this.databox = new mono.DataBox
        },
        twaver.Util.ext("modelimp.PrimitiveModel", modelimp.ModelImp, {
            getContents: function() {
                return this._contents
            },
            get3DObjects: function(a) {
                var b = [];
                if (a) {
                    var c = {};
                    for (var d in this) {
                        var e = this[d];
                        "function" == typeof e && e.constructor == Function || e instanceof mono.DataBox || (console.log(d, ":", this[d] + ">>>>>>>"), c[d] = this[d])
                    }
                    this.databox.clear();
                    var f = new mono.SerializationSettings;
                    f.isDataBoxSerializable = !1;
                    var g = new mono.JsonSerializer(this.databox, f),
                    h = g.serialize(),
                    i = JSON.parse(h);
                    i.datas.push(c),
                    g.deserialize(JSON.stringify(i)),
                    b.push(this.dataBox.getDataAt(0))
                } else b.push(GeometryTranslater.get3DGeometryFromModelImp(this));
                return b
            },
            get2DObjects: function() {
                var a = [],
                b = new PrimitiveNode,
                c = this.getValue(this, "className", "mono.Cube");
                b.setClient("className", c),
                this.setBasicInfo(b);
                var d = {},
                e = this.getValue(this, "radialSegments");
                e && (d.radialSegments = e),
                this.radius && (d.radius = this.radius),
                this.tube && (d.tube = this.tube),
                this.tubularSegments && (d.tubularSegments = this.tubularSegments),
                this.arc && (d.arc = this.arc);
                var f = this.getValue(this, "alignment");
                f && (d.alignment = f);
                var g = this.getValue(this, "mainVisible");
                return Utils.isNotNull(g) && (d.mainVisible = g),
                "mono.Cube" === c ? this.setCubeInfo(d) : "mono.PathNode" === c ? this.setPathNodeInfo(d) : "mono.TextNode" === c ? this.setTextNodeInfo(d) : "mono.ComboNode" === c ? this.setComboNodeInfo(d) : "mono.LatheNode" === c ? this.setLatheNodeInfo(d) : "mono.Cylinder" === c && this.setCylinderInfo(d),
                b.setClient("other", d),
                a.push(b),
                a
            },
            setBasicInfo: function(a) {
                var b = this.getValue(this, "selectable");
                a.setClient("selectable", b);
                var c = this.getValue(this, "editable");
                a.setClient("editable", c);
                var d = this.getValue(this, "size") || this.getValue(this, "assembleSize");
                d && a.setClient("size", d);
                var e = this.getValue(this, "scale");
                e && a.setClient("scale", e);
                var f = this.getValue(this, "dt");
                f && a.setClient("texture", f);
                var g = this.getValue(this, "rot");
                g && a.setClient("rot", g);
                var h = this.getValue(this, "scaleValue");
                h && a.setClient("scaleValue", h);
                var i = this.getValue(this, "transparent");
                i && a.setClient("transparent", i);
                var j = this.getValue(this, "repeat");
                j && a.setClient("repeat", j);
                var k = this.getValue(this, "types");
                k && a.setClient("types", k);
                var l = this.getValue(this, "ov");
                l && (a.setImage(Utils.Path + l), Utils.registerImage(Utils.Path + l, null, null,
                function(b, c) {
                    a.setSize(b, c)
                }));
                var m = this.getValue(this, "oid");
                m && a.setClient(OID, m);
                var n = this.getValue(this, "id");
                n || (n = this.pid),
                a.setClient(GID, n);
                var o = this.getValue(this, "visible");
                a.setClient("visible", o),
                a.setClient("opacity", this.getValue(this, "opacity"));
                var p = this.getValue(this, "pos");
                p && a.setClient("position", p),
                this.ishost && (a.ishost = !0);
                var q = this.getValue(this, "color");
                q && a.setClient("colors", q),
                a.setClient("ambient", this.getValue(this, "ambient"));
                var r = this.getValue(this, TAG_ANIMATION);
                r && a.setClient(TAG_ANIMATION, r);
                var s = this.getValue(this, "animationGroup");
                s && a.setClient("animationGroup", s),
                a.setClient("groupid", this.getValue(this, "groupid"));
                var t = this.getValue(this, CUSTOM_PROPS);
                if (t) {
                    for (var u in t) a.setClient(t[u], this.getValue(this, t[u]));
                    a.setClient(CUSTOM_PROPS, t)
                }
                var v = this.getValue(this, "flipX");
                v && a.setClient("flipX", v);
                var w = this.getValue(this, "flipY");
                w && a.setClient("flipY", w);
                var x = this.getValue(this, PropertyConsts.LAYERID);
                x && a.setClient(PropertyConsts.LAYERID, x);
                var y = this.getValue(this, "specularStrength");
                y && a.setClient("specularStrength", y);
                var z = this.getValue(this, "polygonOffset");
                Utils.isNotNull(z) && a.setClient("polygonOffset", z);
                var A = this.getValue(this, "polygonOffsetFactor");
                A && a.setClient("polygonOffsetFactor", A);
                var B = this.getValue(this, "polygonOffsetUnits");
                B && a.setClient("polygonOffsetUnits", B);
                var C = this.getValue(this, "envmap");
                C && a.setClient("envmap", C);
                var D = this.getValue(this, "reflectRatio");
                D && a.setClient("reflectRatio", D);
                var E = this.getValue(this, "normalmap");
                E && a.setClient("normalmap", E);
                var F = this.getValue(this, "normalScale");
                F && a.setClient("normalScale", F);
                var G = this.getValue(this, "normalType");
                G && a.setClient("normalType", G);
                var H = this.getValue(this, "specularmap");
                H && a.setClient("specularmap", H);
                var I = this.getValue(this, "specular");
                I && a.setClient("specular", I);
                var J = this.getValue(this, "lightmap");
                J && a.setClient("lightmap", J)
            },
            setCubeInfo: function(a) {
                this.wrapMode && (a.wrapMode = this.wrapMode)
            },
            setPathNodeInfo: function(a) {
                this.path && (a.path = this.path),
                this.segments && (a.segments = this.segments);
                var b = this.getValue(this, "segmentsR");
                b && (a.segmentsR = b),
                this.startCap && (a.startCap = this.startCap),
                this.endCap && (a.endCap = this.endCap),
                this.startCapSize && (a.startCapSize = this.startCapSize),
                this.endCapSize && (a.endCapSize = this.endCapSize),
                this.segmentsCap && (a.segmentsCap = this.segmentsCap)
            },
            setTextNodeInfo: function(a) {
                this.text && (a.text = this.text),
                this.textSize && (a.textSize = this.textSize),
                this.height && (a.height = this.height),
                this.weight && (a.weight = this.weight),
                this.style && (a.style = this.style),
                this.curveSegments && (a.curveSegments = this.curveSegments),
                this.bevelEnabled && (a.bevelEnabled = this.bevelEnabled)
            },
            setComboNodeInfo: function(a) {
                this.operators && (a.operators = this.operators),
                this.combos && (a.combos = this.combos),
                this.centralized && (a.centralized = this.centralized)
            },
            setLatheNodeInfo: function(a) {
                this[PATH] && (a.path = this[PATH]),
                this[SEGMENTSH] && (a.segmentsH = this[SEGMENTSH]),
                this[SEGMENTSR] && (a.segmentsR = this[SEGMENTSR]),
                this[ARC] && (a.arc = this[ARC]),
                void 0 !== this[START_CLOSED] && (a.startClosed = this[START_CLOSED]),
                void 0 !== this[END_CLOSED] && (a.endClosed = this[END_CLOSED])
            },
            setCylinderInfo: function(a) {
                Utils.isNotNull(this.openTop) && (a.openTop = this.openTop),
                Utils.isNotNull(this.openBottom) && (a.openBottom = this.openBottom)
            }
        }),
        modelimp.Normal = function() {
            modelimp.Normal.superClass.constructor.apply(this)
        },
        twaver.Util.ext("modelimp.Normal", modelimp.PrimitiveModel, {
            get2DObjects: function() {
                var a = [],
                b = getValue(this, "size"),
                d = {
                    x: -b.x / 2,
                    y: 0
                },
                e = {
                    x: b.x / 2,
                    y: 0
                },
                f = getValue(this, "rot");
                if (f) {
                    var g = c(f.y),
                    h = _twaver.math.createMatrix(g, 0, 0);
                    d = h.transform(d),
                    e = h.transform(e)
                }
                var i = new ImageShapeNode,
                j = [d, e];
                return i.setStyle("vector.outline.color", "#333333"),
                b && (i.setStyle("vector.outline.width", b.z), i.setClient("size", b)),
                i.setStyle("shapenode.closed", !1),
                i.setPoints(new twaver.List(j)),
                a.push(i),
                a
            }
        }),
        modelimp.FloorShapedModel = function() {
            modelimp.FloorShapedModel.superClass.constructor.apply(this)
        },
        twaver.Util.ext("modelimp.FloorShapedModel", modelimp.PrimitiveModel, {
            get3DObjects: function() {
                return default3DShape
            },
            get2DObjects: function() {
                var a = this.getValue(this, "dt"),
                b = this.getValue(this, OUTLINE_SHAPE),
                c = this.getValue(this, TRA_PAR),
                d = this.getValue(this, OPA),
                e = this.getValue(this, PropertyConsts.LAYERID);
                if (b.length % 3 == 0) {
                    for (var f = [], g = 0; g < b.length; g += 3) f.push({
                        x: b[g],
                        y: b[g + 2]
                    });
                    var h = new FloorShapeNode;
                    return h.setLayerId(bottomLayer.getId()),
                    h.setPoints(new twaver.List(f)),
                    h.setClient(SHAPE_TYPE, "FloorShapedModel"),
                    h.setClient(GID, this.getID()),
                    h.setClient(TRA_PAR, c),
                    h.setClient(OPA, d),
                    e && h.setClient(PropertyConsts.LAYERID, e),
                    a && (Utils.registerImage(Utils.Path + a), h.setClient(IMAGE_SRC, Utils.Path + a)),
                    [h]
                }
                return null
            }
        }),
        modelimp.RoomModel = function() {
            modelimp.RoomModel.superClass.constructor.apply(this)
        },
        twaver.Util.ext("modelimp.RoomModel", modelimp.FloorShapedModel, {
            get3DObjects: function() {
                return []
            },
            get2DObjects: function() {
                var a = this.getValue(this, OUTLINE_SHAPE),
                b = this.getValue(this, TRA_PAR),
                c = this.getValue(this, OPA),
                d = this.getValue(this, PropertyConsts.LAYERID);
                if (a.length % 3 == 0) {
                    for (var e = [], f = 0; f < a.length; f += 3) e.push({
                        x: a[f],
                        y: a[f + 2]
                    });
                    var g = this.getValue(this, "size"),
                    h = new ImageShapeNode;
                    return g && h.setClient("size", {
                        x: g.x,
                        y: g.y,
                        z: g.z
                    }),
                    h.setPoints(new twaver.List(e)),
                    h.setClient("className", "RoomModel"),
                    h.setClient("gid", this.getID()),
                    h.setClient(TRA_PAR, b),
                    h.setClient(OPA, c),
                    d && h.setClient(PropertyConsts.LAYERID, d),
                    [h]
                }
                return null
            }
        }),
        modelimp.BlockModel = function() {
            modelimp.BlockModel.superClass.constructor.apply(this)
        },
        twaver.Util.ext("modelimp.BlockModel", modelimp.PrimitiveModel, {
            get3DObjects: function() {
                return default3DShape
            },
            get2DObjects: function() {
                var a = this.getValue(this, "dt"),
                b = this.getValue(this, "dsize"),
                c = this.getValue(this, "pos"),
                d = this.getValue(this, "btype"),
                e = this.getValue(this, "specularStrength"),
                f = this.getValue(this, TRA_PAR),
                g = this.getValue(this, OPA),
                h = this.getValue(this, PropertyConsts.LAYERID),
                i = null;
                "window" == d ? (i = new Window, i.setClient("depth", b.z)) : "door" == d ? (i = new Door, i.setClient("depth", b.z)) : i = "cutoff" == d ? new Cutoff: new Block,
                i.setClient("length", b.x),
                i.setClient("height", b.y),
                e && i.setClient("specularStrength", e),
                c && i.setClient("positionY", c.y),
                a && i.setClient("picture", Utils.Path + a);
                var j = this.getValue(this, "rot");
                return j && i.setClient("angle", j.y),
                f && i.setClient(TRA_PAR, f),
                g && i.setClient(OPA, g),
                h && i.setClient(PropertyConsts.LAYERID, h),
                i.setClient("className", "BlockModel"),
                i.setClient("gid", this.getID()),
                [i]
            }
        }),
        ModelFactory = {},
        ModelFactory.models = {},
        ModelFactory.createModel = function(a) {
            var b = a;
            b && b.indexOf(".") < 0 && (b = "modelimp." + b);
            var c = _twaver.newInstance(b);
            return c
        },
        ModelFactory.getModelFromModelNode = function(a, b) {
            if (!b) return null;
            var c = b.pid;
            c || (c = b.id);
            var d = ModelFactory.models[c];
            return d || (d = ModelFactory.createModelFromModelNode(a, b), d && (ModelFactory.models[c] = d)),
            d
        },
        ModelFactory.createModelFromModelNode = function(a, b) {
            if (!b) return null;
            var c = a.getValue(b, "type"),
            d = a.getValue(b, "shape");
            if (modellib.ModelNode.TYPE_ASSEMBLE == c) {
                var e = null;
                if (d || (d = "AssembleModel"), e = ModelFactory.createModel(d)) {
                    e.id = b.id,
                    e.pid = b.pid;
                    for (var f = a.getModelNodeContents(b), g = 0; g < f.length; g++) {
                        var h = f[g],
                        i = a.getModelNode(h.id),
                        j = {},
                        k = ModelFactory.getModelFromModelNode(a, i);
                        ModelUtils.copyNeedProperties(j, k),
                        ModelUtils.copyNeedProperties(j, h),
                        e.appendChild(j)
                    }
                    ModelUtils.copyProperties(e, b)
                }
                return e
            }
            d || (d = "PrimitiveModel");
            var l = ModelFactory.createModel(d);
            return l.id = b.id,
            ModelUtils.copyProperties(l, b),
            l
        }
    } (),
    TargetFlagNode = function(a) {
        TargetFlagNode.superClass.constructor.apply(this, arguments),
        this.type = a || p.TARGET_POINT,
        this.type == p.ORIGINAL_POINT ? (this.setImage("images/originalpoint.png"), this.setClient(SPACE_POS_Y, 0)) : (this.setImage("images/targetpoint.png"), this.setClient(SPACE_POS_Y, 100)),
        this.showPoint = !0
    },
    twaver.Util.ext("TargetFlagNode", twaver.Follower, {
        isShowPoint: function() {
            return this.showPoint
        },
        setShowPoint: function(a) {
            this.showPoint = a
        },
        getType: function() {
            return this.type
        }
    });
    var p = {
        TARGET_POINT: "targetPoint",
        ORIGINAL_POINT: "originalPoint"
    };
    RoomInteraction = function(a) {
        RoomInteraction.superClass.constructor.call(this, a)
    },
    twaver.Util.ext("RoomInteraction", twaver.vector.interaction.BaseInteraction, {
        lastIndex: -1,
        lastElement: null,
        lastLogicalPoint: null,
        mouseDown: null,
        mouseMoved: null,
        horizontal: null,
        vertical: null,
        block: null,
        addPointCursor: "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAF7SURBVHjatJSxasJQFIa/q0GQBOLWpVIXBbO6iA+gQ8HVxTkiuHXu1FcQJM59Ajd9ACdnBV0qvoCBBCFU0uXapjHGRPRfkns5/8e593J+UavVCKkJtIAGUJV7K2AOTIFZsHixWBAlJfBfAgZAr1+xNaPg8aJ+A7B1lfpyn6uP1roJWMAQ+CJGSgD6YZbtbrvoks/6/4oM3cPQPV6fXW2yU9/GG/0JeI+DZ+R3YJbtbqfknEGDymd9OiUHs2x35emIAzeBXrvoklSytie9F8GtfsXW4jqN6rxfsTX5yBfBDaPgkVbS04gDV0+vn0bSU732eHdXBlhtXSW1UXpWceD5cp9LDZaeeRx4OlrrzuEoEkMPR8ForTtyxC+CZ4A12amJwbLWCudG1EgP5ZhGjnSw08lOZbzRP4HhKYCEED4gfP/PJwLpFhdCLPe50/EtCf3NiWvgxLEZjspIcHBxq+4GliCS5HFqdmjth/ceNtI3dRy+PiHE2f7DOv4ZAHRil+NB+pB1AAAAAElFTkSuQmCC'),auto",
        setUp: function() {
            this.addListener("mousedown", "mousemove", "mouseup", "keydown", "dragover", "drop", "dblclick")
        },
        tearDown: function() {
            this.removeListener("mousedown", "mousemove", "mouseup", "keydown", "dragover", "drop", "dblclick")
        },
        handle_dblclick: function(a) {
            var b = -1,
            c = this.network.getElementAt(a);
            c instanceof ImageShapeNode && (b = twaver.Util.getPointIndex(c.getPoints(), this.network.getLogicalPoint(a), this.network.getEditPointSize()));
            var d = new RoomDialog(c, b);
            d.show()
        },
        handle_mousedown: function(a) {
            if (this.mouseDown = !0, this.lastLogicalPoint = this.network.getLogicalPoint(a), this.lastLogicalPoint) {
                var b = this.network.getElementAt(a);
                if (b instanceof ImageShapeNode && !lock2d) if (resize = this.network.getElementUI(b).isPointOnBorderLine(this.lastLogicalPoint), null !== resize) this.lastElement = b,
                this.network.isMovable = function(a) {
                    return ! 1
                };
                else {
                    var c = b.getPointIndex(this.network.getLogicalPoint(a));
                    c >= 0 && (this.lastIndex = c, this.lastElement = b, this.network.isMovable = function(a) {
                        return ! 1
                    })
                }
                b instanceof Block && (this.block = b)
            }
        },
        handleClicked: function(a, b, c) {
            c ? a.fireInteractionEvent({
                kind: "clickElement",
                event: b,
                element: c
            }) : a.fireInteractionEvent({
                kind: "clickBackground",
                event: b
            })
        },
        handle_mousemove: function(a) {
            if (!lock2d) if (this._setNetworkCreateShapeNodeCursor(), this.mouseDown) {
                var b = this.network.getLogicalPoint(a);
                if (!b) return this.network.getView().scrollTop += 10,
                void(this.network.getView().scrollLeft += 10);
                if (offsetX = this.lastLogicalPoint ? b.x - this.lastLogicalPoint.x: 0, offsetY = this.lastLogicalPoint ? b.y - this.lastLogicalPoint.y: 0, this.lastIndex >= 0) {
                    Utils.stopPropagation(a);
                    var c = this.lastElement.getPoints(),
                    d = c.get(this.lastIndex),
                    e = c.get(this.lastIndex === c.size() - 1 ? 0 : this.lastIndex + 1);
                    this.network.enableSingleOrientationMove ? this.mouseMoved || (this.horizontal = d.x == e.x, this.vertical = !this.horizontal, this.mouseMoved = !0) : !this.mouseMoved && _twaver.isCtrlDown(a) && (this.horizontal = Math.abs(offsetX) >= Math.abs(offsetY), this.vertical = !this.horizontal, this.mouseMoved = !0),
                    this.vertical || (d.x += offsetX, e.x += offsetX),
                    this.horizontal || (d.y += offsetY, e.y += offsetY),
                    this.lastElement.firePointsChange(),
                    this.lastLogicalPoint = b
                }
                if (this.block) {
                    var f = this.block.getClient("edgeIndex"),
                    g = this.block.getClient("length"),
                    h = this.block.getClient("offset"),
                    c = this.block.getParent().getPoints(),
                    d = c.get(f),
                    e = c.get(f === c.size() - 1 ? 0 : f + 1),
                    i = e.x - d.x,
                    j = e.y - d.y,
                    k = Math.abs(i) > Math.abs(j),
                    l = k ? offsetX: offsetY,
                    m = l;
                    if (this.block.getClient("focusLeft")) k ? i > 0 && (m = -m) : (i >= 0 && 0 > j && (l = -l), i >= 0 && j > 0 && (m = -m), 0 > i && j > 0 && (l = -l, m = -m)),
                    this.block.setClient("length", g - l),
                    this.block.setClient("offset", h - m / Math.abs(k ? i: j) / 2);
                    else if (this.block.getClient("focusRight")) k ? 0 > i && (m = -m) : (i >= 0 && 0 > j && (l = -l, m = -m), 0 > i && j > 0 && (l = -l), 0 > i && 0 > j && (m = -m)),
                    this.block.setClient("length", g + l),
                    this.block.setClient("offset", h + m / Math.abs(k ? i: j) / 2);
                    else {
                        var h = Math.abs(i) > Math.abs(j) ? (b.x - this.lastLogicalPoint.x) / i: (b.y - this.lastLogicalPoint.y) / j;
                        this.block.setClient("offset", this.block.getClient("offset") + h)
                    }
                    this.lastLogicalPoint = b
                }
                null !== resize && this.lastElement && (0 === resize ? (this.lastElement.setLocation(this.lastElement.getX() + offsetX, this.lastElement.getY() + offsetY), this.lastElement.setSize(this.lastElement.getWidth() - offsetX, this.lastElement.getHeight() - offsetY)) : 1 === resize ? (this.lastElement.setLocation(this.lastElement.getX(), this.lastElement.getY() + offsetY), this.lastElement.setSize(this.lastElement.getWidth() + offsetX, this.lastElement.getHeight() - offsetY)) : 2 === resize ? this.lastElement.setSize(this.lastElement.getWidth() + offsetX, this.lastElement.getHeight() + offsetY) : 3 === resize && (this.lastElement.setLocation(this.lastElement.getX() + offsetX, this.lastElement.getY()), this.lastElement.setSize(this.lastElement.getWidth() - offsetX, this.lastElement.getHeight() + offsetY)), this.lastLogicalPoint = b)
            } else {
                var n = this.network.getElementAt(a),
                b = this.network.getLogicalPoint(a);
                if (this.lastElement && this.lastElement !== n && (this.lastElement instanceof ImageShapeNode && (this.lastElement.setClient("focusIndex", -1), this.network.getView().style.cursor = "default"), this.lastElement instanceof Block && (this.lastElement.setClient("focus", !1), this.lastElement.setClient("focusLeft", !1), this.lastElement.setClient("focusRight", !1), this.network.getView().style.cursor = "default"), this.lastElement = null), n instanceof ImageShapeNode) if (resize = this.network.getElementUI(n).isPointOnBorderLine(b), null !== resize) this.lastElement = n,
                this.network.getView().style.cursor = "move";
                else {
                    var f = n.getPointIndex(b);
                    n.setClient("focusIndex", f),
                    f >= 0 ? (this.lastElement = n, _twaver.isAltDown(a) ? this.network.getView().style.cursor = this.addPointCursor: this.network.getView().style.cursor = "move") : n.isPointOnPoints(b) || (this.network.getView().style.cursor = "default")
                } else n instanceof Block ? (n.setClient("focus", !0), this.network.getSelectionModel().contains(n) && _twaver.math.getDistance(b, n.getClient("leftPoint")) <= 10 ? (n.setClient("focusLeft", !0), n.setClient("focusRight", !1), this.network.getView().style.cursor = "move") : this.network.getSelectionModel().contains(n) && _twaver.math.getDistance(b, n.getClient("rightPoint")) <= 10 ? (n.setClient("focusLeft", !1), n.setClient("focusRight", !0), this.network.getView().style.cursor = "move") : (n.setClient("focusLeft", !1), n.setClient("focusRight", !1), this.network.getView().style.cursor = "default"), this.lastElement = n) : this.lastElement = null
            }
        },
        handle_mouseup: function(a) {
            this.mouseDown = !1,
            this.mouseMoved = !1,
            this.horizontal = !1,
            this.vertical = !1,
            this.lastIndex = -1,
            this.lastElement = null,
            this.lastLogicalPoint = null,
            this.block = null,
            this.resize = !1,
            this.network.getView().style.cursor = "default",
            lock2d || delete this.network.isMovable
        },
        handle_mousewheel: function(a) {
            if (!lock2d) {
                this.network.getSelectionModel().size() > 0 && (a.preventDefault(), a.stopPropagation());
                var b = !1,
                c = this;
                a.wheelDelta !== a.wheelDeltaX && (a.wheelDelta ? a.wheelDelta > 0 && (b = !0) : a.detail < 0 && (b = !0)),
                this.network.getSelectionModel().toSelection(function(a) {
                    a instanceof PrimitiveNode && c._scaleElement(b, a)
                })
            }
        },
        handle_keydown: function(a) {
            if (!lock2d) {
                var b = !1;
                if (46 == a.keyCode) {
                    if (this.network.getSelectionModel().getSelection().size() > 0) {
                        var c = this.network.getSelectionModel().getSelection();
                        if (1 == c.size() && this.network.getSelectionModel().getLastData() instanceof TargetFlagNode) return;
                        if (confirm("Sure to Delete")) {
                            var d = this.network.getElementBox(),
                            e = new twaver.List;
                            e.addAll(c),
                            e.forEach(function(a) {
                                a instanceof TargetFlagNode || d.remove(a)
                            })
                        }
                    }
                    b = !0
                }
                37 == a.keyCode && (this._moveSelectionElements("left"), b = !0),
                38 == a.keyCode && (this._moveSelectionElements("top"), b = !0),
                39 == a.keyCode && (this._moveSelectionElements("right"), b = !0),
                40 == a.keyCode && (this._moveSelectionElements("bottom"), b = !0),
                Utils.isCtrlDown(a) && (67 === a.keyCode && (this._copySelection(), b = !0), 86 === a.keyCode && (this._pasteSelection(), b = !0)),
                83 === a.keyCode && this._adsorptionSelectionElements(),
                b && (a.preventDefault(), a.stopPropagation())
            }
        },
        handle_dragover: function(a) {
            a.preventDefault ? a.preventDefault() : a.returnValue = !1,
            a.dataTransfer.dropEffect = "copy";
            var b = this.network.getElementAt(a),
            c = this.network.getLogicalPoint(a);
            if (this.network.lastElement && this.network.lastElement !== b && (this.network.lastElement instanceof ImageShapeNode && this.network.lastElement.setClient("focusIndex", -1), this.network.lastElement = null), b instanceof ImageShapeNode) {
                var d = b.getPointIndex(c);
                b.setClient("focusIndex", d),
                d >= 0 && (this.network.lastElement = b)
            } else this.network.lastElement = null;
            return ! 1
        },
        getAllElementsAt: function(a) {
            var b = {
                x: a.x - 1,
                y: a.y - 1,
                width: 2,
                height: 2
            },
            c = this.network.getElementsAtRect(b, !0, null, !1);
            return c
        },
        findFirstFloorAt: function(a) {
            var b = this.getAllElementsAt(a);
            if (b) for (var c = 0; c < b.size(); c++) if (b.get(c) instanceof FloorShapeNode) return b.get(c)
        },
        handle_drop: function(a) {
            a.stopPropagation && a.stopPropagation(),
            a.preventDefault ? a.preventDefault() : a.returnValue = !1;
            var b = a.dataTransfer.getData("Text");
            if (!b) return ! 1;
            var c = JSON.parse(b);
            loadResource === TYPE_CLOUD && c.isTemplate && (c.loadFromCloud = !0, "Component" != c.method && (c.actionType = "loadTemplate"));
            var d = this.network.getElementAt(a);
            if (c.actionType)"loadTemplate" === c.actionType ? c.loadFromCloud ? (modelManager.loadTemplate(this.network.getElementBox(), c), roomTemplateId = c.id) : modelManager.loadTemplate(this.network.getElementBox(), c.id) : (type = "ImageShapeNode", "CreateFloorShapeNode" === c.actionType ? type = "FloorShapeNode": "CreateInnerWallShapeNode" === c.actionType ? type = "InnerWallShapeNode": "CreatePipeShapeNode" === c.actionType ? type = "PipeShapeNode": "CreateRoundPipeShapeNode" === c.actionType ? type = "RoundPipeShapeNode": "CreateRoomWithFloorShapeNode" === c.actionType && (type = function(b) {
                var c = new ImageShapeNode;
                return c instanceof twaver.ShapeNode && b && (c.setPoints(b), c.setClient("isHostNode", !0), c.setClient("decimalNumber", decimalNumber), c.setClient("transparent", !1), c.setClient("opacity", 1), c.setClient(PropertyConsts.LAYERID, PropertyConsts.Layer.WALL), 2 == b._as.length && (alert("Please draw more than two points!"), c.removeAt(0), c.removeAt(1), network.fireInteractionEvent({
                    kind: "removePoint",
                    event: a,
                    element: this.shapeNode
                }))),
                c
            }), classType = window[type] ? window[type] : type, this._createShapeNodeInteractions(classType));
            else if (d && d instanceof ImageShapeNode) if (!c.embeded || d instanceof FloorShapeNode) if ("FloorShapedModel" != c.className || d.getClient(OID)) {
                var e = c.mtarget;
                if (e) {
                    if ("Floor" === e) {
                        var f = this.network.getLogicalPoint2(a),
                        g = this.findFirstFloorAt(f);
                        if (g && c.material) {
                            var h = Utils.Path + c.material;
                            Utils.registerImage(h, this.network),
                            g.setClient(IMAGE_SRC, h)
                        }
                    }
                    "Room" === e && d instanceof ImageShapeNode && this.handleRoomMaterial(d, c)
                } else c.embeded || this._createRoom(this.network, a, c)
            } else {
                var i = this._createElement(this.network, d.getCenterLocation(), c.id);
                i.setClient("hostNodeId", d.getId()),
                d.setClient(OID, d.getId())
            } else {
                var f = this.network.getLogicalPoint(a);
                d.setClient("focusIndex", -1);
                var j = d.getPointIndex(f);
                if (j >= 0) {
                    var k = d.getPoints(),
                    l = k.get(j),
                    m = k.get(j === k.size() - 1 ? 0 : j + 1),
                    n = m.x - l.x,
                    o = m.y - l.y,
                    p = Math.abs(n) > Math.abs(o) ? (f.x - l.x) / n: (f.y - l.y) / o;
                    this._createPureElement(this.network, c,
                    function(a) {
                        a.setClient("edgeIndex", j),
                        a.setParent(d),
                        a.setClient("offset", p);
                        var b = parseFloat("1m") / parseFloat(network._scaleUnitValue),
                        c = a.getClient("length"),
                        e = a.getStyle("vector.outline.width"),
                        f = Math.abs(Math.log(b));
                        e = b > 1 ? e / Math.pow(1.5, f) : e * Math.pow(1.5, f),
                        a.setClient("length", c * b)
                    })
                }
            } else {
                if ("BlockModel" == c.className && c.embeded) return ! 1;
                var e = c.mtarget;
                d || "Room" !== e ? this._createRoom(this.network, a, c) : this.handleRoomMaterial(null, c)
            }
            return this._setNetworkCreateShapeNodeCursor(),
            !1
        },
        handleRoomMaterial: function(a, b) {
            var c = !1;
            if (box2d.forEach(function(a) {
                var b = a;
                return b instanceof ImageShapeNode && !(b instanceof FloorShapeNode) ? (c = !0, !1) : void 0
            }), c) {
                var d = "Change Room Material",
                e = [];
                if (a || (d = "Change All Room Material", e = [{
                    label: "Scope:",
                    id: "cfloor",
                    name: "scope",
                    type: "radio",
                    checked: !0,
                    inner: "For current floor's images"
                },
                {
                    label: "",
                    id: "afloor",
                    name: "scope",
                    type: "radio",
                    checked: !1,
                    inner: "For all floors' images"
                }]), b.texture) var f = [{
                    label: "Image:",
                    id: "pic",
                    value: Utils.Path + b.material
                },
                {
                    label: "Usage:",
                    id: "outside",
                    name: "side",
                    type: "radio",
                    checked: !0,
                    inner: "For all external faces (incudes all frame and pole faces)"
                },
                {
                    label: "",
                    id: "inside",
                    name: "side",
                    type: "radio",
                    checked: !1,
                    inner: "For all internal faces"
                }];
                else var f = [{
                    label: "External Image:",
                    id: "external",
                    value: Utils.Path + b.outside
                },
                {
                    label: "Internal Image:",
                    id: "internal",
                    value: Utils.Path + b.inside
                },
                {
                    label: "Frame Image:",
                    id: "frame",
                    value: Utils.Path + b.frame
                }];
                f = e.concat(f),
                Utils.showInputDialog(f, d, !0, this.setRoomMaterial, this, [a, b.texture])
            }
        },
        setRoomMaterial: function(a, b, c) {
            var d = [];
            if (a ? d.push(a) : box2d.forEach(function(a) {
                var b = a;
                b instanceof ImageShapeNode && !(b instanceof FloorShapeNode) && (c.cfloor ? b.getClient("floorName") === floorPane.getCurrentFloorName() && d.push(b) : d.push(b));
            }), d.length > 0) for (var e = 0; e < d.length; e++) {
                var f = d[e];
                b ? (c.outside ? (f.setClient("wallOuterPic", c.pic), f.setClient("framePic", c.pic), f.setClient("poleTexture", c.pic)) : f.setClient("wallInnerPic", c.pic), f.setClient("useTexture", !0)) : (f.setClient("wallOuterPic", c.external), f.setClient("wallInnerPic", c.internal), f.setClient("framePic", c.frame), f.setClient("poleTexture", c.external), f.setClient("useTexture", !1));
                var g = f instanceof InnerWallShapeNode;
                g && (f.setClient("poleTexture", f.getClient("wallInnerPic")), f.setClient("wallOuterPic", f.getClient("wallInnerPic")))
            }
        },
        _createShapeNodeInteractions: function(a) {
            this.network.setInteractions([new MyCreateShapeNodeInteraction(this.network, a), new twaver.vector.interaction.DefaultInteraction(this.network)])
        },
        _createPureElement: function(b, c, d) {
            var e = c.id;
            a = modelManager.getModelNode(e);
            var f = modelManager.getModelLib();
            if (a) {
                var g = ModelFactory.getModelFromModelNode(f, a);
                if (g instanceof modelimp.ModelImp) for (var h = g.get2DObjects(), i = b.getElementBox(), j = 0; j < h.length; j++) i.add(h[j]),
                b.getSelectionModel().clearSelection(),
                b.getSelectionModel().setSelection(h[j]),
                d && d(h[j])
            }
        },
        _createRoom: function(a, b, c) {
            if ("squareRoomWithFloor" === c.id) {
                var d = this._createElement(a, a.getLogicalPoint(b), "floor02"),
                e = this._createElement(a, a.getLogicalPoint(b), "squareRoom");
                d.setClient("hostNodeId", e.getId()),
                e.setClient(OID, e.getId()),
                e.setClient("decimalNumber", decimalNumber)
            } else if ("LShapedRoomWithFloor" === c.id) {
                var d = this._createElement(a, a.getLogicalPoint(b), "floor03"),
                e = this._createElement(a, a.getLogicalPoint(b), "LShapedRoom");
                d.setClient("hostNodeId", e.getId()),
                e.setClient(OID, e.getId()),
                e.setClient("decimalNumber", decimalNumber)
            } else if ("SquareAddOnRoomWithFloor" === c.id) {
                var d = this._createElement(a, a.getLogicalPoint(b), "floor04"),
                e = this._createElement(a, a.getLogicalPoint(b), "SquareAddOnRoom");
                d.setClient("hostNodeId", e.getId()),
                e.setClient(OID, e.getId()),
                e.setClient("decimalNumber", decimalNumber)
            } else if ("AngledAddOnRoomWithFloor" === c.id) {
                var d = this._createElement(a, a.getLogicalPoint(b), "floor05"),
                e = this._createElement(a, a.getLogicalPoint(b), "AngledAddOnRoom");
                d.setClient("hostNodeId", e.getId()),
                e.setClient(OID, e.getId()),
                e.setClient("decimalNumber", decimalNumber)
            } else if ("RoomByPoints" === c.id) {
                var f = new RoomByPointsDialog(c, a, b);
                f.show()
            } else if (c.loadFromCloud) if (_twaver.isShiftDown(b)) Utils.showTemplateDialog(this, a, b, c);
            else var g = function(a) {
                processHost(a, b)
            },
            h = this._createElement(a, a.getLogicalPoint(b), c, g);
            else if (_twaver.isShiftDown(b)) Utils.showTemplateDialog(this, a, b, c.id);
            else {
                var h = this._createElement(a, a.getLogicalPoint(b), c.id);
                if (processHost(h, b), !c.id) return;
                c.id.indexOf("billboard") >= 0 ? h.setStyle("m.vertical", !0) : c.id.indexOf("pointlight") >= 0 ? "pointlight01" == c.id ? (h.setClient("lightColor", new mono.Color(16777215)), h.setClient("lightIntensity", 1)) : "pointlight02" == c.id && (h.setClient("lightColor", new mono.Color(16773335)), h.setClient("lightIntensity", 1)) : c.id.indexOf("spotlight") >= 0 && "spotlight01" == c.id && (h.setClient("lightColor", new mono.Color(14146559)), h.setClient("lightIntensity", 1), h.setClient("angle", Math.PI))
            }
        },
        _createElement: function(a, b, c, d, e, f) {
            if ("object" != typeof c) return this._createElementDeal(a, b, c, d);
            var g = c,
            h = {
                module: "templates",
                method: "get",
                arguments: {
                    id: g.id
                }
            },
            i = function() {
                var c = JSON.parse(arguments[0]);
                if (c.error) return void alert(c.error);
                var g = c.value;
                if (g) {
                    var h = JSON.parse(g.data);
                    if (h) return h.primitives || h.assembles ? (modelManager.loadSharedPrimitive(h.primitives), modelManager.loadSharedAssemble(h.assembles)) : (modelManager.loadSharedPrimitive(h.primitivesCache), modelManager.loadSharedAssemble(h.assembleCache)),
                    this._createElementDeal(a, b, g.gid, d, e, f)
                }
            };
            require(MONO_URL, h, i, this)
        },
        _createElementDeal: function(a, b, c, d, e, f) {
            var g = modelManager.getModelLib(),
            h = modelManager.getModelNode(c);
            if (h || (h = g.getModelNodeByTemplateName(c)), h) {
                var i = ModelFactory.getModelFromModelNode(g, h);
                if (i instanceof modelimp.ModelImp) {
                    var j, k = i.get2DObjects(!0),
                    l = a.getElementBox();
                    k[0] && (i.mainNode ? (i.mainNode instanceof PrimitiveNode && i.mainNode.setName(i.templateName || i.id), j = i.mainNode, j.setClient(PropertyConsts.LAYERID, PropertyConsts.Layer.TEMPLATE)) : (k[0] instanceof PrimitiveNode && (k[0].setName(i.templateName), k[0].getClient(PropertyConsts.LAYERID) || k[0].setClient(PropertyConsts.LAYERID, PropertyConsts.Layer.TEMPLATE)), j = k[0]));
                    for (var m = parseFloat(i.scaleValue || 1), n = 0; n < k.length; n++) l.add(k[n]),
                    a.getSelectionModel().clearSelection(),
                    a.getSelectionModel().setSelection(k[n]);
                    i.mainNode && (a.getSelectionModel().clearSelection(), a.getSelectionModel().setSelection(i.mainNode)),
                    "mono.Billboard" == h.className && k[0].setStyle("m.vertical", !0);
                    var o = i.mainNode;
                    o || (o = k[0]),
                    o.scaleValue = h.scaleValue;
                    var m = parseFloat(o.scaleValue || 1),
                    p = o.getHeight(),
                    q = o.getWidth();
                    return o.setHeight(p * m),
                    o.setWidth(q * m),
                    o.setCenterLocation(b),
                    d && d(o, e, f),
                    o
                }
            }
        },
        _setNetworkCreateShapeNodeCursor: function() {
            var a = this;
            this.network.getInteractions().forEach(function(b) {
                b instanceof twaver.vector.interaction.CreateShapeNodeInteraction && (a.network.getView().style.cursor = "crosshair")
            })
        },
        _scaleElement: function(a, b) {
            if (b && b instanceof PrimitiveNode && this.network.isSelected(b)) {
                var c = b.getSize(),
                d = b.getClient("oscale"),
                e = b.getCenterLocation();
                if (a && 1e3 > d) {
                    var f = Math.round(1.1 * d),
                    g = 1.1 * c.width,
                    h = 1.1 * c.height;
                    f > 1e3 && (f = 1e3, g = c.width * (1e3 / d), h = c.height * (1e3 / d)),
                    b.setSize(g, h),
                    b.setClient("oscale", f)
                } else if (!a && d > 5) {
                    var f = Math.round(d / 1.1),
                    g = c.width / 1.1,
                    h = c.height / 1.1;
                    5 > f && (f = 5, g = c.width * (5 / d), h = c.height * (5 / d)),
                    b.setSize(g, h),
                    b.setClient("oscale", f)
                }
                b.setName(Utils.changeTwoDecimal(b.getClient("oscale")) + "%\nScroll to Scale"),
                b.setCenterLocation(e)
            }
        },
        _adsorptionSelectionElements: function() {
            var a = box2d.getSelectionModel().getSelection(),
            b = parseInt(localStorage.getItem(SNAPGRID)) || 10;
            a.size() > 0 && a.forEach(function(a) {
                var c = a.getPoints();
                c.forEach(function(a) {
                    a.x = parseInt(a.x / b) * b + (a.x % b < b / 2 ? 0 : b),
                    a.y = parseInt(a.y / b) * b + (a.y % b < b / 2 ? 0 : b)
                }),
                a.setPoints(c)
            })
        },
        _moveSelectionElements: function(a) {
            var b = box2d.getSelectionModel().getSelection();
            if (b.size() > 0) {
                var c = 0,
                d = 0;
                "left" === a && (c = -1),
                "right" === a && (c = 1),
                "top" === a && (d = -1),
                "bottom" === a && (d = 1),
                twaver.Util.moveElements(b, c, d, !1)
            }
        },
        _copySelection: function() {
            var a = box2d.getSelectionModel().getSelection(),
            b = a.toList();
            a.forEach(function(c) {
                box2d.forEach(function(d) { ! a.contains(d) && d.isDescendantOf(c) && b.add(d),
                    d.getClient("hostNodeId") && c.getClient("oid") && d.getClient("hostNodeId") === c.getClient("oid") && b.add(d)
                })
            }),
            Utils.copyDatasToBoxAnchor(b, box2d)
        },
        _pasteSelection: function() {
            var a = floorPane.getCurrentFloorName(),
            b = Utils.pasteBoxAnchorToBox(box2d, a);
            if (b && b.length > 0) {
                box2d.getSelectionModel().clearSelection();
                for (var c in b) b[c] instanceof Block || b[c] instanceof FloorShapeNode && b[c].getClient("hostNodeId") || (box2d.getSelectionModel().appendSelection(b[c]), b[c].setX(b[c].getX() + 20), b[c].setY(b[c].getY() + 20))
            }
        }
    }),
    MonoEditInteraction = function(a, b) {
        MonoEditInteraction.superClass.constructor.call(this, a)
    },
    twaver.Util.ext("MonoEditInteraction", twaver.vector.interaction.EditInteraction, {
        deletePointCursor: "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAGYSURBVHja1JS/SwJhGMc/r16ieXENRSBJQijo0OIS/gE1BK4tzorQVHNTU3OB2ByNDW21tTidtClY0A+nFvHojsCyt+UNTvMujSL6LHccz/fD8/Lc+4hsNssQa8A6kAPS6lsTqAHnwIW72DRNRqG53hPAFlAqpyw9M9tjKfoKwL2jrTa6odVKyygCVeAQuMMHzSXdKyatQj7uEAnKgaKM0SNj9NhYdPSzdnTn6NpYAHb95AH13ComrcJmwv4kdRMJSjYTNsWkVVCnw0+8BpTycYdxUbUllfUUr5dTlu7X6ajOyylLV0P2FOcysz0mRWVyfuL0x/QnQWXSXw3vxwkAzXtHmzioMk0/ca3RDU0sVpman/i80jLs574YW/rcF1Rahq2uuKf4AqietaNji1VtdXhvuAnGYjGAVr0TngsH5cryzAtTAe9OTx90jq6NY2DfNM3uV+IucFXvhPsntzMrUU2GEDCtSV7eBDdPU1w+Rtg25+16J3ygpL5LSHxnbXqtygGxlPJX/mPtOyEhhPyzjn/1Sv8v8fsAeL2I1faEYBkAAAAASUVORK5CYII'),auto",
        setUp: function() {
            MonoEditInteraction.superClass.setUp.apply(this, arguments),
            this.addListener("keydown", "keyup")
        },
        tearDown: function() {
            MonoEditInteraction.superClass.setUp.apply(this, arguments),
            this.removeListener("keydown", "keyup")
        },
        handle_keydown: function(a) {
            this.currentKeyEvent = a,
            this.showSnap = !0
        },
        handle_keyup: function(a) {
            this.currentKeyEvent = null,
            this.showSnap = !1
        },
        handle_mouseup: function(a) {
            if (this.isStart) {
                var b = _twaver.clone(this._endLogical);
                if (this.resizingRect) if (this.lazyMode) if (this.network.isResizeAnimate()) {
                    var c = this,
                    d = new twaver.animate.AnimateBounds(this.node, this.resizingRect,
                    function() {
                        c.network.fireInteractionEvent({
                            kind: "lazyResizeEnd",
                            event: a,
                            element: c.node,
                            resizeDirection: c.resizeDirection
                        })
                    });
                    twaver.animate.AnimateManager.start(d)
                } else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "lazyResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else this.node.setLocation(this.resizingRect.x, this.resizingRect.y),
                this.node.setSize(this.resizingRect.width, this.resizingRect.height),
                this.network.fireInteractionEvent({
                    kind: "liveResizeEnd",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else if (this.shapeNode && this.pointIndex >= 0 && b) {
                    var e = this.shapeNode.getPoints().get(this.pointIndex);
                    if (this.horizontal && (b.y = e.y), this.vertical && (b.x = e.x), this.currentKeyEvent && 83 === this.currentKeyEvent.keyCode) {
                        var f = parseInt(localStorage.getItem(SNAPGRID)) || 10;
                        b.x = parseInt(b.x / f) * f + (b.x % f < f / 2 ? 0 : f),
                        b.y = parseInt(b.y / f) * f + (b.y % f < f / 2 ? 0 : f)
                    }
                    this.shapeNode.setPoint(this.pointIndex, b),
                    this.network.fireInteractionEvent({
                        kind: "liveMovePointEnd",
                        event: a,
                        element: this.shapeNode,
                        pointIndex: this.pointIndex
                    })
                } else if (this.shapeLink && this.pointIndex >= 0 && b) {
                    var e = this.shapeLink.getPoints().get(this.pointIndex);
                    this.horizontal && (b.y = e.y),
                    this.vertical && (b.x = e.x),
                    this.shapeLink.setPoint(this.pointIndex, b),
                    this.network.fireInteractionEvent({
                        kind: "liveMovePointEnd",
                        event: a,
                        element: this.shapeLink,
                        pointIndex: this.pointIndex
                    })
                } else this.linkUI && b && (this.linkUI.setControlPoint(b), this.network.fireInteractionEvent({
                    kind: "liveMovePointEnd",
                    event: a,
                    element: this.linkUI._element
                }))
            }
            this._handle_mouseup(a),
            this.clear()
        },
        _isEditingShapeNode: function(a, b) {
            if (this.node instanceof twaver.ShapeNode) {
                this.shapeNode = this.node;
                for (var c = this.shapeNode.getPoints(), d = 0, e = c.size(); e > d; d++) {
                    var f = c.get(d);
                    if (this._contains(a, f, this.editPointSize)) return _twaver.isAltDown(b) ? this._setCursor(this.deletePointCursor) : this._setCrossCursor(),
                    this.pointIndex = d,
                    !0
                }
                if (null != this.shapeNode.getPointIndex(a) && this.shapeNode.getPointIndex(a) >= 0) return ! 0
            }
            return this.pointIndex = -1,
            !1
        },
        handle_mousemove: function(a) {
            if (this.network.isValidEvent(a)) {
                if (this.isStartRotate && this.node) return this._handleRotateElement(a, this.node),
                void(this.network.isShowRotateScale() && this.repaint());
                if (this.isStart) {
                    if (this.shapeNode && this.pointIndex >= 0) {
                        this._handleMovingShapeNodePoint(a);
                        var b = {},
                        c = parseInt(localStorage.getItem(SNAPGRID)) || 10;
                        if (this.currentKeyEvent && 83 === this.currentKeyEvent.keyCode) {
                            var d = this.shapeNode.getPoints().get(this.pointIndex);
                            b.x = parseInt(d.x / c) * c + (d.x % c < c / 2 ? 0 : c),
                            b.y = parseInt(d.y / c) * c + (d.y % c < c / 2 ? 0 : c),
                            (b.x != d.x || b.y != d.y) && this.repaint()
                        }
                        return
                    }
                    if (this.shapeLink && this.pointIndex >= 0) return void this._handleMovingShapeLinkPoint(a);
                    if (this.node && this.resizeDirection) return void this._handleResizing(a);
                    if (this.linkUI) return void this._handleMovingLinkControlPoint(a);
                    var d = this.network.getLogicalPoint2(a);
                    if (this.node && this.node instanceof twaver.ShapeNode && this.node.getPointIndex(d) && this.node.getPointIndex(d) >= 0) return void(this.network._dragToPan = !1)
                } else {
                    var e = this.network.getElementAt(a);
                    if (this.network.isSelectingElement() || this.network.isMovingElement() || 0 === this.network.getSelectionModel().size()) return void this.clear();
                    var f = this.network.getElementUI(e);
                    if (!f || !f.getEditAttachment()) return void this.clear();
                    var d = this.network.getLogicalPoint2(a);
                    if (e instanceof twaver.ShapeNode && (d = this.network.getLogicalPoint(a)), e instanceof twaver.Node) {
                        if (this.node = e, this.node instanceof Block) return this.network._dragToPan = !1,
                        void(this.isStart = !0);
                        if (this._isEditingShapeNode(d, a) || this._isResizingNode(d)) return void this.network.setEditingElement(!0);
                        if (this._isRotatingElement(d)) return this.network.setRotatingElement(!0),
                        void this.network.setEditingElement(!0)
                    } else if (e instanceof twaver.ShapeLink) {
                        if (this.shapeLink = e, this._isEditingShapeLink(d)) return void this.network.setEditingElement(!0)
                    } else if (f instanceof twaver.network.LinkUI && twaver.Link.isOrthogonalLink(f._element)) {
                        this.linkUI = f;
                        var g = this.linkUI.getControlPoint();
                        return void(g && this._contains(d, g) && (this._setCrossCursor(), this.network.setEditingElement(!0)))
                    }
                    this.clear()
                }
            }
        },
        handle_mousedown: function(a) {
            if (0 === a.button) if (!_twaver.isAltDown(a) || this.network.isEditingElement()) {
                if (this.network.isEditingElement() && !this.isStart && !this.isStartRotate) if (this.node && this.resizeDirection) this.isStart = !0,
                this._handle_mousedown(a),
                this.network.fireInteractionEvent({
                    kind: this.lazyMode ? "lazyResizeStart": "liveResizeStart",
                    event: a,
                    element: this.node,
                    resizeDirection: this.resizeDirection
                });
                else if (this.shapeNode && this.pointIndex >= 0) {
                    var b = this.shapeNode.getPoints()._as.length;
                    _twaver.isAltDown(a) ? 2 == b ? confirm("You will delete the entire wall, Sure to Delete") && (this.shapeNode.removeAt(0), this.shapeNode.removeAt(1), this.network.fireInteractionEvent({
                        kind: "removePoint",
                        event: a,
                        element: this.shapeNode
                    })) : confirm("Sure to Delete") && (3 == b && this.shapeNode.setClient("shapenode.closed", !1), this.shapeNode.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                        kind: "removePoint",
                        event: a,
                        element: this.shapeNode
                    })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: this.shapeNode,
                        pointIndex: this.pointIndex
                    }))
                } else this.shapeLink && this.pointIndex >= 0 ? _twaver.isAltDown(a) ? (this.shapeLink.removeAt(this.pointIndex), this.network.fireInteractionEvent({
                    kind: "removePoint",
                    event: a,
                    element: this.shapeLink
                })) : (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                    kind: "liveMovePointStart",
                    event: a,
                    element: this.shapeLink,
                    pointIndex: this.pointIndex
                })) : this.linkUI ? (this.isStart = !0, this._handle_mousedown(a), this.network.fireInteractionEvent({
                    kind: "liveMovePointStart",
                    event: a,
                    element: this.linkUI._element
                })) : this.shapeNode ? this.isStart = !0 : this.node && (this.node.getClient("className") && "mono.Billboard" == this.node.getClient("className") || (this.isStartRotate = !0, this._handle_mousedown(a)))
            } else {
                var c = this.network.getElementAt(a),
                d = this.network.getLogicalPoint(a);
                if (c instanceof twaver.ShapeNode) {
                    var e = this.getPointIndex(c.getPoints(), d, !0);
                    e > 0 && (this._handle_mousedown(a), this.pointIndex = e, this.shapeNode = c, c.addPoint(d, e), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: c,
                        pointIndex: e
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: c,
                        pointIndex: e
                    }))
                }
                if (c instanceof twaver.ShapeLink) {
                    var f = new twaver.List(c.getPoints()),
                    g = this.network.getElementUI(c);
                    f.add(g.getFromPoint(), 0),
                    f.add(g.getToPoint());
                    var e = this.getPointIndex(f, d) - 1;
                    e > 0 && (this._handle_mousedown(a), this.pointIndex = e, this.shapeLink = c, c.addPoint(d, e), this._setCrossCursor(), this.network.setEditingElement(!0), this.isStart = !0, this.network.fireInteractionEvent({
                        kind: "addPoint",
                        event: a,
                        element: c,
                        pointIndex: e
                    }), this.network.fireInteractionEvent({
                        kind: "liveMovePointStart",
                        event: a,
                        element: c,
                        pointIndex: e
                    }))
                }
            }
        },
        paint: function(a) {
            if (MonoEditInteraction.superClass.paint.apply(this, arguments), this.shapeNode) {
                var b = 10,
                c = new twaver.List,
                d = {},
                e = this.shapeNode.getPoints().size(),
                f = this;
                if (snapGrid = parseInt(localStorage.getItem(SNAPGRID)) || 10, this.shapeNode && this.pointIndex >= 0 && this.showSnap) {
                    var g = this.shapeNode.getPoints(),
                    h = g.get(this.pointIndex);
                    if (!h) return;
                    d.x = parseInt(h.x / snapGrid) * snapGrid + (h.x % snapGrid < snapGrid / 2 ? 0 : snapGrid),
                    d.y = parseInt(h.y / snapGrid) * snapGrid + (h.y % snapGrid < snapGrid / 2 ? 0 : snapGrid);
                    var i = this.pointIndex + 1 >= e ? this.pointIndex + 1 - e: this.pointIndex + 1,
                    j = this.pointIndex - 1 < 0 ? this.pointIndex - 1 + e: this.pointIndex - 1;
                    if (d.x && d.y) {
                        this.img = new Image,
                        c.add(g.get(i)),
                        c.add(d),
                        c.add(g.get(j));
                        var k = "(" + d.x + "," + d.y + ")",
                        l = _twaver.math.getRect(c),
                        m = this.shapeNode.getClient("coordTextFont"),
                        i = (c.get(0), d),
                        j = c.get(1),
                        n = _twaver.g.getTextSize(m, k);
                        _twaver.math.grow(l, 3 * b + Math.max(n.width, n.height), 3 * b + Math.max(n.width, n.height));
                        var o = a;
                        o.fillStyle = "rgb(0,100,0)",
                        o.strokeStyle = "#000000",
                        o.beginPath(),
                        o.arc(d.x, d.y, b, 0, 2 * Math.PI),
                        o.fill(),
                        o.stroke(),
                        o.closePath(),
                        o.strokeStyle = "rgb(0,100,0)";
                        var p = new twaver.List(["moveto", "lineto", "lineto"]);
                        o.beginPath(),
                        _twaver.g.drawLinePoints(o, c, [5, 5], p),
                        o.stroke(),
                        o.closePath(),
                        o.fillStyle = "rgba(0,100,0,0.5)",
                        o.fillRect(d.x + b, d.y - n.height / 2, n.width, n.height),
                        o.font = m,
                        o.fillStyle = "#FFFFFF",
                        o.textBaseline = "middle",
                        o.fillText(k, d.x + b, d.y),
                        o.strokeStyle = "rgb(0,100,0)",
                        this.img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAXCAYAAAARIY8tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAANVSURBVHjapJVfaFtVHMc/9+Q2yU1jZq3RplLFaYu6LQrTTh/0QRixdP6BwRAftuGDlDvfBB9UrChDUQZDWNYHQZxvA/9b2UXxT3ErCI51tUxszexcGtusWxuSnCT35h4fmibNFtOsft/Oj3M+38Pv/H6/oymlaKZ4zBBADNgD7AB6gCCQAZLASeA48J1pyWtgWjODeMx4HHi/O9S25Y4OL53tHtq9Al1o2GVF3nZJZx0uLNmkMvZvwIumJX9a1yAeMzTgja4b9Nd7wz5uv9HLepq9UuLn8zkFDJuWfOs/DSopOdIX9g1FIwY+XaNVSdtl8p8C0+niQdOSr11jEI8ZHuBYX9j33EM9gbrD2ZLLdLpIctlG2i5Gm+C2TW30hn0EvaK6r+QoxmdzXFy2nzYt+WWdwdGB4GRfp771wavgZ1OSyVRhHjgEfA2kgG5gEHhpW8R/azRiVPfPZWx+mMleAHqrBiODIQWgXFftvDughYM6AKeTknPzhTFgt2nJSw3e6xbgm2jE2L4t4q/Gx//Kkbhc2icAjh94WFEx0oTQvp3Ju3MZm18v5jk3X7CAgUZwANOSC8CTZ1My67i1bPR0eAF2i69e2bVw+fwUrltGlZ1VE/FjIl/+faH4BfCUacl8s8c1LZkCPvxzsVSNdQY8AP0iOTEWXk2T5tFr9Ss8JyppKbVYRKfSWae6MNoEQJcApCYEYg0c+BjYZVqyzP+UAHYCy2tix4C9G2A9Em6vXbLgKIAFMTSaOQncUym/j4B9AEOjmZbJ8ZjRBezf3Fnr+MWcA/BLXR+MDIbYAHwTYEUjxo66Mp3NkVgs7dfWm6brwDuAE1u6/P0PdNcaLZWx+X4mOwfcKTYKPzoQvA8Y23oVvFRWTF8qAhwwLVnSNwIfGQxFNSHG77pJD9y/Bu64iok5yd9L9tumJT9fraLrhgMTQCCx5NqnZld6sOgoTiclf6SLh4BXW/pwGsCfAT4DUMpF0wSA0xMSutcD0+nim6Ylh1v+0RrDFW55pf+E8ICmgVJX3LLzjmnJdxs1WquKVu5UB/d4/cn+vcNTjeDXa3AQ+ABYGSuaRvDm7qXtz76cOPPp4UebjYqWNDSaKQMvAO8BZd3nn7r3ieePnPnk8GPNzv07AK/5bsWWYLHkAAAAAElFTkSuQmCC",
                        this.img.onload = function() {
                            o.drawImage(f.img, d.x - 3 * b, d.y - 3 * b, 2 * b, 2 * b)
                        }
                    }
                }
            }
        },
        clear: function() {
            MonoEditInteraction.superClass.clear.apply(this, arguments),
            this.network._dragToPan = !0,
            this.network.setRotatePointSize(twaver.Defaults.NETWORK_ROTATE_POINT_SIZE)
        }
    }),
    mono.AniUtil = {},
    mono.AniUtil.Easing = TWEEN.Easing,
    mono.AniUtil.DefaultEasing = mono.AniUtil.Easing.Linear.None,
    mono.AniUtil.AllEasings = {
        "Linear.None": mono.AniUtil.Easing.Linear.None,
        "Quadratic.In": mono.AniUtil.Easing.Quadratic.In,
        "Quadratic.Out": mono.AniUtil.Easing.Quadratic.Out,
        "Quadratic.InOut": mono.AniUtil.Easing.Quadratic.InOut,
        "Cubic.In": mono.AniUtil.Easing.Cubic.In,
        "Cubic.Out": mono.AniUtil.Easing.Cubic.Out,
        "Cubic.InOut": mono.AniUtil.Easing.Cubic.InOut,
        "Quartic.In": mono.AniUtil.Easing.Quartic.In,
        "Quartic.Out": mono.AniUtil.Easing.Quartic.Out,
        "Quartic.InOut": mono.AniUtil.Easing.Quartic.InOut,
        "Quintic.In": mono.AniUtil.Easing.Quintic.In,
        "Quintic.Out": mono.AniUtil.Easing.Quintic.Out,
        "Quintic.InOut": mono.AniUtil.Easing.Quintic.InOut,
        "Sinusoidal.In": mono.AniUtil.Easing.Sinusoidal.In,
        "Sinusoidal.Out": mono.AniUtil.Easing.Sinusoidal.Out,
        "Sinusoidal.InOut": mono.AniUtil.Easing.Sinusoidal.InOut,
        "Exponential.In": mono.AniUtil.Easing.Exponential.In,
        "Exponential.Out": mono.AniUtil.Easing.Exponential.Out,
        "Exponential.InOut": mono.AniUtil.Easing.Exponential.InOut,
        "Circular.In": mono.AniUtil.Easing.Circular.In,
        "Circular.Out": mono.AniUtil.Easing.Circular.Out,
        "Circular.InOut": mono.AniUtil.Easing.Circular.InOut,
        "Elastic.In": mono.AniUtil.Easing.Elastic.In,
        "Elastic.Out": mono.AniUtil.Easing.Elastic.Out,
        "Elastic.InOut": mono.AniUtil.Easing.Elastic.InOut,
        "Back.In": mono.AniUtil.Easing.Back.In,
        "Back.Out": mono.AniUtil.Easing.Back.Out,
        "Back.InOut": mono.AniUtil.Easing.Back.InOut,
        "Bounce.In": mono.AniUtil.Easing.Bounce.In,
        "Bounce.Out": mono.AniUtil.Easing.Bounce.Out,
        "Bounce.InOut": mono.AniUtil.Easing.Bounce.InOut
    },
    mono.AniUtil.AllEasingNames = [];
    for (name in mono.AniUtil.AllEasings) mono.AniUtil.AllEasingNames.push(name);
    mono.AniUtil.getAllActions = function() {
        return ["", "rotation", "move", "scale"]
    },
    mono.AniUtil.getAllAnchors = function() {
        return ["", "left", "right", "top", "bottom", "front", "back", "center-x", "center-y", "center-z"]
    },
    mono.AniUtil.getAllValues = function(a) {
        return [.1, .2, .3, .4, .5, .6, .7, .8, .9, 1, 1.25, 1.5, 1.75, 2, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330, 360, -30, -60, -90, -120, -150, -180, -210, -240, -270, -300, -330, -360]
    },
    mono.AniUtil.oldAnimationTypes = ["LeftMove", "RightMove", "FrontMove", "BackMove", "LeftRotationClockwise90", "LeftRotationAnticlockwise90", "LeftRotationClockwise120", "LeftRotationAnticlockwise120", "CenterRotationClockwise270", "CenterRotationAnticlockwise270"],
    mono.AniUtil.animate = function(a) {
        requestAnimationFrame(mono.AniUtil.animate),
        TWEEN.update(a)
    },
    mono.AniUtil.animate(),
    mono.AniUtil.createAxisByName = function(a) {
        var b = new mono.Vec3(0, 1, 0);
        return "y" === a && (b = new mono.Vec3(0, 1, 0)),
        "x" === a && (b = new mono.Vec3(1, 0, 0)),
        "z" === a && (b = new mono.Vec3(0, 0, 1)),
        b
    },
    mono.AniUtil.createAnchorPosition = function(a, b) {
        var c = a.getBoundingBox(),
        d = c.size(),
        e = 0,
        f = 0,
        g = 0;
        return "center" === b.substring(0, 6) || ("left" === b ? e = -d.x / 2 : "right" === b ? e = d.x / 2 : "front" === b ? g = d.z / 2 : "back" === b ? g = -d.z / 2 : "top" === b ? f = d.y / 2 : "bottom" === b && (f = -d.y / 2)),
        new mono.Vec3(e, f, g)
    },
    mono.AniUtil.playRotate = function(a, b, c, d, e, f, g, h) {
        var i = mono.AniUtil.createAxisByName(b),
        j = mono.AniUtil.createAnchorPosition(a, c);
        if (!a.__tween) {
            var k = 0,
            l = a.__animated ? d: -d;
            return a.__tweenLastRotation = k,
            a.__tweenDestRotation = l,
            a.__animated = !a.__animated,
            e = e || 1e3,
            f = f || 0,
            g = g || mono.AniUtil.DefaultEasing,
            a.__tween = new TWEEN.Tween({
                v: k
            }).to({
                v: l
            },
            e).easing(g).delay(f).onUpdate(function() {
                a.rotateFromAxis(i, j, this.v - a.__tweenLastRotation),
                a.__tweenLastRotation = this.v
            }).onComplete(function() {
                delete a.__tween,
                delete a.__tweenLastRotation,
                delete a.__tweenDestRotation,
                h && h.apply(a)
            }).start(),
            a.__tween
        }
    },
    mono.AniUtil.playScale = function(a, b, c, d, e, f, g) {
        if (!a.__tween) {
            var h = 0,
            i = c || 1;
            1 > c && (h = 1, i = c || 0),
            d = d || 1e3,
            e = e || 0,
            f = f || mono.AniUtil.DefaultEasing,
            a.__fromPosition = a.getPosition().clone(),
            a.__fromScale = a.getScale().clone();
            var j, k;
            "top" === b || "bottom" === b ? (j = a.getHeight() / 2, k = "y", "bottom" === b && (j = -1 * j)) : "front" === b || "back" === b ? (j = a.getDepth() / 2, k = "z", "back" === b && (j = -1 * j)) : "left" === b || "right" === b ? (j = a.getWidth() / 2, k = "x", "left" === b && (j = -1 * j)) : "center-x" === b ? k = "x": "center-y" === b ? k = "y": "center-z" === b ? k = "z": (j = a.getHeight() / 2, k = "y");
            var l = a.getPosition()[k] - j * a.getScale()[k],
            m = a.getPosition()[k] / a.getScale()[k] * c;
            return 1 > c && (l = a.getPosition()[k], m = a.getPosition()[k] / a.getScale()[k] * c - j * a.getScale()[k]),
            console.log(l, m),
            a.__tween = new TWEEN.Tween({
                scale: h,
                v: l
            }).to({
                scale: i,
                v: m
            },
            d).easing(f).delay(e).onUpdate(function() {
                if (j) {
                    var b = a.__fromPosition.clone();
                    b[k] = this.v,
                    a.setPosition(b)
                }
                var c = a.__fromScale.clone();
                c[k] = this.scale,
                a.setScale(c)
            }).onComplete(function() {
                delete a.__tween,
                delete a.__fromPosition,
                delete a.__fromScale,
                g && g.apply(a)
            }).start(),
            a.__tween
        }
    },
    mono.AniUtil.playMove = function(a, b, c, d, e, f, g) {
        var h; ("left" === b || "right" === b) && (h = "x", "left" === b && (c = -1 * c)),
        ("top" === b || "bottom" === b) && (h = "y", "bottom" === b && (c = -1 * c)),
        ("front" === b || "back" === b) && (h = "z", "back" === b && (c = -1 * c));
        var i = a.getBoundingBox(),
        j = i.max.x - i.min.x,
        k = i.max.y - i.min.y,
        l = i.max.z - i.min.z;
        if ("x" === h && (c *= j), "y" === h && (c *= k), "z" === h && (c *= l), !a.__tween) {
            var m = a.getPosition()[h],
            n = a.__animated ? a.getPosition()[h] - c: a.getPosition()[h] + c;
            return a.__animated = !a.__animated,
            a.__fromPosition = a.getPosition().clone(),
            d = d || 1e3,
            e = e || 0,
            f = f || mono.AniUtil.DefaultEasing,
            a.__tween = new TWEEN.Tween({
                v: m
            }).to({
                v: n
            },
            d).easing(f).delay(e).onUpdate(function() {
                var b = a.__fromPosition.clone();
                b[h] = this.v,
                a.setPosition(b)
            }).onComplete(function() {
                delete a.__tween,
                g && g.apply(a),
                console.log("complete", m, n, a)
            }).start(),
            a.__tween
        }
    },
    mono.AniUtil.getAxisByAnchor = function(a) {
        if ("top" === a || "bottom" === a) return "x";
        if ("left" === a || "right" === a) return "y";
        if ("front" === a || "back" === a) return "y";
        if ("center" === a.substring(0, 6)) {
            var b = a.split("-");
            return b[1]
        }
    },
    mono.AniUtil.playAnimation = function(a, b, c, d, e, f) {
        if (a && b) {
            if ( - 1 != mono.AniUtil.oldAnimationTypes.indexOf(b)) switch (b) {
            case "LeftMove":
                b = "move:left:0.9";
                break;
            case "RightMove":
                b = "move:right:0.9";
                break;
            case "FrontMove":
                b = "move:front:0.9";
                break;
            case "BackMove":
                b = "move:back:0.9";
                break;
            case "LeftRotationClockwise90":
                b = "rotation:left:90";
                break;
            case "LeftRotationAnticlockwise90":
                b = "rotation:left:-90";
                break;
            case "LeftRotationClockwise120":
                b = "rotation:left:120";
                break;
            case "LeftRotationAnticlockwise120":
                b = "rotation:left:-120";
                break;
            case "CenterRotationClockwise270":
                b = "rotation:center-y:270";
                break;
            case "CenterRotationAnticlockwise270":
                b = "rotation:center-y:-270"
            }
            c = c || 1e3,
            d = d || 0,
            e = e || mono.AniUtil.DefaultEasing;
            var g = b.split(":"),
            h = g[0],
            i = g[1],
            j = parseFloat(g[2]);
            if (g.length > 3 && (c = parseInt(g[3])), g.length > 4 && (d = parseInt(g[4])), g.length > 5 && (e = mono.AniUtil.AllEasings[g[5]]), "rotation" === h) {
                var k = mono.AniUtil.getAxisByAnchor(i);
                return j = j / 180 * Math.PI,
                mono.AniUtil.playRotate(a, k, i, j, c, d, e, f)
            }
            return "move" === h ? mono.AniUtil.playMove(a, i, j, c, d, e, f) : "scale" === h ? mono.AniUtil.playScale(a, i, j, c, d, e, f) : void 0
        }
    },
    mono.AniUtil.getAnimationString = function(a, b, c, d, e, f) {
        if (!a || !b || !c) return "";
        var g = a + ":" + b + ":" + c;
        return d && (g += ":" + d),
        g += e ? ":" + e: ":0",
        f && (g += ":" + f),
        g
    },
    mono.AniUtil.findAnimationAgent = function(a) {
        for (var b = a.getClient("animation"); ! b && a.getParent();) b = a.getParent().getClient("animation"),
        a = a.getParent();
        return b ? a: null
    },
    mono.AniUtil.playAlarmAnimation = function(a, b, c, d, e, f) {
        if (!a.__tween) {
            var g = 0,
            h = 60;
            return c = c || 1500,
            d = d || 0,
            e = e || TWEEN.Easing.Elastic.Out,
            a.__tween = new TWEEN.Tween({
                scale: g
            }).to({
                scale: h
            },
            c).easing(e).delay(d).onUpdate(function() {
                b.setScale(this.scale, this.scale, 1)
            }).onComplete(function() {
                delete a.__tween,
                f && f.apply()
            }).start()
        }
    },
    mono.AniUtil.playInspection = function(a, b, c) {
        return b.unshift({
            px: a.getCamera().getPosition().x,
            py: a.getCamera().getPosition().y,
            pz: a.getCamera().getPosition().z,
            tx: a.getCamera().getTarget().x,
            ty: a.getCamera().getTarget().y,
            tz: a.getCamera().getTarget().z
        }),
        b.__cursor || (b.__cursor = 1),
        mono.AniUtil._doPlayInspection(a, b, c)
    },
    mono.AniUtil._doPlayInspection = function(a, b, c) {
        if (b.__cursor < b.length) {
            var d = b[b.__cursor - 1],
            e = b[b.__cursor],
            f = mono.AniUtil._createInspectionTween(a, d, e);
            return f.onComplete(function() {
                b.__cursor++,
                mono.AniUtil._doPlayInspection(a, b, c)
            }),
            f.start(),
            f
        }
        c && c.apply()
    },
    mono.AniUtil._fixStopMissingValues = function(a, b) {
        null == b.px && (b.px = a.getCamera().getPosition().x),
        null == b.py && (b.py = a.getCamera().getPosition().y),
        null == b.pz && (b.pz = a.getCamera().getPosition().z),
        null == b.tx && (b.tx = a.getCamera().getTarget().x),
        null == b.ty && (b.ty = a.getCamera().getTarget().y),
        null == b.tz && (b.tz = a.getCamera().getTarget().z)
    },
    mono.AniUtil._createInspectionTween = function(a, b, c) {
        var d = c.time ? c.time: 2e3,
        e = c.delay ? c.delay: 0,
        f = c.easing ? c.easing: mono.AniUtil.DefaultEasing;
        return mono.AniUtil._fixStopMissingValues(a, b),
        mono.AniUtil._fixStopMissingValues(a, c),
        new TWEEN.Tween(b).to(c, d).easing(f).delay(e).onUpdate(function() {
            a.getCamera().look(new mono.Vec3(this.tx, this.ty, this.tz)),
            a.getCamera().setPosition(this.px, this.py, this.pz)
        })
    },
    mono.AniUtil.playTransform = function(a, b, c, d, e, f) {
        c = c || 2e3,
        d = d || 0,
        e = e || TWEEN.Easing.Linear.None,
        mono.AniUtil._fixTransformMissingValues(a, b);
        var g = mono.AniUtil.createElementTransform(a);
        return new TWEEN.Tween(g).to(b, c).easing(e).delay(d).onUpdate(function() {
            a.setPosition(this.px, this.py, this.pz),
            a.setRotation(this.rx, this.ry, this.rz),
            a.setScale(this.sx, this.sy, this.sz)
        }).onComplete(function() {
            f && f.apply()
        }).start()
    },
    mono.AniUtil._fixTransformMissingValues = function(a, b) {
        null == b.px && (b.px = b.getPosition().x),
        null == b.py && (b.py = b.getPosition().y),
        null == b.pz && (b.pz = b.getPosition().z),
        null == b.rx && (b.rx = b.getRotation().x),
        null == b.ry && (b.ry = b.getRotation().y),
        null == b.rz && (b.rz = b.getRotation().z),
        null == b.sx && (b.sx = b.getScale().x),
        null == b.sy && (b.sy = b.getScale().y),
        null == b.sz && (b.sz = b.getScale().z)
    },
    mono.AniUtil.createElementTransform = function(a) {
        return {
            px: a.getPosition().x,
            py: a.getPosition().y,
            pz: a.getPosition().z,
            rx: a.getRotation().x,
            ry: a.getRotation().y,
            rz: a.getRotation().z,
            sx: a.getScale().x,
            sy: a.getScale().y,
            sz: a.getScale().z
        }
    },
    mono.AniUtil.createTransform = function(a, b, c, d, e, f, g, h, i) {
        return {
            px: a,
            py: b,
            pz: c,
            rx: d,
            ry: e,
            rz: f,
            sx: g,
            sy: h,
            sz: i
        }
    },
    mono.AniUtil.isAnimated = function(a) {
        return a && null != a.__animated && a.__animated === !0
    },
    mono.AniUtil.resetAnimation = function(a) {
        if (a) {
            var b = a.getNodes().toArray();
            if (b) for (var c = 0; c < b.length; c++) {
                var d = b[c];
                mono.AniUtil.isAnimated(d) && mono.AniUtil.playAnimation(d, d.getClient("animation"))
            }
        }
    },
    mono.AniUtil.resetAnimatedFlag = function(a) {
        a && (delete a.__animated, delete a.__played)
    },
    mono.AniUtil.playCameraAnimation = function(a, b, c, d, e, f) {
        if (a && b) {
            c = c || 1e3,
            d = d || 0,
            e = e || mono.AniUtil.DefaultEasing;
            var g = b.split(":"),
            h = (g[0], parseFloat(g[1]));
            h = h / 180 * Math.PI;
            var i = mono.AniUtil.createAxisByName("y"),
            j = a.getTarget();
            if (!a.__tween) {
                var k = 0,
                l = h;
                return a.__tweenLastRotation = k,
                a.__tweenDestRotation = l,
                a.__tween = new TWEEN.Tween({
                    v: k
                }).to({
                    v: l
                },
                c).easing(e).delay(d).onUpdate(function() {
                    var b = q(i, a.getPosition(), j, this.v - a.__tweenLastRotation);
                    a.setPosition(b),
                    a.__tweenLastRotation = this.v
                }).onComplete(function() {
                    delete a.__tween,
                    delete a.__tweenLastRotation,
                    delete a.__tweenDestRotation,
                    f && f.apply(a)
                }).start(),
                a.__tween
            }
        }
    };
    var q = function(a, b, c, d) {
        var e = b.clone();
        return e.rotateFromAxisAndCenter(a, d, c)
    };
    mono.AnimationData = function(a, b, c, d) {
        this.object = b,
        this.animation = c,
        this.groupName = d,
        this._id = a
    },
    twaver.Util.ext("mono.AnimationData", Object, {
        play: function() {
            if (this.object instanceof mono.Entity) {
                this.object.__animated = this.object.__played;
                var a = this.animation.split(";");
                a.length >= 1 && (this.object.__played ? this.playAnimationString(a, a.length - 1, a.length, this.object.__played) : this.playAnimationString(a, 0, a.length, this.object.__played)),
                this.object.__played = !this.object.__played
            }
        },
        playAnimationString: function(a, b, c, d) {
            var e = this;
            this.object.__animated = d,
            d ? a[c - 1] && b >= 0 && mono.AniUtil.playAnimation(this.object, a[b], null, null, null,
            function() {
                e.playAnimationString(a, --b, c, d)
            }) : a[b] && c > b && mono.AniUtil.playAnimation(this.object, a[b], null, null, null,
            function() {
                e.playAnimationString(a, ++b, c, d)
            })
        },
        setAnimationGroup: function(a) {
            this.groupName = a
        },
        setAnimation: function(a) {
            this.animation = a
        },
        isPlayed: function() {
            return this.object && null != this.object.__played && this.object.__played === !0
        },
        reset: function() {
            this.isPlayed() && this.play()
        }
    }),
    mono.AnimationManager = function(a) {
        this.name = a,
        this.animations = [],
        this.animationMap = {},
        this.totalAnimations = [],
        this.isPlayed = !1
    },
    twaver.Util.ext("mono.AnimationManager", Object, {
        add: function(a) {
            this.animations.push(a),
            this.totalAnimations.push(a),
            this.animationMap[a._id] = a
        },
        remove: function(a) {
            var b = this.animations.indexOf(a); - 1 !== b && this.animations.splice(b, 1),
            this.animationMap[a._id] = null,
            b = this.totalAnimations.indexOf(a),
            -1 !== b && this.totalAnimations.splice(b, 1)
        },
        getAnimationById: function(a) {
            return this.animationMap[a]
        },
        stop: function() {
            var a = this.getCurrentAnimation();
            a.stop()
        },
        setTotalAnimations: function(a) {
            if (a && a.length > 0) for (var b in a) {
                var c = this.totalAnimations.indexOf(a[b]); - 1 !== c && this.totalAnimations.push(a[b])
            }
        },
        playAll: function() {
            if (this.animations && this.animations.length > 0) if (isPlayed) for (var a = this.animations.length - 1; a >= 0; a--) this.play(this.animations[a]);
            else for (var a = 0; a < animations.length; a++) this.play(this.animations[a]);
            isPlayed = !isPlayed
        },
        getCurrentAnimation: function() {
            if (this.animations && this.animations.length > 0) for (var a in this.animations) if (this.animations[a].isPlaying) return this.animations[a]
        },
        reset: function() {
            for (var a in this.animations) this.animations[a].reset()
        },
        play: function(a) {
            if (a.groupName) {
                var b = this.getAllAnimationsByGroupName(a.groupName);
                for (var c in b) b[c].play()
            } else a.play()
        },
        getAllAnimations: function() {
            return this.animations
        },
        getAllAnimationsByGroupName: function(a) {
            var b = [];
            if (this.totalAnimations && this.totalAnimations.length > 0) for (var c in this.totalAnimations) this.totalAnimations[c].groupName == a && b.push(this.totalAnimations[c]);
            return b
        },
        resetAllAnimations: function() {
            if (this.animations && this.animations.length > 0) for (var a in this.animations) this.animations[a].reset()
        }
    })
} ();
var extend = function(a, b, c) {
    a.superClass = b,
    a.prototype = inherit(b.prototype),
    a.prototype.constructor = a;
    for (prop in c) a.prototype[prop] = c[prop]
},
Healper_addEventListener = function(a, b, c, d, e) {
    null == e && (e = !1);
    var f = function(a) {
        c.call(f.scope, a)
    };
    f.scope = d,
    a.addEventListener ? a.addEventListener(b, f, e) : a.attachEvent("on" + b, f)
};
SampleData = function() {
    this.x = 0,
    this.y = 0,
    this.value = null
},
RecordSet = function(a, b) {
    this.max = a,
    this.data = b
},
CommonObject = function() {
    CommonObject.superClass.apply(this),
    this._c = {}
},
extend(CommonObject, Object, {
    get: function(a) {
        return this._c[a]
    },
    set: function(a, b) {
        this._c[a] = b
    },
    print: function(a) {
        console.log(a)
    },
    initDefaults: function(a) {
        for (pro in a) this._c[pro] = a[pro]
    }
}),
TH3 = function(a) {
    TH3.superClass.apply(this, arguments),
    this._store = new Store(this),
    this.initDefaults({
        radius: 40,
        element: null,
        canvas: {},
        acanvas: {},
        ctx: {},
        actx: {},
        legend: null,
        visible: !0,
        width: 0,
        height: 0,
        max: 0,
        gradient: !1,
        opacity: 180,
        premultiplyAlpha: !1,
        bounds: {
            l: 1e3,
            r: 0,
            t: 1e3,
            b: 0
        },
        gradient: {.25 : "rgb(0,0,255)",
            .5 : "rgb(0,255,255)",
            .75 : "rgb(0,255,0)",
            1 : "rgb(255,0,0)"
        },
        blur: 15
    }),
    this.init(),
    a ? this.configure(a) : this.initColorPalette()
},
extend(TH3, CommonObject, {
    setRadius: function(a) {
        var b = this.get("radius");
        b != a && (this.set("radius", a), this.updateSettings())
    },
    setBlur: function(a) {
        var b = this.get("blur");
        b != a && (this.set("blur", a), this.updateSettings())
    },
    setGradient: function(a) {
        this.set("gradient", a || {.25 : "rgb(0,0,255)",
            .5 : "rgb(0,255,255)",
            .75 : "rgb(0,255,0)",
            1 : "rgb(255,0,0)"
        }),
        this.initColorPalette()
    },
    setBounds: function() {
        if (2 == arguments.length) this.set("width", arguments[0]),
        this.set("height", arguments[1]);
        else if (1 == arguments.length) {
            var a = arguments[0],
            b = this.get("bounds");
            a.hasOwnProperty("left") && (b.l = a.left),
            a.hasOwnProperty("right") && (b.r = a.right),
            a.hasOwnProperty("top") && (b.t = a.top),
            a.hasOwnProperty("bottom") && (b.b = a.bottom)
        }
        this.updateSettings()
    },
    addPoint: function(a) {
        this._store.addPoint(a)
    },
    pushDataSet: function(a, b) {
        this._store.pushRecordSet(a, b)
    },
    showData: function() {
        console.log(this._store.toJSON())
    },
    configure: function(a) {
        if (this.set("radius", a.radius || 40), this.set("element", a.element instanceof Object ? a.element: document.getElementById(a.element)), this.set("visible", null != a.visible ? a.visible: !0), this.set("max", a.max || !1), this.setGradient(a.gradient), this.set("opacity", parseInt(255 / (100 / a.opacity), 10) || 180), this.set("width", a.width || 0), this.set("height", a.height || 0), a.legend) {
            var b = a.legend;
            b.gradient = this.get("gradient"),
            this.set("legend", new Legend(b))
        }
        this.updateSettings()
    },
    resize: function() {
        var a = this.get("element"),
        b = this.get("canvas"),
        c = this.get("acanvas");
        a ? (b.width = c.width = this.get("width") || a.style.width.replace(/px/, "") || this.getWidth(a), this.set("width", b.width), b.height = c.height = this.get("height") || a.style.height.replace(/px/, "") || this.getHeight(a), this.set("height", b.height)) : (b.width = c.width = this.get("width"), b.height = c.height = this.get("height"))
    },
    init: function() {
        var a = document.createElement("canvas"),
        b = document.createElement("canvas"),
        c = a.getContext("2d"),
        d = b.getContext("2d");
        a.className = "h29#3",
        this.set("canvas", a),
        this.set("ctx", c),
        this.set("acanvas", b),
        this.set("actx", d),
        a.style.cssText = b.style.cssText = "position:absolute;top:0;left:0;",
        a.isMovable = !0,
        this.get("visible") || (a.style.display = "none"),
        d.shadowOffsetX = 15e3,
        d.shadowOffsetY = 15e3,
        d.shadowBlur = this.get("blur")
    },
    bindElement: function(a) {
        this.set("element", a),
        this.appendTo(a)
    },
    updateSettings: function() {
        this.resize();
        var a = this.get("element");
        this.appendTo(a)
    },
    appendTo: function(a) {
        var b = this.get("canvas"),
        c = b.parentElement;
        c !== a && a && (a.appendChild(b), this.get("legend") && a.appendChild(this.get("legend").getElement()))
    },
    initColorPalette: function() {
        var a, b, c, d = document.createElement("canvas"),
        e = this.get("gradient");
        d.width = "1",
        d.height = "256",
        a = d.getContext("2d"),
        b = a.createLinearGradient(0, 0, 1, 256),
        c = a.getImageData(0, 0, 1, 1),
        c.data[0] = c.data[3] = 64,
        c.data[1] = c.data[2] = 0,
        a.putImageData(c, 0, 0),
        c = a.getImageData(0, 0, 1, 1),
        this.set("premultiplyAlpha", c.data[0] < 60 || c.data[0] > 70);
        for (var f in e) b.addColorStop(f, e[f]);
        a.fillStyle = b,
        a.fillRect(0, 0, 1, 256),
        this.set("gradientdata", a.getImageData(0, 0, 1, 256).data)
    },
    getWidth: function(a) {
        var b = a.offsetWidth;
        return a.style.paddingLeft && (b += a.style.paddingLeft),
        a.style.paddingRight && (b += a.style.paddingRight),
        b
    },
    getHeight: function(a) {
        var b = a.offsetHeight;
        return a.style.paddingTop && (b += a.style.paddingTop),
        a.style.paddingBottom && (b += a.style.paddingBottom),
        b
    },
    colorize: function(a, b) {
        var c, d, e, f, g, h, i, j, k, l, m = this.get("width"),
        n = this.get("radius"),
        o = this.get("height"),
        p = this.get("actx"),
        q = this.get("ctx"),
        r = 3 * n,
        s = this.get("premultiplyAlpha"),
        t = this.get("gradientdata"),
        u = this.get("opacity"),
        v = this.get("bounds");
        null != a && null != b ? (a + r > m && (a = m - r), 0 > a && (a = 0), 0 > b && (b = 0), b + r > o && (b = o - r), c = a, d = b, f = a + r, e = b + r) : (c = v.l < 0 ? 0 : v.l, f = v.r > m ? m: v.r, d = v.t < 0 ? 0 : v.t, e = v.b > o ? o: v.b),
        g = p.getImageData(c, d, f - c, e - d),
        h = g.data,
        i = h.length;
        for (var w = 3; i > w; w += 4) j = h[w],
        k = 4 * j,
        k && (l = u > j ? j: u, h[w - 3] = t[k], h[w - 2] = t[k + 1], h[w - 1] = t[k + 2], s && (h[w - 3] /= 255 / l, h[w - 2] /= 255 / l, h[w - 1] /= 255 / l), h[w] = l);
        g.data = h,
        q.putImageData(g, c, d)
    },
    drawBackground: function(a) {},
    drawAlpha: function(a, b, c, d) {
        var e = this.get("radius"),
        f = this.get("actx"),
        g = this.getMax(),
        h = this.get("bounds"),
        i = this.get("blur"),
        j = a - 1.5 * e >> 0,
        k = b - 1.5 * e >> 0,
        l = a + 1.5 * e >> 0,
        m = b + 1.5 * e >> 0;
        f.save(),
        this.drawBackground(f),
        f.restore(),
        f.shadowColor = "rgba(0,0,0," + (c ? c / g: "0.1") + ")",
        console.log(c),
        f.shadowOffsetX = 15e3,
        f.shadowOffsetY = 15e3,
        f.shadowBlur = i,
        f.beginPath(),
        f.arc(a - 15e3, b - 15e3, e, 0, 2 * Math.PI, !0),
        f.closePath(),
        f.fill(),
        d ? this.colorize(j, k) : (j < h.l && (h.l = j), k < h.t && (h.t = k), l > h.r && (h.r = l), m > h.b && (h.b = m))
    },
    toggleDisplay: function() {
        var a = this.get("visible"),
        b = this.get("canvas");
        a ? b.style.display = "none": b.style.display = "block",
        this.set("visible", !a)
    },
    getImage: function() {
        var a = this.get("canvas");
        return a.toDataURL()
    },
    clear: function() {
        var a = this.get("width"),
        b = this.get("height");
        this._store.set("data", []),
        this.get("ctx").clearRect(0, 0, a, b),
        this.get("actx").clearRect(0, 0, a, b)
    },
    cleanup: function() {
        this.get("element").removeChild(this.get("canvas"))
    },
    getMax: function() {
        return this.get("max") ? this.get("max") : this._store._max
    },
    setMax: function(a) {
        this.set("max", a)
    },
    getDataSet: function() {
        return this._store.get("data")
    },
    updateAlpha: function(a) {
        for (var a = this.getDataSet(), b = 0; b < a.length; b++) {
            var c = a[b];
            if (c) for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && this.drawAlpha(b, d, e, !0)
            }
        }
    },
    print: function(a) {
        TH3.superClass.prototype.print.apply(this, arguments)
    }
}),
Store = function(a) {
    Store.superClass.apply(this, arguments),
    this._max = 1,
    this._m = a,
    this.set("data", [])
},
extend(Store, CommonObject, {
    addPoint: function(a) {
        a.value ? this.addDataPoint(a.x, a.y, a.value) : a.count ? this.addDataPoint(a.x, a.y, a.count) : this.addDataPoint(a.x, a.y)
    },
    addDataPoint: function(a, b) {
        if (! (0 > a || 0 > b)) {
            var c = this.get("data");
            return c[a] || (c[a] = []),
            c[a][b] || (c[a][b] = 0),
            c[a][b] += arguments.length < 3 ? 1 : arguments[2],
            2 == c[a][b] && console.log("add data point " + a + "," + b + "   " + c[a][b]),
            this.set("data", c),
            this._max < c[a][b] ? (this._m.get("actx").clearRect(0, 0, this._m.get("width"), this._m.get("height")), void this.setDataSet({
                max: c[a][b],
                data: c
            },
            !0)) : void this._m.drawAlpha(a, b, c[a][b], !0)
        }
    },
    pushRecordSet: function(a, b) {
        this.setDataSet(a, b)
    },
    setDataSet: function(a, b) {
        var c = [],
        d = a.data,
        e = d.length;
        if (this._m.clear(), this._max = a.max, this._m.get("legend") && this._m.get("legend").update(a.max), null != b && b) {
            for (var f in d) if (void 0 !== f) for (var g in d[f]) void 0 !== g && this._m.drawAlpha(f, g, d[f][g], !1)
        } else for (; e--;) {
            var h = d[e];
            c[h.x] || (c[h.x] = []),
            c[h.x][h.y] || (c[h.x][h.y] = 0),
            h.value ? c[h.x][h.y] = h.value: h.count ? c[h.x][h.y] = h.count: c[h.x][h.y] ? c[h.x][h.y]++:c[h.x][h.y] = 1,
            this._m.drawAlpha(h.x, h.y, c[h.x][h.y], !1)
        }
        this._m.colorize(),
        this.set("data", d)
    },
    exportDataSet: function() {
        var a = this.get("data"),
        b = [];
        for (var c in a) if (void 0 !== c) for (var d in a[c]) void 0 !== d && b.push({
            x: parseInt(c, 10),
            y: parseInt(d, 10),
            count: 1e3
        });
        return {
            max: this._max,
            data: b
        }
    },
    generateRandomDataSet: function(a) {
        var b = this._m.get("width"),
        c = this._m.get("height"),
        d = {},
        e = Math.floor(1e3 * Math.random() + 1);
        d.max = e;
        for (var f = []; a--;) f.push({
            x: Math.floor(Math.random() * b + 1),
            y: Math.floor(Math.random() * c + 1),
            count: Math.floor(Math.random() * e + 1)
        });
        d.data = f,
        this.setDataSet(d)
    },
    toJSON: function() {
        for (var a = [], b = this.get("data"), c = 0; c < b.length; c++) if (b[c]) for (var d = 0; d < b[c].length; d++) b[c][d] && a.push({
            x: c,
            y: d,
            v: b[c][d]
        });
        return JSON.stringify(a)
    }
}),
Legend = function(a) {
    Legend.superClass.apply(this, arguments),
    this.set("decimal", 0),
    this.init(a)
},
extend(Legend, CommonObject, {
    init: function(a) {
        this.config = a,
        a && a.decimal && this.set("decimal", a.decimal);
        var b, c, d = a.title || "Legend",
        e = a.position,
        f = a.offset || 10,
        g = (a.gradient, document.createElement("ul")),
        h = "";
        this.processGradientObject(),
        h += e.indexOf("t") > -1 ? "top:" + f + "px;": "bottom:" + f + "px;",
        h += e.indexOf("l") > -1 ? "left:" + f + "px;": "right:" + f + "px;",
        b = document.createElement("div"),
        b.style.cssText = "border-radius:5px;position:absolute;" + h + "font-family:Helvetica; width:256px;z-index:10000000000; background:rgba(255,255,255,1);padding:10px;border:1px solid black;margin:0;",
        b.innerHTML = "<h3 style='padding:0;margin:0;text-align:center;font-size:16px;'>" + d + "</h3>",
        g.style.cssText = "position:relative;font-size:12px;display:block;list-style:none;list-style-type:none;margin:0;height:15px;",
        c = document.createElement("div"),
        c.style.cssText = ["position:relative;display:block;width:256px;height:15px;border-bottom:1px solid black; background-image:url(", this.createGradientImage(), ");"].join(""),
        b.appendChild(g),
        b.appendChild(c),
        b.className = "l_m",
        this.set("element", b),
        this.set("labelsEl", g),
        this.update(1)
    },
    processGradientObject: function() {
        var a = this.config.gradient,
        b = [];
        for (var c in a) a.hasOwnProperty(c) && b.push({
            stop: c,
            value: a[c]
        });
        b.sort(function(a, b) {
            return a.stop - b.stop
        }),
        b.unshift({
            stop: 0,
            value: "rgba(0,0,0,0)"
        }),
        this.set("gradientArr", b)
    },
    createGradientImage: function() {
        var a, b = this.get("gradientArr"),
        c = b.length,
        d = document.createElement("canvas"),
        e = d.getContext("2d");
        d.width = "256",
        d.height = "15",
        a = e.createLinearGradient(0, 5, 256, 10);
        for (var f = 0; c > f; f++) a.addColorStop(1 / (c - 1) * f, b[f].value);
        e.fillStyle = a,
        e.fillRect(0, 5, 256, 10),
        e.strokeStyle = "black",
        e.beginPath();
        for (var f = 0; c > f; f++) e.moveTo((1 / (c - 1) * f * 256 >> 0) + .5, 0),
        e.lineTo((1 / (c - 1) * f * 256 >> 0) + .5, 0 == f ? 15 : 5);
        return e.moveTo(255.5, 0),
        e.lineTo(255.5, 15),
        e.moveTo(255.5, 4.5),
        e.lineTo(0, 4.5),
        e.stroke(),
        this.set("ctx", e),
        d.toDataURL()
    },
    getElement: function() {
        return this.get("element")
    },
    update: function(a) {
        for (var b, c, d = this.get("gradientArr"), e = this.get("ctx"), f = this.get("labelsEl"), g = "", h = this.get("decimal"), i = 0; i < d.length; i++) b = (a * d[i].stop).toFixed(h),
        c = e.measureText(b).width / 2 >> 0,
        0 == i && (c = 0),
        i == d.length - 1 && (c *= 2),
        g += '<li style="position:absolute;left:' + (((1 / (d.length - 1) * i * 256 || 0) >> 0) - c + .5) + 'px">' + b + "</li>";
        f.innerHTML = g
    }
}),
TemperatureBoard = function(a, b, c, d, e, f, g) {
    this.direction = c || "v",
    this.width = a,
    this.height = b,
    this.map = new TH3(g),
    this.map.setRadius(d || 25),
    this.map.setBounds(a, b),
    this.map.setGradient(e),
    this.map.setBlur(f || 15)
},
extend(TemperatureBoard, Object, {
    setDirection: function(a) {
        this.direction = a
    },
    setSize: function(a, b) {
        this.width = a,
        this.height = b,
        map.setBounds(a, b)
    },
    drawBackground: function(a) {
        this.map.drawBackground(a),
        this.map.updateAlpha()
    },
    addPoint: function() {
        if (1 == arguments.length && "object" == typeof arguments[0]) this.map.addPoint(arguments[0]);
        else if (3 == arguments.length) {
            var a = new SampleData;
            a.x = arguments[0],
            a.y = arguments[1],
            a.value = arguments[2],
            this.map.addPoint(a)
        }
    },
    getImage: function() {
        return this.map.getImage()
    },
    getTemperatureBoard: function() {
        var a = new TGL.Plane(this.width, this.height);
        return a.setStyle("m.texture.repeat", new TGL.Vec2(1, 1)).setStyle("m.type", "basic").setStyle("m.texture.image", this.getImage()).setStyle("m.transparent", !0).setStyle("m.side", "both"),
        "h" == this.direction && a.setRotation(90 * Math.PI / 180, 0, 0),
        a
    },
    setGradient: function(a) {
        this.map.setGradient(a),
        this.map.updateAlpha()
    },
    setRadius: function(a) {
        this.map.setRadius(a),
        this.map.updateAlpha()
    },
    setBlur: function(a) {
        this.map.setBlur(a),
        this.map.updateAlpha()
    },
    setMax: function(a) {
        this.map.setMax(a),
        this.map.updateAlpha()
    }
}),
LEDDisplay = function(a) {
    this._dom = document.createElement("canvas"),
    this._dom.setAttribute("width", 160),
    this._dom.setAttribute("height", 32);
    var b = new Image,
    c = this;
    b.onload = function() {
        c.repaint()
    },
    b.src = a,
    this.board = b
},
extend(LEDDisplay, Object, {
    repaint: function() {
        this.paint(this.cont)
    },
    getx: function(a) {
        return NaN === a ? 10 : a >= 0 && 9 >= a ? a: 10
    },
    getView: function() {
        return this._dom
    },
    display: function(a) {
        var b = a;
        a.length || (b += "");
        for (var c = b.length,
        d = [], e = 0; c > e; e++) d.push(b.substr(e, 1));
        this.paint(d)
    },
    paint: function(a) {
        this.cont = a;
        var b = this._dom,
        c = b.getContext("2d");
        c.clearRect(0, 0, b.width, b.height);
        for (var d = 0; d < a.length; d++) {
            var e = this.getx(Number(a[d]));
            c.drawImage(this.board, 32 * e, 0, 32, 32, 32 * d, 0, 32, 32)
        }
    }
}),
mono.Toolkits = {},
mono.Toolkits.loadGraph = function(a, b, c, d) {
    return modelManager.loadGraph(a, b, c, d)
},
mono.Toolkits.loadTemplateByName = function(a, b, c, d, e) {
    modelManager.loadTemplateFromCloud(a, b, c, e)
},
mono.Toolkits.loadTemplateById = function(a, b, c, d, e) {
    modelManager.loadCloudTemplateById(a, b, c, d, e)
},
mono.Toolkits.loadGraphUrl = function(a, b, c, d, e, f) {
    modelManager.loadGraphUrl(a, b, c, d, e, f)
},
mono.Toolkits.loadGraphDatas = function(a) {
    return modelManager.loadGraphDatas(a)
},
mono.Toolkits.exportGraph = function(a) {
    return modelManager.serializeGraphInfo(a, !0)
},
mono.Toolkits.loadTemplate = function(a, b, c) {
    return modelManager.loadComponentTemplateFromContents(a, b, c, !1)
},
mono.Toolkits.loadTemplateUrl = function(a, b, c, d, e) {
    modelManager.loadComponentTemplateFromURL(a, b, c, d, e)
},
mono.Toolkits.login = function(a, b, c, d) {
    Utils.login(a, b, c, d)
},
mono.Toolkits.batchExportTemplates = function(a) {
    return (new TemplateTablePane).batchDownloadTemplates(a)
};
var modelManager, timerID, taskCount = 0,
showDim = !1,
showCoord = !1,
decimalNumber = 2,
refreshNetwork, loadmodels = function(a) {
    var b = document.createElement("script");
    b.setAttribute("type", "text/javascript"),
    b.setAttribute("src", Utils.RelativePath + "resources/" + a),
    document.getElementsByTagName("head")[0].appendChild(b)
},
initModelLib = function(a) {
    modelManager = new modellib.ModelManager,
    a && (loadmodels("RoomPrimitives.json"), loadmodels("RoomAssembles.json"))
},
parsePrimitives = function(a) {
    modelManager.parsePrimitives(a),
    modelManager.loadSharedPrimitive(),
    taskCount++
},
parseAssembles = function(a) {
    modelManager.parseAssembles(a),
    modelManager.loadSharedAssemble(),
    taskCount++
},
parseLib = function(a) {
    modelManager.parseLib(a),
    taskCount++
} +
function(a, b) {
    mono.LoadingManager = function(a, c, d) {
        var e = this,
        f = 0,
        g = 0;
        this.onLoad = a,
        this.onProgress = c,
        this.onError = d,
        this.itemStart = function(a) {
            g++
        },
        this.itemEnd = function(a) {
            f++,
            e.onProgress !== b && e.onProgress(a, f, g),
            f === g && e.onLoad !== b && e.onLoad()
        }
    },
    mono.DefaultLoadingManager = new mono.LoadingManager,
    mono.ImageLoader = function(a) {
        this.manager = a !== b ? a: mono.DefaultLoadingManager
    },
    mono.ImageLoader.prototype = {
        constructor: mono.ImageLoader,
        load: function(a, c, d, e) {
            var f = this,
            g = document.createElement("img");
            return c !== b && g.addEventListener("load",
            function(b) {
                f.manager.itemEnd(a),
                c(this)
            },
            !1),
            d !== b && g.addEventListener("progress",
            function(a) {
                d(a)
            },
            !1),
            e !== b && g.addEventListener("error",
            function(a) {
                e(a)
            },
            !1),
            this.crossOrigin !== b && (g.crossOrigin = this.crossOrigin),
            g.src = a,
            f.manager.itemStart(a),
            g
        },
        loadFile: function(a, c, d, e) {
            var f = this,
            g = new FileReader;
            c !== b && (g.onload = function() {
                c(g.result),
                f.manager.itemEnd(a.name)
            }),
            d !== b && g.addEventListener("progress",
            function(a) {
                d(a)
            },
            !1),
            e !== b && g.addEventListener("error",
            function(a) {
                e(a)
            },
            !1),
            g.readAsDataURL(a),
            f.manager.itemStart(a.name)
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        }
    },
    mono.XHRLoader = function(a) {
        this.manager = a !== b ? a: mono.DefaultLoadingManager
    },
    mono.XHRLoader.prototype = {
        constructor: mono.XHRLoader,
        load: function(a, c, d, e) {
            var f = this,
            g = new XMLHttpRequest;
            c !== b && g.addEventListener("load",
            function(b) {
                c(b.target.responseText),
                f.manager.itemEnd(a)
            },
            !1),
            d !== b && g.addEventListener("progress",
            function(a) {
                d(a)
            },
            !1),
            e !== b && g.addEventListener("error",
            function(a) {
                e(a)
            },
            !1),
            this.crossOrigin !== b && (g.crossOrigin = this.crossOrigin),
            g.open("GET", a, !0),
            g.send(null),
            f.manager.itemStart(a)
        },
        loadFile: function(a, c, d, e) {
            if (a) {
                var f = this,
                g = new FileReader;
                c !== b && (g.onload = function() {
                    c(g.result),
                    f.manager.itemEnd(a.name)
                }),
                d !== b && g.addEventListener("progress",
                function(a) {
                    d(a)
                },
                !1),
                e !== b && g.addEventListener("error",
                function(a) {
                    e(a)
                },
                !1),
                g.readAsText(a),
                f.manager.itemStart(a.name)
            }
        },
        setCrossOrigin: function(a) {
            this.crossOrigin = a
        }
    },
    mono.MTLLoader = function(a, b, c) {
        this.baseUrl = a,
        this.options = b,
        this.crossOrigin = c
    },
    mono.extend(mono.MTLLoader, null, {
        constructor: mono.MTLLoader,
        load: function(a, b, c, d) {
            var e = this,
            f = new mono.XHRLoader;
            f.setCrossOrigin(this.crossOrigin),
            f.load(a,
            function(a) {
                b(e.parse(a))
            })
        },
        loadFile: function(a, b, c, d) {
            var e = this,
            f = new mono.XHRLoader;
            f.loadFile(a,
            function(a) {
                b(e.parse(a))
            })
        },
        loadText: function(a, b) {
            b(this.parse(a))
        },
        parse: function(a) {
            for (var b = a.split("\n"), c = {},
            d = /\s+/, e = {},
            f = 0; f < b.length; f++) {
                var g = b[f];
                if (g = g.trim(), 0 !== g.length && "#" !== g.charAt(0)) {
                    var h = g.indexOf(" "),
                    i = h >= 0 ? g.substring(0, h) : g;
                    i = i.toLowerCase();
                    var j = h >= 0 ? g.substring(h + 1) : "";
                    if (j = j.trim(), "newmtl" === i) c = {
                        name: j
                    },
                    e[j] = c;
                    else if (c) if ("ka" === i || "kd" === i || "ks" === i) {
                        var k = j.split(d, 3);
                        c[i] = [parseFloat(k[0]), parseFloat(k[1]), parseFloat(k[2])]
                    } else c[i] = j
                }
            }
            var l = new mono.MTLLoader.MaterialCreator(this.baseUrl, this.options);
            return l.setMaterials(e),
            l
        }
    }),
    mono.MTLLoader.MaterialCreator = function(a, b) {
        this.baseUrl = a,
        this.options = b,
        this.materialsInfo = {},
        this.materials = {},
        this.materialsArray = [],
        this.nameLookup = {},
        this.side = this.options && this.options.side ? this.options.side: mono.FrontSide,
        this.wrap = this.options && this.options.wrap ? this.options.wrap: mono.RepeatWrapping
    },
    mono.extend(mono.MTLLoader.MaterialCreator, mono.EventDispatcher, {
        constructor: mono.MTLLoader.MaterialCreator,
        setMaterials: function(a) {
            this.materialsInfo = this.convert(a),
            this.materials = {},
            this.materialsArray = [],
            this.nameLookup = {}
        },
        convert: function(a) {
            if (!this.options) return a;
            var b = {};
            for (var c in a) {
                var d = a[c],
                e = {};
                b[c] = e;
                for (var f in d) {
                    var g = !0,
                    h = d[f],
                    i = f.toLowerCase();
                    switch (i) {
                    case "kd":
                    case "ka":
                    case "ks":
                        this.options && this.options.normalizeRGB && (h = [h[0] / 255, h[1] / 255, h[2] / 255]),
                        this.options && this.options.ignoreZeroRGBs && 0 === h[0] && 0 === h[1] && 0 === h[1] && (g = !1);
                        break;
                    case "d":
                        this.options && this.options.invertTransparency && (h = 1 - h)
                    }
                    g && (e[i] = h)
                }
            }
            return b
        },
        preload: function() {
            for (var a in this.materialsInfo) this.create(a)
        },
        getIndex: function(a) {
            return this.nameLookup[a]
        },
        getAsArray: function() {
            var a = 0;
            for (var b in this.materialsInfo) this.materialsArray[a] = this.create(b),
            this.nameLookup[b] = a,
            a++;
            return this.materialsArray
        },
        create: function(a) {
            return this.materials[a] === b && this.createMaterial_(a),
            this.materials[a]
        },
        createMaterial_: function(a) {
            var b = this,
            c = this.materialsInfo[a],
            d = {
                name: a,
                side: this.side
            };
            for (var e in c) {
                var f = c[e];
                switch (e.toLowerCase()) {
                case "kd":
                    d.diffuse = (new mono.Color).setRGB(f[0], f[1], f[2]);
                    break;
                case "ka":
                    d.ambient = (new mono.Color).setRGB(f[0], f[1], f[2]);
                    break;
                case "ks":
                    d.specular = (new mono.Color).setRGB(f[0], f[1], f[2]);
                    break;
                case "map_kd":
                    if ("string" == typeof this.baseUrl) d.map = {},
                    d.map.img = this.baseUrl + f,
                    d.map.wrapS = this.wrap,
                    d.map.wrapT = this.wrap;
                    else if ("object" == typeof this.baseUrl) {
                        if (f.indexOf(".") > 0) {
                            f = f.substring(0, f.lastIndexOf(".")).toLowerCase();
                            var g = {};
                            if (/\-s/.test(f)) {
                                var h = /\-s( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
                                g = h.exec(f);
                                var i = f.split(g[0]);
                                f = i[i.length - 1].trim(),
                                g.repeatR = parseInt(g[1]),
                                g.repeatC = parseInt(g[2])
                            }
                            if (/\-t/.test(f)) {
                                var h = /\-t( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
                                g = h.exec(f);
                                var i = f.split(g[0]);
                                f = i[i.length - 1].trim(),
                                g.repeatR = parseInt(g[1]),
                                g.repeatC = parseInt(g[2])
                            }
                        }
                        this.baseUrl[f] && (d.map = {},
                        d.map.img = this.baseUrl[f], d.map.wrapS = b.wrap, d.map.wrapT = b.wrap, d.map.repeatR = g.repeatR, d.map.repeatC = g.repeatC)
                    }
                    break;
                case "ns":
                    d.shininess = f;
                    break;
                case "d":
                    1 > f && (d.transparent = !0, d.opacity = f)
                }
            }
            return d.diffuse && (d.ambient || (d.ambient = d.diffuse), d.color = d.diffuse),
            this.materials[a] = d,
            this.materials[a]
        },
        loadTexture: function(a, b, c, d) {
            var e = /\.dds$/i.test(a);
            if (e) var f = mono.ImageUtils.loadCompressedTexture(a, b, c, d);
            else {
                var g = new Image,
                f = new mono.Texture(g, b),
                h = new mono.ImageLoader;
                h.crossOrigin = this.crossOrigin,
                h.load(a,
                function(a) {
                    f.image = mono.MTLLoader.ensurePowerOfTwo_(a),
                    f.needsUpdate = !0,
                    c && c(f)
                })
            }
            return f
        }
    }),
    mono.MTLLoader.ensurePowerOfTwo_ = function(a) {
        if (!mono.MTLLoader.isPowerOfTwo_(a.width) || !mono.MTLLoader.isPowerOfTwo_(a.height)) {
            var b = document.createElement("canvas");
            b.width = mono.MTLLoader.nextHighestPowerOfTwo_(a.width),
            b.height = mono.MTLLoader.nextHighestPowerOfTwo_(a.height);
            var c = b.getContext("2d");
            return c.drawImage(a, 0, 0, a.width, a.height, 0, 0, b.width, b.height),
            b
        }
        return a
    },
    mono.MTLLoader.isPowerOfTwo_ = function(a) {
        return 0 === (a & a - 1)
    },
    mono.MTLLoader.nextHighestPowerOfTwo_ = function(a) {--a;
        for (var b = 1; 32 > b; b <<= 1) a |= a >> b;
        return a + 1
    },
    mono.OBJLoader = function(a) {
        this.manager = a !== b ? a: mono.DefaultLoadingManager
    },
    mono.extend(mono.OBJLoader, Object, {
        constructor: mono.ObJLoader,
        load: function(a, b, c, d) {
            var e = this,
            f = new mono.XHRLoader(e.manager);
            f.setCrossOrigin(this.crossOrigin),
            f.load(a,
            function(a) {
                b(e.parse(a))
            })
        },
        parse: function(a) {
            function c(a, b, c) {
                return new mono.Vec3(a, b, c)
            }
            function d(a, b) {
                return new mono.Vec2(a, b)
            }
            function e(a, b, c, d) {
                return new mono.Face3(a, b, c, d)
            }
            function f(a, c, d, f) {
                f === b ? i.faces.push(e(parseInt(a) - (l + 1), parseInt(c) - (l + 1), parseInt(d) - (l + 1))) : i.faces.push(e(parseInt(a) - (l + 1), parseInt(c) - (l + 1), parseInt(d) - (l + 1), [n[parseInt(f[0]) - 1].clone(), n[parseInt(f[1]) - 1].clone(), n[parseInt(f[2]) - 1].clone()]))
            }
            function g(a, b, c) {
                i.uvs.push([o[parseInt(a) - 1].clone(), o[parseInt(b) - 1].clone(), o[parseInt(c) - 1].clone()])
            }
            function h(a, c, d) {
                a[3] === b ? (f(a[0], a[1], a[2], d), c !== b && c.length > 0 && g(c[0], c[1], c[2])) : (d !== b && d.length > 0 ? (f(a[0], a[1], a[3], [d[0], d[1], d[3]]), f(a[1], a[2], a[3], [d[1], d[2], d[3]])) : (f(a[0], a[1], a[3]), f(a[1], a[2], a[3])), c !== b && c.length > 0 && (g(c[0], c[1], c[3]), g(c[1], c[2], c[3])))
            }
            var i, j, k = new mono.Element,
            l = 0;
            /^o /gm.test(a) === !1 && (i = new mono.Entity, j = new mono.BasicMaterial, i.setStyle("m.type", "phong"), k.addChild(i));
            for (var m = 0,
            n = [], o = [], p = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, q = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, r = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, s = /f( +\d+)( +\d+)( +\d+)( +\d+)?/, t = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, u = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, v = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, w = a.split("\n"), x = 0; x < w.length; x++) {
                var y = w[x];
                y = y.trim();
                var z;
                0 !== y.length && "#" !== y.charAt(0) && (null !== (z = p.exec(y)) ? i.vertices.push(c(parseFloat(z[1]), parseFloat(z[2]), parseFloat(z[3]))) : null !== (z = q.exec(y)) ? n.push(c(parseFloat(z[1]), parseFloat(z[2]), parseFloat(z[3]))) : null !== (z = r.exec(y)) ? o.push(d(parseFloat(z[1]), parseFloat(z[2]))) : null !== (z = s.exec(y)) ? h([z[1], z[2], z[3], z[4]]) : null !== (z = t.exec(y)) ? h([z[2], z[5], z[8], z[11]], [z[3], z[6], z[9], z[12]]) : null !== (z = u.exec(y)) ? h([z[2], z[6], z[10], z[14]], [z[3], z[7], z[11], z[15]], [z[4], z[8], z[12], z[16]]) : null !== (z = v.exec(y)) ? h([z[2], z[5], z[8], z[11]], [], [z[3], z[6], z[9], z[12]]) : /^o /.test(y) ? (i !== b && (l += i.vertices.length), i = new mono.Entity, j = new mono.BasicMaterial, i.setStyle("m.type", "phong"), i._name = y.substring(2).trim(), k.addChild(i), m = 0) : /^g /.test(y) || (/^usemtl /.test(y) ? y.substring(7).trim() : /^mtllib /.test(y) || /^s /.test(y)))
            }
            for (var x = 0,
            A = k._childList._as.length; A > x; x++) {
                var i = k._childList._as[x];
                i.computed = !1,
                i.computeNodeData(),
                i.computeCentroids(),
                i.computeFaceNormals(),
                i.computeBoundingSphere()
            }
            return k
        }
    }),
    mono.OBJMTLLoader = function() {},
    mono.extend(mono.OBJMTLLoader, mono.MTLLoader, {
        constructor: mono.OBJMTLLoader,
        load: function(a, b, c, d, e, f) {
            var g = this,
            h = new mono.MTLLoader(c);
            h.load(b,
            function(b) {
                var c = b;
                c.preload();
                var e = new mono.XHRLoader(g.manager);
                e.setCrossOrigin(this.crossOrigin),
                e.load(a,
                function(a) {
                    for (var b = g.parse(a), e = 0; e < b._childList._as.length; e++) {
                        var f = b._childList._as[e];
                        if (f.mname) {
                            var h = c.create(f.mname);
                            g.setGeometryStyle(f, h)
                        }
                        for (var i = 0; i < f._childList._as.length; i++) {
                            var j = f._childList._as[i];
                            if (j.mname) {
                                var k = c.create(j.mname);
                                g.setGeometryStyle(j, k)
                            }
                        }
                    }
                    d(b)
                })
            })
        },
        setGeometryStyle: function(a, b) {
            if (b.map) {
                this.loadTexture(a, b.map.img);
                var c = b.map.repeatR,
                d = b.map.repeatC;
                c && d && a.setStyle("m.texture.repeat", new mono.Vec2(c, d))
            }
            a.setStyle("m.ambient", b.ambient),
            a.setStyle("m.specular", b.specular),
            a.setStyle("m.color", b.color),
            b.transparent && (a.setStyle("m.transparent", !0), a.setStyle("m.opacity", b.opacity))
        },
        loadBase64: function(a, b, c, d, e, f) {
            var g = this,
            h = mono.base64decode(b),
            i = mono.base64decode(a),
            j = new mono.MTLLoader(c);
            j.loadText(h,
            function(a) {
                var b = a;
                b.preload();
                for (var c = g.parse(i), e = 0; e < c._childList._as.length; e++) {
                    var f = c._childList._as[e];
                    if (f.mname) {
                        var h = b.create(f.mname);
                        g.setGeometryStyle(f, h)
                    }
                    for (var j = 0; j < f._childList._as.length; j++) {
                        var k = f._childList._as[j];
                        if (k.mname) {
                            var l = b.create(k.mname);
                            g.setGeometryStyle(k, l)
                        }
                    }
                }
                d(c)
            });
        },
        loadFiles: function(a, b, c, d, e, f) {
            var g = this,
            h = new mono.MTLLoader(c);
            h.loadFile(b,
            function(b) {
                var c = b;
                c.preload();
                var e = new mono.XHRLoader(g.manager);
                e.loadFile(a,
                function(a) {
                    for (var b = g.parse(a), e = 0; e < b._childList._as.length; e++) {
                        var f = b._childList._as[e];
                        if (f.mname) {
                            var h = c.create(f.mname);
                            g.setGeometryStyle(f, h)
                        }
                        for (var i = 0; i < f._childList._as.length; i++) {
                            var j = f._childList._as[i];
                            if (j.mname) {
                                var k = c.create(j.mname);
                                g.setGeometryStyle(j, k)
                            }
                        }
                    }
                    d(b)
                })
            })
        },
        loadTexture: function(a, b) {
            if ("string" == typeof b) a.setStyle("m.texture.image", b);
            else if (a && b) {
                var c = new mono.ImageLoader;
                c.loadFile(b,
                function(b) {
                    a.setStyle("m.texture.image", b)
                })
            }
        },
        parse: function(a, c) {
            function d(a, b, c) {
                return new mono.Vec3(a, b, c)
            }
            function e(a, b) {
                return new mono.Vec2(a, b)
            }
            function f(a, b, c, d) {
                return new mono.Face3(a, b, c, d)
            }
            function g(a, c) {
                if (o.length > 0 && (n.vertices = o, n.computed = !1, n.computeCentroids(), n.computeFaceNormals(), n.computeBoundingSphere(), n.faces.length > 0)) {
                    var d = n._name;
                    m.addChild(n),
                    n = new mono.Entity,
                    n._name = d,
                    n.setStyle("m.type", "phong"),
                    p = 0
                }
                a !== b && (n._name = a),
                c !== b && (n.mname = c)
            }
            function h(a, c, d, e) {
                e === b ? n.faces.push(f(parseInt(a) - (k + 1), parseInt(c) - (k + 1), parseInt(d) - (k + 1))) : n.faces.push(f(parseInt(a) - (k + 1), parseInt(c) - (k + 1), parseInt(d) - (k + 1), [q[parseInt(e[0]) - 1].clone(), q[parseInt(e[1]) - 1].clone(), q[parseInt(e[2]) - 1].clone()]))
            }
            function i(a, b, c) {
                n.uvs.push([r[parseInt(a) - 1].clone(), r[parseInt(b) - 1].clone(), r[parseInt(c) - 1].clone()])
            }
            function j(a, c, d) {
                a[3] === b ? (h(a[0], a[1], a[2], d), c !== b && c.length > 0 && i(c[0], c[1], c[2])) : (d !== b && d.length > 0 ? (h(a[0], a[1], a[3], [d[0], d[1], d[3]]), h(a[1], a[2], a[3], [d[1], d[2], d[3]])) : (h(a[0], a[1], a[3]), h(a[1], a[2], a[3])), c !== b && c.length > 0 && (i(c[0], c[1], c[3]), i(c[1], c[2], c[3])))
            }
            var k = 0,
            l = new mono.Entity,
            m = l,
            n = new mono.Entity;
            n.setStyle("m.type", "phong");
            for (var o = [], p = 0, q = [], r = [], s = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, t = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, u = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/, v = /f( +\d+)( +\d+)( +\d+)( +\d+)?/, w = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/, x = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/, y = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/, z = a.split("\n"), A = 0; A < z.length; A++) {
                var B = z[A];
                B = B.trim();
                var C;
                if (0 !== B.length && ("#" !== B.charAt(0) || "o" == B.charAt(2))) if (null !== (C = s.exec(B))) o.push(d(parseFloat(C[1]), parseFloat(C[2]), parseFloat(C[3])));
                else if (null !== (C = t.exec(B))) q.push(d(parseFloat(C[1]), parseFloat(C[2]), parseFloat(C[3])));
                else if (null !== (C = u.exec(B))) r.push(e(parseFloat(C[1]), parseFloat(C[2])));
                else if (null !== (C = v.exec(B))) j([C[1], C[2], C[3], C[4]]);
                else if (null !== (C = w.exec(B))) j([C[2], C[5], C[8], C[11]], [C[3], C[6], C[9], C[12]]);
                else if (null !== (C = x.exec(B))) j([C[2], C[6], C[10], C[14]], [C[3], C[7], C[11], C[15]], [C[4], C[8], C[12], C[16]]);
                else if (null !== (C = y.exec(B))) j([C[2], C[5], C[8], C[11]], [], [C[3], C[6], C[9], C[12]]);
                else if ("#" === B.charAt(0) && "o" === B.charAt(2)) g(),
                k += o.length,
                o = [],
                m = new mono.Entity,
                m._name = B.substring(2).trim(),
                l.addChild(m);
                else if (/^g /.test(B)) g(B.substring(2).trim(), b);
                else if (/^usemtl /.test(B)) g(b, B.substring(7).trim());
                else if (/^mtllib /.test(B)) {
                    if (c) {
                        var D = B.substring(7);
                        D = D.trim(),
                        c(D)
                    }
                } else / ^s / .test(B)
            }
            return g(b, b),
            l
        }
    })
} (window);
TGL.Overview3D = function(a, b) {
    function c(b) {
        event.stopPropagation();
        var c = f.getFirstElementByMouseEvent(b, !1);
        f.animateCamera(a.getCamera(), a.getDefaultInteraction(), a.getCamera().t(), c.point)
    }
    TGL.Network3D.call(this, a.getDataBox()),
    this.network3d = a,
    this.adjustBounds(200, 200);
    var d = this.getRootView();
    a.getRootView().appendChild(d),
    this.setInteractions([]),
    d.addEventListener("mousemove",
    function(a) {
        a.stop = !0
    }),
    d.addEventListener("mousewheel",
    function(a) {
        a.stop = !0
    }),
    this.zoomEstimateOverview();
    var e = this.getCamera();
    e.p(new mono.Vec3(0, 1.2 * e.getDistance(), .1)),
    e.lookAt(new mono.Vec3(0, 0, 0)),
    d.addEventListener("dblclick", c);
    var f = this
},
TGL.extend(TGL.Overview3D, TGL.Network3D, {
    destory: function() {},
    adjustBounds: function(a, b) {
        TGL.Network3D.prototype.adjustBounds.call(this, a, b);
        var c = this.getRootView();
        c.style.position = "absolute",
        c.style.right = "10px",
        c.style.bottom = "10px"
    },
    animateCamera: function(a, b, c, d, e) {
        var f = a.getPosition().sub(a.getTarget()),
        g = new mono.Animate({
            from: 0,
            to: 1,
            dur: 500,
            easing: "easeBoth",
            onUpdate: function(e) {
                var g = c.x + (d.x - c.x) * e,
                h = c.y + (d.y - c.y) * e,
                i = c.z + (d.z - c.z) * e,
                j = new mono.Vec3(g, h, i);
                a.lookAt(j),
                b.target = j;
                var k = (new mono.Vec3).addVectors(f, j);
                a.setPosition(k)
            }
        });
        g.onDone = e,
        g.play()
    }
});
